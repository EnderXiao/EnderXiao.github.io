---
title: React学习笔记一
date: 2022-01-05 10:40:48
categories:
  - - 研究生
    - 打工
    - React
  - - 前端
tags:
  - 打工
  - 前端框架
  - React
  - life
headimg:
  'https://z3.ax1x.com/2021/08/05/fego40.png'
mathjax: true

---

前端框架React学习笔记

<!-- more -->

## 前言

上研究生后老师让直接去实习，实习单位使用React + React Native进行安卓混合开发。于是先学习一下React

## React概述

React是一个构建用户见面的JS库

### React特点

1. 声明式

   只需要描述UI（HTML）看起来是啥样，即描述结构，React负责渲染UI以及在数据变化时更新UI

2. 基于组件

   - 用于表示页面中的部分内容
   - 通过组合、复用多个组件，就能实现完整的页面功能

3. 学习一次随处使用

   - 使用React开发Web应用

   - 使用React-native开发移动端应用
   - React 360开发VR应用

### React 安装

```shell
npm i react react-dom
```

- react包是核心，提供创建元素，组件的功能
- react-dom包提供DOM相关功能

### React初见

1. 选择一个目录

2. 创建index.html

3. 在该目录下安装react包

   ```shell
   npm i react react-dom
   ```

   

```html
<!DOCTYPE html>
<html lang="cn">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width-device-width, initial-1.0 ">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>react</title>
</head>

<body>

    <div id="root"></div>
    <!-- 引入reactjs -->
    <script src="./node_modules/react/umd/react.development.js"></script>
    <script src="./node_modules/react-dom/umd/react-dom.development.js"></script>
    <script>
        // 创建React元素
        // 参数：
        //     1. 元素名称
        //     2. 元素属性
        //     3. 第三个及其之后的参数：元素子节点
        const title = React.createElement('h1', null, "Hello React")

        // 渲染React元素
        // 参数：
        //     1. 要渲染的react元素
        //     2. 挂载点，一个DOM对象，指定渲染位置
        ReactDOM.render(title, document.getElementById("root"))
    </script>
</body>

</html>
```

### React脚手架

#### 脚手架的意义

1. 脚手架是开发现代Web应用的必备
2. 充分利用Webpack、Babel、ESLint等工具辅助项目开发
3. 零配置，无需手动配置繁琐的工具即可使用
4. 关注业务二部是工具配置

#### 使用脚手架初始化项目

```shell
npx create-react-app my-app
```

使用

```shell
npm start
```

启动项目

#### npx 的意义

原来使用npm上下载的包时，如果想在任意地方使用，需要全局安装这个包，但npx之后无需全局安装，即可使用。

#### 脚手架中导入React包

由于React基于Webpack，因此导入时可直接使用ES6中的模块化语法进行导入：

```js
import React from 'react'
import ReactDOM from 'react-dom' //使用react制作web应用时导入该渲染组件
```

## JSX

### JSX基本使用

即JavaScript XML，表示在JS中写XML格式的代码

优点：

1. 声明式语法更直观，与HTML结构相同，降低了学习成本、提升开发效率

#### 使用步骤

使用JSX语法创建react元素

```react
const title = <h1>Hello JSX</h1>
```

使用reactDOM.render渲染react元素到页面

```react
ReactDOM.render(title, root)
```

#### JSX原理

react脚手架中配置了babel，JSX会经过babel编译为标准的JS语法。

编译JSX语法的包为@babel/preset-react

#### 注意事项

1. React元素的属性名采用驼峰命名法
2. 使用JSX为标签设置属性时，应修改为驼峰命名：
   1. class属性 -> className
   2. for -> htmlFor
   3. tabindex -> tabIndex
3. 没有子节点的React元素，可以使用但标签`<span />`结束
4. 推荐使用小括号包裹JSX，从而避免JS中的自动插入分号陷阱

### JSX中嵌入JS表达式

语法：

```react
const name = 'Jack'
const dv = (
	<div>你好，我叫：{name} </div>
)
```

### JSX条件渲染

根据条件渲染特定的JSX结构

```react
const isLoading = false
cont loadData = () => {
	if (isLoading) {
		return <div>loading...</div>
	}
	
	return <div>数据加载完成，此处显示加载后的数据</div>
}

const title = (
	<h1>
		条件渲染：
		{loadData()}
	</h1>
)

ReactDOM.render(title, document.getElementById('root'))
```

此外还可以使用三目运算符和逻辑与运算符

```react
const isLoading = false
cont loadData = () => {
    return isLoading && (<div>loading...</div>)
}

const title = (
	<h1>
		条件渲染：
		{loadData()}
	</h1>
)

ReactDOM.render(title, document.getElementById('root'))
```

### JSX列表渲染

使用数组的map()方法

需要注意的是渲染列表时应该添加key属性，key属性的值要保证唯一

通过便利创建什么元素，就要把key通过遍历加上。

尽量避免使用索引号作为key

```react
import React from 'react'
import ReactDOM from 'react-dom'

const songs = [
    {id: 1, name: '111'},
    {id: 2, name: '222'},
    {id: 3, name: '333'},
]

const title = (
	<ul>
        {songs.map(item = > <li key={item.id}>{item.name}</li>)}
	</ul>
)

ReactDOM.render(title, document.getElementById('root'))
```

### JSX样式处理

两种方式：

1. 行内样式——style
2. 类名——className

使用样式时需要引入

```react
import React from 'react'
import ReactDOM from 'react-dom'

//引入css
import './css/index.css'

const list = (
    <h1 className="title" style={{ clolr: 'red', backgroundColor: 'skyblue'}}>
)

ReactDOM.render(list, document.getElementById('root'))
```

### JSX总结

1. JSX是React的核心内容
2. JSX表示在JS中写HTML结构，是声明式的体现
3. 使用JSX配合嵌入JS表达式、条件渲染、列表渲染、可以描述任意UI结构
4. 推荐使用className的方式给JSX添加样式
5. React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能

## React组件

组件的特点：

1. 可复用
2. 独立
3. 可组合

### 组件的两种创建方式

1. 函数
2. 类

#### 函数组件

为了和函数进行区分，对函数组件进行如下约定：

1. 函数名必须以**大写字母开头**
2. 函数组件必须**有返回值**

但函数返回值可以为NULL

```react
function Hello() {
    return (
        <div>我是一个函数组件</div>
    )
}
```

渲染组件时直接使用函数名作为组件标签即可

```react
ReactDOM.render(<Hello />, root)
```

也能使用箭头函数来构造组件

```react
const Hello = () => <div>我是一个箭头函数组件</div>
```

React根据名称首字母是否大写来区分组件和普通React元素

#### 类组件

使用ES6中的class创建的组件，为了与普通类进行区分，使用如下约定：

1. 类名首**字母大写**
2. 类组件需要继承自**React.Component**，从而使用父类中提供的方法和属性
3. 类组件必须提供**render()**方法
4. render方法**必须有返回值**，表示组件的结构

```react
class Hello extends React.Component {
    render() {
        return <div>Hello Class Component</div>
    }
}

ReactDOM.render(<Hello />, root)
```

#### 组件的组织

组件作为一个单独的个体，一般会放到一个单独的JS文件中

1. 创建JS文件，对应组件名称.js
2. 在JS文件中导入React
3. 创建组件
4. 在JS文件中导出该组件
5. 在index.js中导入该组件
6. 渲染组件

组件JS文件

```react
// Hello.js
import React from 'react'
class Hello extends React.Component {
    render() {
        return <div>Hello Class Component</div>
    }
}

// 导出Hello组件
export default Hello
```

index中渲染组件

```react
// index.js
import Hello from './Hello'
// 渲染导入的Hello组件
ReactDOM.render(<Hello />, root)
```

## React事件处理

### 事件绑定

1. React事件绑定语法与DOM事件绑定相似
2. on+事件名称={事件处理程序}，如onClick={() => {}}
3. React事件采用驼峰命名法

```react
class App exntends React.Component {
    handleClick() {
        console.log('单击事件被触发')
    }
    
    render() {
        return (
            <button onClick={this.handleClick}>点我</button>
        )
    }
}
```

函数组件绑定事件，使用内部函数定义

```react
function App() {
    function handleClick() {
        console.log('单击事件出发了')
    }
    
    return(
        <button onClick={handleClick}>点我</button>
    )
}
```

### 事件对象

1. 可以通过事件处理程序的参数获取到事件对象
2. React中的事件对象叫做：**合成事件(重要，需补充)**（对象）
3. 合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题

```react
function handleClick(e) {
    e.preventDefault() //组织浏览器的默认行为
    console.log('事件对象', e)
}

<a onClick={handleClick}>点我，不会跳转页面</a>
```

### 有状态组件和无状态组件

1. 函数组件又称为**无状态组件**，类组件叫做**有状态组件**
2. 状态(state)即**数据**
3. 函数组件没有自己的状态，**只负责数据展示**（静）
4. 类组件有自己的状态，**负责更新UI**

### 组件的state和setState

#### state的基本使用

1. 状态即数据，时组件内部的私有数据，只能在组件内部使用
2. state的值是对象，表示一个组件中可以有多个数据

状态的初始化方式如下：

```react
class Hello extends React.Component {
    constructor() {
        // ES6中必须包含
        super();
        // 初始化state
        this.state = {
            count: 0,
        };
    }
    
    render() {
        return (
            <div>有状态组件</div>
        )
    }
}
```

也可以使用ES6中的简化语法：

```react
class Hello extends React.Component {
    // 简化语法
    // 初始化state
    state = {
        count: 0
    }
    
    render() {
        return (
            <div>有状态组件</div>
        )
    }
}
```

可以使用this获取状态的数据

```react
class Hello extends React.Component {
    // 简化语法
    // 初始化state
    state = {
        count: 0
    }
    
    render() {
        return (
            <div>计数器: {this.state.count}</div>
        )
    }
}
```

#### setState()修改状态

1. 状态是可变的
2. 语法：this.setState({要修改的数据})
3. 不要直接修改state中的值
4. setState()作用：
   1. 修改state
   2. 更新UI
5. 思想：**数据驱动视图**

```react
class App extends React.Component {
    state = {
        count: 0
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={() => {
                        this.setState({
                            count: this.state.count + 1
                        })
                    }}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

#### 从JSX中抽离事件处理程序

1. JSX中掺杂了过多JS逻辑代码会使得JSX逻辑混乱
2. 将逻辑抽离到单独的方法中，保证JSX结构清晰
3. 由于箭头函数不具备this，因此会向外层寻找this的指向，render()函数中的this指向组件实例，因此不会有问题，但进行抽离后的函数不具备this指向。
4. 可以使用如下解决方式：
   1. 箭头函数
   2. Function.prototype.bind()
   3. class的实例方法

##### 箭头函数

利用箭头函数自身不绑定this的特点，会根据外部环境推断。对于方法中的this，谁调用就指向谁。

```react
class App extends React.Component {
    state = {
        count: 0
    }

	// 事件处理程序
	onIncrement(){
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={() => this.onIncrement()}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

##### Function.prototype.bind()

1. 利用ES5中的bind方法，将事件处理程序中的this与组件实列绑定

2. 类似于小程序中的

   ```js
   let that = this
   that.onIncrement()
   ```

```react
class App extends React.Component {

	constructor() {
        super()
        this.state = {
        	count: 0
    	}
        this.onIncrement = this.onIncrement.bind(this)
    }

	// 事件处理程序
	onIncrement(){
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={this.onIncrement}>+1</button>
            </div>
        )
    }
}
```

##### class实例方法

使用箭头函数形式的class实例方法

注意，该语法为实验性语法，但由于babel的存在，可以直接使用

```react
class App extends React.Component {
    state = {
        count: 0
    }

	// 事件处理程序
	onIncrement = () => {
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={this.onIncrement}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

## 表单处理

React两种表单处理方式

1. 受控组件
2. 非受控组件（DOM方式）

### 受控组件

1. HTML中的表单元素是可输入的，也就是有自己的可变状态
2. React中可变状态通常保存在state中，使用setState来i需改
3. React将state与表单元素值value绑定到一起，由state的值来控制表单元素的值
4. 受控组件：即值收到React控制的表单元素

受控组件的使用包括以下步骤：

1. 在state中添加一个状态，作为表单元素的value值（控制表单元素值的来源）
2. 给表单元素绑定change事件，将表单元素的值设置为state的值（控制表单元素值的变化）

```react
class App extends React.Component {
    state = {
        txt: '',
    }

	handleChange = e => {
        this.setState({
            txt: e.target.value
        })
    }

	render() {
        return (
            <div>
                <input type="text" value={this.state.txt} onChange={this.handleChange} />
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

如下练习将不同的表单标签转化为受控组件。

1. 文本框，富文本框，下拉框操作value属性
2. 复选框操作checked属性

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.state = {
      txt: '',
      content: '',
      city: 'bj',
      Selection: false,
    }
  }

  handleChange = e => {
    this.setState({
      txt: e.target.value
    })
  }

  handleContent = e => {
    this.setState({
      content: e.target.value
    })
  }

  handleCity = e => {
    this.setState({
      city: e.target.value
    })
  }

  handleSelection = e => {
    this.setState({
      Selection: e.target.checked
    })
  }

  render(){
    return (
      <div>
        <input type="text" value={this.state.txt} onChange={this.handleChange}></input>
        <br/>

        <textarea value={this.state.content} onChange={this.handleContent}></textarea>
        <br/>

        <select value={this.state.city} onChange={this.handleCity}>
          <option value="sh">上海</option>
          <option value="bj">北京</option>
          <option value="gz">广州</option>
        </select>
        <br/>

        <input type="checkbox" checked={this.state.Selection} onChange={this.handleSelection}></input>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

但是可以发现用如上方法控制表单元素会产生很多重复新的onChange函数，因此需要对多表单元素进行优化，即使用一个事件处理程序同时处理多个表单元素。

#### 多表单元素优化

1. 给表单元素添加name属性，名称与state相同
2. 根据表单元素类型获取对应值
3. 在change事件处理程序中通过[name]来修改对应的state

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.state = {
      txt: '',
      content: '',
      city: 'bj',
      Selection: false,
    }
  }

  handleChange = e => {
    // 获取当前DOM对象
    const target = e.target;

    // 根据类型获取值
    const value = target.type === 'checkbox'
      ? target.checked
      : target.value;

    // 获取name
    const name = target.name;

    this.setState({

      // 此处定义属性使用了ES6中的新特性 属性名表达式
      // 即使用表达式作为属性或函数名
      // 此处会将name转化为string
      [name]: value,
    });
  }

  render(){
    return (
      <div>
        <input type="text" name='txt' value={this.state.txt} onChange={this.handleChange}></input>
        <br/>

        <textarea name='content' value={this.state.content} onChange={this.handleChange}></textarea>
        <br/>

        <select name='city' value={this.state.city} onChange={this.handleChange}>
          <option value="sh">上海</option>
          <option value="bj">北京</option>
          <option value="gz">广州</option>
        </select>
        <br/>

        <input name='Selection' type="checkbox" checked={this.state.Selection} onChange={this.handleChange}></input>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

### 非受控组件

借助于ref，使用原生DOM方法来获取表单元素值

ref的作用：获取DOM或组件

这种方式通过直接操作DOM实现

使用步骤：

1. 通过React.createRef()方法创建一个ref对象
2. 将创建好的ref对象添加到文本框中
3. 通过ref对象获取到文本框中的值

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.txtRef = React.createRef()
  }

  // 获取文本框的值
  getTxt = () => {
    console.log('文本框的值为：', this.txtRef.current.value);
  }

  render(){
    return (
      <div>
        <input type="text" ref={this.txtRef} />

        <button onClick={this.getTxt}>获取文本框的值</button>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

## 案例一

式样以上知识，实现一个无回复功能的评论版

### 渲染评论列表

1. 在state总初始化评论列表数据
2. 使用map循环渲染列表数据
3. 注意给每个被渲染的元素添加一个key

### 评论区条件渲染

1. 判断列表长度是否为0
2. 如果为0则渲染暂无评论 
3. 注意讲逻辑与JSX分离

### 获取评论信息

1. 使用受控组件的方式实现
2. 注意设置handle方法和name属性

### 发表评论

1. 为按钮绑定单击事件
2. 在事件处理程序中通过state获取评论信息
3. 将评论添加到state中，更新state
4. 边界情况：清空文本框，文本框判空

### 最终实现

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {

  constructor() {
    super()
    this.state = {
      comments: [
        { id: 1, name: 'jack', comment: 'You jump'},
        { id: 2, name: 'rose', comment: 'I jump'},
        { id: 3, name: 'joker', comment: 'I see you jump'},
      ],
      // 当前评论人
      userName: '',
      // 当前评论内容
      userContent: '',
    }
  }

  renderList() {
    const {comments} = this.state
    if(comments.length === 0) {
      return (
        <div className='no-comment'>暂无评论，快去评论吧</div>
      )
    } else {
      return (
        <ul>
          { 
            comments.map(item => (
              <li key={item.id}>
                <h3>评论人：{item.name}</h3>
                <p>评论内容：{item.comment}</p>
              </li>
            ))
          }
        </ul>
      )
    }
  }

  handleChange = (e) => {
    const {name, value} = e.target;
    this.setState({
      [name]: value,
    });
  }

  addComment = () => {
    const {comments, userName, userContent} = this.state

    //判空，使用trim去除空格
    if(userName.trim() === '' || userContent.trim === '' ) {
      alert('请输入评论人和评论内容');
      return;
    }
    // 此处使用了ES6的新特性：拓展运算符...
    // 该运算符用于将可便利对象拆分为单个
    const newIndex = comments.length + 1;
    const newComments = [...comments,
      {
        id: newIndex,
        name: userName,
        comment: userContent,
      }
    ];

    console.log(newComments);

    this.setState({
      comments: newComments,
      userName: '',
      userContent: '',
    });
  }

  render(){
    const {userName, userContent} = this.state;

    return (
      <div className='app'>
        <div>
          <input
            name='userName'
            className='user'
            value={userName}
            type='text'
            placeholder='请输入评论人'
            onChange={this.handleChange} />
          <br/>

          <textarea
            className='content'
            name='userContent'
            cols='30'
            row = '10'
            placeholder='请输入评论内容'
            value={userContent}
            onChange={this.handleChange}
            />
            <br />
            <button onClick={this.addComment}>发表评论</button>
        </div>
        {/* 通过条件渲染决定渲染什么内容 */}
        {this.renderList()}
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

## 组件间通讯

### 组件props

由于组件的封闭性，要接受外部数据应该通过props来实现

- props的作用：接受传递给组件的数据
- 传递数据：给组件标签添加属性
- 接受数据：
  - 函数组件通过**参数props**接收数据
  - 类组件通过**this.props**接受数据

```react
<Hello name='jack' age = {19} />
```

```react
function Hello(props) {
    console.log(props)
    return (
        <div>接受到数据: {props.name}</div>
    )
}
```

```react
class Hello extends React.Component {
    
    // 推荐写法
    constructor(props) {
        super(props)
    }
	render() {
		return (
			<div>接收到数据：{this.props.age}</div>
		)
	}
}
```

#### 组件props的特点

1. 可以给组件传递任意类型的值
2. props是一个**只读**属性，无法修改
3. 使用类组件时，如果写了构造函数，应该将props传递给super()，否则，无法在构造函数中获取到props

### 组件通讯的三种方式

1. 父组件 -> 子组件
2. 子组件 -> 父组件
3. 兄弟组件

#### 父组件到子组件

1. 父组件提供要传递的state数据
2. 给子组件标签添加属性，值为state中的数据
3. 子组件中通过props接受父组件中传递的数据

```react
class Parent extends React.Component {
    state = { lastName: '王' }
	render() {
        return (
            <div>
                传递给子组件：<Child name={this.state.lastName} />
            </div>
        )
    }
}
```

```react
function Child(props) {
    return <div>子组件接受：{props.name} </div>
}
```

#### 子组件到父组件

思路：利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数

1. 父组件提供一个回调函数，用于接收数据
2. 将该函数作为属性值传递给子组件
3. 子组件通过props调用回调函数
4. 将子组件的数据作为参数传递给回调函数
5. 注意回调函数中this指向的问题

```react
class Parent extends React.Component {
    // 提供回调
    getChildMsg = (msg) => {
        console.log('接收到子组件数据', msg)
    }
	render() {
        return (
            // 传递给子组件
            <div>
                子组件：<Child getMsg={this.getChildMsg} />
            </div>
        )
    }
}
```

```react
class Child extends React.Component {
    // 提供回调
    stats = {childMsg: 'React'}
	handleClick = () => {
		this.props.getMsg(this.state.childMsg)        
    }
	render() {
        return (
            // 传递给子组件
            <button onClick={this.handleClick}>点我，给父组件传递数据</button>
        )
    }
}
```

#### 兄弟组件通讯

- 思路：将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态

- 将这种思想称为**状态提升**
- 公共父组件职责：
  1. 提供共享状态（父到子通讯）
  2. 提供操作共享状态的方法（子到父通讯）
- 要通讯的子组件只需要通过props接受状态或操作状态的方法

```react
class Counter extends React.Component {
    // 提供共享状态
    state = {
        count: 0
    }
	
	// 提供修改状态的方法
	onIncrement = () => {
        this.setState({
            count: this.state.count + 1
        })
    }
    
    render() {
        return (
            <div>
                <Child1 count={this.state,count} />
                <Child2 onIncrement={this.onIncrement} />
            </div>
        )
    }
}

const Child1 = (props) => {
    return <h1>计数器：{props.count}</h1>
}

const CHild2 = (props) => {
    return <button onClick={() => props.onIncrement}> +1 </button>
}
```

### Context

考虑这样一个实际应用中的问题：对于相互嵌套很深层次的组件，我们应该如何进行通讯？例如下面这个结构中组件App想要给Child传递数据

常规的思路可能是使用Props一层一层往下传递，但是这样操作起来会十分繁琐。

```xml
<App>
    <Node>
        <SubNode>
            <Child>
            </Child>
        </SubNode>
    </Node>
</App>
```

React为我们提供了更好的方式：**Context**

它的作用就是跨组件传递数据（比如：主题，语言设置等需要在根组件配置数据）

使用方法如下：

1. 调用React.createContext()创建Provider(提供数据)和Consumer(消费数据)两个组件
2. 使用Provider组件作为父节点
3. 设置Value属性，表示要传递的数据
4. 调用Consumer组件接受数据
5. 即Provider包裹父节点，Consumer被子组件包裹

```react

// 创建context
const {Provider, Consumer} = React.getContext() 

class App extends React.Component {
	render() {
        return (
            // 使用Provider作为父节点
            // 设置要传递的数据
            <Provider value="pink">
            	<div className='app'>
                	<Node />
	            </div>
			</Provider>
        )
    }
}

const Node = props => {
    return (
        <div className="node">
            <subNode />
        </div>
    )
}

const SubNode = props => {
    return (
        <div className="subnode">
            <Child />
        </div>
    )
}

const Child = props => {
    return <div className='child'>
        <!-- 使用consumer组件接受数据 -->
        <Consumer>
            {
                data => <span>我是子节点 -- {data}</span>
            }
        </Consumer>
    </div>
}

ReactDOm.render(<App />, document.getElementById('root'))
```

### props深入

#### children属性

表示组件标签的子节点，当组件标签有子节点时，props就会有该属性。

children属性和普通的props一样，值可以任意。

```react
const App = props => {
    return (
        <div>
            <h1>组件标签的子节点：</h1>
            {props.children}
        </div>
    )
}

ReactDOM.render{<App>我是子节点</App>, document.getElementById('root')}
```

#### props校验

对于组件而言，props是外来的，无法保证使用组件时传入的值的格式。

那么会出现以下问题：

1. 传入数据不对可能导致组件内部报错
2. 组件的使用者不知道明确的错误原因

React提供了props校验作为解决方法。

props校验：

1. 运行在创建组件时只当props的类型、格式等

2. 能捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性

使用步骤：

1. 安装prop-types包
2. 导入prop-types
3. 使用`组件名.propTypes={}`来给组件的props添加校验规则
4. 校验规则通过PropTypes对象指定

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'

const App = props => {
  const arr = props.colors
  const lis = arr.map((item, index) => <li key={index}>{item}</li>)

  return <ul>{lis}</ul>
}

// 添加props校验
App.propTypes = {
  colors: PropTypes.array
}

ReactDOM.render(<App colors={['red', 'blue']} />, document.getElementById('root'))
```

props校验常见校验规则：

| 常见类型      | array,bool,func,number,object,string |
| ------------- | ------------------------------------ |
| React元素类型 | element                              |
| 必填项        | isRequired                           |
| 特定结构对象  | shape({})                            |

详见官方文档：[PropTypes](https://reactjs.org/docs/typechecking-with-proptypes.html)

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'

const App = props => {
  return (
    <div>
      <h1>props校验：</h1>
    </div>
  )
}

// 添加props校验
// 属性a的类型：        数值（number）
// 属性fn的类型：       函数（func）且为必填
// 属性tag的类型：      React元素（element）
// 属性filter的类型：   对象（{area: '上海', price: 1999}）
App.propTypes = {
  a: PropTypes.number,
  fn: PropTypes.func.isRequired,
  tag: PropTypes.element,
  filter: PropTypes.shape({
    area: PropTypes.string,
    price: PropTypes.number,
  })
}

ReactDOM.render(<App fn={() => {}} />, document.getElementById('root'))
```

#### props默认值

例如当我们设计一个分页组件时，每页显示条数可以为默认值。

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'

const App = props => {
  return (
    <div>
      <h1>props默认值：{props.pageSize}</h1>
    </div>
  )
}

// 添加props默认值
App.defaultProps = {
  pageSize: 10
}

ReactDOM.render(<App />, document.getElementById('root'))
```

## 组件的生命周期

学习组件的生命周期有助于理解组件的运行方式、从而完成更复杂的组件功能、分析组件错误原因等等

组件的生命周期指：组件从被创建到挂载在页面中运行，再到组件不用时卸载的过程。

钩子函数：生命周期的每个阶段总伴随着一些方法调用，这些方法就是生命周期的钩子函数，为开发人员在不同阶段操作组件提供了时机。

**只有类组件才有生命周期**

#### 生命周期的三个阶段

1. 创建时
2. 更新时
3. 卸载时

##### 创建时（挂在阶段）

- 执行时机：组件创建时（页面加载时）
- 钩子函数执行顺序：
  1. constructor()
  2. render()
  3. componentDidMount()

| 钩子函数          | 触发时机                  | 作用                                    |
| ----------------- | ------------------------- | --------------------------------------- |
| constructor       | 创建组件时，最先执行      | 1. 初始化state2. 为事件处理程序绑定this |
| render            | 每次组件渲染都会触发      | 渲染UI（注意：不能调用setState()）      |
| componentDidMount | 组件挂载（完成DOM渲染）后 | 1. 发送网络请求2. DOM操作               |

> 不能在render中调用setState的原因是：调用setState会导致数据更新以及UI更新（渲染），即setState方法将会调用render方法，因此如果在render中调用setState会导致递归效用

> componentDidMount会紧跟render方法触发，由于DOM操作需要DOM结构已经渲染，因此DOM操作应被放置于该钩子函数内。

##### 更新阶段

- 更新阶段的执行时机包括：
  1. New props，组件接收到新属性
  2. setState()，调用该方法时
  3. forceUpdate()，调用该方法时

其中forceUpdate用于使组件强制更新，即使没有数值上的改变。

- 钩子函数执行顺序：
  1. render()
  2. componentDidUpdate()

| 钩子函数           | 触发时机                  | 作用                         |
| ------------------ | ------------------------- | ---------------------------- |
| render             | 每次组件渲染都会触发      | 渲染UI（与挂载阶段是同一个） |
| componentDidUpdate | 组件更新（完成DOM渲染）后 | 1. 发送网络请求2. DOM操作    |

> 需要注意的是在componentDidUpdate中调用setState()必须放在一个if条件中，原因与在render中调用setState相同，render执行完后会立即执行componentDidUpdate导致递归调用。通常会比较更新前后的props是否相同，来决定是否重新渲染组件。可以使用componentDidUpdate(prevProps)得到上一次的props，通过this.props获取当前props

```react
class App extends React.Component {
    
    constructor(props) {
        super(props)
        
        this.state = {
            count: 0
        }
        console.warn('生命周期钩子函数：constructor')
    }
    
   	componentDidMount(){
         console.warn('生命周期钩子函数：componentDidMount')
    }
    
    handleClick = () =>{
        this.setState({
            count: this.state.count + 1
        })
    }
    
    render() {
        return (
            <div>
                <Counter count={this.state.count} />
                <button onClick={this.handleClick}>打豆豆</button>
            </div>
        )
    }
}

class Counter extends React.Component {
    render() {
        console.warn('--子组件--生命周期钩子函数：render')
        return <h1 id='title'>统计豆豆被打的次数：{this.props.count}</h1>
    }
    

    
    conponentDidUpdate(prevProps) {
        console.warn('--子组件--生命周期钩子函数：conponentDidUpdate')
        
        console.log('上一次的props: ', prevProps, '，当前的props：', this.props)
        if(prevProps.count !== this.props.count) {
            this.setState({})
            // 发送ajax请求的代码
        }
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

##### 卸载时（卸载阶段）

- 执行时机：组件从页面中消失

- 钩子函数执行顺序：
  - componentWillUnmount

| 钩子函数             | 触发时机                 | 作用                               |
| -------------------- | ------------------------ | ---------------------------------- |
| componentWillUnmount | 组件卸载（从页面中消失） | 执行清理工作（比如：清理定时器等） |

```react
class App extends React.Component {
    
    constructor(props) {
        super(props)
        
        this.state = {
            count: 0
        }
        console.warn('生命周期钩子函数：constructor')
    }
    
   	componentDidMount(){
         console.warn('生命周期钩子函数：componentDidMount')
    }
    
    handleClick = () =>{
        this.setState({
            count: this.state.count + 1
        })
    }
    
    render() {
        return (
            <div>
                {this.state.count > 3 ? (
                    <p>豆豆被打死了~</p>
                ) : (
                  <Counter count={this.state.count} />  
                )}
                <button onClick={this.handleClick}>打豆豆</button>
            </div>
        )
    }
}

class Counter extends React.Component {
    
    conponentDidMount() {
        // 开启定时器
    	this.timerId = setInterval(() => {
            console.log("定时器正在执行~")
        }. 500)    
    }
    
    render() {
        console.warn('--子组件--生命周期钩子函数：render')
        return <h1 id='title'>统计豆豆被打的次数：{this.props.count}</h1>
    }
    
    conponentWillUnmount(){
        console.warn('--子组件--生命周期钩子函数：conponentWillUnmount')
        // 清理定时器
        clearInterval(this.timerId)
    }
    
    conponentDidUpdate(prevProps) {
        console.warn('--子组件--生命周期钩子函数：conponentDidUpdate')
        
        console.log('上一次的props: ', prevProps, '，当前的props：', this.props)
        if(prevProps.count !== this.props.count) {
            this.setState({})
            // 发送ajax请求的代码
        }
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

##### 其他钩子函数

- 旧版本遗留，先已弃用的钩子函数：
  - componentWillMount()
  - ComponentWillReceiveProps()
  - ComponentWillUpdate()
- 新版完整生命周期钩子函数：
  - 创建时：
    - constructor
    - getDerivedStateFromProps(不常用)
    - render
    - React更新DOM和refs
    - componentDidMount
  - 更新时
    - getDerivedStateFromProps(不常用)
    - shouldComponentUpdate(详见组件性能优化)
    - render
    - getSnapshotBeforeUpdate(不常用)
    - React更新DOM和refs
    - componentDidUpdate
  - 卸载时
    - componentWillUnmount

## render-props和高阶组件

### 组件复用

如果两个组件中的部分功能相似或相同时，该如何处理？

因此对于相似的功能，我们希望能偶复用相似的功能。

复用时事实上时复用以下两点：

1. state
2. 操作state的方法（组件状态逻辑

React中组件复用包含两种方式：

1. render props模式
2. 高阶组件（HOC）

以上两种方式是利用React自身特点的编码技巧，不是API

### render-props模式

思路：将要复用的state和操作state的方法封装到一个组件中

问题：

1. 如何拿到该组件中复用的state
   - 在使用组件时，添加一个值为函数的prop，通过函数参数来获取（需要组件内部实现）
2. 如何渲染任意UI
   - 使用该函数的返回值作为要渲染的UI内容（需要组件内部实现）

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'

/*
  render props 模式
*/

// 导入图片资源
import img from './images/end_favicon128.ico'

// 创建复用组件
class Mouse extends React.Component {
  constructor(props) {
    super(props)
      
    // 鼠标位置state
    this.state = {
      x: 0,
      y: 0,
    }
  }

  // 鼠标位置事件处理函数
  handleMouseMove = e => {
    this.setState({
      x: e.clientX,
      y: e.clientY,
    })
  }

  // 开启鼠标监听事件
  componentDidMount() {
    window.addEventListener('mousemove', this.handleMouseMove)
  }

  render() {
    return this.props.render(this.state)
  }
}

const App = props => {
  return (
    <div>
      <h1>render props 模式</h1>
      <Mouse render={(mouse) => {
        return (
          <p>鼠标位置：{mouse.x}, {mouse.y}</p>
        )
      }} />

      {/* 复用Mouse组件 */}
      <Mouse render={mouse => {
        return (
          <img src={img} style={{
            position: 'absolute',
            top: mouse.y,
            left: mouse.x
          }} />
        )
      }}>
      </Mouse>
    </div>
  )
}


ReactDOM.render(<App />, document.getElementById('root'))
```

在上面这个例子中：

- Mouse组件负责：封装复用的状态逻辑代码：
  1. 状态：鼠标坐标（x，y）
  2. 操作状态的方法：鼠标移动事件
- 传入的render prop负责：使用复用的状态来渲染UI结构

##### children代替render

此外还能使用children替代上例中的render，这种方式更直观，更推荐使用：

```react
<Mouse>
    {(mouse) => <p>鼠标位置是 {mouse.x}, {mouse.y}</p>}
</Mouse>

// 组件内部
render() {
  return this.props.children(this.state)
}
```

此处联想到前文提到的Context：

```react
const Child = props => {
    return <div className='child'>
        <!-- 使用consumer组件接受数据 -->
        <Consumer>
            {
                data => <span>我是子节点 -- {data}</span>
            }
        </Consumer>
    </div>
}
```

实际上此处context也是使用了render props模式，且使用了children代替render。

现在可以对render props给出一个粗略的定义：

> render props 模式是指将一个函数作为prop，并使用该函数告诉组件要渲染什么内容的技术

##### render props模式代码优化

1. 给render props模式添加props校验
2. 组件卸载时应该解除mousemove事件绑定（使用react添加的事件绑定react会帮我们处理）

### 高阶组件

高阶组件时一种采用**包装（装饰）模式**实现的状态逻辑复用（例如python中的高阶函数，java中的AOP）

实现思路：

- 高阶组件（HOC）是一个函数，接收要包装的组件，返回增强后的组件
- 高阶组件内部创建一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给包装组件WrappedComponent

#### 使用步骤

1. 创建一个函数，名称约定以with开头
2. 指定函数参数，参数应以大写字母开头（因为参数要被作为组件渲染）
3. 在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回
4. 在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件
5. 调用高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面中

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'
import react from 'react';
import img from './images/end_favicon128.ico'
import { render } from '@testing-library/react';

/*
  高阶组件模式
*/

// 创建高阶组件
function withMouse(WrappedComponent) {
  // 该组件提供复用的状态逻辑
  class Mouse extends react.Component {
    constructor() {
      super()

      this.state = {
        x: 0,
        y: 0,
      }
    }

    componentDidMount() {
      window.addEventListener('mousemove', this.handleMouseMove)
    }

    handleMouseMove = e => {
      this.setState({
        x: e.clientX,
        y: e.clientY,
      })
    }

    render() {
      return <WrappedComponent {...this.state}></WrappedComponent>
    }

    componentWillUnmount() {
      window.removeEventListener('mousemove', this.handleMouseMove)
    }
  }

  return Mouse
}


const Cat = props => (
  <img src={img} alt='logo' style={{
    position: 'absolute',
    top: props.y,
    left: props.x,
  }}
  />
)

const Position = props => (
  <p>
    鼠标当前位置：(x: {props.x}, y: {props.y})
  </p>
)


// 获取增强后的组件
const MousePosition = withMouse(Position)

const CatMouse = withMouse(Cat)

class App extends React.Component {
  render (){
    return (
      <div>
        <h1>高阶组件模式</h1>
        {/* 渲染增强后的组件 */}
        <MousePosition />
        <CatMouse />
      </div>
    )
  }
} 


ReactDOM.render(<App />, document.getElementById('root'))
```



#### 设置displayName

使用高阶组件存在的问题：

- 得到的两个组件名称相同
  - 原因是默认情况下React使用组件名称作为displayName
  - 为高阶组件设置displayName便于调试时区分不同的组件
  - displayName：用于设置调试信息（React Develop Tools信息）

设置方法：

```react
// 获得组件的displayName的函数
function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

// 设置displayName
Mouse.displayName = `WithMouse${getDisplayName(WrappedComponent)}`
```



#### 传递props

使用高阶组件实际上是用一个组将将另一个组件包裹，那么这样会导致渲染时传入的props无法传递到被包裹的组件，而是传递到用于包裹的组件中，因此需要在用于包裹的组件中将props和state一起传递给被包裹的组件。

```react
render() {
      return <WrappedComponent {...this.state} {...this.props}></WrappedComponent>
}
```

## React原理



## Angular框架

### MVVM

> **MVVM是MVC的增强版，实质上和MVC没有本质区别，只是代码的位置变动而已**。
>
> ——[MVVM是什么 - 简书 (jianshu.com)](https://www.jianshu.com/p/6aeeecd64dcf)

#### MVC

之前学习过MVC框架，对于MVC框架，可以简述为一下三个方面：

1. Model：数据模型，用来存储数据
2. View：视图界面，用来展示UI界面和响应用户交互
3. Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互

#### MVC的缺点

在开发过程中，由于需求的变更或添加，项目的复杂度越来越高，代码量越来越大，此时我们会发现MVC维护起来有些吃力，首先被人吐槽的最多的就是MVC的简写变成了Massive-View-Controller（意为沉重的Controller）

#### MVVM的改进

由于Controller主要用来处理各种逻辑和数据转化，复杂业务逻辑界面的Controller非常庞大，维护困难，所以有人想到**把Controller的数据和逻辑处理部分从中抽离出来，用一个专门的对象去管理，这个对象就是ViewModel，是Model和Controller之间的一座桥梁**。当人们去尝试这种方式时，发现Controller中的代码变得非常少，变得易于测试和维护，只需要**Controller和ViewModel做数据绑定**即可，这也就催生了MVVM的热潮。

因此，MVVM包含以下四个组件：

1. View
2. View Controller
3. View Model
4. Model

#### MVVM的优缺点

##### 优点

1. Controller清晰简洁： ViewModel分离了大部分Controller代码，更加清晰和容易维护。
2. 方便测试：开发中大部分Bug来至于逻辑处理，由于ViewModel分离了许多逻辑，可以对ViewModel构造单元测试。
3. 开发解耦(举两个例子)：
   1.  一人负责逻辑实现、另一人负责UI实现；
   2.  敏捷开发时，会发经常发不是等后端做好了接口我们再去开发，不过在没有接口的情况下通常我们可以把Controller和View完成。

##### 缺点

1. 看起来代码会比MVC多点
2. 需要对每个Controller实现绑定，如果处理不好，反而会有一种“画虎不成反类犬”的感觉

#### MVVM框架组成

1. 数据绑定
2. 指令系统
3. 路由和导航
4. 状态保持
5. 第三方组件库
