---
title: React学习笔记一
date: 2022-01-05 10:40:48
categories:
  - - 研究生
    - 打工
    - React
  - - 前端
tags:
  - 打工
  - 前端框架
  - React
  - life
headimg:
  'https://z3.ax1x.com/2021/08/05/fego40.png'
mathjax: true

---

前端框架React学习笔记

<!-- more -->

## 前言

上研究生后老师让直接去实习，实习单位使用React + React Native进行安卓混合开发。于是先学习一下React

## React概述

React是一个构建用户见面的JS库

### React特点

1. 声明式

   只需要描述UI（HTML）看起来是啥样，即描述结构，React负责渲染UI以及在数据变化时更新UI

2. 基于组件

   - 用于表示页面中的部分内容
   - 通过组合、复用多个组件，就能实现完整的页面功能

3. 学习一次随处使用

   - 使用React开发Web应用

   - 使用React-native开发移动端应用
   - React 360开发VR应用

### React 安装

```shell
npm i react react-dom
```

- react包是核心，提供创建元素，组件的功能
- react-dom包提供DOM相关功能

### React初见

1. 选择一个目录

2. 创建index.html

3. 在该目录下安装react包

   ```shell
   npm i react react-dom
   ```

   

```html
<!DOCTYPE html>
<html lang="cn">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width-device-width, initial-1.0 ">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>react</title>
</head>

<body>

    <div id="root"></div>
    <!-- 引入reactjs -->
    <script src="./node_modules/react/umd/react.development.js"></script>
    <script src="./node_modules/react-dom/umd/react-dom.development.js"></script>
    <script>
        // 创建React元素
        // 参数：
        //     1. 元素名称
        //     2. 元素属性
        //     3. 第三个及其之后的参数：元素子节点
        const title = React.createElement('h1', null, "Hello React")

        // 渲染React元素
        // 参数：
        //     1. 要渲染的react元素
        //     2. 挂载点，一个DOM对象，指定渲染位置
        ReactDOM.render(title, document.getElementById("root"))
    </script>
</body>

</html>
```

### React脚手架

#### 脚手架的意义

1. 脚手架是开发现代Web应用的必备
2. 充分利用Webpack、Babel、ESLint等工具辅助项目开发
3. 零配置，无需手动配置繁琐的工具即可使用
4. 关注业务二部是工具配置

#### 使用脚手架初始化项目

```shell
npx create-react-app my-app
```

使用

```shell
npm start
```

启动项目

#### npx 的意义

原来使用npm上下载的包时，如果想在任意地方使用，需要全局安装这个包，但npx之后无需全局安装，即可使用。

#### 脚手架中导入React包

由于React基于Webpack，因此导入时可直接使用ES6中的模块化语法进行导入：

```js
import React from 'react'
import ReactDOM from 'react-dom' //使用react制作web应用时导入该渲染组件
```

## JSX

### JSX基本使用

即JavaScript XML，表示在JS中写XML格式的代码

优点：

1. 声明式语法更直观，与HTML结构相同，降低了学习成本、提升开发效率

#### 使用步骤

使用JSX语法创建react元素

```react
const title = <h1>Hello JSX</h1>
```

使用reactDOM.render渲染react元素到页面

```react
ReactDOM.render(title, root)
```

#### JSX原理

react脚手架中配置了babel，JSX会经过babel编译为标准的JS语法。

编译JSX语法的包为@babel/preset-react

#### 注意事项

1. React元素的属性名采用驼峰命名法
2. 使用JSX为标签设置属性时，应修改为驼峰命名：
   1. class属性 -> className
   2. for -> htmlFor
   3. tabindex -> tabIndex
3. 没有子节点的React元素，可以使用但标签`<span />`结束
4. 推荐使用小括号包裹JSX，从而避免JS中的自动插入分号陷阱

### JSX中嵌入JS表达式

语法：

```react
const name = 'Jack'
const dv = (
	<div>你好，我叫：{name} </div>
)
```

### JSX条件渲染

根据条件渲染特定的JSX结构

```react
const isLoading = false
cont loadData = () => {
	if (isLoading) {
		return <div>loading...</div>
	}
	
	return <div>数据加载完成，此处显示加载后的数据</div>
}

const title = (
	<h1>
		条件渲染：
		{loadData()}
	</h1>
)

ReactDOM.render(title, document.getElementById('root'))
```

此外还可以使用三目运算符和逻辑与运算符

```react
const isLoading = false
cont loadData = () => {
    return isLoading && (<div>loading...</div>)
}

const title = (
	<h1>
		条件渲染：
		{loadData()}
	</h1>
)

ReactDOM.render(title, document.getElementById('root'))
```

### JSX列表渲染

使用数组的map()方法

需要注意的是渲染列表时应该添加key属性，key属性的值要保证唯一

通过便利创建什么元素，就要把key通过遍历加上。

尽量避免使用索引号作为key

```react
import React from 'react'
import ReactDOM from 'react-dom'

const songs = [
    {id: 1, name: '111'},
    {id: 2, name: '222'},
    {id: 3, name: '333'},
]

const title = (
	<ul>
        {songs.map(item = > <li key={item.id}>{item.name}</li>)}
	</ul>
)

ReactDOM.render(title, document.getElementById('root'))
```

### JSX样式处理

两种方式：

1. 行内样式——style
2. 类名——className

使用样式时需要引入

```react
import React from 'react'
import ReactDOM from 'react-dom'

//引入css
import './css/index.css'

const list = (
    <h1 className="title" style={{ clolr: 'red', backgroundColor: 'skyblue'}}>
)

ReactDOM.render(list, document.getElementById('root'))
```

### JSX总结

1. JSX是React的核心内容
2. JSX表示在JS中写HTML结构，是声明式的体现
3. 使用JSX配合嵌入JS表达式、条件渲染、列表渲染、可以描述任意UI结构
4. 推荐使用className的方式给JSX添加样式
5. React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能

## React组件

组件的特点：

1. 可复用
2. 独立
3. 可组合

### 组件的两种创建方式

1. 函数
2. 类

#### 函数组件

为了和函数进行区分，对函数组件进行如下约定：

1. 函数名必须以**大写字母开头**
2. 函数组件必须**有返回值**

但函数返回值可以为NULL

```react
function Hello() {
    return (
        <div>我是一个函数组件</div>
    )
}
```

渲染组件时直接使用函数名作为组件标签即可

```react
ReactDOM.render(<Hello />, root)
```

也能使用箭头函数来构造组件

```react
const Hello = () => <div>我是一个箭头函数组件</div>
```

React根据名称首字母是否大写来区分组件和普通React元素

#### 类组件

使用ES6中的class创建的组件，为了与普通类进行区分，使用如下约定：

1. 类名首**字母大写**
2. 类组件需要继承自**React.Component**，从而使用父类中提供的方法和属性
3. 类组件必须提供**render()**方法
4. render方法**必须有返回值**，表示组件的结构

```react
class Hello extends React.Component {
    render() {
        return <div>Hello Class Component</div>
    }
}

ReactDOM.render(<Hello />, root)
```

#### 组件的组织

组件作为一个单独的个体，一般会放到一个单独的JS文件中

1. 创建JS文件，对应组件名称.js
2. 在JS文件中导入React
3. 创建组件
4. 在JS文件中导出该组件
5. 在index.js中导入该组件
6. 渲染组件

组件JS文件

```react
// Hello.js
import React from 'react'
class Hello extends React.Component {
    render() {
        return <div>Hello Class Component</div>
    }
}

// 导出Hello组件
export default Hello
```

index中渲染组件

```react
// index.js
import Hello from './Hello'
// 渲染导入的Hello组件
ReactDOM.render(<Hello />, root)
```

## React事件处理

### 事件绑定

1. React事件绑定语法与DOM事件绑定相似
2. on+事件名称={事件处理程序}，如onClick={() => {}}
3. React事件采用驼峰命名法

```react
class App exntends React.Component {
    handleClick() {
        console.log('单击事件被触发')
    }
    
    render() {
        return (
            <button onClick={this.handleClick}>点我</button>
        )
    }
}
```

函数组件绑定事件，使用内部函数定义

```react
function App() {
    function handleClick() {
        console.log('单击事件出发了')
    }
    
    return(
        <button onClick={handleClick}>点我</button>
    )
}
```

### 事件对象

1. 可以通过事件处理程序的参数获取到事件对象
2. React中的事件对象叫做：**合成事件(重要，需补充)**（对象）
3. 合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题

```react
function handleClick(e) {
    e.preventDefault() //组织浏览器的默认行为
    console.log('事件对象', e)
}

<a onClick={handleClick}>点我，不会跳转页面</a>
```

### 有状态组件和无状态组件

1. 函数组件又称为**无状态组件**，类组件叫做**有状态组件**
2. 状态(state)即**数据**
3. 函数组件没有自己的状态，**只负责数据展示**（静）
4. 类组件有自己的状态，**负责更新UI**

### 组件的state和setState

#### state的基本使用

1. 状态即数据，时组件内部的私有数据，只能在组件内部使用
2. state的值是对象，表示一个组件中可以有多个数据

状态的初始化方式如下：

```react
class Hello extends React.Component {
    constructor() {
        // ES6中必须包含
        super();
        // 初始化state
        this.state = {
            count: 0,
        };
    }
    
    render() {
        return (
            <div>有状态组件</div>
        )
    }
}
```

也可以使用ES6中的简化语法：

```react
class Hello extends React.Component {
    // 简化语法
    // 初始化state
    state = {
        count: 0
    }
    
    render() {
        return (
            <div>有状态组件</div>
        )
    }
}
```

可以使用this获取状态的数据

```react
class Hello extends React.Component {
    // 简化语法
    // 初始化state
    state = {
        count: 0
    }
    
    render() {
        return (
            <div>计数器: {this.state.count}</div>
        )
    }
}
```

#### setState()修改状态

1. 状态是可变的
2. 语法：this.setState({要修改的数据})
3. 不要直接修改state中的值
4. setState()作用：
   1. 修改state
   2. 更新UI
5. 思想：**数据驱动视图**

```react
class App extends React.Component {
    state = {
        count: 0
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={() => {
                        this.setState({
                            count: this.state.count + 1
                        })
                    }}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

#### 从JSX中抽离事件处理程序

1. JSX中掺杂了过多JS逻辑代码会使得JSX逻辑混乱
2. 将逻辑抽离到单独的方法中，保证JSX结构清晰
3. 由于箭头函数不具备this，因此会向外层寻找this的指向，render()函数中的this指向组件实例，因此不会有问题，但进行抽离后的函数不具备this指向。
4. 可以使用如下解决方式：
   1. 箭头函数
   2. Function.prototype.bind()
   3. class的实例方法

##### 箭头函数

利用箭头函数自身不绑定this的特点，会根据外部环境推断。对于方法中的this，谁调用就指向谁。

```react
class App extends React.Component {
    state = {
        count: 0
    }

	// 事件处理程序
	onIncrement(){
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={() => this.onIncrement()}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

##### Function.prototype.bind()

1. 利用ES5中的bind方法，将事件处理程序中的this与组件实列绑定

2. 类似于小程序中的

   ```js
   let that = this
   that.onIncrement()
   ```

```react
class App extends React.Component {

	constructor() {
        super()
        this.state = {
        	count: 0
    	}
        this.onIncrement = this.onIncrement.bind(this)
    }

	// 事件处理程序
	onIncrement(){
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={this.onIncrement}>+1</button>
            </div>
        )
    }
}
```

##### class实例方法

使用箭头函数形式的class实例方法

注意，该语法为实验性语法，但由于babel的存在，可以直接使用

```react
class App extends React.Component {
    state = {
        count: 0
    }

	// 事件处理程序
	onIncrement = () => {
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={this.onIncrement}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

## 表单处理

React两种表单处理方式

1. 受控组件
2. 非受控组件（DOM方式）

### 受控组件

1. HTML中的表单元素是可输入的，也就是有自己的可变状态
2. React中可变状态通常保存在state中，使用setState来i需改
3. React将state与表单元素值value绑定到一起，由state的值来控制表单元素的值
4. 受控组件：即值收到React控制的表单元素

受控组件的使用包括以下步骤：

1. 在state中添加一个状态，作为表单元素的value值（控制表单元素值的来源）
2. 给表单元素绑定change事件，将表单元素的值设置为state的值（控制表单元素值的变化）

```react
class App extends React.Component {
    state = {
        txt: '',
    }

	handleChange = e => {
        this.setState({
            txt: e.target.value
        })
    }

	render() {
        return (
            <div>
                <input type="text" value={this.state.txt} onChange={this.handleChange} />
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

如下练习将不同的表单标签转化为受控组件。

1. 文本框，富文本框，下拉框操作value属性
2. 复选框操作checked属性

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.state = {
      txt: '',
      content: '',
      city: 'bj',
      Selection: false,
    }
  }

  handleChange = e => {
    this.setState({
      txt: e.target.value
    })
  }

  handleContent = e => {
    this.setState({
      content: e.target.value
    })
  }

  handleCity = e => {
    this.setState({
      city: e.target.value
    })
  }

  handleSelection = e => {
    this.setState({
      Selection: e.target.checked
    })
  }

  render(){
    return (
      <div>
        <input type="text" value={this.state.txt} onChange={this.handleChange}></input>
        <br/>

        <textarea value={this.state.content} onChange={this.handleContent}></textarea>
        <br/>

        <select value={this.state.city} onChange={this.handleCity}>
          <option value="sh">上海</option>
          <option value="bj">北京</option>
          <option value="gz">广州</option>
        </select>
        <br/>

        <input type="checkbox" checked={this.state.Selection} onChange={this.handleSelection}></input>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

但是可以发现用如上方法控制表单元素会产生很多重复新的onChange函数，因此需要对多表单元素进行优化，即使用一个事件处理程序同时处理多个表单元素。

#### 多表单元素优化

1. 给表单元素添加name属性，名称与state相同
2. 根据表单元素类型获取对应值
3. 在change事件处理程序中通过[name]来修改对应的state

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.state = {
      txt: '',
      content: '',
      city: 'bj',
      Selection: false,
    }
  }

  handleChange = e => {
    // 获取当前DOM对象
    const target = e.target;

    // 根据类型获取值
    const value = target.type === 'checkbox'
      ? target.checked
      : target.value;

    // 获取name
    const name = target.name;

    this.setState({

      // 此处定义属性使用了ES6中的新特性 属性名表达式
      // 即使用表达式作为属性或函数名
      // 此处会将name转化为string
      [name]: value,
    });
  }

  render(){
    return (
      <div>
        <input type="text" name='txt' value={this.state.txt} onChange={this.handleChange}></input>
        <br/>

        <textarea name='content' value={this.state.content} onChange={this.handleChange}></textarea>
        <br/>

        <select name='city' value={this.state.city} onChange={this.handleChange}>
          <option value="sh">上海</option>
          <option value="bj">北京</option>
          <option value="gz">广州</option>
        </select>
        <br/>

        <input name='Selection' type="checkbox" checked={this.state.Selection} onChange={this.handleChange}></input>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

### 非受控组件

借助于ref，使用原生DOM方法来获取表单元素值

ref的作用：获取DOM或组件

这种方式通过直接操作DOM实现

使用步骤：

1. 通过React.createRef()方法创建一个ref对象
2. 将创建好的ref对象添加到文本框中
3. 通过ref对象获取到文本框中的值

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.txtRef = React.createRef()
  }

  // 获取文本框的值
  getTxt = () => {
    console.log('文本框的值为：', this.txtRef.current.value);
  }

  render(){
    return (
      <div>
        <input type="text" ref={this.txtRef} />

        <button onClick={this.getTxt}>获取文本框的值</button>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

## 案例一

式样以上知识，实现一个无回复功能的评论版

### 渲染评论列表

1. 在state总初始化评论列表数据
2. 使用map循环渲染列表数据
3. 注意给每个被渲染的元素添加一个key

### 评论区条件渲染

1. 判断列表长度是否为0
2. 如果为0则渲染暂无评论 
3. 注意讲逻辑与JSX分离

### 获取评论信息

1. 使用受控组件的方式实现
2. 注意设置handle方法和name属性

### 发表评论

1. 为按钮绑定单击事件
2. 在事件处理程序中通过state获取评论信息
3. 将评论添加到state中，更新state
4. 边界情况：清空文本框，文本框判空

### 最终实现

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {

  constructor() {
    super()
    this.state = {
      comments: [
        { id: 1, name: 'jack', comment: 'You jump'},
        { id: 2, name: 'rose', comment: 'I jump'},
        { id: 3, name: 'joker', comment: 'I see you jump'},
      ],
      // 当前评论人
      userName: '',
      // 当前评论内容
      userContent: '',
    }
  }

  renderList() {
    const {comments} = this.state
    if(comments.length === 0) {
      return (
        <div className='no-comment'>暂无评论，快去评论吧</div>
      )
    } else {
      return (
        <ul>
          { 
            comments.map(item => (
              <li key={item.id}>
                <h3>评论人：{item.name}</h3>
                <p>评论内容：{item.comment}</p>
              </li>
            ))
          }
        </ul>
      )
    }
  }

  handleChange = (e) => {
    const {name, value} = e.target;
    this.setState({
      [name]: value,
    });
  }

  addComment = () => {
    const {comments, userName, userContent} = this.state

    //判空，使用trim去除空格
    if(userName.trim() === '' || userContent.trim === '' ) {
      alert('请输入评论人和评论内容');
      return;
    }
    // 此处使用了ES6的新特性：拓展运算符...
    // 该运算符用于将可便利对象拆分为单个
    const newIndex = comments.length + 1;
    const newComments = [...comments,
      {
        id: newIndex,
        name: userName,
        comment: userContent,
      }
    ];

    console.log(newComments);

    this.setState({
      comments: newComments,
      userName: '',
      userContent: '',
    });
  }

  render(){
    const {userName, userContent} = this.state;

    return (
      <div className='app'>
        <div>
          <input
            name='userName'
            className='user'
            value={userName}
            type='text'
            placeholder='请输入评论人'
            onChange={this.handleChange} />
          <br/>

          <textarea
            className='content'
            name='userContent'
            cols='30'
            row = '10'
            placeholder='请输入评论内容'
            value={userContent}
            onChange={this.handleChange}
            />
            <br />
            <button onClick={this.addComment}>发表评论</button>
        </div>
        {/* 通过条件渲染决定渲染什么内容 */}
        {this.renderList()}
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

## 组件间通讯

### 组件props

由于组件的封闭性，要接受外部数据应该通过props来实现

- props的作用：接受传递给组件的数据
- 传递数据：给组件标签添加属性
- 接受数据：
  - 函数组件通过**参数props**接收数据
  - 类组件通过**this.props**接受数据

```react
<Hello name='jack' age = {19} />
```

```react
function Hello(props) {
    console.log(props)
    return (
        <div>接受到数据: {props.name}</div>
    )
}
```

```react
class Hello extends React.Component {
    
    // 推荐写法
    constructor(props) {
        super(props)
    }
	render() {
		return (
			<div>接收到数据：{this.props.age}</div>
		)
	}
}
```

#### 组件props的特点

1. 可以给组件传递任意类型的值
2. props是一个**只读**属性，无法修改
3. 使用类组件时，如果写了构造函数，应该将props传递给super()，否则，无法在构造函数中获取到props

### 组件通讯的三种方式

1. 父组件 -> 子组件
2. 子组件 -> 父组件
3. 兄弟组件

#### 父组件到子组件

1. 父组件提供要传递的state数据
2. 给子组件标签添加属性，值为state中的数据
3. 子组件中通过props接受父组件中传递的数据

```react
class Parent extends React.Component {
    state = { lastName: '王' }
	render() {
        return (
            <div>
                传递给子组件：<Child name={this.state.lastName} />
            </div>
        )
    }
}
```

```react
function Child(props) {
    return <div>子组件接受：{props.name} </div>
}
```

#### 子组件到父组件

思路：利用回调函数，父组件提供回调，子组件调用，将要传递的数据作为回调函数的参数

1. 父组件提供一个回调函数，用于接收数据
2. 将该函数作为属性值传递给子组件
3. 子组件通过props调用回调函数
4. 将子组件的数据作为参数传递给回调函数
5. 注意回调函数中this指向的问题

```react
class Parent extends React.Component {
    // 提供回调
    getChildMsg = (msg) => {
        console.log('接收到子组件数据', msg)
    }
	render() {
        return (
            // 传递给子组件
            <div>
                子组件：<Child getMsg={this.getChildMsg} />
            </div>
        )
    }
}
```

```react
class Child extends React.Component {
    // 提供回调
    stats = {childMsg: 'React'}
	handleClick = () => {
		this.props.getMsg(this.state.childMsg)        
    }
	render() {
        return (
            // 传递给子组件
            <button onClick={this.handleClick}>点我，给父组件传递数据</button>
        )
    }
}
```

#### 兄弟组件通讯

- 思路：将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态

- 将这种思想称为**状态提升**
- 公共父组件职责：
  1. 提供共享状态（父到子通讯）
  2. 提供操作共享状态的方法（子到父通讯）
- 要通讯的子组件只需要通过props接受状态或操作状态的方法

```react
class Counter extends React.Component {
    // 提供共享状态
    state = {
        count: 0
    }
	
	// 提供修改状态的方法
	onIncrement = () => {
        this.setState({
            count: this.state.count + 1
        })
    }
    
    render() {
        return (
            <div>
                <Child1 count={this.state,count} />
                <Child2 onIncrement={this.onIncrement} />
            </div>
        )
    }
}

const Child1 = (props) => {
    return <h1>计数器：{props.count}</h1>
}

const CHild2 = (props) => {
    return <button onClick={() => props.onIncrement}> +1 </button>
}
```

### Context

考虑这样一个实际应用中的问题：对于相互嵌套很深层次的组件，我们应该如何进行通讯？例如下面这个结构中组件App想要给Child传递数据

常规的思路可能是使用Props一层一层往下传递，但是这样操作起来会十分繁琐。

```xml
<App>
    <Node>
        <SubNode>
            <Child>
            </Child>
        </SubNode>
    </Node>
</App>
```

React为我们提供了更好的方式：**Context**

它的作用就是跨组件传递数据（比如：主题，语言设置等需要在根组件配置数据）

使用方法如下：

1. 调用React.createContext()创建Provider(提供数据)和Consumer(消费数据)两个组件
2. 使用Provider组件作为父节点
3. 设置Value属性，表示要传递的数据
4. 调用Consumer组件接受数据
5. 即Provider包裹父节点，Consumer被子组件包裹

```react

// 创建context
const {Provider, Consumer} = React.getContext() 

class App extends React.Component {
	render() {
        return (
            // 使用Provider作为父节点
            // 设置要传递的数据
            <Provider value="pink">
            	<div className='app'>
                	<Node />
	            </div>
			</Provider>
        )
    }
}

const Node = props => {
    return (
        <div className="node">
            <subNode />
        </div>
    )
}

const SubNode = props => {
    return (
        <div className="subnode">
            <Child />
        </div>
    )
}

const Child = props => {
    return <div className='child'>
        <!-- 使用consumer组件接受数据 -->
        <Consumer>
            {
                data => <span>我是子节点 -- {data}</span>
            }
        </Consumer>
    </div>
}

ReactDOm.render(<App />, document.getElementById('root'))
```

### props深入

#### children属性

表示组件标签的子节点，当组件标签有子节点时，props就会有该属性。

children属性和普通的props一样，值可以任意。

```react
const App = props => {
    return (
        <div>
            <h1>组件标签的子节点：</h1>
            {props.children}
        </div>
    )
}

ReactDOM.render{<App>我是子节点</App>, document.getElementById('root')}
```

#### props校验

对于组件而言，props是外来的，无法保证使用组件时传入的值的格式。

那么会出现以下问题：

1. 传入数据不对可能导致组件内部报错
2. 组件的使用者不知道明确的错误原因

React提供了props校验作为解决方法。

props校验：

1. 运行在创建组件时只当props的类型、格式等

2. 能捕获使用组件时因为props导致的错误，给出明确的错误提示，增加组件的健壮性

使用步骤：

1. 安装prop-types包
2. 导入prop-types
3. 使用`组件名.propTypes={}`来给组件的props添加校验规则
4. 校验规则通过PropTypes对象指定

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'

const App = props => {
  const arr = props.colors
  const lis = arr.map((item, index) => <li key={index}>{item}</li>)

  return <ul>{lis}</ul>
}

// 添加props校验
App.propTypes = {
  colors: PropTypes.array
}

ReactDOM.render(<App colors={['red', 'blue']} />, document.getElementById('root'))
```

props校验常见校验规则：

| 常见类型      | array,bool,func,number,object,string |
| ------------- | ------------------------------------ |
| React元素类型 | element                              |
| 必填项        | isRequired                           |
| 特定结构对象  | shape({})                            |

详见官方文档：[PropTypes](https://reactjs.org/docs/typechecking-with-proptypes.html)

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'

const App = props => {
  return (
    <div>
      <h1>props校验：</h1>
    </div>
  )
}

// 添加props校验
// 属性a的类型：        数值（number）
// 属性fn的类型：       函数（func）且为必填
// 属性tag的类型：      React元素（element）
// 属性filter的类型：   对象（{area: '上海', price: 1999}）
App.propTypes = {
  a: PropTypes.number,
  fn: PropTypes.func.isRequired,
  tag: PropTypes.element,
  filter: PropTypes.shape({
    area: PropTypes.string,
    price: PropTypes.number,
  })
}

ReactDOM.render(<App fn={() => {}} />, document.getElementById('root'))
```

#### props默认值

例如当我们设计一个分页组件时，每页显示条数可以为默认值。

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'

const App = props => {
  return (
    <div>
      <h1>props默认值：{props.pageSize}</h1>
    </div>
  )
}

// 添加props默认值
App.defaultProps = {
  pageSize: 10
}

ReactDOM.render(<App />, document.getElementById('root'))
```

## 组件的生命周期

学习组件的生命周期有助于理解组件的运行方式、从而完成更复杂的组件功能、分析组件错误原因等等

组件的生命周期指：组件从被创建到挂载在页面中运行，再到组件不用时卸载的过程。

钩子函数：生命周期的每个阶段总伴随着一些方法调用，这些方法就是生命周期的钩子函数，为开发人员在不同阶段操作组件提供了时机。

**只有类组件才有生命周期**

#### 生命周期的三个阶段

1. 创建时
2. 更新时
3. 卸载时

##### 创建时（挂在阶段）

- 执行时机：组件创建时（页面加载时）
- 钩子函数执行顺序：
  1. constructor()
  2. render()
  3. componentDidMount()

| 钩子函数          | 触发时机                  | 作用                                    |
| ----------------- | ------------------------- | --------------------------------------- |
| constructor       | 创建组件时，最先执行      | 1. 初始化state2. 为事件处理程序绑定this |
| render            | 每次组件渲染都会触发      | 渲染UI（注意：不能调用setState()）      |
| componentDidMount | 组件挂载（完成DOM渲染）后 | 1. 发送网络请求2. DOM操作               |

> 不能在render中调用setState的原因是：调用setState会导致数据更新以及UI更新（渲染），即setState方法将会调用render方法，因此如果在render中调用setState会导致递归效用

> componentDidMount会紧跟render方法触发，由于DOM操作需要DOM结构已经渲染，因此DOM操作应被放置于该钩子函数内。

##### 更新阶段

- 更新阶段的执行时机包括：
  1. New props，组件接收到新属性
  2. setState()，调用该方法时
  3. forceUpdate()，调用该方法时

其中forceUpdate用于使组件强制更新，即使没有数值上的改变。

- 钩子函数执行顺序：
  1. shouldComponentUpdate
  2. render()
  3. componentDidUpdate()

| 钩子函数              | 触发时机                                                   | 作用                                       |
| --------------------- | ---------------------------------------------------------- | ------------------------------------------ |
| shouldComponentUpdate | 更新阶段的钩子函数，组件重新渲染前执行（即在render前执行） | 通过该函数的返回值来决定组件是否重新渲染。 |
| render                | 每次组件渲染都会触发                                       | 渲染UI（与挂载阶段是同一个）               |
| componentDidUpdate    | 组件更新（完成DOM渲染）后                                  | 1. 发送网络请求2. DOM操作                  |

> 需要注意的是在componentDidUpdate中调用setState()必须放在一个if条件中，原因与在render中调用setState相同，render执行完后会立即执行componentDidUpdate导致递归调用。通常会比较更新前后的props是否相同，来决定是否重新渲染组件。可以使用componentDidUpdate(prevProps)得到上一次的props，通过this.props获取当前props

```react
class App extends React.Component {
    
    constructor(props) {
        super(props)
        
        this.state = {
            count: 0
        }
        console.warn('生命周期钩子函数：constructor')
    }
    
   	componentDidMount(){
         console.warn('生命周期钩子函数：componentDidMount')
    }
    
    handleClick = () =>{
        this.setState({
            count: this.state.count + 1
        })
    }
    
    render() {
        return (
            <div>
                <Counter count={this.state.count} />
                <button onClick={this.handleClick}>打豆豆</button>
            </div>
        )
    }
}

class Counter extends React.Component {
    render() {
        console.warn('--子组件--生命周期钩子函数：render')
        return <h1 id='title'>统计豆豆被打的次数：{this.props.count}</h1>
    }
    

    
    conponentDidUpdate(prevProps) {
        console.warn('--子组件--生命周期钩子函数：conponentDidUpdate')
        
        console.log('上一次的props: ', prevProps, '，当前的props：', this.props)
        if(prevProps.count !== this.props.count) {
            this.setState({})
            // 发送ajax请求的代码
        }
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

##### 卸载时（卸载阶段）

- 执行时机：组件从页面中消失

- 钩子函数执行顺序：
  - componentWillUnmount

| 钩子函数             | 触发时机                 | 作用                               |
| -------------------- | ------------------------ | ---------------------------------- |
| componentWillUnmount | 组件卸载（从页面中消失） | 执行清理工作（比如：清理定时器等） |

```react
class App extends React.Component {
    
    constructor(props) {
        super(props)
        
        this.state = {
            count: 0
        }
        console.warn('生命周期钩子函数：constructor')
    }
    
   	componentDidMount(){
         console.warn('生命周期钩子函数：componentDidMount')
    }
    
    handleClick = () =>{
        this.setState({
            count: this.state.count + 1
        })
    }
    
    render() {
        return (
            <div>
                {this.state.count > 3 ? (
                    <p>豆豆被打死了~</p>
                ) : (
                  <Counter count={this.state.count} />  
                )}
                <button onClick={this.handleClick}>打豆豆</button>
            </div>
        )
    }
}

class Counter extends React.Component {
    
    conponentDidMount() {
        // 开启定时器
    	this.timerId = setInterval(() => {
            console.log("定时器正在执行~")
        }. 500)    
    }
    
    render() {
        console.warn('--子组件--生命周期钩子函数：render')
        return <h1 id='title'>统计豆豆被打的次数：{this.props.count}</h1>
    }
    
    conponentWillUnmount(){
        console.warn('--子组件--生命周期钩子函数：conponentWillUnmount')
        // 清理定时器
        clearInterval(this.timerId)
    }
    
    conponentDidUpdate(prevProps) {
        console.warn('--子组件--生命周期钩子函数：conponentDidUpdate')
        
        console.log('上一次的props: ', prevProps, '，当前的props：', this.props)
        if(prevProps.count !== this.props.count) {
            this.setState({})
            // 发送ajax请求的代码
        }
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

##### 其他钩子函数

- 旧版本遗留，先已弃用的钩子函数：
  - componentWillMount()
  - ComponentWillReceiveProps()
  - ComponentWillUpdate()
- 新版完整生命周期钩子函数：
  - 创建时：
    - constructor
    - getDerivedStateFromProps(不常用)
    - render
    - React更新DOM和refs
    - componentDidMount
  - 更新时
    - getDerivedStateFromProps(不常用)
    - shouldComponentUpdate(详见组件性能优化)
    - render
    - getSnapshotBeforeUpdate(不常用)
    - React更新DOM和refs
    - componentDidUpdate
  - 卸载时
    - componentWillUnmount

## render-props和高阶组件

### 组件复用

如果两个组件中的部分功能相似或相同时，该如何处理？

因此对于相似的功能，我们希望能偶复用相似的功能。

复用时事实上时复用以下两点：

1. state
2. 操作state的方法（组件状态逻辑

React中组件复用包含两种方式：

1. render props模式
2. 高阶组件（HOC）

以上两种方式是利用React自身特点的编码技巧，不是API

### render-props模式

思路：将要复用的state和操作state的方法封装到一个组件中

问题：

1. 如何拿到该组件中复用的state
   - 在使用组件时，添加一个值为函数的prop，通过函数参数来获取（需要组件内部实现）
2. 如何渲染任意UI
   - 使用该函数的返回值作为要渲染的UI内容（需要组件内部实现）

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'

/*
  render props 模式
*/

// 导入图片资源
import img from './images/end_favicon128.ico'

// 创建复用组件
class Mouse extends React.Component {
  constructor(props) {
    super(props)
      
    // 鼠标位置state
    this.state = {
      x: 0,
      y: 0,
    }
  }

  // 鼠标位置事件处理函数
  handleMouseMove = e => {
    this.setState({
      x: e.clientX,
      y: e.clientY,
    })
  }

  // 开启鼠标监听事件
  componentDidMount() {
    window.addEventListener('mousemove', this.handleMouseMove)
  }

  render() {
    return this.props.render(this.state)
  }
}

const App = props => {
  return (
    <div>
      <h1>render props 模式</h1>
      <Mouse render={(mouse) => {
        return (
          <p>鼠标位置：{mouse.x}, {mouse.y}</p>
        )
      }} />

      {/* 复用Mouse组件 */}
      <Mouse render={mouse => {
        return (
          <img src={img} style={{
            position: 'absolute',
            top: mouse.y,
            left: mouse.x
          }} />
        )
      }}>
      </Mouse>
    </div>
  )
}


ReactDOM.render(<App />, document.getElementById('root'))
```

在上面这个例子中：

- Mouse组件负责：封装复用的状态逻辑代码：
  1. 状态：鼠标坐标（x，y）
  2. 操作状态的方法：鼠标移动事件
- 传入的render prop负责：使用复用的状态来渲染UI结构

##### children代替render

此外还能使用children替代上例中的render，这种方式更直观，更推荐使用：

```react
<Mouse>
    {(mouse) => <p>鼠标位置是 {mouse.x}, {mouse.y}</p>}
</Mouse>

// 组件内部
render() {
  return this.props.children(this.state)
}
```

此处联想到前文提到的Context：

```react
const Child = props => {
    return <div className='child'>
        <!-- 使用consumer组件接受数据 -->
        <Consumer>
            {
                data => <span>我是子节点 -- {data}</span>
            }
        </Consumer>
    </div>
}
```

实际上此处context也是使用了render props模式，且使用了children代替render。

现在可以对render props给出一个粗略的定义：

> render props 模式是指将一个函数作为prop，并使用该函数告诉组件要渲染什么内容的技术

##### render props模式代码优化

1. 给render props模式添加props校验
2. 组件卸载时应该解除mousemove事件绑定（使用react添加的事件绑定react会帮我们处理）

### 高阶组件

高阶组件时一种采用**包装（装饰）模式**实现的状态逻辑复用（例如python中的高阶函数，java中的AOP）

实现思路：

- 高阶组件（HOC）是一个函数，接收要包装的组件，返回增强后的组件
- 高阶组件内部创建一个类组件，在这个类组件中提供复用的状态逻辑代码，通过prop将复用的状态传递给包装组件WrappedComponent

#### 使用步骤

1. 创建一个函数，名称约定以with开头
2. 指定函数参数，参数应以大写字母开头（因为参数要被作为组件渲染）
3. 在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回
4. 在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件
5. 调用高阶组件，传入要增强的组件，通过返回值拿到增强后的组件，并将其渲染到页面中

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';
import PropTypes from 'prop-types'
import react from 'react';
import img from './images/end_favicon128.ico'
import { render } from '@testing-library/react';

/*
  高阶组件模式
*/

// 创建高阶组件
function withMouse(WrappedComponent) {
  // 该组件提供复用的状态逻辑
  class Mouse extends react.Component {
    constructor() {
      super()

      this.state = {
        x: 0,
        y: 0,
      }
    }

    componentDidMount() {
      window.addEventListener('mousemove', this.handleMouseMove)
    }

    handleMouseMove = e => {
      this.setState({
        x: e.clientX,
        y: e.clientY,
      })
    }

    render() {
      return <WrappedComponent {...this.state}></WrappedComponent>
    }

    componentWillUnmount() {
      window.removeEventListener('mousemove', this.handleMouseMove)
    }
  }

  return Mouse
}


const Cat = props => (
  <img src={img} alt='logo' style={{
    position: 'absolute',
    top: props.y,
    left: props.x,
  }}
  />
)

const Position = props => (
  <p>
    鼠标当前位置：(x: {props.x}, y: {props.y})
  </p>
)


// 获取增强后的组件
const MousePosition = withMouse(Position)

const CatMouse = withMouse(Cat)

class App extends React.Component {
  render (){
    return (
      <div>
        <h1>高阶组件模式</h1>
        {/* 渲染增强后的组件 */}
        <MousePosition />
        <CatMouse />
      </div>
    )
  }
} 


ReactDOM.render(<App />, document.getElementById('root'))
```



#### 设置displayName

使用高阶组件存在的问题：

- 得到的两个组件名称相同
  - 原因是默认情况下React使用组件名称作为displayName
  - 为高阶组件设置displayName便于调试时区分不同的组件
  - displayName：用于设置调试信息（React Develop Tools信息）

设置方法：

```react
// 获得组件的displayName的函数
function getDisplayName(WrappedComponent) {
  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
}

// 设置displayName
Mouse.displayName = `WithMouse${getDisplayName(WrappedComponent)}`
```



#### 传递props

使用高阶组件实际上是用一个组将将另一个组件包裹，那么这样会导致渲染时传入的props无法传递到被包裹的组件，而是传递到用于包裹的组件中，因此需要在用于包裹的组件中将props和state一起传递给被包裹的组件。

```react
render() {
      return <WrappedComponent {...this.state} {...this.props}></WrappedComponent>
}
```

## React原理

### setState方法

#### 更新数据

- setState方法更新数据时**异步**的
- 因此使用该语法时，后面的setState不能依赖于前面的setState
- 另外，待用多次setState方法，只会触发一次重新渲染

#### 推荐语法

推荐使用setState((state, props) => {})语法

- 参数state表示最新的state

- 参数props表示最新的props
- 该方法中state的更新仍然是异步的，但该方法利用了回调函数的特性：setState本身是异步的，但setState函数内部的语句依然是同步进行的。解决数据不一致的问题，使得其参数中的state每次都是获取到最新的state，这样连续使用setState方法不会出现异步问题

```react
this.setState((state, props) => {
    return {
        count: state.count + 1
    }
})
this.setState((state, props) => {
    return {
        count: state.count + 1
    }
})
// 两次setState将导致count+2
```

##### 回调函数

思考这样一个实际引用中的问题：

```js
function postApi (url, data) {
    var result = {};
    $.ajax({
        url: url,
        type: 'post',
        data: data ? data : {},
        success: (res) => {
            result = res
        },  
        fail:  (err) => {
           result = res
         }
    })
    return result
}
```

我们需要通过调用请求API得到一些数据，请求API中使用Ajax请求数据，但Ajax是异步的。

于是我们调用：

```js
var res = postApi(url, data)
```

得到的res将是{}。

原因就在于JS这类脚本语言的执行机制，当js代码运行到调用postAPI的语句时，对于这些同步语句，JS将顺序执行，知道遇到异步语句，而此时，JS已经执行完postApi的传参，那么下一步将会创建一个result变量并将其初始化。接下来JS遇到了异步语句ajax，那么JS将会将ajax放入异步队列，然后继续执行下一个同步语句，也就是return result，同时位于异步队列中的ajax会进行计时器等待，取出并执行等操作。因此res接收到数据时，postApi中并没有完成对result的赋值。

当然ajax可以通过设置async:false将其设置为同步语句，但这样会导致进程阻塞效率下降。因此我们现在希望在执行完ajax中的语句后再对res赋值。

于是我们想到可以把postApi中的res作为参数传递给一个函数，由于函数时在异步语句内调用的，而异步语句的内部的操作实际上是同步的，因此ajax内部的函数调用会顺序执行。

下面我们给出回调函数的定义：

>回调函数值函数的应用方式，出现在两个函数之间，用于指定**异步的语句做完之后要做的事情**

下发如下：

- 把函数a当做参数传递到函数b中
- 在函数b中以形参的方式进行调用

```js
function a(cb){
  cb()
}
function b(){
  console.log('函数b')
}
a(b)
```

这一定义很像python中的高阶函数，高阶函数的定义为：以函数作为参数的函数，称为高阶函数。

可见高阶函数是对上例中的a进行了定义，而回调函数是对上例中的b进行了定义。

那么我们就可以使用回调函数来解决之前提到的这个问题：

```js
function postApi ( url, data, cb ) {
    $.ajax({
        url: url,
        type: 'post',
        data: data ? data : {},
        success:  (res) => {
            cb && cb(res)
        },
        fail:  (err) => {
            cb && cb(err)
        }
    })
}

postApi(url, data, (res) => {
    console.log(res)
})
```

此时我们就可以在调用postApi时传入的箭头函数中得到正确的res值，并在其中对res值进行一些操作。

甚至还可以使用闭包这一概念去理解这一方法的应用，使用回调函数时，实际上是利用了闭包的思想，保存了函数执行时的作用域，使得异步操作能在这个作用域中拿到准确的数据。

#### 第二个参数

事实上setState函数还存在第二个参数：

```react
this.setState(
    (state, props) => {},
    () => {console.log('这个回调函数会在状态更新后立即执行')}
)
```

- 使用场景：在状态更新后并且页面完成重修渲染后立即执行某个操作
- 注意这个执行时机与componentDidUpdate钩子函数执行时机相同
- 语法`setState(updater[, callback])`

### JSX语法转化过程

- JSX仅仅是React.createElement的语法糖
- JSX语法会被@babel/preset-react插件编译为createElement方法
- createElement方法最终又会被转化为React元素（React Element），该元素是一个JS对象，用来描述UI内容

### 组件更新机制

对于多层树结构的组件结构，组件的更新过程如下：

- 父组件重新渲染时，子组件也会被重修渲染
- 渲染只发生在当前组件的子树中
- 更新顺序按中序遍历序更新

![image-20220111111224656](E:\EnderBlogSource\EnderXiao.github.io\source\images\image-20220111111224656.png)

### 组件性能优化

#### 减轻state

- 只存储根组件渲染相关的数据（如列表数据/loading等）
  - 不用做渲染的数据不要放在state中，比如定时器id
  - 这些数据可以直接放在this中

#### 避免不必要的重新渲染

- 父组件的更新将会引起子组件更新
- 但如果子组件没有任何变换也会重新渲染
- 可以使用钩子函数shouldComponentUpdate(nextProps, nextState)
  - 触发时机：更新阶段的钩子函数，组件重新渲染前执行（即在render前执行）
  - 作用：返回一个boolean，通过该函数的返回值来决定组件是否重新渲染。
  - 两个参数表示了最新的state与最新的props
  - 在该函数中使用this.state能够获取到更新前的状态

#### 纯组件

考虑上文提到的使用shouldComponentUpdate方法实现的避免重新渲染，如果每一个组件都需要我们手动地去实现这样的一个钩子函数，将会产生非常多的重复代码，但是有时候使用该方法运行我们进行一些特殊的操作，比如深比较，因此React为我们提供了更方便的方法：PureComponent

```react
class Father extends Component {
    constructor(props) {
        super(props);
        this.state = { value:0 }
    }
    onClick=()=>{
        this.setState({
            value : this.state.value+1
        })
    }
    render() { 
        console.log('father render')
        return (<div>
            <button onClick={this.onClick}>click me</button>
            <Son value={this.state.value}></Son>
        </div>  );
    }
}
```

```react
import React, { Component,PureComponent } from 'react';

class Son extends PureComponent {
    constructor(props) {
        super(props);
        this.state = {  }
    }
    render() { 
        console.log('son render')
        return (<div>
            {this.props.value}
        </div>  );
    }
}
 
export default Son;
```

但是使用纯组件时，纯组件内部进行的新旧值对比采用的是shallpw compare（浅对比）的方法：

- 对于值类型而言：直接比较两个值是否相同
- 但对于引用类型而言：值对比对象的地址是否相同

因此采用纯组件时，当我们需要更新state或props中的引用类型数据时，应该创建一个新数据，而不是直接修改原数据。

可以使用扩展运算符来创建新数据：

```react
const newObj = {...state.obj, number:2}
this.setState({obj: newObj})

// 更新数组时不要使用push/unshift等直接修改当前数组的方法
// 可以使用concat或slice等返回新数组的方法
this.setState({
    list: [...this.state.list, {/*新数据*/}]
})
```

### 虚拟DOM与Diff算法

React更新的思路是：只要state发生变化，就需要重新渲染视图。

但有这么一个问题：如果组件中有多个DOM元素，当只有一个DOM元素需要更新时，是不是也需要将整个组件全部更新？

实际上React通过虚拟DOM与Diff算法实现了组件的**部分更新**

实际上虚拟DOM对象就是React元素，用于描述UI。

React部分渲染的实现流程如下：

1. 初次渲染时，React根据初始state（Model），创建一个虚拟DOM对象（虚拟DOM树）
2. 根据虚拟DOM生产真正的DOM，渲染到页面中
3. 当数据变化后，重新根据新数据，创建新的虚拟DOM对象
4. 与上一次得到的虚拟DOM对象，使用Diff算法对比得到需要更新的内容
5. 最终，React只将变化的内容更新（patch）到DOM中，重新渲染得到页面

![image-20220111134757555](E:\EnderBlogSource\EnderXiao.github.io\source\images\image-20220111134757555.png)

实际上虚拟DOM最大的价值在于：

> 虚拟DOM让React脱离了浏览器环境的束缚，为跨平台提供了基础

## 路由

### React路由

现代前端应用大多数时SPA（单页应用程序），也就是只有一个HTML页面的应用程序，因为他的用户体验更好、对服务器的压力更小。为了有效地使用单个页面来管理原来多个页面的功能，前端路由应运而生。

- 前端路由功能：让用户从一个视图（页面）导航到另一个视图（页面）
- 前端路由是一套映射规则，在React中，是URL路径与组件的对应关系
- 使用React路由简单来说，就是配置路径和组件（配对）

### React路由基本使用

1. 安装：`yarn add react-router-dom`
2. 导入路由的三个核心组件：BrowserRouter/Route/Link
   - `import {BrowserRouter as Router, Route, Link} from 'react-router-dom'`
3. 使用Router组件包裹整个应用
4. 使用Link组件作为导航菜单（路由入口）
   - `<Link to="/first">页面一</Link>`
5. 使用Route组件配置路由规则和要展示的组件（路由出口）
   - path表示路径，与Link中的to属性的内容对应
   - component表示要展示的组件
   - `<Route path="/first" component={First}></Route>`
   - **注意react-router-domV6版本之后使用方法有所改动**

### 常用组件声明

- Router组件：包裹整个应用，以恶搞React应用只需要使用一次
- 两种常用的Router：
  - HashRouter（使用URL的哈希值实现（localhost:3000/#/first））在Vue中兼容性更好
  - BrowserRouter（使用H5中的history API实现（localhost:3000/first））
- Link组件：用于指定导航链接
  - 最终会被编译为a标签；to属性被编译为href，即浏览器地址栏中的pathname
  - 可以通过location.pathname来获取to中的值
- Route组件：指定路由展示组件相关信息
  - path属性：路由规则
  - component属性：展示的组件
  - Route组件写在哪，组件就会被渲染在哪

### 路由执行过程

1. 点击Link组件，修改了浏览器地址中的url
2. React路由监听到地址栏url变化
3. React路由内部遍历所有Route组件，使用路由规则（path）与pathname进行匹配
4. 当路由规则与pathname匹配时，展示该Route组件的内容

### 编程式导航

- 编程式导航：通过JS代码实现页面跳转

```react
this.props.history.push('/home')
```

- history是Reract路由提供的，用于获取浏览器历史记录的相关信息
- push（path）：跳转到某个页面，参数path表示要跳转的路径
- **注意react-route-domV6版本不支持此方法，应使用useNavigate()API**
  - `const navigate = userNavigate();navigate('/home')`
- go(n)：前进或后退到某个页面，参数n表示前进或后退页面的数量（-1表示后退一页）

### 默认路由

- 进入页面时默认的展示页面
- 默认路由：进入页面时就会默认匹配的路由
- 默认路由的path：/
  - `<Route path="/" component={Home} />`

### 匹配模式

#### 模糊匹配模式

- 问题：默认路由在路由切换时仍然会被显示(**V6没有这个问题**)
- 原因：默认情况下React路由是模糊匹配模式
- 模糊匹配规则：之哟啊pathname以path开头就会被匹配成功

### 精确匹配

- 给Route组件添加exact属性，就能让其变为精确匹配模式
- 精确匹配：只有当path和pathname 完全匹配时才会展示该路由

## redux

- redux是一个专门用于状态管理的JS库（不是react插件库）
- 可用于三大框架，但基本与React配合
- 集中式管理react应用中多个组件共享状态

### 使用redux的情况

1. 某个组件的状态需要让其他组件共享
2. 一个组件需要改变另一个组件的状态（通讯）

### 核心概念

#### action

- 动作对象
- 包含2个属性
  - type：标识属性，字符串，唯一，必要属性
  - data：数据属性，任意类型，可选属性
- 例如：`{ type: 'TOGGLE_TODO', index: 1 }`

#### reducer

- 用于初始化状态、加工状态
- 加工时，根据旧的state和action，产生新的state的**纯函数**

#### store

- 将state、action、reducer联系在一起的对象

- 如何得到此对象：

  ```react
  import {createStore} from 'redux'
  import reducer from './reducers'
  const store = createStore(reducer)
  ```

- 此对象的功能：

  - getState():得到state
  - dispatch(action): 分发action，触发reducer调用，产生新的state
  - subscribe(listener): 注册监听，当产生了新的state时，自动调用

### Redux案例

纯react写法：

```react
import React, { Component } from "react";
import Count from './component/Count'

//App.js
class App extends Component {
    render() {
        return (
            <div>
                <Count />
            </div>
        )
    }
}

export default App
```

```react
import React, { Component } from "react";

// Count组件
class Count extends Component {

    constructor() {
        super()
        this.state = {
            count:0,
            selectNumber: '1',
        }
    }

    increment = () => {
        // 函数体
        const {count, selectNumber} = this.state
        console.log(count, typeof(selectNumber));
        this.setState({
            count: count + (+ selectNumber)
        })
    }
    decrement = () => {
        // 函数体
        const {count, selectNumber} = this.state
        console.log( count, typeof(selectNumber));
        this.setState({
            count: count - (+ selectNumber),
        })
    }
    incrementIfOdd = () => {
        // 函数体
        const {count, selectNumber} = this.state
        console.log(count, selectNumber);
        if(count % 2 !=0){
            this.setState({
                count: count + + selectNumber
            })
        }
    }
    incrementAsync = () => {
        // 函数体
        const {count, selectNumber} = this.state
        console.log(count, selectNumber);
        setTimeout(() => {
            this.setState({
                count: count + + selectNumber
            })
        }, 500)
    }
    handleChange = (e) => {
        const target = e.target

        const value = target.type === "checkbox" ? target.checked : target.value;
        const name = target.name

        this.setState({
            [name]: value
        })
    }
    render() {
        return (
            <div>
                <h1>当前求和为：{this.state.count}</h1>
                <select name="selectNumber" value={this.state.selectNumber} onChange={this.handleChange}>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                </select>&nbsp;
                <button onClick={this.increment}>+</button>&nbsp;
                <button onClick={this.decrement}>-</button>&nbsp;
                <button onClick={this.incrementIfOdd}>当前求和为奇数则加</button>&nbsp;
                <button onClick={this.incrementAsync}>异步加</button>
            </div>
        )
    }
}

export default Count
```



## React-Native

### 项目结构

react-native目录结构简介：

```js
- android 与安卓客户端编译相关的配置
- ios	与ios哭护短编译相关的配置
- .eslintrc.js	代码风格配置
- .prettierrc.js	代码格式化风格配置
- App.js	项目的根组件
- index.js	项目的入口文件	
- package.json	项目第三方包相关信息
```

### RN布局

#### flex布局

- 所有容器默认为felxbox
- 并且默认为纵向排列，即`felx-direction: colum`

#### 样式继承

- 在RN中样式没有继承关系

#### 单位

- 在RN中不能为表示宽高的数字增加单位，RN会自动处理单位。

- RN中可以使用百分比表示宽高。

- RN中的默认单位为dp

- px与dp转换：

  - $$
    dp宽高 = 屏幕宽高(px) * 元素宽高(px) / 设计稿宽高(px)
    $$

可以通过构造如下工具来解决px转dp的问题

```js
import {Dimensions} from "react-native"

export const screenWidth = Dimensions.get("window").width;

export const screenHeight = Dimension.get("window").height;

/**
 * 次数假设设计稿宽为375
 */
export const pxToDp = (elePx) => screenWidth * elePx / 375
```



#### 屏幕宽高

```react
import {Dimensions} from "react-native";
const screenWidth = Math.round(Dimensions.get('window').width);
const screenHeight = Math.round(Dimensions.get('windows').height);
```

#### 变换

```react
<Text style={{transform:[{translateY:300}, {scale:2}]}}>变换</Text>
```

#### 标签

##### View

- 相当于div
- 不支持字体大小，字体颜色
- 不能直接放文本内容
- 不支持直接绑定点击事件（一般使用`TouchableOpacity`代替）

##### Text

> 文本标签

- 文本标签，可以设置字体颜色、大小
- 支持绑定点击事件

##### TouchableOpacity

> 可以绑定点击事件的块标签

- 相当于块容器
- 支持绑定点击事件`onPress`
- 可以设置点击时的透明度

```jsx
<TouchableOpecity activeOpacity={0.5} onPress={this.handleOnPress}></TouchableOpecity>
```

##### Image

> 图片标签

- 渲染本地图片时

```jsx
<Image source={require("../img.png")} />
```

- 渲染网络图片

```jsx
<Image source={{url:"https://z3.ax1x.com/2021/08/05/fego40.png"}} style={{width:200,height:300}} />
```

​	注意一定要加宽高，不然无法显示

- Android设备上渲染GIF和WebP

  默认不支持，需要在`Android/app/build/gradle`中手动添加模块：

  ```jsx
  dependencies {
  	// 如果需要支持Android4.0之前的版本
      implementation 'com.facebook.fresco:animated-base-support:1.3.0'
      // GIF支持
      implementation 'com.facebook.fresco:animated-gif:2.0.0'
      // Webp格式，包括Webp动图支持
      implementation 'com.facebook.fresco:animated-webp:2.1.0'
      implementation 'com.facebook.fresco:webpsupport:2.0.0'
  }
  ```

  注意当更改依赖时需要重启调试

- ImageBackground

  > 用于实现带有背景的块级元素

  ```jsx
  <ImageBackground source={...} style={{width:'100%', height: '100%'}}>
  	<Text>Inside</Text>
  </ImageBackground>
  ```

  必须就有style属性

- TextInpute

  > 输入框组件

  通过`onChangeText`事件来获取输入框的值

  ```jsx
  <TextInpute onChangeText={handleChangeText} ></TextInpute>
  ```

  注意他初始状态是没有样式的

### 调试

RN有两种调试方式：

1. 谷歌浏览器

   - 不能查看标签结构
   - 不能查看网络请求

2. 使用RN推荐的工具react-native-debugger

   - 可以查看标签结构

   - 不能查看网络请求

想要查看网络请求则需要进行如下配置：

1. 找到项目入口文件index.js

2. 加入以下代码：

   ```jsx
   GLOBAL.XMLHttpRequest = GLOBAL.originalXMLHttpRequest || GLOBAL.XMLHttpRequest
   ```


### this指向问题

可以使用如下四种方式解决this指向问题：

```react
import React, { Component } from 'react'
import { View, Text } from 'react-native'
class Index extends Component {
    state = { num:100 }
	// 丢失 state
	handlePress1() {
        console.log(this.state);
    }
	// 正常
	handlePress2 = () => {
        console.log(this.state);
    }
	// 正常
	handlePress3() {
        console.log(this.state)
    }
	// 正常
	handlePress4() {
        console.log(this.state)
    }

	// 正常
	handlePress5() {
        console.log(this.state)
    }
	constructor() {
        super()
        this.handlePress = this.handlePress.bind(this);
    }
	
	// 正常
	render() {
        return (
            <View>
                {/* 导致事件函数中获取不到 */}
                <Text onPress={this.handlePress1} >事件1</Text>
                <Text onPress={this.handlePress2} >事件2</Text>
                <Text onPress={this.handlePress3.bind(this)} >事件3</Text>
                 <Text onPress={()=>this.handlePress4()}>事件4</Text>
                <Text onPress={handlePress5()}>事件5</Text>
            </View>
        )
    }
}
```

### RN生命周期

与React相同

### mobx

> react中全局数据管理库，可以简单实现数据的跨组件共享

#### 安装依赖

- mobx核心库
- mobx-react方便在react中使用mobx技术的库
- @babel/plugin-proposal-decorators让rn项目支持es7中的装饰器语法库

```shell
yarn add mobx mobx-react @babel/plugin-proposal-decorators
```

#### 添加配置

在babel.config.js添加如下配置：

```react
plugins: [
    ['@babel/plugin-proposal-decorators', {'legacy':true}]
]
```

#### 新建全局数据文件

新建文件`mobx\index.js`添加如下配置

```react
import {observable, action} from 'mbox'

class RootStore {
    // es7装饰器语法，使用Object.defineProperty实现
    // observable 表示数据可以监控，表示是全局数据
    @observable name = "Hello"
	// action行为 表示 changeName是个可以修改全局共享数据的方法
	@action changeName(name) {
        this.name = name;
    }
}

export default new RootStore()
```

#### 挂载

通过provider来挂载和传递

```react
import React, { Component } from 'react';
import { View } from 'react-native';
import rootStore from './mobx';
import { Provider } from 'mbox-react';
class Index extends Component {
    render() {
        return (
            <View>
                <Provider rootStore={rootStore}>
                    <Sub1></Sub1>
                </Provider>
            </View>
        )
    }
}
```

#### 使用

```react
import React, { Component } from 'react';
import { View, Text } from 'react-native';
import { inject,observer } from 'mbox-react';

@inject("rootStore") // 注入Provider的属性名，用来获取全局数据
@observer // 接收全局遍历改变，当全局发生改变，组件重新渲染从而显示最新数据
class Sub1 extends Component {
    changeName = () => {
        // 修改全局数据
        this.props.rootStore.changeName("goodbye");
    }
    render() {
        return (
          <View>
                <Text onPress={this.changeName}>{this.props.rootStore.name}</Text>
          </View>  
        );
    }
}
```

