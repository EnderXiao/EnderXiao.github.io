---
title: React学习笔记一
date: 2022-01-05 10:40:48
categories:
  - - 研究生
    - 打工
    - React
  - - 前端
tags:
  - 打工
  - 前端框架
  - React
  - life
headimg:
  'https://z3.ax1x.com/2021/08/05/fego40.png'
mathjax: true

---

前端框架React学习笔记

<!-- more -->

## 前言

上研究生后老师让直接去实习，实习单位使用React + React Native进行安卓混合开发。于是先学习一下React

## React概述

React是一个构建用户见面的JS库

### React特点

1. 声明式

   只需要描述UI（HTML）看起来是啥样，即描述结构，React负责渲染UI以及在数据变化时更新UI

2. 基于组件

   - 用于表示页面中的部分内容
   - 通过组合、复用多个组件，就能实现完整的页面功能

3. 学习一次随处使用

   - 使用React开发Web应用

   - 使用React-native开发移动端应用
   - React 360开发VR应用

### React 安装

```shell
npm i react react-dom
```

- react包是核心，提供创建元素，组件的功能
- react-dom包提供DOM相关功能

### React初见

1. 选择一个目录

2. 创建index.html

3. 在该目录下安装react包

   ```shell
   npm i react react-dom
   ```

   

```html
<!DOCTYPE html>
<html lang="cn">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width-device-width, initial-1.0 ">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>react</title>
</head>

<body>

    <div id="root"></div>
    <!-- 引入reactjs -->
    <script src="./node_modules/react/umd/react.development.js"></script>
    <script src="./node_modules/react-dom/umd/react-dom.development.js"></script>
    <script>
        // 创建React元素
        // 参数：
        //     1. 元素名称
        //     2. 元素属性
        //     3. 第三个及其之后的参数：元素子节点
        const title = React.createElement('h1', null, "Hello React")

        // 渲染React元素
        // 参数：
        //     1. 要渲染的react元素
        //     2. 挂载点，一个DOM对象，指定渲染位置
        ReactDOM.render(title, document.getElementById("root"))
    </script>
</body>

</html>
```

### React脚手架

#### 脚手架的意义

1. 脚手架是开发现代Web应用的必备
2. 充分利用Webpack、Babel、ESLint等工具辅助项目开发
3. 零配置，无需手动配置繁琐的工具即可使用
4. 关注业务二部是工具配置

#### 使用脚手架初始化项目

```shell
npx create-react-app my-app
```

使用

```shell
npm start
```

启动项目

#### npx 的意义

原来使用npm上下载的包时，如果想在任意地方使用，需要全局安装这个包，但npx之后无需全局安装，即可使用。

#### 脚手架中导入React包

由于React基于Webpack，因此导入时可直接使用ES6中的模块化语法进行导入：

```js
import React from 'react'
import ReactDOM from 'react-dom' //使用react制作web应用时导入该渲染组件
```

## JSX

### JSX基本使用

即JavaScript XML，表示在JS中写XML格式的代码

优点：

1. 声明式语法更直观，与HTML结构相同，降低了学习成本、提升开发效率

#### 使用步骤

使用JSX语法创建react元素

```react
const title = <h1>Hello JSX</h1>
```

使用reactDOM.render渲染react元素到页面

```react
ReactDOM.render(title, root)
```

#### JSX原理

react脚手架中配置了babel，JSX会经过babel编译为标准的JS语法。

编译JSX语法的包为@babel/preset-react

#### 注意事项

1. React元素的属性名采用驼峰命名法
2. 使用JSX为标签设置属性时，应修改为驼峰命名：
   1. class属性 -> className
   2. for -> htmlFor
   3. tabindex -> tabIndex
3. 没有子节点的React元素，可以使用但标签`<span />`结束
4. 推荐使用小括号包裹JSX，从而避免JS中的自动插入分号陷阱

### JSX中嵌入JS表达式

语法：

```react
const name = 'Jack'
const dv = (
	<div>你好，我叫：{name} </div>
)
```

### JSX条件渲染

根据条件渲染特定的JSX结构

```react
const isLoading = false
cont loadData = () => {
	if (isLoading) {
		return <div>loading...</div>
	}
	
	return <div>数据加载完成，此处显示加载后的数据</div>
}

const title = (
	<h1>
		条件渲染：
		{loadData()}
	</h1>
)

ReactDOM.render(title, document.getElementById('root'))
```

此外还可以使用三目运算符和逻辑与运算符

```react
const isLoading = false
cont loadData = () => {
    return isLoading && (<div>loading...</div>)
}

const title = (
	<h1>
		条件渲染：
		{loadData()}
	</h1>
)

ReactDOM.render(title, document.getElementById('root'))
```

### JSX列表渲染

使用数组的map()方法

需要注意的是渲染列表时应该添加key属性，key属性的值要保证唯一

通过便利创建什么元素，就要把key通过遍历加上。

尽量避免使用索引号作为key

```react
import React from 'react'
import ReactDOM from 'react-dom'

const songs = [
    {id: 1, name: '111'},
    {id: 2, name: '222'},
    {id: 3, name: '333'},
]

const title = (
	<ul>
        {songs.map(item = > <li key={item.id}>{item.name}</li>)}
	</ul>
)

ReactDOM.render(title, document.getElementById('root'))
```

### JSX样式处理

两种方式：

1. 行内样式——style
2. 类名——className

使用样式时需要引入

```react
import React from 'react'
import ReactDOM from 'react-dom'

//引入css
import './css/index.css'

const list = (
    <h1 className="title" style={{ clolr: 'red', backgroundColor: 'skyblue'}}>
)

ReactDOM.render(list, document.getElementById('root'))
```

### JSX总结

1. JSX是React的核心内容
2. JSX表示在JS中写HTML结构，是声明式的体现
3. 使用JSX配合嵌入JS表达式、条件渲染、列表渲染、可以描述任意UI结构
4. 推荐使用className的方式给JSX添加样式
5. React完全利用JS语言自身的能力来编写UI，而不是造轮子增强HTML功能

## React组件

组件的特点：

1. 可复用
2. 独立
3. 可组合

### 组件的两种创建方式

1. 函数
2. 类

#### 函数组件

为了和函数进行区分，对函数组件进行如下约定：

1. 函数名必须以**大写字母开头**
2. 函数组件必须**有返回值**

但函数返回值可以为NULL

```react
function Hello() {
    return (
        <div>我是一个函数组件</div>
    )
}
```

渲染组件时直接使用函数名作为组件标签即可

```react
ReactDOM.render(<Hello />, root)
```

也能使用箭头函数来构造组件

```react
const Hello = () => <div>我是一个箭头函数组件</div>
```

React根据名称首字母是否大写来区分组件和普通React元素

#### 类组件

使用ES6中的class创建的组件，为了与普通类进行区分，使用如下约定：

1. 类名首**字母大写**
2. 类组件需要继承自**React.Component**，从而使用父类中提供的方法和属性
3. 类组件必须提供**render()**方法
4. render方法**必须有返回值**，表示组件的结构

```react
class Hello extends React.Component {
    render() {
        return <div>Hello Class Component</div>
    }
}

ReactDOM.render(<Hello />, root)
```

#### 组件的组织

组件作为一个单独的个体，一般会放到一个单独的JS文件中

1. 创建JS文件，对应组件名称.js
2. 在JS文件中导入React
3. 创建组件
4. 在JS文件中导出该组件
5. 在index.js中导入该组件
6. 渲染组件

组件JS文件

```react
// Hello.js
import React from 'react'
class Hello extends React.Component {
    render() {
        return <div>Hello Class Component</div>
    }
}

// 导出Hello组件
export default Hello
```

index中渲染组件

```react
// index.js
import Hello from './Hello'
// 渲染导入的Hello组件
ReactDOM.render(<Hello />, root)
```

## React事件处理

### 事件绑定

1. React事件绑定语法与DOM事件绑定相似
2. on+事件名称={事件处理程序}，如onClick={() => {}}
3. React事件采用驼峰命名法

```react
class App exntends React.Component {
    handleClick() {
        console.log('单击事件被触发')
    }
    
    render() {
        return (
            <button onClick={this.handleClick}>点我</button>
        )
    }
}
```

函数组件绑定事件，使用内部函数定义

```react
function App() {
    function handleClick() {
        console.log('单击事件出发了')
    }
    
    return(
        <button onClick={handleClick}>点我</button>
    )
}
```

### 事件对象

1. 可以通过事件处理程序的参数获取到事件对象
2. React中的事件对象叫做：**合成事件(重要，需补充)**（对象）
3. 合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题

```react
function handleClick(e) {
    e.preventDefault() //组织浏览器的默认行为
    console.log('事件对象', e)
}

<a onClick={handleClick}>点我，不会跳转页面</a>
```

### 有状态组件和无状态组件

1. 函数组件又称为**无状态组件**，类组件叫做**有状态组件**
2. 状态(state)即**数据**
3. 函数组件没有自己的状态，**只负责数据展示**（静）
4. 类组件有自己的状态，**负责更新UI**

### 组件的state和setState

#### state的基本使用

1. 状态即数据，时组件内部的私有数据，只能在组件内部使用
2. state的值是对象，表示一个组件中可以有多个数据

状态的初始化方式如下：

```react
class Hello extends React.Component {
    constructor() {
        // ES6中必须包含
        super();
        // 初始化state
        this.state = {
            count: 0,
        };
    }
    
    render() {
        return (
            <div>有状态组件</div>
        )
    }
}
```

也可以使用ES6中的简化语法：

```react
class Hello extends React.Component {
    // 简化语法
    // 初始化state
    state = {
        count: 0
    }
    
    render() {
        return (
            <div>有状态组件</div>
        )
    }
}
```

可以使用this获取状态的数据

```react
class Hello extends React.Component {
    // 简化语法
    // 初始化state
    state = {
        count: 0
    }
    
    render() {
        return (
            <div>计数器: {this.state.count}</div>
        )
    }
}
```

#### setState()修改状态

1. 状态是可变的
2. 语法：this.setState({要修改的数据})
3. 不要直接修改state中的值
4. setState()作用：
   1. 修改state
   2. 更新UI
5. 思想：**数据驱动视图**

```react
class App extends React.Component {
    state = {
        count: 0
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={() => {
                        this.setState({
                            count: this.state.count + 1
                        })
                    }}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

#### 从JSX中抽离事件处理程序

1. JSX中掺杂了过多JS逻辑代码会使得JSX逻辑混乱
2. 将逻辑抽离到单独的方法中，保证JSX结构清晰
3. 由于箭头函数不具备this，因此会向外层寻找this的指向，render()函数中的this指向组件实例，因此不会有问题，但进行抽离后的函数不具备this指向。
4. 可以使用如下解决方式：
   1. 箭头函数
   2. Function.prototype.bind()
   3. class的实例方法

##### 箭头函数

利用箭头函数自身不绑定this的特点，会根据外部环境推断。对于方法中的this，谁调用就指向谁。

```react
class App extends React.Component {
    state = {
        count: 0
    }

	// 事件处理程序
	onIncrement(){
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={() => this.onIncrement()}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

##### Function.prototype.bind()

1. 利用ES5中的bind方法，将事件处理程序中的this与组件实列绑定

2. 类似于小程序中的

   ```js
   let that = this
   that.onIncrement()
   ```

```react
class App extends React.Component {

	constructor() {
        super()
        this.state = {
        	count: 0
    	}
        this.onIncrement = this.onIncrement.bind(this)
    }

	// 事件处理程序
	onIncrement(){
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={this.onIncrement}>+1</button>
            </div>
        )
    }
}
```

##### class实例方法

使用箭头函数形式的class实例方法

注意，该语法为实验性语法，但由于babel的存在，可以直接使用

```react
class App extends React.Component {
    state = {
        count: 0
    }

	// 事件处理程序
	onIncrement = () => {
        console.log('事件处理程序中的this', this)
        this.setState({
            count: this.state.count + 1
        })
    }

	render() {
        return (
            <div>
                <h1>计数器: { this.state.count }</h1>
                <button onClick={this.onIncrement}>+1</button>
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

## 表单处理

React两种表单处理方式

1. 受控组件
2. 非受控组件（DOM方式）

### 受控组件

1. HTML中的表单元素是可输入的，也就是有自己的可变状态
2. React中可变状态通常保存在state中，使用setState来i需改
3. React将state与表单元素值value绑定到一起，由state的值来控制表单元素的值
4. 受控组件：即值收到React控制的表单元素

受控组件的使用包括以下步骤：

1. 在state中添加一个状态，作为表单元素的value值（控制表单元素值的来源）
2. 给表单元素绑定change事件，将表单元素的值设置为state的值（控制表单元素值的变化）

```react
class App extends React.Component {
    state = {
        txt: '',
    }

	handleChange = e => {
        this.setState({
            txt: e.target.value
        })
    }

	render() {
        return (
            <div>
                <input type="text" value={this.state.txt} onChange={this.handleChange} />
            </div>
        )
    }
}

ReactDOM.render(<App />, document.getElementById('root'))
```

如下练习将不同的表单标签转化为受控组件。

1. 文本框，富文本框，下拉框操作value属性
2. 复选框操作checked属性

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.state = {
      txt: '',
      content: '',
      city: 'bj',
      Selection: false,
    }
  }

  handleChange = e => {
    this.setState({
      txt: e.target.value
    })
  }

  handleContent = e => {
    this.setState({
      content: e.target.value
    })
  }

  handleCity = e => {
    this.setState({
      city: e.target.value
    })
  }

  handleSelection = e => {
    this.setState({
      Selection: e.target.checked
    })
  }

  render(){
    return (
      <div>
        <input type="text" value={this.state.txt} onChange={this.handleChange}></input>
        <br/>

        <textarea value={this.state.content} onChange={this.handleContent}></textarea>
        <br/>

        <select value={this.state.city} onChange={this.handleCity}>
          <option value="sh">上海</option>
          <option value="bj">北京</option>
          <option value="gz">广州</option>
        </select>
        <br/>

        <input type="checkbox" checked={this.state.Selection} onChange={this.handleSelection}></input>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

但是可以发现用如上方法控制表单元素会产生很多重复新的onChange函数，因此需要对多表单元素进行优化，即使用一个事件处理程序同时处理多个表单元素。

#### 多表单元素优化

1. 给表单元素添加name属性，名称与state相同
2. 根据表单元素类型获取对应值
3. 在change事件处理程序中通过[name]来修改对应的state

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.state = {
      txt: '',
      content: '',
      city: 'bj',
      Selection: false,
    }
  }

  handleChange = e => {
    // 获取当前DOM对象
    const target = e.target;

    // 根据类型获取值
    const value = target.type === 'checkbox'
      ? target.checked
      : target.value;

    // 获取name
    const name = target.name;

    this.setState({

      // 此处定义属性使用了ES6中的新特性 属性名表达式
      // 即使用表达式作为属性或函数名
      // 此处会将name转化为string
      [name]: value,
    });
  }

  render(){
    return (
      <div>
        <input type="text" name='txt' value={this.state.txt} onChange={this.handleChange}></input>
        <br/>

        <textarea name='content' value={this.state.content} onChange={this.handleChange}></textarea>
        <br/>

        <select name='city' value={this.state.city} onChange={this.handleChange}>
          <option value="sh">上海</option>
          <option value="bj">北京</option>
          <option value="gz">广州</option>
        </select>
        <br/>

        <input name='Selection' type="checkbox" checked={this.state.Selection} onChange={this.handleChange}></input>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

### 非受控组件

借助于ref，使用原生DOM方法来获取表单元素值

ref的作用：获取DOM或组件

这种方式通过直接操作DOM实现

使用步骤：

1. 通过React.createRef()方法创建一个ref对象
2. 将创建好的ref对象添加到文本框中
3. 通过ref对象获取到文本框中的值

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {
  constructor(){
    super()
    this.txtRef = React.createRef()
  }

  // 获取文本框的值
  getTxt = () => {
    console.log('文本框的值为：', this.txtRef.current.value);
  }

  render(){
    return (
      <div>
        <input type="text" ref={this.txtRef} />

        <button onClick={this.getTxt}>获取文本框的值</button>
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

## 案例一

式样以上知识，实现一个无回复功能的评论版

### 渲染评论列表

1. 在state总初始化评论列表数据
2. 使用map循环渲染列表数据
3. 注意给每个被渲染的元素添加一个key

### 评论区条件渲染

1. 判断列表长度是否为0
2. 如果为0则渲染暂无评论 
3. 注意讲逻辑与JSX分离

### 获取评论信息

1. 使用受控组件的方式实现
2. 注意设置handle方法和name属性

### 发表评论

1. 为按钮绑定单击事件
2. 在事件处理程序中通过state获取评论信息
3. 将评论添加到state中，更新state
4. 边界情况：清空文本框，文本框判空

### 最终实现

```react
import './index.css';
import React from 'react';
import ReactDOM from 'react-dom';

class App extends React.Component {

  constructor() {
    super()
    this.state = {
      comments: [
        { id: 1, name: 'jack', comment: 'You jump'},
        { id: 2, name: 'rose', comment: 'I jump'},
        { id: 3, name: 'joker', comment: 'I see you jump'},
      ],
      // 当前评论人
      userName: '',
      // 当前评论内容
      userContent: '',
    }
  }

  renderList() {
    const {comments} = this.state
    if(comments.length === 0) {
      return (
        <div className='no-comment'>暂无评论，快去评论吧</div>
      )
    } else {
      return (
        <ul>
          { 
            comments.map(item => (
              <li key={item.id}>
                <h3>评论人：{item.name}</h3>
                <p>评论内容：{item.comment}</p>
              </li>
            ))
          }
        </ul>
      )
    }
  }

  handleChange = (e) => {
    const {name, value} = e.target;
    this.setState({
      [name]: value,
    });
  }

  addComment = () => {
    const {comments, userName, userContent} = this.state

    //判空，使用trim去除空格
    if(userName.trim() === '' || userContent.trim === '' ) {
      alert('请输入评论人和评论内容');
      return;
    }
    // 此处使用了ES6的新特性：拓展运算符...
    // 该运算符用于将可便利对象拆分为单个
    const newIndex = comments.length + 1;
    const newComments = [...comments,
      {
        id: newIndex,
        name: userName,
        comment: userContent,
      }
    ];

    console.log(newComments);

    this.setState({
      comments: newComments,
      userName: '',
      userContent: '',
    });
  }

  render(){
    const {userName, userContent} = this.state;

    return (
      <div className='app'>
        <div>
          <input
            name='userName'
            className='user'
            value={userName}
            type='text'
            placeholder='请输入评论人'
            onChange={this.handleChange} />
          <br/>

          <textarea
            className='content'
            name='userContent'
            cols='30'
            row = '10'
            placeholder='请输入评论内容'
            value={userContent}
            onChange={this.handleChange}
            />
            <br />
            <button onClick={this.addComment}>发表评论</button>
        </div>
        {/* 通过条件渲染决定渲染什么内容 */}
        {this.renderList()}
      </div>
    )
  }

}

ReactDOM.render(
  <App />, document.getElementById("root")
);
```

## 组件间通讯

### 组件props

由于组件的封闭性，要接受外部数据应该通过props来实现

- props的作用：接受传递给组件的数据
- 传递数据：给组件标签添加属性
- 接受数据：
  - 函数组件通过**参数props**接收数据
  - 类组件通过**this.props**接受数据

```react
<Hello name='jack' age = {19} />
```

```react
function Hello(props) {
    console.log(props)
    return (
        <div>接受到数据: {props.name}</div>
    )
}
```



## Angular框架

### MVVM

> **MVVM是MVC的增强版，实质上和MVC没有本质区别，只是代码的位置变动而已**。
>
> ——[MVVM是什么 - 简书 (jianshu.com)](https://www.jianshu.com/p/6aeeecd64dcf)

#### MVC

之前学习过MVC框架，对于MVC框架，可以简述为一下三个方面：

1. Model：数据模型，用来存储数据
2. View：视图界面，用来展示UI界面和响应用户交互
3. Controller：控制器(大管家角色)，监听模型数据的改变和控制视图行为、处理用户交互

#### MVC的缺点

在开发过程中，由于需求的变更或添加，项目的复杂度越来越高，代码量越来越大，此时我们会发现MVC维护起来有些吃力，首先被人吐槽的最多的就是MVC的简写变成了Massive-View-Controller（意为沉重的Controller）

#### MVVM的改进

由于Controller主要用来处理各种逻辑和数据转化，复杂业务逻辑界面的Controller非常庞大，维护困难，所以有人想到**把Controller的数据和逻辑处理部分从中抽离出来，用一个专门的对象去管理，这个对象就是ViewModel，是Model和Controller之间的一座桥梁**。当人们去尝试这种方式时，发现Controller中的代码变得非常少，变得易于测试和维护，只需要**Controller和ViewModel做数据绑定**即可，这也就催生了MVVM的热潮。

因此，MVVM包含以下四个组件：

1. View
2. View Controller
3. View Model
4. Model

#### MVVM的优缺点

##### 优点

1. Controller清晰简洁： ViewModel分离了大部分Controller代码，更加清晰和容易维护。
2. 方便测试：开发中大部分Bug来至于逻辑处理，由于ViewModel分离了许多逻辑，可以对ViewModel构造单元测试。
3. 开发解耦(举两个例子)：
   1.  一人负责逻辑实现、另一人负责UI实现；
   2.  敏捷开发时，会发经常发不是等后端做好了接口我们再去开发，不过在没有接口的情况下通常我们可以把Controller和View完成。

##### 缺点

1. 看起来代码会比MVC多点
2. 需要对每个Controller实现绑定，如果处理不好，反而会有一种“画虎不成反类犬”的感觉

#### MVVM框架组成

1. 数据绑定
2. 指令系统
3. 路由和导航
4. 状态保持
5. 第三方组件库

### Angular概述

由Google开发的MVVM框架，官网：[Angular](https://angular.cn/)

#### 环境搭建

##### nodeJS

nodeJS官网安装

##### cnpm

```shell
npm install -g cnpm --registry==https://registry.npm.taobao.org
```

使用淘宝镜像

##### angular-client

```shell
npm isntall -g @angular/cli
# 或者使用cnpm安装
```

##### 验证安装

```shell
ng v# 验证安装
```

#### Angular创建项目

```shell
ng new helloWorld# ng new 项目名# 可以使用如下命令跳过下载依赖的过程ng new helloWorld --skip-install
```

通过选择路由及CSS预处理器创建项目

使用cnpm/npm安装依赖

```shell
npm install
```

使用

```shell
ng serve --open	
```

启动项目

为VScode安装Angular snippets组件

## Angular项目结构

目录结构：

```
--my-app	|__ [.angular] angular框架相关依赖	|__ [node_modules] 第三方模块（依赖）文件	|__ [src] 项目文件		|__ [app] 组件，及app.modules.ts定义模板		|__ [assets] 静态资源		|__ [enviroments] 为目标环境准备的文件			|__ index.html 主页面			|__ main.ts 应用主要入口			|__ polyfills.ts 填充库，把不同点进行标准化，例如socket.io			|__ styles.css 全局样式			|__ test.ts 单元测试入口			|__ tsconfig.app.json			|__ tsconfig.spec.json TypeScript编译器配置文件	|__ .browserslistrc angular支持浏览器的配置文件	|__ angular.json angular配置文件	|__ package.json npm配置文件	|__ tsconfig.json typeScript编译器配置文件	|__ karma.conf.js Karma单元测试配置	|__ .editorconfig 编辑器配置文件
```

#### 模块

先来看一眼跟模块的代码：

```typescript
/*该文件是Angular根模块， 告诉Angular如何组装应用 *//*Angular核心模块 */import { NgModule } from '@angular/core';/*浏览器解析模块 */import { BrowserModule } from '@angular/platform-browser';import { AppRoutingModule } from './app-routing.module';/*根组件 */import { AppComponent } from './app.component';import { HelloworldComponent } from './helloworld/helloworld.component';/*装饰器，接受一个元数据对象，告诉Angular如何编译和启动应用 */@NgModule({  declarations: [ /*配置当前项目运行的组件 */    AppComponent,    HelloworldComponent  ],  imports: [  /*配置当前模块运行依赖的其他模块 */    BrowserModule,    AppRoutingModule  ],  providers: [],  /*配置项目所需的服务 */  bootstrap: [AppComponent] /*（启动时默认加载的组件）指定应用的主视图（称为根组件）通过引导App module来启动应用 。*/})//根模块不需要导出任何东西，因为不需要被其他组件导入。export class AppModule { }
```



