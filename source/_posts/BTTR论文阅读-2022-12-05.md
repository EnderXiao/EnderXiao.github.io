---
title: BTTR论文阅读
date: 2022-12-05 10:44:26
categories:
  - - 研究生
    - 科研
    - OCR
tags:
  - 手写体识别
  - 深度神经网络
  - 深度学习
  - 注意力机制
headimg:
  'https://z3.ax1x.com/2021/08/05/fego40.png'
mathjax: true
---

## 摘要
处于encoder-decoder结构在许多不同的领域取得了很好的成效，而本文采用基于transformer的解码器代替基于RNN的解码器，使整个模型体系结构更简洁，并且引入新的训练策略来充分利用transformer在双向语言建模中的潜力。

## 改进

本文提出现存方法在不同程度上存在覆盖范围缺乏的问题，主要有两种方式：

1. 过解析
2. 欠解析

过解析意味着手写图像识别(HME)图像中的某些区域被多次冗余翻译

欠解析则表示某些区域仍然未翻译

大多数encoder-decoder是基于RNN，RNN中当前单元的输出仅取决于上一隐藏层的参数，由于梯度消失等问题，他们很难发现距离很远的两个字符之间的关系。这一问题在HMER任务中暴露得更为明显，因为对于Latex结构而言，RNN很难捕获到两个相距较远的`{`和`}`符号之间的关系，导致基于Latex语法规范的识别错误。

传统的自回归模型在推理阶段使用从左到右逐个预测的方式。这种方式可能产生不平衡的输出，例如前缀预测比后缀更准确。为了克服这一问题，本文提出采用两个独立的编码器，分别从左到右和从右到左的方向训练。然而，这将导致训练参数的增加，因此本文采用单一解码器进行双向语言建模。

本文使用位置编码缓解了覆盖问题，提出了一种新的双向训练策略。

## 方法

### HMER简述

手写公式识别目前分为两类方法：

1. 基于语法
2. 基于encoder-decoder

#### 基于语法

该方法通过：

- 符号分割
- 符号识别
- 结构分析三个部分进行

需要研究人员提出预定义语法，如随机上下文无关语法、关系语法、定子句语法。这些语法规则不由数据驱动，需要手工设计，不能从大型数据集中获益

#### 基于encoder-decoder

在HMER任务中，Zhang等观察到了覆盖缺乏的问题，并提出WAP用于HMER任务。后续研究中DenseWAP用DenseNet编码器取代WAP中的VGG。DenseWAP-TD通过用树形解码器替换字符串解码器，增强了模型处理复杂公式的能力。Wu等人使用笔画信息，将HMER制定为一个图到图的建模任务。这种基于编码器的模型在多个CROHME竞赛中获得了优异成绩。

### Transformer

一种完全基于注意力机制的神经网络结构。其内部自注意力机制使Transformer相比于RNN取得了两个方面突破：

1. transformer不需要像RNN那样依赖于上一步状态。并行化使得transformer在训练阶段能够节约更多时间。
2. 同一序列中的标记通过自注意力机制直接建立一对一连接。这种机制解决了RNN梯度消失的问题，使Transformer比RNN更适用于**长序列**处理。

近年来，在CV和NLP领域中，RNN正在被Transformer取代。

### R2L语言模型

为了解决传统模型只能适用于从左到右的语言模型的缺陷，许多学者尝试了从右向左的语言模型。但目前目前提出的方案都不可避免的增加了模型的复杂度。本文提出的单解码器双向语言模型能够很好的保持模型的简洁性。

### 本文方法

#### CNN编码器

本文使用DenseNet作为HME图像特征提取器，本文在编码部分添加了一个1*1的卷积层，用于将图片的特征维度调整为`embedding dimension`以便进行之后的处理

#### 位置编码

由于transformer模型本身对每个输入向量没有任何位置感，因此我们使用两种类型的位置编码来处理这些信息。详细地说，我们分别使用图像位置编码和词位置编码来表示图像特征位置和词向量位置。

##### 词向量位置编码

对于给定的位置$pos$和维度$d$，则词向量位置编码定义为：

$p^{W}_{pos,d}[2i] = sin(pos/1000^{2i/d}) \\ p^{W}_{pos,d}[2i + 1] = cos(pos/1000^{2i/d})$

其中$i$为维度索引

##### 图像位置编码

采用二维归一化位置编码来表示图像的位置特征

首先计算正弦位置编码$p^W_{pos,d/2}$，然后将他们连接在一起。

对于一个二维位置坐标$(x,y)$，且与字位置编码相同的维数d，将图像位置编码向量$p^I_{x,y,d}$表示为：

$\overline {x} = \frac{x}{H}, \overline y = \frac{y}{W} \\ P^I_{x,y,d} = [p^W_{\overline {x}, d/2}; p^W_{\overline {y}, d/2}]$

#### Transformer编码器

每个基本的transformer层模块由四个基本部分组成。

##### 比例缩放的点积注意力

这种注意机制本质上是基于查询和键之间的相似性，使用查询从键-值对中获取值。

$Attention(Q,K,V) = softmax(\frac{QK^{T}}{\sqrt{d_k}})V$

关于为什么dot-product attention需要被scaled参考[文章](https://blog.csdn.net/qq_37430422/article/details/105042303)

##### 多头注意力机制

通过多头机制，比例缩放的点积注意力模块可以共同关注多个表示子空间的特征映射。

$H_i = Attention(QW_i^Q, KW_i^K, VW_i^V) \\ MultiHead(Q,K,V) = [H_1;...;H_h]W^o$

##### 带掩模的多头注意力

在解码器部分，由于自回归特性，根据输入图像和先前生成的符号来预测下一个符号。在训练阶段，使用一个下三角形掩模矩阵，使自注意模块能够限制每个时间步长的注意区域。由于掩模的多头注意机制，整个训练过程只需要一次前向计算。

##### 前馈网络

位置前馈网络(FNN)由三个操作组成：一个线性变换、一个ReLU激活函数和另一个线性变换。 经过多头注意，不同步长之间的信息已经充分交换。FFN使每个步长能够单独整合自己的内部信息。

$FFN(x) = max(0, xW_1 + b_1)W_2 + b_2$

#### 双向训练

首先，在字典中引入了两个特殊的符号$<SOS>$和$ <EOS>$来表示序列的开始和结束。对于目标Latex序列$y=\{y_{1},...y_{T}\}$，我们将目标序列:

从左到右(L2R)表示为：$\vec y=\{<SOS>，y_{1}，…，y_{T}，<EOS>\}$

从右到左(R2L)表示为：$\overleftarrow y=\{<EOS>，y_{T}，…，y_{1}，<SOS>\}$

以图像x和模型参数θ为条件，传统的自回归模型需要计算概率分布：

$p(\vec y_j | \vec y_{<j}, x, \theta)$

j是目标序列中的索引

在本文中，由于transformer模型本身实际上并不关心输入符号的顺序，因此我们可以使用单个transformer解码器来进行双向语言建模。

$p(\overleftarrow y_j∣\overleftarrow y_{<j}，x，θ)$

为了实现这一目标，提出了一种简单而有效的双向训练策略，对于每个训练样本，我们将Latex序列生成两个目标序列L2R和R2L，并计算同一批的训练损失。与单向语言建模相比，我们的方法训练了一个模型，在不牺牲模型简洁性的情况下执行双向语言建模。

## 网络

在编码器部分，为了与当前最好的方法进行公平的比较，我们使用了与DenseWAP模型相同的DenseNet特征提取器。具体来说，在主干网络中使用了bottleneck层，并在它们之间添加过渡层，以减少特征图的数量。在每个bottleneck中，我们将增长率设置为k=24，每个块的深度设置为D=16，过渡层的压缩超参数设置为θ=0.5。

在解码器部分，我们使用了标准的transformer模型。我们将embedded维度和模型维度设置为d=256，多头注意模块的头数设置为H=8，FFN中间层维数设置为d=1024，transformer层数设置为N=3。dropout设置为0.3用来防止过拟合。

## 训练

我们的训练目标是使预测真实标签的概率最大化，所以我们使用标准的交叉熵损失函数来计算在每个编码位置真实值与预测概率之间的损失。给定训练样本$\{x^{(z)}y^{(z)}\}^{Z}_{z=1}$，优化的目标函数如下：

$\vec L^{(z)}_j(\theta) = -log p(\vec y_j^{(z)}|\vec y_{<j}^{(z)},x^{(z)}, \theta)$

$\overleftarrow L_j^{(z)}(\theta) = -logp(\overleftarrow y_{<j}^{(z)}, x^{(z)}, \theta)$

$L(\theta) = \frac{1}{2ZL} \sum_{z=1}^Z \sum_{z=1,j=1} ^L (\vec L_j ^{(z)}(\theta) + \overleftarrow L_j ^{(z)} (\theta))$

该模型使用Adadelta算法从头开始进行训练，权重衰减为10−4，ρ=0.9，ϵ \epsilonϵ=10−6。使用PyTorch框架来实现。该模型在四个NVIDIA 1080Ti gpu上进行训练，具有11×4GB内存。

### 前向推理

可用如下计算公式得到Latex序列：

$ \hat y =argmaxp(y∣x,θ)$

x为输入图像，θ为模型参数。

不像训练阶段，使用下三角掩模矩阵同时生成所有时间步长的预测。由于我们没有真实的标签，所以我们只能逐个地预测符号，直到“End”符号或达到预定义的最大长度。

显然，我们不能搜索所有可能的序列，因此提出了一种启发式集束搜索（beam search）来平衡计算成本和决策质量。此外，利用我们的解码器能够进行双向语言建模，使用近似联合搜索来提高性能。其基本思想包括三个步骤：

1. 首先，在L2R和R2L方向上使用双向训练的transformer进行波束搜索，得到两个前k的最好预测。
2. 然后，我们将L2R假设反转为R2L方向，将R2L假设转化为L2R方向，并将这些假设作为真实标签，计算训练阶段的损失值。
3. 最后，将这些损失值加到它们原来的假设分数中，得到最终的分数，然后用于找到最佳候选值。在实践中，我们设置光束大小为k=10，最大长度为200，长度惩罚为α=1.0。

## 数据集

- CROHME14
- CROHME16
- CROHME19
