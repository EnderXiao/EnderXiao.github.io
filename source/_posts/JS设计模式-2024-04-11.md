---
title: JS设计模式
date: 2024-04-11 14:11:11
categories:
  - - 前端
    - 设计模式
tags:
  - life
  - 设计模式
  - 前端
  - JS
headimg:
  'https://s11.ax1x.com/2022/03/13/bqYfFH.jpg'
plugins:
  - mathjax
---
设计模式收集使用JS实现，参考[JS设计模式Github仓库](https://github.com/zy445566/design-pattern-in-javascript)以及书《JavaScript设计模式与开发实践》曾探著
<!-- more -->

## 设计模式

设计模式通常是前任在开发中总结而来的经验，通常我们在看别人代码的时候，会产生：“为什么这么写”的疑问。而学习设计模式的目的在于帮助我们更好地理解代码。

本文沿用GoF四人组(Erich Gamma、Richard Helm、Ralph Johnson、John Vlissides)的分类方式将设计模式分为：
- 创建型模式
  - 创建对象
- 结构型模式
  - 处理类或对象的组合
- 行为型模式
  - 描述类或对象怎样交互和怎样分配职责

三类并使用JS进行实现

## 设计模式六大原则

在描述设计模式之前，先来聊聊设计原则吧，因为稍后介绍的设计模式都或多或少的应用了这些设计原则，而且这些原则能够帮助我们提高自己代码的健壮性。

本章参考[知乎——六大设计模式](https://zhuanlan.zhihu.com/p/110130347)

六大设计原则包括：
- 单一责任原则(Single Responsibility Principle)
  - 定义：应该有，且仅有一个原因引起类的变更
  - 理解：即一个接口或类或方法，应该具有单一职责，例如一个接口要么进行协议管理要么进行数据传输，不应同时具备上述两种职责。
  - 优点：
    - 类复杂性低
    - 可读性，可维护性高
    - 变更分析低
  - 总结：**一个类或接口只承担一个职责。**
- 开闭原则(Open Closed Principle)
  - 定义：一个软件实体（类，模块，函数）对扩展开放，对修改封闭
  - 理解：开闭原则是其他五大原则的精神领袖，其他五大原则都是实现开闭原则的具体型态
  - 优点：
    - 提高可复用性与可维护性
  - 总结：**对软件实体的改动，最好用扩展而非修改的方式。**
- 里氏替换原则(Liskov Substitution Principle)（LSP❌）
  - 定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P中，使用对象o2替换所有的对象o1时，程序P的行为没有发生变化，那么类型S是类型T的子类型。
  - 理解：**就是只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常**。符合该原则的继承可以被定义为良好的继承
    - 子类必须完全实现父类的方法
    - 子类可以有自己的个性
    - 覆盖或实现父类的方法时，输入参数可以被放大，即子类重载父类方法时，参数范围要$\geq$父类方法参数
    - 覆盖或实现父类的方法时，输出结果可以被缩小，即子类重载父类方法时，返回值范围要$\leq$父类方法返回值
  - 总结：**在继承类时，务必重写（override）父类中所有的方法，尤其需要注意父类的protected方法（它们往往是让你重写的），子类尽量不要暴露自己的public方法供外界调用。**
- 迪米特法则(Law of Demeter)(也叫最少知道原则)
  - 定义：一个对象应该对其他对象有最少的了解
  - 理解：
    - 只和直接的朋友交流：出现在成员变量、方法的输入输出参数中的类称为成员**朋友类**，一个类的方法中只能和朋友类进行数据交流，不能涉及其他类
    - 朋友间也是有距离的：开发中尽量不要对外公布太多public方法和非静态的public变量，尽量内敛，可以整合为一个方法的需要进行整合。
    - 是自己的就是自己的：如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。
  - 总结：**尽量减少对象之间的交互，从而减小类之间的耦合。**
- 接口隔离原则(Interface Segregation Principle)
  - 定义：户端不应该依赖它不需要的接口，或者说类间的依赖关系应该建立在最小的接口上。
  - 理解：把一个臃肿的接口拆分为多个独立的接口
  - 总结：**不要对外暴露没有实际意义的接口。**
- 依赖倒置原则(Dependence Inversion Principle)
  - 定义：即面向接口编程
    - 模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的
    - 接口或抽象类不依赖于实现类
    - 实现类依赖接口或抽象类
  - 理解：
    - 每个类尽量都有接口或抽象类，或者接口和抽象类两者都具备。
    - 变量的字面类型尽量是接口或抽象类。
    - 任何类都不应该从具体类派生。
    - 尽量不要重写基类的方法。如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要重写。
  - 优点：
    - 减少类间的耦合性，提高系统的稳定性
    - 降低并行开发引起的风险
    - 提高代码的可读性和可维护性。
  - 总结：**高层模块不应该依赖于低层模块，而应该依赖于抽象。抽象不应依赖于细节，细节应依赖于抽象。**

我们把这六大原则的首字母放进一个Set中，并保持原有顺序，就能得到字符串`SOLID`，预示着六大原则结合后的好处：健壮、稳定

## 创建型模式

{%note quote::
创建型模式 (Creational Pattern) 对类的实例化过程进 行了抽象，能够 将软件模块中对象的创建和对象的使用 分离 。为了使软件的结构更加清晰，外界对于这些对象 只需要知道它们共同的接口，而不清楚其具体的实现细 节，使整个系统的设计更加符合单一职责原则。
创建型模式在 创建什么 (What) ， 由谁创建 (Who) ， 何 时创建 (When) 等方面都为软件设计者提供了尽可能大 的灵活性。创建型模式 隐藏了类的实例的创建细节，通 过隐藏对象如何被创建和组合在一起达到使整个系统独 立的目的 。
%}

### 单例模式（Singleton Pattern）

在面向对象设计的语言中，单例模式通常为我们提供了一种避免多次进行实例化的方法，从而降低构造带来的性能消耗，在基于ES6的语法中，我们也可以实现这一功能。

另外单例模式分为：
- 懒汉式
  - 使用时才进行实例化
- 饿汉式
  - 先初始化，用的时候直接返回

由于js不需要考虑线程安全，所以推荐使用懒汉式写法，饿汉在JS中反而容易产生没必要的垃圾。

```JS
class SingleObject {
  constructor () {
    // TODO: 防止使用new创建对象
    if(new.target !== undefined) {
      const errorMsg = "This is single object,Can't use keyword new!";
      const tipMsg = "You should use method getInstance to get instance。";
      throw new Error(`\n${errorMsg}\n${tipMsg}`)
    }
  }

  // TODO: getInstance获取单例
  static getInstance() {
    // TODO: 如果存在单例直接返回
    if(SingleObject.instance) {
      return SingleObject.instance
    }
    // TODO: 否则创建
    SingleObject.instance = {}
    SingleObject.instance.__proto__ = SingleObject.prototype
    return SingleObject.instance
  }

  // TODO: 实际功能
  doSomething() {
    console.log("..doing")
  }
}

const instance1 = SingleObject.getInstance();
const instance2 = SingleObject.getInstance();

instance1.doSomething()  // ...doing
console.log(instance1 === instance2)  // true
```

但上述方法仍然存在一些不足，比如不满足<span style="color:red">1.单一责任原则</span>，上述代码中进行单例是否存在判断的代码与实例化的代码是融合在一起的。另外上述代码也没能很好的满足<span style="color: red">2.开闭原则</span>，因为如果在后续的场景中，我们需要创建多个对象时，就需要修改关于new方式的控制。

因此我们可以通过代理的方式将实现单例的代码抽离出来，他需要实现一下几个功能：

1. 单例判断
2. 支持接收任何对象，并返回对象单例

```JS
function getSingle(classFun) {
  let result;
  return () => {
    return result || (result = new classFun())
  }
}

class Object {
  constructor() {}

  doSomething() {
    console.log("...doing")
  }

  // 支持函数式调用
  __call__(){
    return new Object()
  }
}

const singleObjectProxy = getSingle(Object)
const instance1 = singleObjectProxy()
const instance2 = singleObjectProxy()

const instance3 = new Object()

console.log(instance1 === instance2)  // true
console.log(instance1 === instance3)  // false
instance1.doSomething()  // ...doing
instance3.doSomething()  // ...doing
```

单例设计模式远不止能够在面向对象中使用，利用单例模式，创建某些唯一的`div`浮窗来实现登陆框，iframe，script标签解决跨域问题时候，我们希望整个项目，或者某个页面中仅使用一个实例来减少创建实例的开销以优化性能。

并且懒汉式的单例模式能够避免页面在第一次加载的时候就将该元素加载。等到真正要用到这个元素时才创建该元素并加载DOM

```JS
let getSingle = function(fn) {
  let result;
  return (...args) => {
    return result || (result = fn.apply(this, args))
  }
}

let createLoginLayer = () => {
  let dir = document.createElement('div')
  div.innerHtml = 'Login Window'
  div.style.display = 'none'
  document.body.appendChild(div)
  return div
}

let createSingleLoginLayer = getSingle(createLoginLayer)

document.getElementById('LoginBtn').onclick = function() {
  let loginLayer = createSingleLoginLayer()
  loginLayer.style.display = 'block'
}
```

## 结构型模式

{%note quote::
其描述 如何将类或者对 象结合在一起形成更大的结构 ，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。
结构型模式可以分为 类结构型模式 和 对象结构型模式 ：
• 类结构型模式关心类的组合 ，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。
• 对象结构型模式关心类与对象的组合，通过关联关系使得在一个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继承关系，因此大部分结构型模式都是 对象结构型模式 。
%}

## 行为型模式

{%note quote::
行为型模式 (Behavioral Pattern) 是对 在不 同的对象之间划分责任和算法的抽象化 。
行为型模式不仅仅关注类和对象的结构，而 且 重点关注它们之间的相互作用 。 通过行为型模式，可以更加清晰地 划分类与
对象的职责 ，并 研究系统在运行时实例对象 之间的交互 。在系统运行时，对象并不是孤 立的，它们可以通过相互通信与协作完成某 些复杂功能，一个对象在运行时也将影响到 其他对象的运行。
行为型模式分为 类行为型模式 和 对象行为型模式 两种：
• 类行为型模式 ：类的行为型模式 使用继承关系在几个类之间分配行为 ，类行为型模式主要通过多态等方式来分配父类与子类的职责。
• 对象行为型模式 ：对象的行为型模式则 使用对象的聚合关联关系来分配行为 ，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式
%}
